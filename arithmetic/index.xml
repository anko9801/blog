<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Arithmetics on</title><link>https://anko9801.github.io/blog/arithmetic/</link><description>Recent content in Arithmetics on</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><atom:link href="https://anko9801.github.io/blog/arithmetic/index.xml" rel="self" type="application/rss+xml"/><item><title>Modint</title><link>https://anko9801.github.io/blog/arithmetic/modulo/modint/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://anko9801.github.io/blog/arithmetic/modulo/modint/</guid><description>説明 演算 方法 計算量 足し算 $a + b$ 足してN以上になったらN引く $O(1)$ 引き算 $a - b$ 引いて0未満になったらN足す $O(1)$ 掛け算 $a \times b$ 掛けてNで割った余り $O(1)$ 割り算 $a \div b$ 拡張ユークリッドの互除法 $O(\log^2 N)$ 累乗 $a ^ e$ 繰り返し二乗法 $O(\log N)$ 平方根 $\sqrt{a}$ Tonelli Shanksのアルゴリズム $O(\log^2 N)$ 累乗根 $\sqrt[e]{a}$ Tonelli Shanksのアルゴリズム $O(\min(N^{1/4},\sqrt{e})\log{e}\log^2{N})$ 対数 $\log_e{a}$ 離散対数問題 $O(\sqrt{N})$ (参考: 整数論テクニック集のpdf など) 実装 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 #include &amp;lt;cstdint&amp;gt;#include &amp;lt;istream&amp;gt;#include &amp;lt;type_traits&amp;gt;#include &amp;lt;vector&amp;gt; using ll = long long; using u64 = std::uint_fast64_t; const ll MOD = 1000000007; const ll MODD = 998244353; constexpr u64 Modulus = MOD; class Modint { public: u64 num = 0; constexpr Modint() noexcept {} constexpr Modint(const u64 x) noexcept : num(x % Modulus) {} inline constexpr operator ll() const noexcept { return num; } inline constexpr Modint &amp;amp;operator+=(const Modint rhs) noexcept { num += rhs.</description></item><item><title>中国剰余定理</title><link>https://anko9801.github.io/blog/arithmetic/crt/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://anko9801.github.io/blog/arithmetic/crt/</guid><description>説明 Garnerのアルゴリズム
計算量 $O(n^2 + n\log(\max p_i))$
実装 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 #include &amp;lt;vector&amp;gt; // x % m[i] = r[i] % m[i] を満たす正で最小の x を返す // mは互いに素であると仮定 // とりあえず解の存在判定は保留 template &amp;lt;typename T&amp;gt; T CRT(std::vector&amp;lt;T&amp;gt; r, std::vector&amp;lt;T&amp;gt; m) { ll n = r.</description></item><item><title>任意Modint</title><link>https://anko9801.github.io/blog/arithmetic/modulo/arbitrary_modint/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://anko9801.github.io/blog/arithmetic/modulo/arbitrary_modint/</guid><description>説明 演算 方法 計算量 足し算 $a + b$ 足してN以上になったらN引く $O(1)$ 引き算 $a - b$ 引いて0未満になったらN足す $O(1)$ 掛け算 $a \times b$ 掛けてNで割った余り $O(1)$ 割り算 $a \div b$ 拡張ユークリッドの互除法 $O(\log^2 N)$ 累乗 $a ^ e$ 繰り返し二乗法 $O(\log N)$ 平方根 $\sqrt{a}$ Tonelli Shanksのアルゴリズム $O(\log^2 N)$ 累乗根 $\sqrt[e]{a}$ Tonelli Shanksのアルゴリズム $O(\min(N^{1/4},\sqrt{e})\log{e}\log^2{N})$ 対数 $\log_e{a}$ 離散対数問題 $O(\sqrt{N})$ (参考: 整数論テクニック集のpdf など) 実装 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 #include &amp;lt;cstdint&amp;gt;#include &amp;lt;istream&amp;gt;#include &amp;lt;vector&amp;gt; using ll = long long; class runtime_modint { using u64 = std::uint_fast64_t; static u64 &amp;amp;mod() { static u64 mod_ = 0; return mod_; } public: u64 a; runtime_modint(const u64 x = 0) : a(x % get_mod()) {} u64 &amp;amp;value() noexcept { return a; } const u64 &amp;amp;value() const noexcept { return a; } inline constexpr operator ll() const noexcept { return a; } runtime_modint operator+(const runtime_modint rhs) const { return runtime_modint(*this) += rhs; } runtime_modint operator-(const runtime_modint rhs) const { return runtime_modint(*this) -= rhs; } runtime_modint operator*(const runtime_modint rhs) const { return runtime_modint(*this) *= rhs; } runtime_modint operator/(const runtime_modint rhs) const { return runtime_modint(*this) /= rhs; } runtime_modint &amp;amp;operator+=(const runtime_modint rhs) { a += rhs.</description></item><item><title>数論変換</title><link>https://anko9801.github.io/blog/arithmetic/ntt/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://anko9801.github.io/blog/arithmetic/ntt/</guid><description>説明 複素数上のFFTを有限体上に取り替えたのがNTT。乗法群の位数が大きな2のべき乗を持っていると精度を落とさずに計算できて嬉しい。
計算量 $O(N\log{N})$
実装 使用例</description></item><item><title>数論的関数/進数変換</title><link>https://anko9801.github.io/blog/arithmetic/arithmetical_function/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://anko9801.github.io/blog/arithmetic/arithmetical_function/</guid><description>オイラーの$\phi$関数 メビウスの$\mu$関数 カーマイケルの$\lambda$関数</description></item><item><title>最大公約数・最小公倍数</title><link>https://anko9801.github.io/blog/arithmetic/gcd/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://anko9801.github.io/blog/arithmetic/gcd/</guid><description>説明 ユークリッドの互除法
計算量 $O(\log{N})$
実装 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 template &amp;lt;typename T&amp;gt; T gcd(T a, T b) { T r; while (b &amp;gt; 0) { r = a % b; a = b; b = r; } return a; } template &amp;lt;typename T&amp;gt; T lcm(T a, T b) { return a / gcd(a, b) * b; } template &amp;lt;typename T&amp;gt; T extgcd(T a, T b, T &amp;amp;x, T &amp;amp;y) { T g = a; x = 1; y = 0; if (b) { g = extgcd(b, a % b, y, x); y -= a / b * x; } return g; } 使用例</description></item><item><title>素因数分解</title><link>https://anko9801.github.io/blog/arithmetic/primes/factorize/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://anko9801.github.io/blog/arithmetic/primes/factorize/</guid><description>説明 計算量 実装 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 #include &amp;lt;vector&amp;gt; template &amp;lt;typename T&amp;gt; std::vector&amp;lt;std::pair&amp;lt;T, int&amp;gt;&amp;gt; factors(T N) { std::vector&amp;lt;std::pair&amp;lt;T, int&amp;gt;&amp;gt; res; for (T a = 2; a * a &amp;lt;= N; ++a) { if (N % a !</description></item><item><title>素数列挙</title><link>https://anko9801.github.io/blog/arithmetic/primes/primes/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://anko9801.github.io/blog/arithmetic/primes/primes/</guid><description>説明 エラトステネスの篩
計算量 実装 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 #include &amp;lt;vector&amp;gt; std::vector&amp;lt;int&amp;gt; primes; std::vector&amp;lt;bool&amp;gt; Eratosthenes(int N) { std::vector&amp;lt;bool&amp;gt; isprime(N + 1, true); isprime[0] = isprime[1] = false; for (int p = 2; p &amp;lt;= N; ++p) { if (!</description></item><item><title>行列</title><link>https://anko9801.github.io/blog/arithmetic/matrix/matrix/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://anko9801.github.io/blog/arithmetic/matrix/matrix/</guid><description>説明 計算量 実装 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 #include &amp;lt;bits/stdc++.</description></item><item><title>高速ゼータ変換・高速メビウス変換</title><link>https://anko9801.github.io/blog/arithmetic/zeta/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://anko9801.github.io/blog/arithmetic/zeta/</guid><description>説明 計算量 実装 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 #include &amp;lt;vector&amp;gt; template &amp;lt;typename T&amp;gt; class Eratosthenes { public: std::vector&amp;lt;bool&amp;gt; isprime; // 素数 std::vector&amp;lt;T&amp;gt; minfactor; // 最小の素因数 // メビウス関数 μ // μ(1)=1 // n がある素数pで2回以上割り切れるとき、μ(n)=0 // n=p1×p2×…pK と素因数分解できるとき、μ(n)=(−1)^K // f(1)=∑[i=1~N]μ(i)F(i) 約数系包除原理 std::vector&amp;lt;T&amp;gt; mobius; // エラトステネスの篩 O(NloglogN) Eratosthenes(int N) : isprime(N + 1, true), minfactor(N + 1, -1), mobius(N + 1, 1) { isprime[1] = false; minfactor[1] = 1; for (T p = 2; p &amp;lt;= N; ++p) { if (!</description></item><item><title>高速フーリエ変換 (FFT)</title><link>https://anko9801.github.io/blog/arithmetic/fft/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://anko9801.github.io/blog/arithmetic/fft/</guid><description>説明 次の記事がわかりやすいです。
【競プロer向け】FFT を習得しよう！ | 東京工業大学デジタル創作同好会traP
計算量 $O(N\log{N})$
実装 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 #include &amp;lt;complex&amp;gt;#include &amp;lt;vector&amp;gt; using namespace std; using ll = long long; using ld = long double; using Complex = complex&amp;lt;ld&amp;gt;; const ld PI = 3.</description></item><item><title>高速素因数分解 (Pollard-ρ法/Miller-Rabin法)</title><link>https://anko9801.github.io/blog/arithmetic/primes/fast_factorize/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://anko9801.github.io/blog/arithmetic/primes/fast_factorize/</guid><description>説明 Pollard-$\rho$ 法と Miller-Rabin 法を用いて $O(n^{\frac{1}{4}}\log^3n)$ で素因数分解できる。
Miller–Rabin 素数判定法 Miller-Rabin 素数判定法は与えられた数 $n$ が素数かどうかを計算時間 $O(k\log^3 n)$ で誤り率 $4^{-k}$ 以下で判定する確率的素数判定アルゴリズムである。
フェルマーの小定理について考える。素数である剰余 $n$ について、その乗法群の位数 $n-1$ はそれを $2$ で割れるだけ割った数を $d$ として $n-1 = 2^sd$ と書ける。</description></item></channel></rss>