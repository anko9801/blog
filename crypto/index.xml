<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Cryptoes on</title><link>https://anko9801.github.io/blog/crypto/</link><description>Recent content in Cryptoes on</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><atom:link href="https://anko9801.github.io/blog/crypto/index.xml" rel="self" type="application/rss+xml"/><item><title/><link>https://anko9801.github.io/blog/crypto/AES/Symmetric_cryptography/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://anko9801.github.io/blog/crypto/AES/Symmetric_cryptography/</guid><description>最新の状況はこの発表を見ればすべてわかる Invited talk: Symmetric Cryptography for Long Term Security, by Maria Naya Plasencia - YouTube 軽量な セキュリティ vs. 効率 応用に合わせた性質</description></item><item><title>AES</title><link>https://anko9801.github.io/blog/crypto/AES/AES/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://anko9801.github.io/blog/crypto/AES/AES/</guid><description>AES-ECB (Electronic Codeblock) AES-CBC (Cipher Block Chaining) AES-CTR PCBC (Propagating Cipher Block Chaining) CFB (Cipher Feedback) AES-GCM (Galois/Counter Mode) AES-NI</description></item><item><title>Attack Model</title><link>https://anko9801.github.io/blog/crypto/cryptography/AttackModel/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://anko9801.github.io/blog/crypto/cryptography/AttackModel/</guid><description>ランダムオラクルモデル
選択平文攻撃(Chosen-plaintext attack; CPA) 適応的選択平文攻撃(Adaptive chosen-plaintext attack; CPA2) 選択暗号文攻撃(Chosen-ciphertext attack; CCA1) 適応的選択暗号文攻撃(Adaptive Chosen-ciphertext attack; CCA2) Side-channel attack ↓めちゃくちゃわかりにくい、といってわかりやすさが上がる方法とは？定理証明だと思う.</description></item><item><title>Attacks on SIKE</title><link>https://anko9801.github.io/blog/crypto/ECC/SIKE/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://anko9801.github.io/blog/crypto/ECC/SIKE/</guid><description>Attacks on SIDH/SIKE | ellipticnews (wordpress.com) jack4818/Castryck-Decru-SageMath: A SageMath implementation of the Castryck-Decru Key Recovery attack on SIDH (github.com)</description></item><item><title>Baby-step Giant-step</title><link>https://anko9801.github.io/blog/crypto/DLP/BSGS/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://anko9801.github.io/blog/crypto/DLP/BSGS/</guid><description>説明 半分全列挙を用いて $O(\sqrt{N}\log{N})$ でDLPが解ける。
位数 $N$ の巡回群 $G$ について $a, b\in G$ が与えられるので $a^n = b$ となる最小の $n\in \mathbb{N}$ を求める問題を考える。このとき $m = \lceil\sqrt{N}\rceil$ とおき、$n$ を $m$ で割ると $n = qm + r \ (q, r\in[0, \lceil\sqrt{N}\rceil)\ )$ と表せられる。すると $r$ に対して $ba^{-r}$ を全列挙し、そのリストに対して $a^{qm}$ が含まれているような $q$ を探索すると高速に解が求まる。</description></item><item><title>BKZ(Block Korkine-Zolotareff) 基底簡約</title><link>https://anko9801.github.io/blog/crypto/Lattice/BKZ/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://anko9801.github.io/blog/crypto/Lattice/BKZ/</guid><description>説明 HKZ(Hermite-Korkine-Zolotareff) 基底簡約
サイズ基底簡約 条件に合うように基底ベクトルの交換 計算量 実装 使用例 参考</description></item><item><title>Boneh-Durfee Attack</title><link>https://anko9801.github.io/blog/crypto/RSA/Boneh-DurfeeAttack/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://anko9801.github.io/blog/crypto/RSA/Boneh-DurfeeAttack/</guid><description>説明 $e$ が大きすぎると以下の式に対し Coppersmith Method を用いて攻撃できる。
$$ \begin{aligned} ed &amp;amp;= 1 &amp;amp; \pmod{\phi} \ ed &amp;amp;= k \phi + 1 &amp;amp; (\mathrm{over}\ \mathbb{Z}) \ 0 &amp;amp;= k \phi + 1 &amp;amp; \pmod e \ &amp;amp;= k (N + 1 - p - q) + 1 &amp;amp; \pmod e \ &amp;amp;= 2k \left(\frac{N + 1}{2} + \frac{-p -q}{2}\right) + 1 &amp;amp; \pmod e \ \end{aligned} $$</description></item><item><title>Chosen-ciphertext Attack</title><link>https://anko9801.github.io/blog/crypto/RSA/RSA-CCA/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://anko9801.github.io/blog/crypto/RSA/RSA-CCA/</guid><description>説明 任意の暗号を復号した結果を知っているとき、ある暗号文の復号結果を防がれていたとしても他の暗号を送ることで解読できます。 $2^e$ を暗号文に掛けて復号した結果を $2$ で割ればその平文がわかります。
$$ \begin{aligned} Dec(2^ec) = 2m \pmod N \end{aligned} $$
これに対する防御方法として平文にパディングを施し、復号化した際にパディング形式が違うときは相手に渡さないようにするという方法があります。これによって正当な暗号文しか受け入れず、適応的選択暗号文攻撃を防げます。
パディング形式の1つにPKCS #1 v1.5があります。
0002&amp;lt;random&amp;gt;00&amp;lt;hashprefix&amp;gt;&amp;lt;message&amp;gt;</description></item><item><title>Common Modulus Attack</title><link>https://anko9801.github.io/blog/crypto/RSA/CommonModulusAttack/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://anko9801.github.io/blog/crypto/RSA/CommonModulusAttack/</guid><description>説明 共通の平文を異なる $e$ で暗号化した暗号文が分かっているとき平文を求められる。
$$ \begin{aligned} c_1 &amp;amp;≡ m^{e_1} &amp;amp; \pmod N \ c_2 &amp;amp;≡ m^{e_2} &amp;amp; \pmod N \ \gcd(e_1, e_2) &amp;amp;= s_1e_1 + s_2e_2 \ c_1^{s_1} c_2^{s_2} &amp;amp;= m^{s_1e_1 + s_2e_2} = m^{\gcd(e_1, e_2)} &amp;amp; \pmod N \end{aligned} $$</description></item><item><title>Coppersmith Method</title><link>https://anko9801.github.io/blog/crypto/coppersmith/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://anko9801.github.io/blog/crypto/coppersmith/</guid><description>説明 Thm. Howgrave-Grahamの補題 $N$ を法、 $g(x) \in \mathbb{Z}[x]$ を整数多項式とし、含まれる単項式の数を $\omega$ とする。$g(x)$ に対してある $X$ が存在し、$g(x_0) = 0 \pmod{N}$ なる $x_0 \in \mathbb{Z}$ について $|x_0| \leq X$ であると仮定する。このとき</description></item><item><title>Differencial cryptoanalysis</title><link>https://anko9801.github.io/blog/crypto/Hash/DifferencialCryptoanalysis/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://anko9801.github.io/blog/crypto/Hash/DifferencialCryptoanalysis/</guid><description>https://github.com/aappleby/smhasher/wiki/MurmurHash2Flaw
Differencial cryptanalysis これはハッシュ関数の実装に踏み込む手法である. スケッチとしては何かしらのパラメータが同じなどの特殊な場合のとき, 簡約化ができ, 単純な算術演算による条件式をいくつか生成できる. これを SMT で解くらしい.</description></item><item><title>Diffie-Hellman 鍵交換</title><link>https://anko9801.github.io/blog/crypto/cryptography/Diffie-Hellman/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://anko9801.github.io/blog/crypto/cryptography/Diffie-Hellman/</guid><description>説明 共有鍵を作る為の操作である。共有鍵を作ることができれば共有鍵暗号を用いて通信できる。
AliceとBobが巡回群 $G$ とその生成元 $g$ を共有する。 AliceとBobはそれぞれ秘密鍵 $x_a, x_b$ を生成し、公開鍵 $y_a = g^{x_a}, y_b = g^{x_b}$ を公開する。 AliceとBobは自分の秘密鍵と相手の公開鍵を掛けると $s = g^{x_ax_b} = y_b^{x_a} = y_a^{x_b}$ となり、$s$ はAliceとBobのみが知る共有鍵となる。 ECDH だと $s$ の $x$ 座標をハッシュ化したものを共有鍵として使う。</description></item><item><title>ECFFT</title><link>https://anko9801.github.io/blog/crypto/ECC/ECFFT/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://anko9801.github.io/blog/crypto/ECC/ECFFT/</guid><description>ECFFT1.pdf (toronto.edu)</description></item><item><title>Fiat-Shamir 変換</title><link>https://anko9801.github.io/blog/crypto/cryptography/Fiat-Shamir/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://anko9801.github.io/blog/crypto/cryptography/Fiat-Shamir/</guid><description>Fiat-Shamir変換は、証明システムを非対話型にするために使用される有名なスキームで、検証者がランダムに選択するチャレンジの値を（ランダムオラクルモデルとして）暗号学的ハッシュ関数を使って決定論的に導出することで、証明システムのプロトコルを非対話型にする。
チャレンジのハッシュ計算の際の入力に、証明するステートメントに関するすべての公開値（ランダムなコミットメント値を含む）を含める必要があるということ（↑の例だと入力は、G、V、P、UserID、OtherInfo）。</description></item><item><title>Franklin-Reiter Related Message Attack</title><link>https://anko9801.github.io/blog/crypto/RSA/Franklin-ReiterRelatedMessageAttack/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://anko9801.github.io/blog/crypto/RSA/Franklin-ReiterRelatedMessageAttack/</guid><description>説明 $f(m_1) = m_2$ $m_1 = pad_1 + m, m_2 = pad_2 + m, m_2 = m_1 + (pad_2 - pad_1)$</description></item><item><title>Frozen Heart</title><link>https://anko9801.github.io/blog/crypto/cryptography/FrozenHeart/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://anko9801.github.io/blog/crypto/cryptography/FrozenHeart/</guid><description>Frozen Heartは、Fiat-Shamir変換でチャレンジのハッシュ計算の際の入力に、証明するステートメントに関するすべての公開値（ランダムなコミットメント値を含む）を含める必要があるということ（↑の例だと入力は、G、V、P、UserID、OtherInfo）を遵守していないプロトコルや実装による脆弱性。
詳しいことはすべてここに
Fiat-Shamir変換の安全でない適用による脆弱性Frozen Heart - Develop with pleasure! (hatenablog.com) Coordinated disclosure of vulnerabilities affecting Girault, Bulletproofs, and PlonK | Trail of Bits Blog</description></item><item><title>Fujisaki-Okamoto Transformation</title><link>https://anko9801.github.io/blog/crypto/cryptography/Fujisaki-Okamoto_Transformation/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://anko9801.github.io/blog/crypto/cryptography/Fujisaki-Okamoto_Transformation/</guid><description>説明 証明 参考文献 The Fujisaki-Okamoto Transformation (uni-paderborn.de)</description></item><item><title>GHS Attack</title><link>https://anko9801.github.io/blog/crypto/ECC/GHS-Attack/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://anko9801.github.io/blog/crypto/ECC/GHS-Attack/</guid><description>Weil descent 攻撃とも呼ばれる</description></item><item><title>Gram-Schmidt の直交化 (GSO: Gram-Schmidt Orthonormalization)</title><link>https://anko9801.github.io/blog/crypto/Lattice/GSO/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://anko9801.github.io/blog/crypto/Lattice/GSO/</guid><description>説明 Gram-Schmidt 直交化 Gram-Schmidt 直交化 (GSO; Gram-Schmidt Orthonormalization) とは実 $m$ 次元ベクトル空間 $\mathbb{R}^m$ の任意の $\mathbb{R}$ ベクトル空間としての基底を直交基底に変換する方法である. イメージは グラム・シュミットの正規直交化法のWikipedia のgifがわかりやすいです。$\mathbf{b}n$ の直交化は $\mathbf{b}{1},\ldots, \mathbf{b}_{n-1}$ すべてと直行するように元の高さのまま移動させる。</description></item><item><title>Håstad’s Broadcast Attack</title><link>https://anko9801.github.io/blog/crypto/RSA/H%C3%A5stadsBroadcastAttack/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://anko9801.github.io/blog/crypto/RSA/H%C3%A5stadsBroadcastAttack/</guid><description>説明 平文を互いに素な $N_1, \ldots, N_e$ で暗号化された暗号文が分かっているとき、中国剰余定理を用いて $m$ を求められる。
$$ \begin{aligned} c_1 &amp;amp;≡ m^e \pmod{N_1} \ c_2 &amp;amp;≡ m^e \pmod{N_2} \ \vdots \ c_e &amp;amp;≡ m^e \pmod{N_e} \ m^e &amp;amp;≡ CRT(c_1, c_2, \dots , c_e) \pmod{N_1N_2\cdots N_e} \ m^e &amp;amp;= CRT(c_1, c_2, \dots , c_e) \end{aligned} $$</description></item><item><title>Invalid Curve Attack</title><link>https://anko9801.github.io/blog/crypto/ECC/Invalid-Curve-Attack/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://anko9801.github.io/blog/crypto/ECC/Invalid-Curve-Attack/</guid><description>説明 ざっくり言うと楕円曲線上に点が乗っていないときに位数が低くなることを利用する攻撃です。
適当に選んだ数は小さな素数で割れやすい のと同じように
Google CTF Tiramisu write up (zenn.dev)</description></item><item><title>Lagrange 基底簡約 (Gauss 基底簡約)</title><link>https://anko9801.github.io/blog/crypto/Lattice/Lagrange/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://anko9801.github.io/blog/crypto/Lattice/Lagrange/</guid><description>説明 任意の $q \in \mathbb{Z}$ に対して
$$ |\mathbf{b}_1| \leq |\mathbf{b}_2| \leq |\mathbf{b}_1 + q\mathbf{b}_2| $$
を満たすとき、2次元格子の基底 $\{\mathbf{b}_1, \mathbf{b}_2\}$ はLagrange 簡約されているという。</description></item><item><title>LLL 基底簡約</title><link>https://anko9801.github.io/blog/crypto/Lattice/LLL/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://anko9801.github.io/blog/crypto/Lattice/LLL/</guid><description>説明 $n$ 次元格子 $L$ の基底 $\lbrace\mathbf{b_1},\ldots,\mathbf{b_n}\rbrace$ について以下の条件を満たすとき、その基底は LLL 簡約されている (Lenstra-Lenstra-Lovasz(LLL)-reduced)と呼ぶ。
基底 $\lbrace\mathbf{b_1},\ldots,\mathbf{b_n}\rbrace$ がサイズ簡約されている。 Lovasz条件: 任意の $2 \leq k \leq n$ に対して $\delta|\mathbf{b}{k-1}^*| \leq |\pi{k-1}(\mathbf{b}_{k-1})|$ を満たす。ただし、各 $1 \leq l \leq n$ に対して、$\pi_l$ は $\mathbb{R}$-ベクトル空間 $\langle\mathbf{b} _1,\ldots,\mathbf{b} _{l-1}\rangle _\mathbb{R}$ の直交補空間への直交射影とする。 これに対し、LLL 基底簡約アルゴリズムは次のように行う。</description></item><item><title>LSB Decryption Oracle Attack</title><link>https://anko9801.github.io/blog/crypto/RSA/LSB-DecryptionOracleAttack/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://anko9801.github.io/blog/crypto/RSA/LSB-DecryptionOracleAttack/</guid><description>説明 全てが分かっていなくとも偶奇さえ分かれば任意の暗号文を復号できる。 ある暗号文 $c$ に対し、$2^e$ をx回掛けた値を復号した下位1bitを得て平文を求めます。得られる下位1bitは次の関数 $f(x)$ を用いて $f(x) \bmod 2$ と表せられます。decは復号化関数です。
$$ \begin{aligned} f(x) &amp;amp;= Dec(2^{ex}c \bmod N) = 2^xm \bmod N \ \end{aligned} $$</description></item><item><title>Millar</title><link>https://anko9801.github.io/blog/crypto/ECC/Millar/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://anko9801.github.io/blog/crypto/ECC/Millar/</guid><description/></item><item><title>MOV/FR Reduction</title><link>https://anko9801.github.io/blog/crypto/ECC/MOV-FR-Reduction/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://anko9801.github.io/blog/crypto/ECC/MOV-FR-Reduction/</guid><description>MOV Reduction $R=dP$ となるECDLPを解く
Weil pairing $e_n: E[n]\times E[n]\to \mu_n\subseteq \mathbb{F}_{p^k}^*$
$E[n]\subseteq E(\mathbb{F}_{p^k})$ となる最小の $k$ を持ってくる 位数 $n$ の $\alpha=e_n(P, Q)$ となるように $Q \in E[n]$ を取ってくる $\beta = e_n(dP, Q)$ $\mathbb{F}_{p^k}^*$ 上のDLPを $\alpha, \beta$ を用いて解く $k$ は多くとも6まで $E(\mathbb{F}{p^k}^*)\cong\mathbb{Z}{c_1n_1}\oplus\mathbb{Z}_{c_2n_1}$</description></item><item><title>Note</title><link>https://anko9801.github.io/blog/crypto/Note/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://anko9801.github.io/blog/crypto/Note/</guid><description>Crypto in CTF writeup Crypto in CTF :: Mystify (mystiz.hk) を解いていく。
Q3 2021 Pwn2Win CTF 2021 t00 rare ECDSAで署名/検証ができるが、特定のハッシュ値のときは不可 $q=q_1q_2+1$ として秘密鍵が $x=(7^{q_2})^y$, $P = kG$, $s=\frac{h+rx}{k}\iff P=\frac{h+rx}{s}G\iff g^yG=r^{-1}(sP-hG)$ である 特定のハッシュ値のとき $kP=G$ を求める 解法 $h+q$ でバイパス BSGSで $g^yG$ の $y$ を求める 高速なライブラリfastecdsaを使う A2S AESのラウンドを10回から2回に変更 解法 0CTF 2021 Quals zer0lfsr- Crypto CTF 2022</description></item><item><title>Partial Key Exposure Attack</title><link>https://anko9801.github.io/blog/crypto/RSA/PartialKeyExposureAttack/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://anko9801.github.io/blog/crypto/RSA/PartialKeyExposureAttack/</guid><description>説明 秘密鍵を部分的に知っていさえいれば、Coppersmith Method を用いて解けてしまう。 $n$ を $N$ のビット数とする。
$p, q$ のどちらかを $n/4$ ビット程度知っているとき $$ \begin{aligned} f(x) &amp;amp;= p_{upper} + x &amp;amp; \pmod p \ f(x) &amp;amp;= 2^{k}x + p_{lower} &amp;amp; \pmod p \ f(x,y) &amp;amp;= 2^kx + p_{mid} + y &amp;amp; \pmod p \ \end{aligned} $$</description></item><item><title>Pohlig-Hellman</title><link>https://anko9801.github.io/blog/crypto/DLP/Pohlig_Hellman/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://anko9801.github.io/blog/crypto/DLP/Pohlig_Hellman/</guid><description>説明 中国剰余定理を用いて大きな群を複数の小さな群の直積に分割する。
実装 1 2 3 4 5 6 7 8 9 fact = factor(G.order()) ord = int(G.order()) dlogs = [] for p, e in fact: t = ord // p ^ e dlog = discrete_log(t * Q, t * G, operation=&amp;#34;+&amp;#34;) dlogs += [dlog] print(crt(dlogs, primes)) 使用例 参考</description></item><item><title>Pohlig-Hellman Attack</title><link>https://anko9801.github.io/blog/crypto/ECC/Pohlig-Hellman/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://anko9801.github.io/blog/crypto/ECC/Pohlig-Hellman/</guid><description>説明 中国剰余定理を用いて大きな群を複数の小さな群の直積に分ける。
楕円曲線暗号の楕円曲線の位数は細かく素因数分解できることが多い。
楕円曲線の位数 $#E = p_1^{e_1}p_2^{e_2}\ldots p_k^{e_k}$ と素因数分解できる。$Q = dP$ となるとき次のように $d_i$ を置く。
$$ \begin{aligned} d_1 &amp;amp;= d \pmod{p_1^{e_1}} \ d_2 &amp;amp;= d \pmod{p_2^{e_2}} \ &amp;amp;\vdots \ d_k &amp;amp;= d \pmod{p_k^{e_k}} \ \end{aligned} $$</description></item><item><title>Pollard's rho 法</title><link>https://anko9801.github.io/blog/crypto/DLP/Pollard_rho/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://anko9801.github.io/blog/crypto/DLP/Pollard_rho/</guid><description>説明 初期点 $x_0$ と適当な副作用のない疑似乱数関数 $f(x)$ を決めて $x_{i+1} = f(x_i)$ となるように数列 $(x_0, x_1, \ldots)$ を生成する。このとき $0 \leq \exists i &amp;lt; \exists j &amp;lt; N$, $x_i = x_j$ となる $i,j$ を見つけられたらDLPが解けるという仕組みです。</description></item><item><title>Return Of Coppersmith Attack</title><link>https://anko9801.github.io/blog/crypto/RSA/ROCA/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://anko9801.github.io/blog/crypto/RSA/ROCA/</guid><description>説明 主要な暗号ハードウェアメーカで使われているライブラリ RSALib の鍵生成アルゴリズムの欠陥。
$$ \begin{aligned} p &amp;amp;= kM + (e^a \bmod M) \ q &amp;amp;= lM + (e^b \bmod M) \ N &amp;amp;= pq = e^{a + b} \pmod M \end{aligned} $$</description></item><item><title>RSA-CRT Fault Attack</title><link>https://anko9801.github.io/blog/crypto/RSA/RSA-CRT-FaultAttack/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://anko9801.github.io/blog/crypto/RSA/RSA-CRT-FaultAttack/</guid><description>説明 RSAの復号をする際に $c^d$ を計算しますが、 $d = e^{-1} \pmod {\phi (N)}$ は比較的大きいので処理が重くなります。これに対してRSA-CRTは中国剰余定理(CRT)を利用して高速化を図っています。
$$ \begin{aligned} m_p &amp;amp;= c^{d \ \bmod \ p−1} &amp;amp; \pmod p \ m_q &amp;amp;= c^{d \ \bmod \ q−1} &amp;amp; \pmod q \ m &amp;amp;= \mathrm{CRT}(m_p, m_q) &amp;amp; \pmod {N} \ &amp;amp;= m_q + (m_p - m_q) (q^{-1} \bmod p) q &amp;amp; \pmod {N} \ \end{aligned} $$</description></item><item><title>RSA暗号</title><link>https://anko9801.github.io/blog/crypto/RSA/RSA/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://anko9801.github.io/blog/crypto/RSA/RSA/</guid><description>説明 暗号化 $c = m^{e} \pmod N$ を計算します。
秘密鍵である大きな素数 $p, q$ を生成し、公開鍵 $N = pq$ を公開します。 そして数値化した平文 $m$ に対して暗号文 $c$ は $c = m^e \pmod N$ となります。 復号化 $m = c^{e^{-1}} \pmod N$ を計算します。</description></item><item><title>SageMath チートシート</title><link>https://anko9801.github.io/blog/crypto/SageMath/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://anko9801.github.io/blog/crypto/SageMath/</guid><description>説明 SageMathのプログラムを書くときに参照したいと思うチートシートを作成したい。
実装 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 # import load(&amp;#39;coppersmith.</description></item><item><title>Schnorr Signatures</title><link>https://anko9801.github.io/blog/crypto/cryptography/Schnorr/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://anko9801.github.io/blog/crypto/cryptography/Schnorr/</guid><description>説明 非対話型ゼロ知識証明な署名の一種。
巡回群 $G$ 上で署名を行う。各パラメータは次のように定義する。
生成元 $g$ 秘密鍵 $x$ 公開鍵 $y = g^x$ メッセージ $M$ 署名 乱数 $k$ を生成し、次の値を計算する。</description></item><item><title>Schoof Algorithm</title><link>https://anko9801.github.io/blog/crypto/ECC/Schoof/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://anko9801.github.io/blog/crypto/ECC/Schoof/</guid><description>Hasse-Weil 定理より
$$ q+1-2\sqrt{q}\leq|E(\mathbb{F}_q)|\leq q+1+2\sqrt{q} $$
$|E(\mathbb{F}_q)|=q+1+t$ とおける。$\mathbb{F}_q$ のフロベニウス写像 $\sigma$ のトレース $t$ を計算できれば位数が求まる。しかし $t$ は $2\sqrt{q}$ のオーダーであるため、直接計算できない。そこで素数 $l$ を剰余にとってそれぞれの $t$ の値を求め、中国剰余定理によって $t$ を求める。</description></item><item><title>Small Common Private Exponent Attack</title><link>https://anko9801.github.io/blog/crypto/RSA/SmallCommonPrivateExponentAttack/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://anko9801.github.io/blog/crypto/RSA/SmallCommonPrivateExponentAttack/</guid><description>説明 実装 使用例 参考</description></item><item><title>SSH</title><link>https://anko9801.github.io/blog/crypto/SSH/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://anko9801.github.io/blog/crypto/SSH/</guid><description>OpenSSH 9.0 ポスト量子暗号化時代への対応として、格子暗号系の「Streamlined NTRU Prime」と、楕円曲線暗号系の「x25519」からなるハイブリッド手法がデフォルトとなっている。
ed448 ed25519
Gnu Privacy Guard: GPG master key sub key Pritty Good Privacy: PGP鍵 GPGで自分用の秘密鍵を1つに統一する · JoeMPhilips</description></item><item><title>SSSA Attack</title><link>https://anko9801.github.io/blog/crypto/ECC/SSSA-Attack/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://anko9801.github.io/blog/crypto/ECC/SSSA-Attack/</guid><description>説明 $$ \newcommand{\calO}{\mathcal{O}} \newcommand{\FF}{\mathbb{F}} \newcommand{\tE}{\tilde{E}} \newcommand{\ZZ}{\mathbb{Z}} \newcommand{\QQ}{\mathbb{Q}} \DeclareMathOperator{\Ker}{Ker} \DeclareMathOperator{\ord}{ord} $$
Definition $\FF_p$ 素数$p$に対して$p$個の元からなる有限体 素数$p$の剰余群 $\mathbb{Z}/p\mathbb{Z}$ $\mathbb{Q}_p$ p進数体 $27=2.</description></item><item><title>TFHE (Torus Fully Homomorphic Encryption)</title><link>https://anko9801.github.io/blog/crypto/Lattice/TFHE/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://anko9801.github.io/blog/crypto/Lattice/TFHE/</guid><description>説明 完全準同型暗号の1つ
完全なる Zero Trust なサーバーを作れる。
参考 セキュキャンの資料</description></item><item><title>Tour of Lattice</title><link>https://anko9801.github.io/blog/crypto/Lattice/tour_of_Lattice/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://anko9801.github.io/blog/crypto/Lattice/tour_of_Lattice/</guid><description>格子暗号を極める！ 無限工事編
はじめに // TODO 説明 耐量子暗号です！あとはセキュキャンで話題のTFHEとか紹介したいな
これは大学1年で習う線形代数を前提知識として扱います。
量子アルゴリズムはどこで解説すべき？ 暗号関連で解説すべきなのはGroverとShorのアルゴリズムの2つだけやが量子コンピューター上の演算や量子フーリエが前提知識無しやとキツイかもしれん。 量子コンピュータという題材で分けた方が良さそう？本に頼ればいいは一理あるが論文以外の文献は未だ少なく暗号専門の解説がほしいところ 自分の文章力と時間に要相談ということで 格子 (Lattice) 図でイメージ掴むのが速い</description></item><item><title>Tour of RSA</title><link>https://anko9801.github.io/blog/crypto/RSA/tour-of-RSA/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://anko9801.github.io/blog/crypto/RSA/tour-of-RSA/</guid><description>RSA暗号を極める！(理論編) というか無限工事編です(文章が拙くて申し訳ない)
はじめに すぐそこに秘密の世界があります。この記事を読んでいるなら、あなたは暗号化された通信を通してサーバーから電気線を通り、遥々その端末に届いている文字を読んでいます。
こんなことを考えてみてほしい。機器から暗号を使って通信をしていますが、私達が触れていないだけで暗号は誰でも解けるものであり、近くを通った人が自分の通信を盗聴しているかもしれない。ゾクッとしませんか。
そんなことが2017年に起こりました。ROCA攻撃と呼ばれるものです。暗号の中でも最も世界で活躍していると言われる「RSA暗号」が簡単に解けてしまうというものです。
その「RSA暗号」の本当の世界を覗いてみましょう。
CryptoはCTF特有のメタ的な能力よりかは数学力に重きが置かれる分野です。最近では発想だけではなくテクニックを知らないと解けないような問題が多くなってきました。そこでこの記事ではRSA関連の問題でよく使うテクニックを体系的に1から習得します。
テクニック GCD, 中国剰余定理, 終結式, グレブナー基底, LLL, Approximate GCD, Coppersmith
前提知識は出来る限り高校数学に絞っていますが、それでも少し大学での数学が出てきますので適宜補ってほしいです。
時計の世界 RSA暗号を語る上で最も根幹を成すのが、Nを自然数として「Nを法とする」算術です。</description></item><item><title>Wiener's Attack</title><link>https://anko9801.github.io/blog/crypto/RSA/WienersAttack/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://anko9801.github.io/blog/crypto/RSA/WienersAttack/</guid><description>説明 $3d &amp;lt; N^{\frac{1}{4}}$ のとき ( $d$ が小さすぎるか $e$ が大きすぎるとき)、$e/N$ に対し主近似分数を並べると $k/d$ がある。
$$ \begin{aligned} ed &amp;amp;≡ 1 = k\phi(N) + 1 = k(N - p - q + 1) + 1 \ \frac{e}{N} &amp;amp;= \frac{k}{d}\left(1-\frac{p + q - 1 - \frac{1}{k}}{N}\right) \approx \frac{k}{d} \ \frac{e}{N} &amp;amp;\approx q_0 + \cfrac{1}{q_1 + \cfrac{1}{q_2 + \cfrac{1}{\ddots \cfrac{}{q_{m-1} + \cfrac{1}{q_m}}}}} = \frac{k_m}{d_m} \ \end{aligned} $$</description></item><item><title>その他の暗号</title><link>https://anko9801.github.io/blog/crypto/cryptography/other/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://anko9801.github.io/blog/crypto/cryptography/other/</guid><description>GoogleがTLSでの採用を提唱している共通鍵暗号方式「ChaCha」についてまとめた - sonickun.log (hatenablog.com) ChaCha RFC 7538 Salsa20
Integer factorization
Benaloh Blum–Goldwasser Cayley–Purser Damgård–Jurik GMR Goldwasser–Micali Naccache–Stern Paillier Rabin RSA Okamoto–Uchiyama Schmidt–Samoa Discrete logarithm</description></item><item><title>サイズ基底簡約</title><link>https://anko9801.github.io/blog/crypto/Lattice/size_reduction/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://anko9801.github.io/blog/crypto/Lattice/size_reduction/</guid><description>説明 $n$ 次元格子 $L$ の基底 $\{\mathbf{b_1},\ldots,\mathbf{b_n}\}$ を GSO 係数 $\mu_{i,j}$ が
$$ |\mu_{i,j}| \leq \frac{1}{2} \quad (1 \leq \forall j &amp;lt; \forall i \leq n) $$</description></item><item><title>ゼロ知識証明</title><link>https://anko9801.github.io/blog/crypto/cryptography/ZeroKnowledgeProof/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://anko9801.github.io/blog/crypto/cryptography/ZeroKnowledgeProof/</guid><description>ゼロ知識証明の性質
完全性（Completeness） 証明者の主張が真であるならば、検証者は真であることが必ずわかること。 健全性（Soundness） 証明者の主張が偽であれば、検証者はかなり高い確率でそれが偽であること見抜けること。 ゼロ知識性（Zero Knowledge） あらゆる場合において、検証者が証明者から何らかの知識（情報）を盗もうとしても、証明者の主張が真であること以上の知識は得られない 名前の通り対話型は有名な洞窟の例のように証明者と検証者がやりとりを繰り返し、証明者が本当に正しい情報を持っているかを確率的に検証する方です。</description></item><item><title>ハッシュ関数</title><link>https://anko9801.github.io/blog/crypto/Hash/hash/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://anko9801.github.io/blog/crypto/Hash/hash/</guid><description>説明 原像計算困難性 与えられた $h$ に対して $H(m) = h$ となる $m$ を見つけることが困難である． 第二原像計算困難性 $m1$ が与えられたときに $H(m1) = H(m2)$ となる $m2(̸= m1)$ を求めるのが困難である． 衝突困難性 相異なる $m1$ と $m2$ で，$H(m1) = H(m2)$ となるメッセージを見つけることが困難である． HMAC (Hash-based MAC)</description></item><item><title>メルセンヌ ツイスタ</title><link>https://anko9801.github.io/blog/crypto/PRNG/MersenneTwister/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://anko9801.github.io/blog/crypto/PRNG/MersenneTwister/</guid><description>説明 長い周期 $2^{19937}-1$ を持つ疑似乱数生成器。連続した624回の32ビット出力から内部状態を復元できてしまう。 2つの値で十分のときもあるらしい https://www.ambionics.io/blog/php-mt-rand-prediction
参考 メルセンヌ・ツイスタをわかった気になる Mersenne Twisterの出力を推測してみる</description></item><item><title>参考資料</title><link>https://anko9801.github.io/blog/crypto/books/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://anko9801.github.io/blog/crypto/books/</guid><description>Crypto books 暗号理論入門―暗号アルゴリズム、署名と認証、その数学的基礎 （原書第３版）ブーフマン Buchmann (著)
The Block Cipher Companion
現代暗号の誕生と発展：ポスト量子暗号・仮想通貨・新しい暗号 岡本 龍明 (著)</description></item><item><title>指数計算法 (Index Calculus Algorithm)</title><link>https://anko9801.github.io/blog/crypto/DLP/IndexCalculus/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://anko9801.github.io/blog/crypto/DLP/IndexCalculus/</guid><description>説明 実装 使用例 参考</description></item><item><title>数体ふるい法</title><link>https://anko9801.github.io/blog/crypto/DLP/NumberFieldSieve/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://anko9801.github.io/blog/crypto/DLP/NumberFieldSieve/</guid><description>説明 実装 使用例 参考</description></item><item><title>格子</title><link>https://anko9801.github.io/blog/crypto/Lattice/Lattice/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://anko9801.github.io/blog/crypto/Lattice/Lattice/</guid><description>説明 格子 (Lattice) 図でイメージ掴むのが速い
線形独立な $n$ 個のベクトル $\mathbf{b}_1, \mathbf{b}_2, \ldots , \mathbf{b}_n \in \mathbb{R}^m$ について整数係数の線形結合によって生成されるベクトルの集合を格子 $L$ と定義します。
$$ L = \left{ \sum_{i=0}^{n} a_i\mathbf{b}_i \ \middle| \ a_i \in \mathbb{Z} \right} $$</description></item><item><title>楕円曲線暗号</title><link>https://anko9801.github.io/blog/crypto/ECC/ECC/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://anko9801.github.io/blog/crypto/ECC/ECC/</guid><description>楕円曲線暗号 楕円曲線 $K$ を任意の体、 $f(x) \in K[x]$ を3次方程式とする。ただし $f(x)$ の3解は相異なる。ここで次の方程式を考える。
$$ y^2 = f(x) $$
$x, y$ 線形変換によって2次の項は消すことができ、
$$ y^2 = x^3 + ax + b $$</description></item><item><title>準同型暗号</title><link>https://anko9801.github.io/blog/crypto/cryptography/homomorphism/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://anko9801.github.io/blog/crypto/cryptography/homomorphism/</guid><description>レベルn準同型 = 加法準同型 + n回の乗算準同型
乗算回数に制約がある完全準同型 レベルnはn次方程式を計算できる レベル2準同型なら乗算が1度だけ可能 Unpadded RSA 乗法準同型 $$ \begin{aligned} \mathcal{E}(m_1)\times\mathcal{E}(m_2) &amp;amp;= m_1^em_2^e &amp;amp; \bmod n \ &amp;amp;= (m_1m_2)^e &amp;amp; \bmod n \ &amp;amp;= \mathcal{E}(m_1m_2) \end{aligned} $$</description></item><item><title>逆元が存在しないとき</title><link>https://anko9801.github.io/blog/crypto/RSA/NoInverse/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://anko9801.github.io/blog/crypto/RSA/NoInverse/</guid><description>説明 乗法群の位数が $\phi(N) = se^n = 0 \pmod e$ のとき $e$ の逆元が取れない。このとき、位数 $s$ の乗法群に落として逆元を取り、位数 $se^n$ の元を $e^n$ 回掛けて全探索すると平文が見つかる。
計算量 $O(e^n)$</description></item><item><title>離散対数問題 (DLP)</title><link>https://anko9801.github.io/blog/crypto/DLP/DLP/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://anko9801.github.io/blog/crypto/DLP/DLP/</guid><description>説明 離散対数問題 (DLP: Discrete Logarithm Problem) とは巡回群 $G$ について $a, b\in G$ が与えられるので $a^n = b$ となる最小の $n\in \mathbb{N}$ を求める問題である。</description></item></channel></rss>