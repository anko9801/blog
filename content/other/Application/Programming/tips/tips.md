`inline` は呼び出し地点で関数のコードを展開する.
`constexpr` は呼び出し地点で静的に計算し, 定数としてインライン展開される.
### コンパイラの最適化手法: 定数伝搬で十分ではないか？またそれに任せることはできないのか?
- 関数の形だと定数伝搬できるところもできないので最適化できない.
- 定数伝搬可能関数と同値な性質
- 抽象化された機能を使うより抽象化されてない機能の方がよいというのは改善すべき.

- 停止性問題(決められる性質をeBPFや)

静的に計算するにはいくつか条件が必要となるが C++ では次のように定義されている. constexpr制約
- constexpr変数は初期化時, constexpr関数は呼び出し時に静的に検査する.
- constexpr変数はprimitiveな値/演算, constexprかつ静的に決定可能な変数/関数によって初期化されること.
- constexpr関数は. つまりコンパイル可能かは呼び出し時の引数に依存する.
- constexpr関数の引数には実行時にしか決まらない値(標準入力, ファイルから読んだ値, 乱数など)を渡すことができる.
- constexpr テンプレート関数がコンパイル可能かは呼び出し時に依存する
```cpp
inline constexpr Type funcname() noexcept { }
```
`const` や `private, public` などのアクセス修飾子, 名前空間などのスコープは静的に検査することで性質を保証し, その保証を利用してコードの見通しをよくしたり, バグを防げる.
`const` は初期化後に二度と変更されない変数や関数である.


C++20 `<concepts>`
