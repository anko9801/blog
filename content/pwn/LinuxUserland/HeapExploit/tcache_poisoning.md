
 ヒープ関連
資料
[https://www.youtube.com/watch?v=0-vWT-t0UHg]
[https://www.valinux.co.jp/technologylibrary/document/linux/malloc0001/ malloc(3)のメモリ管理構造 - VALINUX]
[https://qiita.com/kaityo256/items/9e78b507940b2292bf79 mallocの動作を追いかける(mmap編)]
[https://heap-exploitation.dhavalkapil.com heap-exploitation]
攻撃デモ [https://github.com/shellphish/how2heap how2heap]
[https://ptr-yudai.hatenablog.com/entry/2019/05/31/235444 ヒープ系問題におけるstdout / stderrを利用したメモリリーク - CTFするぞ]

tcache
fastbin
unsorted bin
mmap

code:c
 struct malloc_chunk {
   INTERNAL_SIZE_T      mchunk_prev_size;  /* Size of previous chunk (if free).  */
   INTERNAL_SIZE_T      mchunk_size;       /* Size in bytes, including overhead. */
   struct malloc_chunk* fd;                /* double links -- used only if free. */
   struct malloc_chunk* bk;
   /* Only used for large blocks: pointer to next larger size.  */
   struct malloc_chunk* fd_nextsize; /* double links -- used only if free. */
   struct malloc_chunk* bk_nextsize;
 };
Allocated chunk
code:c
     chunk-> +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
             |             Size of previous chunk, if unallocated (P clear)  |
             +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
             |             Size of chunk, in bytes                     |A|M|P|
       mem-> +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
             |             User data starts here...                          .
             .                                                               .
             .             (malloc_usable_size() bytes)                      .
             .                                                               |
 nextchunk-> +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
             |             (size of chunk, but used for application data)    |
             +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
             |             Size of next chunk, in bytes                |A|0|1|
             +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
Notice how the data of an allocated chunk uses the first attribute (mchunk_prev_size) of the next chunk. mem is the pointer which is returned to the user.
Free chunk
code:c
     chunk-> +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
             |             Size of previous chunk, if unallocated (P clear)  |
             +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
     `head:' |             Size of chunk, in bytes                     |A|0|P|
       mem-> +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
             |             Forward pointer to next chunk in list             |
             +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
             |             Back pointer to previous chunk in list            |
             +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
             |             Unused space (may be 0 bytes long)                .
             .                                                               .
             .                                                               |
 nextchunk-> +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
     `foot:' |             Size of chunk, in bytes                           |
             +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
             |             Size of next chunk, in bytes                |A|0|0|
             +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

 ヒープバッファオーバーフロー :  Heap-based buffer overflow
ヒープ上のバッファオーバーフローを利用して、関数の戻りアドレスや関数ポインタを書き換える
[https://inaz2.hatenablog.com/entry/2014/05/14/011448 ヒープオーバーフローによるGOT overwriteをやってみる - ももいろテクノロジー]
[https://inaz2.hatenablog.com/entry/2014/05/15/012621 ヒープオーバーフローによるC++ vtable overwriteをやってみる - ももいろテクノロジー]

 use-after-free
解放した領域を誤って使用してしまうUse After Freeを利用し、同じ領域に悪意のあるデータ構造を確保して利用させる事で、関数ポインタを書き換える。
[https://inaz2.hatenablog.com/entry/2014/06/18/215452 use-after-freeによるGOT overwriteをやってみる - ももいろテクノロジー]
[https://inaz2.hatenablog.com/entry/2014/06/18/220735 use-after-freeによるC++ vtable overwriteをやってみる - ももいろテクノロジー]

前回使用したサイズ以下の容量を確保することでfreeした後のデータを使える。
解放済みポインタ ( ダングリングポインタ :  dangling pointer ) を悪意のあるアドレスへ変えることで意図しない挙動にすることができる。

 C++ vtable overwrite
C++では仮想関数を実現する為に実行バイナリ中に型に対して呼び出す関数の対応表( vtable :  virtual method table )を持つ。このvtableの行先を書き換える。たぶん、C++だけではなく動的ポリモーフィズムを選択した言語なら出来そう。
動的ポリモーフィズム C++
静的ポリモーフィズム Rust
[https://inaz2.hatenablog.com/entry/2014/05/15/012621 ヒープオーバーフローによるC++ vtable overwriteをやってみる - ももいろテクノロジー]
[https://inaz2.hatenablog.com/entry/2014/06/18/220735 use-after-freeによるC++ vtable overwriteをやってみる - ももいろテクノロジー]
[https://ptr-yudai.hatenablog.com/entry/2019/02/12/000202 _IO_str_overflowを使ったvtable改竄検知の回避手法 - CTFするぞ]

 __free_hook 書き換え
__free_hookはfree時に呼び出す関数アドレスを指定できる。Full RELROでも書き換えられる。
[https://qiita.com/hanya1995/items/c29a89737bbd521e67f2 SECCON Beginners CTF 2020 Beginners Heap Writeup &初心者向け解説]

 tcache poisoning
[https://hackmd.io/@Xornet/H1hYUUR2I SECCON Beginners CTF 2019 - Babyheap]

 tcache double-free
glibc 2.28 以前の tcache では double free が検出されない
[https://smallkirby.hatenablog.com/entry/2020/12/15/042803 【pwn 41.0】realloc-baseのmemory corruptionの古い小ネタと最近のtcache周りの小話 - newbieからバイナリアンへ]

　chunk overlap

　fastbin attack


[https://ptr-yudai.hatenablog.com/entry/2019/05/31/235444 ヒープ系問題におけるstdout / stderrを利用したメモリリーク - CTFするぞ]