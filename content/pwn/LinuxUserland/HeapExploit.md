---
title: "glibc heap exploitation を支える技術"
---

この記事を和訳します。
https://0x434b.dev/overview-of-glibc-heap-exploitation-techniques/

この記事では広く知られている GLIBC heap exploitation の技術の全体像を見ることを目的としています。実際の攻撃は読者への課題とします。blah blah

64bitのシステムを前提とします。

## Heap Exploit の基礎
### Chunks
チャンクサイズとデータサイズは違います。チャンクはデータの前に 0x10 分のメタデータを使います。
malloc はデータサイズ0x10ごとに
チャンクサイズを基本に扱います。
free allocated

![[Pasted image 20221228215339.png]]

### bins
bins とは free されたチャンクのリストです。bins はチャンクのサイズによって管理の仕方が異なります。次にそれらを簡単に紹介します。
free listを使って管理する。
チャンクのリサイクルをすることで最適化します。

リストは2種類あり、次のような性質があります。
- 単方向連結リストは高速なリストです。LIFO で先頭は arena で管理されています。チャンクのデータ部分の先頭 8 バイトは forward pointer (fd) として使われ、次のチャンクのポインターが格納されています。末尾の fd は NULL になります。
- 双方向循環リストは双方向移動できる円形のリストです。FIFO で先頭と末尾は arena で管理されていて、チャンクのデータ部分の先頭 16 バイトは forward pointer (fd), back pointer (bk) として使われます。

tcache -> fastbins -> unsortedbin -> smallbins -> largebins -> top_chunk

#### tcache (per-thread cache) bins
glibc v2.26 以降では各スレッドに tcache を持ち各スレッドに特化して
64 tcache bins サイズごとに単方向連結リストがあり、最大で 7 個持てる (arena の変数 `tcache_count` がカウントする)
tcache が満杯になると他の bins に

![[Pasted image 20221229003517.png]]

#### fastbins
tcache が既にいっぱいのとき、チャンクサイズが 0x20 から 0xb0 なら fastbins という単方向連結リストに繋がれます。fastbins はサイズに合わせて 0x20, 0x30, ..., 0xa0, 0xb0 と全部で 10 個あり、それぞれ同じ大きさのチャンクを格納しています。各 fastbins の先頭は arena にあり、

![[Pasted image 20221228220533.png]]

#### unsortedbin
更にキャッシュ最適化をする
任意の大きさのチャンクは unsortedbin という双方向循環リストに繋がれます。unsortedbin は1つのみで
リストの先頭と末尾は arena にあります。先頭に挿入されます。

last_remainder
要求のあったサイズと合致するchunkが見つからない場合、既存のchunkを要求サイズで分割する場合があります。残りの領域は新たなchunkとして登録されます。last_remainderはこの時の残りのchunkの内、最新のアドレスを格納します。
切り出しが複数あるとフラグメンテーションが進む

smallbins の範囲でサイズより大きければ split
just-fitならそれを返す

![[Pasted image 20221229003524.png]]

#### smallbins
unsortedbin でソートが起こったとき、チャンクサイズが 0x20 から 0x3f0 なら smallbins という FIFO の双方向循環リストに繋がれます。62個の各 smallbins の先頭は arena にあります。

![[Pasted image 20221229000853.png]]

#### largebins
largebins という双方向循環リストに繋がれます。先頭は arena にあります。
fastbins や smallbins とは違い、just-fitなチャンクではなくある範囲のチャンクサイズ
ある範囲のチャンクサイズに対し1つのlargebin
largebinの中でuniqueなサイズを1つ取ってきてそれらをnextsizeの循環リストを作る

largebins から確保されたメモリは `last_remainder` はセットされない。

![[Pasted image 20221229003544.png]]

#### Unlinking
#### Remaindering
#### Exhausting
#### Consolidation

#### Arena
arena は malloc が使う為の状態以上の何物でもない。

主に bins から構成されるが、その他にいくつか注目すべきフィールドがある。
- `mutex`フィールドは arena へのアクセスを serialize する。
- `flag` フィールドはヒープメモリが連続であるかが書かれてある。
- `have_fastchunks` は fastbins が空ではないことを表す真偽値。
- `binmap` はsmallbins largebinsで素早く見つける為に使われるビットベクタです。
- `next` フィールドは arena の単方向循環リスト。`next_free` も空いてる arena の単方向連結リストです。
- `attached_threads` は arena にアクセスしているスレッドの数です。
- `system_mem` は arena によって現在確保されている書き込み可能なメモリの合計値。`max_system_mem` はその最大値です。

![[Pasted image 20221229122847.png]]

#### malloc hooks
これらのフックは heap exploit において非常に有用でしたが glibc >= 2.34 で削除されました。

- `__malloc_hook` / `__free_hook` / `__realloc_hook`
- `__after_morecore_hook`
- `__malloc_initialize_hook`
- `__memalign_hook`
- `_dl_open_hook`

## 修正済み技術
### House of Prime
fastbins の最大サイズ変数を破損させて、特定の状況下で攻撃者が arena 構造体をハイジャックし、その結果任意のメモリチャンクを返すか、
アイデア
2回の `free()` 、1回の `malloc()` の呼び出しができるとき


TODO malloc.c を書き換えてビルドしたものを使ってパフォーマンス計測