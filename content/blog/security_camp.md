セキュリティ・キャンプ全国大会2022 オンライン
専門コース C【脅威解析クラス】応募課題

以下の問1から問8について、それぞれ5,000文字以内で回答してください。

問5および問6については配布ファイルを使用します。以下に配布ファイルのSHA-256ハッシュ値を記載しますので、正しいファイルを取得できていることを確認した上で課題に取り組んでください。

- sc2022_challenge05.zip
  - 0292b1972845b6c3a57129acfd0de403f6f8080a4e2a3eef93c3913c63efe0df

- sc2022_20220322T230402.zip
  - 088e8fb04f486bae5d2dca1ccf9e5b971044c297bd03f7a5bd05bfaded6f27c3

なお、正解がある設問については、"正解していること"よりも"正解にたどり着くまでのプロセスや熱意"を重要視しています。答えにたどり着くまでの試行錯誤や自分なりの工夫等を書いて、精一杯アピールしてください。

## 問1
あなたがセキュリティ・キャンプ全国大会に応募する理由を教えてください。受講生や講師とのコミュニケーション、受講したい講義、なりたい自分など、何でも構いません。

私は大学のサークルでCTF班と呼ばれる班に所属し、毎週CTFに参加し、セキュリティについて学んでいます。先月、そのサークルが主催するCTFの問題の作成から開発、運営まで携わる機会を頂き、それらを経験した結果、自分がセキュリティについて知らないことがあまりにも多く、知っていても表面的で断片的なことに過ぎないことを痛感しました。それでセキュリティについて、徹底的に勉強したいと強く思ったことがセキュキャンに応募する理由です。

箇条書きにすると以下の通りです。

- CTFに強くなりたい
- 強い人や知らない分野と出会って刺激されたい`
- カーネルエクスプロイトを出来るようになってカーネルの脆弱性を見つけ、修正、報告したい
- ウイルスを実際に読んでAnti Virusソフトを自作してみたい
- 物理レイヤーへの攻撃や複数レイヤーを通じた攻撃、他分野と合わせた攻撃(シーケンサーの脆弱性を踏むようなDNAの生成など)、最近の技術であるTEEやeBPFへの攻撃について知りたい
- 攻撃/防御を抽象化したい

欲張りですが、何でも学んで経験してみたいです。

## 問2
今までに解析したことのあるソフトウェアやハードウェアにはどのようなものがありますか？解析の目的や解析方法、結果として得られた知見などを含めて教えてください。

CTFで実行ファイルを読んだりすることはありますが、世のソフトウェアのバイナリを読むと言った経験が乏しくて本当の解析の例を出せません。ただ、ソースコードを読むという体験なら幾つかあります。

Linuxカーネルを知りたいという欲求からサークルの2人でLinuxカーネルを読むことをしています。syscallの実装やスケジューラ、メモリ管理やKASLRなどの実装を読んでいました。高速化の為に読みにくく雑(?)な実装になるのが面白いなと感じます。得られた知見というと大きなコードを読む力です。自分はどんなコードであれ、気になった機能を一番下まで深掘りして読みたくなってしまうのですが、もう1人の方が途中で切り上げてくださり、丁度いい塩梅で読むことが出来ていると思います。(それでも抑えきれず、途中から読んでる場所が全然違ってきて知見を共有できないことが多々ありました笑)

後は必要に応じて OSS 例えば python や golang などの言語の実装だったり V8 だったり CTF では Crypto を担当してるので SageMath の実装だったりをよく読みます。

ハードウェア系であれば購入してきたLEDランプの光量が少ない為、回路を読んではんだ付けして光量を増やしました。また物を分解する癖があり、キーボード、ラジオ、タップ、ルーターなどを分解したりしました。

## 問3
今までに作成したソフトウェアやハードウェアにはどのようなものがありますか？
どんな言語やライブラリ、パーツを使って作ったのか、どこにこだわって作ったのか、などたくさん自慢してください。

- 自作プログラミング言語
2018年度のSecHack365に参加し、IoT向け言語として安全性と手軽さ、速度を持ち合わせた言語を作りました。C++のライブラリを用い、LLVMベースの言語で、C++, Rust, Kotlinに影響されていて、他とは違う所はライフタイムに関連する機能を実装したりした所です。その当時はそれで満足していたようですが、今の視点からするとおもちゃなのでより安全で心地よい言語を書きたいなと思います。

- 量子コンピュータ用のC++ライブラリ
JOIの夏季合宿でqasmと呼ばれる言語へのトランスパイラと古典コンピュータ上でのシミュレート(もちろんqubit数に対し指数時間/メモリ)をIBM Qにある演算に対し実装しました。

- 将棋AI
高校生のころ、ディープラーニングを用いて何か作りたいと思い、将棋AIを学習させました。どこかのサイトにある棋譜を元に Chainer で書いたものに学習させました。その当時は探索アルゴリズムに弱く、アルファベータ法などを知らなかった為、序盤/中盤は強いですが終盤はかなり弱いというものになりました。最近では GPT-3 などの Transformer が流行っていて、もう一度勉強し直して音声変換技術やブラウザのタブについてカテゴリに応じて自動的にグループ化するもの、あとは文章を書くのが苦手なのでブログを書くお手伝いをしてくれるものなどを作りたいなと思っています。

- 水中ロボット
高校のときに水中ロボットをチームで開発し、水中ロボコンinJAMSTECに芝浦工業大学附属高校として参加し、優勝しました。自分はプログラムを書いただけなのでほぼ他の方のおかげですが、それがきっかけとなり、今は水中ロボコンのサークルで回路を組む手伝いをしています。

- レイトレーシング
シェーダーについてあまり理解できてなかったのでレイトレーシング技術が面白そうと思いそのエンジンを開発しました。Ray Tracing in One Weekend という記事を参考にしてRustで書き、ppmと呼ばれる形式で出力して表示するというものを作りました。レイマーチングはまだ出来てないのでやりたいなと思っています。

- ELF解析ツール
ELFの静的解析と動的解析ができるツールです。ELFファイルをバイナリで直読みできるようになりたいと思い開発しました。
静的解析は ELF header, Program header table, Section header table などを読んで Spotify TUI などで使われているライブラリ tui-rs で TUI 表示してもらうものです。動的解析は実質自作デバッガーでそれを実行するプロセスを起動してptraceでアタッチし、レジスタやアセンブリなどの情報を取ってきて表示してくれるものです。メモリの値から大体の型を決めてアドレスは参照先のも表示したり文字列は文字列として表示しました。

- 自作シンボリック実行エンジン
rev問をやっているとangrと呼ばれるシンボリック実行エンジンをよく使うのですが、その仕組みがあんまり理解できてなかったので自作しました。開発期間が3日間なのでx64アーキテクチャで本当に小規模なものを作りました(本当はボーっと生きてたら3日後にLTがあることに気付き、やばいと思いつつ、この無謀なネタにしたら作れてしまったという締切駆動開発の凄さと恐ろしさを知りました)。
シンボリック実行エンジン自体の仕組みは命令列をSMTに投げるだけというものです。実際はSMTまで自作したかったですが、資料が見つからず、z3に任せることにしました。実装はx64アーキテクチャの必要最小限の命令を実装しました。ネタを考えたときにその時流行っていたCVE-2022-0778: OpenSSLの無限ループの脆弱性を検出しようと考えていましたが、普通にやると(よく考えればできそうですが)ループ回数に対し、指数時間掛かり、5,6回くらいのループで数時間のオーダーとなり、数十回までループすれば無限ループと決定できたのですが、その検出は不可能と後で気付きました。
また言語はRustで開発したのですが設計の段階で大きな間違いを犯していて、どのようにしても解決できないような循環参照に陥り、その修正にかなり悩ませられ、開発のほとんど時間はこれに注ぎ込みました。おかげでRustの設計思想が分かるようになり、ライフタイムに頭を抱えるということがほぼ無くなりました。

- 競技プログラミングとCTFのコンテストの運営、開発、作問
開発では Rust, React で競プロのコード実行とフロントを繋ぐ部分の修正をしたり、 Ansible を書きました。作問は Crypto 分野を主に作り、他は簡単なものを1つずつほど作りました。改めて CTFer としてよわいなと感じ、これから1年強くなろうと決意しました。

- その他
これは車輪の再発明で開発には入らないと思いますが、理解したくなったら自作することがあり、OS, シェル, ALU, DB, ゲームエンジン などを自作しました。

## 問4
ここ数年に発表された、以下のキーワードに関連するニュースや記事や学術論文から1つ選び、それに関して調べた内容を記述してください。内容には、1.選んだ理由、2.技術的詳細、3.被害規模または影響範囲、4.対策、の4点を必ず含めてください。なお、対策は今ある技術のみに捕われず、将来的な技術や法律など、自由な発想で書いてください。

キーワード：
- サイバーセキュリティインシデント
- マルウェア
- 攻撃キャンペーン
- 脆弱性
- 新たな攻撃手法
- 未知の脅威

サイバーセキュリティインシデントの1つとしてサプライチェーン攻撃があります。これはどうすれば攻撃を防ぐことができるか気になったため選びました。
サプライチェーン攻撃とは例えばOSSであればライブラリに悪意のあるスクリプトが埋め込められるとそれに依存する全てのプロジェクトに被害が波及するような攻撃です。今年3月にもnpmでサプライチェーン攻撃がありました。ハードウェアであれば、部品のボードに微小なチップが埋め込まれていたり、ハードウェアトロイと呼ばれる集積回路に不正な処理が埋め込まれていたりする可能性があり、それをベースに組んだ製品は機密情報を盗まれたり妨害されることが考えられます。
これらに対しセキュリティを担保するためには、悪意のあるスクリプトを検知する手法やハードウェアトロイを検出する手法を開発する必要があり、それが出来なければ DevSecOps の思想のように部品調達からサービス化まで全体を通じたセキュリティの評価手法を社会的な仕組みや制度を通して行えればよいと思います。
また、これは実現可能かどうかは分かりませんが、私はより進んだ攻撃/防御の概念の理解によって言語側からサポートできると思っています。

## 問5
配布ファイル（sc2022_challenge05.zip）に含まれるsafe.exe.gzfは解析対象のPEプログラムをGhidraデータベース形式に変換したものです。data.datは解析対象のプログラムが使用するデータです。safe.exe.gzfを解析して以下の問題に対して回答してください。

※Ghidraのインストールおよびgzfに関する補足: https://hackmd.io/@qKyR9Y4rS7y7ytUCRr6FRg/H188XOvXq

### 問5-1 
このプログラムの目的、挙動を説明せよ。

Windows関連の様々な関数があることがわかり、 WinMain 関数についてデコンパイラを用いて調べると、 'C:\Users\Public\KB59E7269.log' というファイルを開き、その内容を暗号化したものをアプリのディレクトリ名としてウィンドウを起動しているようです。他の関数はライブラリや内部情報を取得してプロセスの起動準備を行うイニシャライザのような関数群などがありましたがプログラムとは関係がなさそうなのでこれらは無視します。
つまり、このプログラムはWindowsのログファイルを暗号化するプログラムです。

### 問5-2 
data.datがどのような形式で暗号化されているか答えよ。また、復号されるデータの内容がどのようなものか答えよ。

察するに暗号化されたものが data.dat に書かれてあると考えられます。
暗号化の手法について読んでみると、まずファイルを16バイトのヘッダとそれ以外に分割し、ヘッダは共通鍵として、具体的には内部状態(S-box)を生成するのに使い、内部状態を用いて後半の内容を暗号化します。内部状態は0x00から0xffまでの値の順列となっており具体的な生成方法は以下の通りです。ただし演算は $\mathbb{Z}/256\mathbb{Z}$ 上で行うこととします。

1. 256バイトの内部状態に0x00から0xffまで書き込む。
2. 数 w をおき、現在見ている内部状態の値とヘッダの値を w に足し、内部状態の w の位置にある値とスワップする。
3. 2を内部状態の最初から順番に最後まで繰り返す。

暗号化の具体的な方法は以下の通りです。

1. 数 p をおき、現在見ている内部状態の値を p に足し、内部状態の p の位置にある値とスワップする。
2. スワップしたそれぞれの数を足した位置にある内部状態の値の位置にある内部状態の値を暗号化したい内容とxorする。
3. 1,2を暗号化したい内容の最初から順番に最後まで繰り返す。

復号することについて考えます。この暗号は共通鍵方式のストリーム暗号に属し、秘密鍵であるヘッダさえ分かれば内部状態が分かり復号することができます。つまり復号する方法は2つあり、1つは秘密鍵を当てる方法、もう1つはこの暗号の脆弱性を発見する方法があります。
まず秘密鍵を直接当てる方法です。気付いたことはログファイルということなのでまず ASCII で書かれている可能性が高いということがあります。これで128ビット全探索が約112ビット全探索となりましたが目標は大体32ビット全探索なのでこれは誤差です。他にもWindowsのログファイル特有の性質を調べましたが無さそうでした。また以下のように定式化しても構造が複雑で秘密鍵の特定が難しかったです。

$$
\begin{aligned}
&\begin{cases}
p_{i+1} = p_i + s_i + h_i \\
s_i \iff s_{p_{i}} \\
\end{cases} \\
&\begin{cases}
p_{i+1} = p_i + s_i \\
s_i \iff s_{p_{i}} \\
m_{i} = c_i \oplus ss(s_i + s_{p_{i}}) \\
\end{cases}
\end{aligned}
$$

そこで2つ目、暗号の規則性を発見することを考えます。調べてみると差分解析法や線形解読法が当てはまりそうなのでそれをやろうとしたのですが、文献の少なさと難しさから応募するまでに試すことが出来ませんでした。

### 問5-3
data.datを復号するスクリプト作成して提出せよ。

秘密鍵を全探索するスクリプトを書きました。

```python
from string import printable

strs = printable

def search(h):
    if len(h) == 16:
        dec = decrypt(list(reversed(h)))
        m = []
        for i in range(size):
            c = next(dec)
            m.append(cipher[i] ^ c)
            if chr(m[i]) not in strs:
                if i > 5:
                    print(bytes(reversed(h)), bytes(m))
                break
        return
    for s in strs:
        h.append(ord(s))
        search(h)
        h.pop()

def decrypt(h):
    sbox = [0] * 0x100
    for i in range(0x100):
        sbox[i] = i
    swap = 0
    for i in range(0x100):
        swap += h[i & 0xf] + sbox[i]
        swap &= 0xff
        sbox[i], sbox[swap] = sbox[swap], sbox[i]
    swap = 0
    i = 0
    while True:
        swap += sbox[i]
        swap &= 0xff
        sbox[i], sbox[swap] = sbox[swap], sbox[i]
        yield sbox[sbox[(sbox[i] + sbox[swap]) & 0xff]]
        i = (i + 1) & 0xff

with open('data.dat', 'rb') as f:
    cipher = f.read()
    size = len(cipher)
    search([])
```

## 問6
配布ファイル（sc2022_20220322T230402.zip）は、Windows 10 PCのユーザsc2022のホームディレクトリ(C:¥Users¥sc2022¥)以下を取得し、zip形式で圧縮したファイルです。このユーザは、あるファイルサーバ上のファイルにアクセスしていたこと、あるオンラインストレージサービスを利用していたこと、が判明しています。

以下の問題に対して、配布ファイルをどのように解析したかも含めて回答してください。

### 問6-1
ユーザがアクセスしたファイルサーバー上のファイルに関連する情報を可能な限り記載してください(例: ファイル名、ファイルパス、日時等)。

まず一通り見て関係がないと断言できるものを見つけます。以下のようなものは関係ないと言えます。

- NTUSER.DATなど: Windowsレジストリの実体
- desktop.ini: デスクトップの表示方法

これよりAppData以下が怪しいことがわかるのでそれらを中心に調べます。まず cloud, storage, drive, file などのストレージサービスで使われていそうな単語で grep し、ブラウザの閲覧履歴にありそうというアタリを付けました。

```
$ rg "storage" --binary -M 1 -m 1
```

そしてFireFoxの閲覧履歴を保存している以下のファイルから使ったファイルサーバーは firestorage だということがわかります。

`C/Users/sc2022/AppData/Roaming/Mozilla/Firefox/Profiles/hc93rfhn.default-release/places.sqlite`

https://fire.st/ZM7Nt1u などからcanary.txtというファイルにアクセスし、last_visit_dateから2022-03-22 22:35に閲覧していることがわかります。

### 問6-2 
ユーザが利用していたオンラインストレージサービスに関連する情報を可能な限り記載してください(例: サービス名、アクセス方法、日時等)。

ユーザーが利用していたオンラインストレージサービスは FireStorage で WindowsSearch のよくみるサイトなどから FireFox を起動し、2022年03月22日の22:35に閲覧した。

### 問6-3
ユーザは、ファイルサーバ上のファイルをオンラインストレージサービスにアップロードしたか、していた場合はどのファイルであったかを回答してください。

アップロードしたファイルはこのようなファイルである。
canary.txt
```
FDGG

```

## 問7
Binary Exploitに関して、次の各問に回答してください。

### 問7-1
Heap Buffer Overflowとはどのような脆弱性かを簡潔に説明してください。また、この脆弱性を攻撃者がどのように攻撃に利用するかを説明してください。

コンピュータは様々な方法でメモリを管理しています。その中でプロセスごとに持つメモリ領域として スタック(Stack) と ヒープ(Heap) があります。また、Buffer Overflowとは想定されるサイズ以上に書き込むことができてしまう脆弱性です。つまり、Heap Buffer Overflowとはヒープというメモリ領域で必要以上に書き込みが出来てしまう脆弱性です。
具体的な攻撃方法はヒープの構造について知らなければ説明できないので先にそれについて整理します。

ヒープはメモリを動的に確保、解放する仕組みをもつメモリ領域です。プログラムは malloc()/free() 関数によって確保/解放します。
最初に malloc() が呼ばれると syscall の1つである sbrk() が呼び出され、ヒープ領域を作ります。malloc() で確保され続け、ヒープ領域に空きが少なくなってくると sbrk syscall によってヒープ領域を拡張します。基本戦略としてそれぞれの空き領域をチャンクとして管理し、それらチャンクをいかに上手く使い回すかで速度が変わります。例えば、図書館の事務を想像してもらって、借りて返した本をもう一度借りるということが頻繁に起こるときに、いちいち元にあった場所に戻してまた取ってくるというのは手間で、手元に置いておく方が便利です。ただ全ての本を手元に置いておける訳ではありません。どうやって制限された場所で効率よく管理するか。これと同じようにチャンクを一旦保持しておくということをします。また、フラグメンテーションが起こるとそのチャンク free lilst と呼ばれる連結リストとして管理しています。この malloc()/free() は確保するメモリサイズを指定できるのですがサイズによって格納方法を変えています。
以下64bitのシステムを前提にして考えます。

- tcache
始めの7つのチャンクはtcacheでキャッシュされます。per-thread cache の略らしいです。
- fastbins
128B(`global_max_fast`)までの小さな領域は fastbins によってキャッシュされます。fastbins ではサイズに応じて16Bおきにリストを作成しています。これにより best-fit allocator となります。実装は main_arena にあるfastbinsY からチャンクが伸びています。
- unsorted bins
malloc_consolidate() などで他の bin で管理されなくなったものを保持します。これらは確保されるか bin に登録されるまで残り続けます。
- smallbins
1KB(`MIN_LARGE_SIZE`)までの領域は smallbins によって管理されます。8Bおきにリストを作ります。
- largebins
1KB(`MIN_LARGE_SIZE`)以上の大きな領域は largebins によって管理されます。サイズに対し指数的に間隔を広く取ってリストで管理します。
- mmap/munmap
128KB(`M_MMAP_THRESHOLD`)以上の場合は mmap/munmap によりカーネルから直接確保されます。

そして Heap Buffer Overflow はそれを使うことでデータの上書きができ、それによってヒープの管理構造を乗っ取ることができることがあります。

また、OSの核であるカーネルもヒープ領域を持ち、それに対しての BOF はKernel Heap Buffer Overflow と呼びます。ここら辺はあまり試したことがなく説明できるものが少ないですが、1回だけ meowmow という問題で Kernel Exploit を勉強していたときに kmalloc がサイズごとに分けられ、Slabと呼ばれるページ単位を小分けにして管理しているものに HBOF が出来る構造体と tty_struct 構造体を載せ、 tty_struct を書き換えて攻撃できるというものを知りました。それ以外の攻撃手法は全く知らないのでこれから理解していこうと思います。

### 問7-2
Use-after-Freeとはどのような脆弱性かを簡潔に説明してください。また、この脆弱性を攻撃者がどのように攻撃に利用するかを説明してください。

ヒープ領域のチャンクを解放した後でも使えてしまう脆弱性です。例えば、unsorted bin で Use-after-Free ができると管理領域の情報を覗くことができ、例えば fd から libc base が分かったりします。libc base が分かれば、libc 上のガジェットから Stack Buffer Overflow などで ROP を組む事ができ、シェルを起動できます。

### 問7-3
以下のx64アーキテクチャのROP gadgetを組み合わせ、後の各処理を実現するROP chainを構築してください。ROP chainは、64-bitのアドレスや値をカンマ(,)区切りで書いてください。ただし、関数A, Bのアドレスはそれぞれ0x401aa0, 0x401bb0、64-bit非負整数型変数xのアドレスは0x602080とします。また、関数A, Bの呼び出し規約はAMD64 ABIに従っており、引数・戻り値ともに64-bitの非負整数値とします。

このROP gadgetの組み合わせだけでは実現できないと判断した場合は、その理由を書いてください。

0x401027: pop rdi; ret;
0x40103a: pop rcx; ret;
0x4011f2: pop rsi; pop r12; ret;
0x40132a: mov rdi, rax; rep movsq; ret;
0x401401: xchg eax, edi; ret;

(例) A(1); B(2);
--> 0x401027, 1, 0x401aa0, 0x401027, 2, 0x401bb0

(1) A(1, 2); B(3);
(2) A(B(0));
(3) A(x);
(4) x = 0xdeadbeefcafebabe;

問題の意味が分からない場合はReturn Oriented Programmingについて調べ、ROPについてあなたが理解した内容を書いてください。

(1) A(1, 2); B(3);
0x401027, 1, 0x4011f2, 2, 0, 0x401aa0, 0x401027, 3, 0x401bb0

(2) A(B(0));
0x401027, 0, 0x401bb0, 0x401401, 0x401aa0

(3) A(x);
メモリ参照のガジェットが無いため、xの値をレジスタに格納することが出来ず、実現できません。

(4) x = 0xdeadbeefcafebabe;
スタックのアドレスが分からず、スタック上に書き込みたい値を書いてもストリング命令の転送前のアドレスを指定することが出来ないため、実現できません。

A: 0x401aa0, B: 0x401bb0
x: 0x602080

## 問8
eBPF(extended Berkeley Packet Filter)はLinuxカーネルが提供する機能の名前です。eBPFについて次の各問に答えてください。

### 問8-1
eBPFとはどのような機能かを「JIT」という言葉を用いて説明してください。

eBPF は extended Berkley Packet Filter の略で、カーネルの特定のポイントでフックさせて実行するコードを安全に仕込める技術です。これを利用することで安全で高速にカーネルの制御や活用ができます。例えばカーネルのトレースをしたり、内部情報を取得したり、パケットフィルタリングさせたり、syscallに制限を掛けたりすることができます。eBPF の中身は BPF 独自の命令セットを解釈する仮想マシンとカーネル空間とユーザー空間で共有するストレージオブジェクトがあります。ストレージオブジェクトによってカーネルの情報をユーザーにわたすことが出来ます。

プログラムは次のようにロードします。

C言語のBPFプログラム -> BPFバイトコード -> マシンコード

C言語のBPFプログラムからBPFバイトコードへはLLVM/Clangを用いてコンパイルします。生成されたBPFバイトコードは bpf syscall によりカーネルに渡され、BPF Verifierと呼ばれる検査機を用いて安全に実行できるか確認してから、マシンコードへJIT (Just In Time) コンパイラでコンパイルし、ロードされます。これによりカーネルを再起動せずにカーネル内で安全にサンドボックス化されたプログラムを実行できます。

### 問8-2
あなたが身近に使っているアプリケーションでBPF/eBPFを利用するものを探し、どのような使われ方がしているかを説明してください。見つからない場合は、普段使っていないアプリケーションでも構いません。

普段使っているアプリケーションにeBPFは用いられていなかったので、Pixieと呼ばれるアプリケーションについて調べました。
Pixie は Kubernetes クラスタのプロファイラやメトリクスの可視化を行うアプリケーションです。eBPFを用いることで様々なレイヤーでのスループットやレイテンシ、エラーを収集することができ、それらの情報を統合させてHTTPリクエストやネットワークトラフィック、それらのフロー、スロークエリ、NodeやPodのモニタリングなどをしてくれます。
