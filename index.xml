<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>🪴 あやめHex on</title><link>https://anko9801.github.io/blog/</link><description>Recent content in 🪴 あやめHex on</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><atom:link href="https://anko9801.github.io/blog/index.xml" rel="self" type="application/rss+xml"/><item><title>Setup</title><link>https://anko9801.github.io/blog/notes/setup/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://anko9801.github.io/blog/notes/setup/</guid><description>Making your own Quartz Setting up Quartz requires a basic understanding of git. If you are unfamiliar, this resource is a great place to start!</description></item><item><title>Editing Content in Quartz</title><link>https://anko9801.github.io/blog/notes/editing/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://anko9801.github.io/blog/notes/editing/</guid><description>Editing Quartz runs on top of Hugo so all notes are written in Markdown.
Folder Structure Here&amp;rsquo;s a rough overview of what&amp;rsquo;s what.</description></item><item><title>Obsidian Vault Integration</title><link>https://anko9801.github.io/blog/notes/obsidian/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://anko9801.github.io/blog/notes/obsidian/</guid><description>Setup Obsidian is the preferred way to use Quartz. You can either create a new Obsidian Vault or link one that your already have.</description></item><item><title>Preview Changes</title><link>https://anko9801.github.io/blog/notes/preview-changes/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://anko9801.github.io/blog/notes/preview-changes/</guid><description>If you&amp;rsquo;d like to preview what your Quartz site looks like before deploying it to the internet, here&amp;rsquo;s exactly how to do that!</description></item><item><title>Deploying Quartz to the Web</title><link>https://anko9801.github.io/blog/notes/hosting/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://anko9801.github.io/blog/notes/hosting/</guid><description>Hosting on GitHub Pages Quartz is designed to be effortless to deploy. If you forked and cloned Quartz directly from the repository, everything should already be good to go!</description></item><item><title/><link>https://anko9801.github.io/blog/blog/security_camp/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://anko9801.github.io/blog/blog/security_camp/</guid><description>セキュリティ・キャンプ全国大会2022 オンライン 専門コース C【脅威解析クラス】応募課題
以下の問1から問8について、それぞれ5,000文字以内で回答してください。
問5および問6については配布ファイルを使用します。以下に配布ファイルのSHA-256ハッシュ値を記載しますので、正しいファイルを取得できていることを確認した上で課題に取り組んでください。
sc2022_challenge05.zip
0292b1972845b6c3a57129acfd0de403f6f8080a4e2a3eef93c3913c63efe0df sc2022_20220322T230402.zip
088e8fb04f486bae5d2dca1ccf9e5b971044c297bd03f7a5bd05bfaded6f27c3 なお、正解がある設問については、&amp;ldquo;正解していること&amp;quot;よりも&amp;quot;正解にたどり着くまでのプロセスや熱意&amp;quot;を重要視しています。答えにたどり着くまでの試行錯誤や自分なりの工夫等を書いて、精一杯アピールしてください。</description></item><item><title/><link>https://anko9801.github.io/blog/blog/Vim/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://anko9801.github.io/blog/blog/Vim/</guid><description>Matering Vim Language https://www.youtube.com/watch?v=wlR5gYd6um0
https://vim.help/12-clever-tricks#12.2 https://career.levtech.jp/guide/knowhow/article/29/
僕がVimで愛用しているプラグイン30連発 https://liginc.co.jp/469142
Vim の operator プラグインをまとめた https://qiita.com/rbtnn/items/a47ed6684f1f0bc52906
vimcolorschemes https://vimcolorschemes.com</description></item><item><title/><link>https://anko9801.github.io/blog/crypto/AES/Symmetric_cryptography/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://anko9801.github.io/blog/crypto/AES/Symmetric_cryptography/</guid><description>最新の状況はこの発表を見ればすべてわかる Invited talk: Symmetric Cryptography for Long Term Security, by Maria Naya Plasencia - YouTube 軽量な セキュリティ vs. 効率 応用に合わせた性質</description></item><item><title/><link>https://anko9801.github.io/blog/data_structure/LinkedList/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://anko9801.github.io/blog/data_structure/LinkedList/</guid><description>1 2 3 4 pub enum List { Empty, Elem(i32, List), }</description></item><item><title/><link>https://anko9801.github.io/blog/memo/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://anko9801.github.io/blog/memo/</guid><description>仮想デスクトップについて開ける分野のサイトを制限する
OWON SPE6103
面白さ＝文脈変化×納得感 - CGMプランナーの思考 (hatenablog.com)
Joel on Software プログラマのためのユーザインタフェースデザイン 第1章: 環境をコントロールできれば楽しく感じるもの - The Joel on Software Translation Project (archive.</description></item><item><title/><link>https://anko9801.github.io/blog/other/Application/OS/ACPI/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://anko9801.github.io/blog/other/Application/OS/ACPI/</guid><description/></item><item><title/><link>https://anko9801.github.io/blog/other/Application/OS/BIOS/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://anko9801.github.io/blog/other/Application/OS/BIOS/</guid><description/></item><item><title/><link>https://anko9801.github.io/blog/other/Application/OS/FileSystem/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://anko9801.github.io/blog/other/Application/OS/FileSystem/</guid><description/></item><item><title/><link>https://anko9801.github.io/blog/other/Application/OS/Keyboard/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://anko9801.github.io/blog/other/Application/OS/Keyboard/</guid><description/></item><item><title/><link>https://anko9801.github.io/blog/other/Application/OS/Scheduler/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://anko9801.github.io/blog/other/Application/OS/Scheduler/</guid><description>タスク ジョブ、プロセス、スレッド
プロセススケジューラ スケジュールする単位はタスク。タスクはプロセスやスレッドによって作業している仕事のこと。
初期スケジューラ (~v2.4) 実行可能タスクは一般にランキューと呼ばれるキューに繋がれています。 $O(n)$
ランキューから順方向に全走査してタイムスライスが最大のタスクにコンテキストスイッチ。 インターバルタイマーが割り込み、タイムスライスを減らす。 タイムスライスを使い果たすとランキュー末尾に挿入。 1~3をすべての実行可能タスクのタイムスライスが0になるまで繰り返し、すべて使い果たしたらタイムスライスを初期化。このとき、スリープ状態のタスクには少しタイムスライスを追加。 nice 値が小さいほどタイムスライスが貰える。有効範囲は -19 ~ 20 で root でないとマイナス値を設定できない。 nice() システムコールによって変更可能。</description></item><item><title/><link>https://anko9801.github.io/blog/other/Application/Profiler/perf/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://anko9801.github.io/blog/other/Application/Profiler/perf/</guid><description>perfから読み解くプロセッサトレースの仕組み (perf + Intel PT/ARM CoreSight) - Qiita</description></item><item><title/><link>https://anko9801.github.io/blog/other/Application/Server/exploit/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://anko9801.github.io/blog/other/Application/Server/exploit/</guid><description>いもす研 (imos laboratory) (imoz.jp)</description></item><item><title/><link>https://anko9801.github.io/blog/other/Application/Server/kernel-optimization/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://anko9801.github.io/blog/other/Application/Server/kernel-optimization/</guid><description>カーネルパラメータ チューニング 【Linux】カーネルパラメータのパフォーマンスチューニングについて
ファイルディスクリプタの上限 ulimit -l 10000
sshだとulimitできない https://yohei-a.hatenablog.jp/entry/20090310/1236706236
http://ramblog.blog129.fc2.com/blog-category-4.html
1 2 3 # /etc/systemd/system/*.service [Service] LimitNOFILE=65535 カーネルパラメータ 上ほど優先順位高い(同じ名前のfileをoverrideする) /etc/sysctl.</description></item><item><title/><link>https://anko9801.github.io/blog/other/Circuit/FPGA-HDL-%E8%AB%96%E7%90%86%E5%9B%9E%E8%B7%AF/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://anko9801.github.io/blog/other/Circuit/FPGA-HDL-%E8%AB%96%E7%90%86%E5%9B%9E%E8%B7%AF/</guid><description/></item><item><title/><link>https://anko9801.github.io/blog/other/Circuit/PC%E5%91%A8%E8%BE%BA/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://anko9801.github.io/blog/other/Circuit/PC%E5%91%A8%E8%BE%BA/</guid><description>スクリーン ブラウン管 ニキシー管 液晶</description></item><item><title/><link>https://anko9801.github.io/blog/other/Circuit/%E3%82%A2%E3%83%8A%E3%83%AD%E3%82%B0-%E3%82%BB%E3%83%B3%E3%82%B5%E3%83%BC/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://anko9801.github.io/blog/other/Circuit/%E3%82%A2%E3%83%8A%E3%83%AD%E3%82%B0-%E3%82%BB%E3%83%B3%E3%82%B5%E3%83%BC/</guid><description>液晶</description></item><item><title/><link>https://anko9801.github.io/blog/other/Circuit/%E3%82%B7%E3%82%B9%E3%83%86%E3%83%A0%E5%88%B6%E5%BE%A1/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://anko9801.github.io/blog/other/Circuit/%E3%82%B7%E3%82%B9%E3%83%86%E3%83%A0%E5%88%B6%E5%BE%A1/</guid><description>モーターコントローラー Hブリッジを用いて電気を流し正転、逆転するのと逆起電力によるブレーキを操作している。 MOSFET を4つ</description></item><item><title/><link>https://anko9801.github.io/blog/other/Circuit/%E3%83%91%E3%83%AF%E3%82%A8%E3%83%AC/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://anko9801.github.io/blog/other/Circuit/%E3%83%91%E3%83%AF%E3%82%A8%E3%83%AC/</guid><description>電源 LCRメーター</description></item><item><title/><link>https://anko9801.github.io/blog/other/Circuit/%E3%83%9E%E3%82%A4%E3%82%B3%E3%83%B3/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://anko9801.github.io/blog/other/Circuit/%E3%83%9E%E3%82%A4%E3%82%B3%E3%83%B3/</guid><description>マイコンの一番楽しい所ってなに
主に次を使うことが多いです。
ATmega328P (Arduino) RP2040 (Raspberry Pi Pico) STM32 Nucleo (STM32F303K8) Universal Asynchronous Receiver/Transmitter: UART
Hardware Abstraction Layer (HAL)</description></item><item><title/><link>https://anko9801.github.io/blog/other/Idea/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://anko9801.github.io/blog/other/Idea/</guid><description>version update時の確認不足で何かしらの悪意のあるプログラムを入れることができる</description></item><item><title/><link>https://anko9801.github.io/blog/other/streat/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://anko9801.github.io/blog/other/streat/</guid><description>物理学 生物学 ロケット 飛行
回路 トランジスタ (NPN接合)
AVRマイコンライター自作 電源自作 JTAG によるデバッグ FPGA による RISC-V CPU 自作 CPU Break toolchain 自作 プログラミング言語自作 OS自作 Kernel Exploit ロスレス音声コーデック (PARCOR係数・エンコード済み残差信号) Video DeepLearning</description></item><item><title/><link>https://anko9801.github.io/blog/pwn/glibc/glibc/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://anko9801.github.io/blog/pwn/glibc/glibc/</guid><description>glibc ビルド方法 https://www.gnu.org/software/libc/ のリリースページから ftp に飛んでダウンロードする. ビルド作業用のディレクトリを作ってそこに入る ../glibc-hoge/congifure --prefix=/path/to/インストールしたい場所 make -j{N} make install glibc 自前ビルドしてるとデバッグ情報も付いてくる. patchelf では手で叩かないといけない. pwninit なら glibc を同じ階層に入れておけば pwninit で勝手にやってくれる.</description></item><item><title/><link>https://anko9801.github.io/blog/pwn/Kernel/kernel_reading/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://anko9801.github.io/blog/pwn/Kernel/kernel_reading/</guid><description>tkmru/linux-insides-ja: Japanese version of linux-insides book (github.com) Cryptogenic/PS5-IPV6-Kernel-Exploit: An experimental webkit-based kernel exploit (Arb. R/W) for the PS5 on &amp;lt;= 4.</description></item><item><title/><link>https://anko9801.github.io/blog/pwn/pwn/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://anko9801.github.io/blog/pwn/pwn/</guid><description>脆弱性の種類と，その攻略方法 Vulnerabilities: Stack BOF, Heap BOF, Use After Free, Format String Bug, Race Condition &amp;hellip; Exploit Techniques: ret2plt, ret2libc, ROP, GOT Overwrite, Stack pivot &amp;hellip; Anti-Exploits: NX, ASLR, RELRO, PIE, Stack Canary &amp;hellip;</description></item><item><title/><link>https://anko9801.github.io/blog/web/Browser/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://anko9801.github.io/blog/web/Browser/</guid><description>browser d0iasm/vulbr: Toy browser on single process / thread (github.com)
WAF
PHP の file_get_contents はローカルファイルもウェブ上も取ってくる。 正規表現の . は改行にマッチしない。
React Preact MobX Solid: React + MobX feat.</description></item><item><title/><link>https://anko9801.github.io/blog/web/security/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://anko9801.github.io/blog/web/security/</guid><description>XSS Prototype Pollution CSV Injection SQL Injection FTP Injection XXE CSRF Clickjacking SSRF Web Cache Poisoning Relative Path Overwrite
XXE CSP WAF</description></item><item><title>AES</title><link>https://anko9801.github.io/blog/crypto/AES/AES/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://anko9801.github.io/blog/crypto/AES/AES/</guid><description>AES-ECB (Electronic Codeblock) AES-CBC (Cipher Block Chaining) AES-CTR PCBC (Propagating Cipher Block Chaining) CFB (Cipher Feedback) AES-GCM (Galois/Counter Mode) AES-NI</description></item><item><title>Anti debugging</title><link>https://anko9801.github.io/blog/rev/anti_debugging/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://anko9801.github.io/blog/rev/anti_debugging/</guid><description>説明 参考 Linux (anti)+ debugging (feneshi.co) ウェブアプリをソースごとパクる業者に対する対策 - Qiita</description></item><item><title>Attack Model</title><link>https://anko9801.github.io/blog/crypto/cryptography/AttackModel/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://anko9801.github.io/blog/crypto/cryptography/AttackModel/</guid><description>ランダムオラクルモデル
選択平文攻撃(Chosen-plaintext attack; CPA) 適応的選択平文攻撃(Adaptive chosen-plaintext attack; CPA2) 選択暗号文攻撃(Chosen-ciphertext attack; CCA1) 適応的選択暗号文攻撃(Adaptive Chosen-ciphertext attack; CCA2) Side-channel attack ↓めちゃくちゃわかりにくい、といってわかりやすさが上がる方法とは？定理証明だと思う.</description></item><item><title>Attacks on SIKE</title><link>https://anko9801.github.io/blog/crypto/ECC/SIKE/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://anko9801.github.io/blog/crypto/ECC/SIKE/</guid><description>Attacks on SIDH/SIKE | ellipticnews (wordpress.com) jack4818/Castryck-Decru-SageMath: A SageMath implementation of the Castryck-Decru Key Recovery attack on SIDH (github.com)</description></item><item><title>Automatic Exploit Generation</title><link>https://anko9801.github.io/blog/pwn/AEG/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://anko9801.github.io/blog/pwn/AEG/</guid><description>説明 自動的にexploitを行うコードを生成する
参考文献 AEG: Automatic Exploit Generation (psu.edu)</description></item><item><title>AWS</title><link>https://anko9801.github.io/blog/other/Application/Server/AWS/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://anko9801.github.io/blog/other/Application/Server/AWS/</guid><description>7777 - Your remote AWS database on your local port 7777
Scanning for AWS Security Issues With Trivy | liamg</description></item><item><title>Baby-step Giant-step</title><link>https://anko9801.github.io/blog/crypto/DLP/BSGS/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://anko9801.github.io/blog/crypto/DLP/BSGS/</guid><description>説明 半分全列挙を用いて $O(\sqrt{N}\log{N})$ でDLPが解ける。
位数 $N$ の巡回群 $G$ について $a, b\in G$ が与えられるので $a^n = b$ となる最小の $n\in \mathbb{N}$ を求める問題を考える。このとき $m = \lceil\sqrt{N}\rceil$ とおき、$n$ を $m$ で割ると $n = qm + r \ (q, r\in[0, \lceil\sqrt{N}\rceil)\ )$ と表せられる。すると $r$ に対して $ba^{-r}$ を全列挙し、そのリストに対して $a^{qm}$ が含まれているような $q$ を探索すると高速に解が求まる。</description></item><item><title>Binary Indexed Tree</title><link>https://anko9801.github.io/blog/data_structure/bit/bit/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://anko9801.github.io/blog/data_structure/bit/bit/</guid><description>説明 計算量 add $O(\log N)$ sum $O(\log N)$ 実装 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 template &amp;lt;typename T&amp;gt; class BIT { int N; vector&amp;lt;T&amp;gt; bit; BIT(isizet size) { N = size + 2; bit.</description></item><item><title>BKZ(Block Korkine-Zolotareff) 基底簡約</title><link>https://anko9801.github.io/blog/crypto/Lattice/BKZ/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://anko9801.github.io/blog/crypto/Lattice/BKZ/</guid><description>説明 HKZ(Hermite-Korkine-Zolotareff) 基底簡約
サイズ基底簡約 条件に合うように基底ベクトルの交換 計算量 実装 使用例 参考</description></item><item><title>Boneh-Durfee Attack</title><link>https://anko9801.github.io/blog/crypto/RSA/Boneh-DurfeeAttack/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://anko9801.github.io/blog/crypto/RSA/Boneh-DurfeeAttack/</guid><description>説明 $e$ が大きすぎると以下の式に対し Coppersmith Method を用いて攻撃できる。
$$ \begin{aligned} ed &amp;amp;= 1 &amp;amp; \pmod{\phi} \ ed &amp;amp;= k \phi + 1 &amp;amp; (\mathrm{over}\ \mathbb{Z}) \ 0 &amp;amp;= k \phi + 1 &amp;amp; \pmod e \ &amp;amp;= k (N + 1 - p - q) + 1 &amp;amp; \pmod e \ &amp;amp;= 2k \left(\frac{N + 1}{2} + \frac{-p -q}{2}\right) + 1 &amp;amp; \pmod e \ \end{aligned} $$</description></item><item><title>Callouts</title><link>https://anko9801.github.io/blog/notes/callouts/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://anko9801.github.io/blog/notes/callouts/</guid><description>Callout support Quartz supports the same Admonition-callout syntax as Obsidian.
This includes
12 Distinct callout types (each with several aliases) Collapsable callouts See documentation on supported types and syntax here.</description></item><item><title>chokudai サーチ</title><link>https://anko9801.github.io/blog/heuristic/chokudai_search/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://anko9801.github.io/blog/heuristic/chokudai_search/</guid><description>説明 ビームサーチにおいてビーム幅を1から順に増やしていく手法。実行時間が決まっているときやあるスコア基準を満たしたいときに管理しやすい。
実装 参考 chokudaiサーチ chokudaiサーチ(ビームサーチ亜種)の利点の話</description></item><item><title>Chosen-ciphertext Attack</title><link>https://anko9801.github.io/blog/crypto/RSA/RSA-CCA/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://anko9801.github.io/blog/crypto/RSA/RSA-CCA/</guid><description>説明 任意の暗号を復号した結果を知っているとき、ある暗号文の復号結果を防がれていたとしても他の暗号を送ることで解読できます。 $2^e$ を暗号文に掛けて復号した結果を $2$ で割ればその平文がわかります。
$$ \begin{aligned} Dec(2^ec) = 2m \pmod N \end{aligned} $$
これに対する防御方法として平文にパディングを施し、復号化した際にパディング形式が違うときは相手に渡さないようにするという方法があります。これによって正当な暗号文しか受け入れず、適応的選択暗号文攻撃を防げます。
パディング形式の1つにPKCS #1 v1.5があります。
0002&amp;lt;random&amp;gt;00&amp;lt;hashprefix&amp;gt;&amp;lt;message&amp;gt;</description></item><item><title>CJK + Latex Support (测试)</title><link>https://anko9801.github.io/blog/notes/CJK-+-Latex-Support-%E6%B5%8B%E8%AF%95/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://anko9801.github.io/blog/notes/CJK-+-Latex-Support-%E6%B5%8B%E8%AF%95/</guid><description>Chinese, Japanese, Korean Support 几乎在我们意识到之前，我们已经离开了地面。
우리가 그것을 알기도 전에 우리는 땅을 떠났습니다.
私たちがそれを知るほぼ前に、私たちは地面を離れていました。
Latex Block math works with two dollar signs $$.</description></item><item><title>Common Modulus Attack</title><link>https://anko9801.github.io/blog/crypto/RSA/CommonModulusAttack/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://anko9801.github.io/blog/crypto/RSA/CommonModulusAttack/</guid><description>説明 共通の平文を異なる $e$ で暗号化した暗号文が分かっているとき平文を求められる。
$$ \begin{aligned} c_1 &amp;amp;≡ m^{e_1} &amp;amp; \pmod N \ c_2 &amp;amp;≡ m^{e_2} &amp;amp; \pmod N \ \gcd(e_1, e_2) &amp;amp;= s_1e_1 + s_2e_2 \ c_1^{s_1} c_2^{s_2} &amp;amp;= m^{s_1e_1 + s_2e_2} = m^{\gcd(e_1, e_2)} &amp;amp; \pmod N \end{aligned} $$</description></item><item><title>Configuration</title><link>https://anko9801.github.io/blog/notes/config/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://anko9801.github.io/blog/notes/config/</guid><description>Configuration Quartz is designed to be extremely configurable. You can find the bulk of the configuration scattered throughout the repository depending on how in-depth you&amp;rsquo;d like to get.</description></item><item><title>Coppersmith Method</title><link>https://anko9801.github.io/blog/crypto/coppersmith/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://anko9801.github.io/blog/crypto/coppersmith/</guid><description>説明 Thm. Howgrave-Grahamの補題 $N$ を法、 $g(x) \in \mathbb{Z}[x]$ を整数多項式とし、含まれる単項式の数を $\omega$ とする。$g(x)$ に対してある $X$ が存在し、$g(x_0) = 0 \pmod{N}$ なる $x_0 \in \mathbb{Z}$ について $|x_0| \leq X$ であると仮定する。このとき</description></item><item><title>Custom Domain</title><link>https://anko9801.github.io/blog/notes/custom-Domain/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://anko9801.github.io/blog/notes/custom-Domain/</guid><description>Registrar This step is only applicable if you are using a custom domain! If you are using a &amp;lt;YOUR-USERNAME&amp;gt;.github.io domain, you can skip this step.</description></item><item><title>Detect Virtualization</title><link>https://anko9801.github.io/blog/rev/detect_virtualization/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://anko9801.github.io/blog/rev/detect_virtualization/</guid><description>説明 参考 Linux Detect Virtualization (feneshi.co) LordNoteworthy/al-khaser: Public malware techniques used in the wild: Virtual Machine, Emulation, Debuggers, Sandbox detection.</description></item><item><title>Differencial cryptoanalysis</title><link>https://anko9801.github.io/blog/crypto/Hash/DifferencialCryptoanalysis/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://anko9801.github.io/blog/crypto/Hash/DifferencialCryptoanalysis/</guid><description>https://github.com/aappleby/smhasher/wiki/MurmurHash2Flaw
Differencial cryptanalysis これはハッシュ関数の実装に踏み込む手法である. スケッチとしては何かしらのパラメータが同じなどの特殊な場合のとき, 簡約化ができ, 単純な算術演算による条件式をいくつか生成できる. これを SMT で解くらしい.</description></item><item><title>Diffie-Hellman 鍵交換</title><link>https://anko9801.github.io/blog/crypto/cryptography/Diffie-Hellman/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://anko9801.github.io/blog/crypto/cryptography/Diffie-Hellman/</guid><description>説明 共有鍵を作る為の操作である。共有鍵を作ることができれば共有鍵暗号を用いて通信できる。
AliceとBobが巡回群 $G$ とその生成元 $g$ を共有する。 AliceとBobはそれぞれ秘密鍵 $x_a, x_b$ を生成し、公開鍵 $y_a = g^{x_a}, y_b = g^{x_b}$ を公開する。 AliceとBobは自分の秘密鍵と相手の公開鍵を掛けると $s = g^{x_ax_b} = y_b^{x_a} = y_a^{x_b}$ となり、$s$ はAliceとBobのみが知る共有鍵となる。 ECDH だと $s$ の $x$ 座標をハッシュ化したものを共有鍵として使う。</description></item><item><title>DRM</title><link>https://anko9801.github.io/blog/other/Circuit/HIEE/DRM/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://anko9801.github.io/blog/other/Circuit/HIEE/DRM/</guid><description>DRMの仕組みと実装を理解する メモ DRM(Digital Rights Management)とは
Digital rights management (DRM) is the management of legal access to digital content. Various tools or technological protection measures (TPM)[1] such as access control technologies can restrict the use of proprietary hardware and copyrighted works.</description></item><item><title>eBPF</title><link>https://anko9801.github.io/blog/pwn/eBPF/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://anko9801.github.io/blog/pwn/eBPF/</guid><description/></item><item><title>ECFFT</title><link>https://anko9801.github.io/blog/crypto/ECC/ECFFT/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://anko9801.github.io/blog/crypto/ECC/ECFFT/</guid><description>ECFFT1.pdf (toronto.edu)</description></item><item><title>ELF</title><link>https://anko9801.github.io/blog/other/Application/Structure/ELF/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://anko9801.github.io/blog/other/Application/Structure/ELF/</guid><description>ELF Header Program Header Segment</description></item><item><title>Fiat-Shamir 変換</title><link>https://anko9801.github.io/blog/crypto/cryptography/Fiat-Shamir/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://anko9801.github.io/blog/crypto/cryptography/Fiat-Shamir/</guid><description>Fiat-Shamir変換は、証明システムを非対話型にするために使用される有名なスキームで、検証者がランダムに選択するチャレンジの値を（ランダムオラクルモデルとして）暗号学的ハッシュ関数を使って決定論的に導出することで、証明システムのプロトコルを非対話型にする。
チャレンジのハッシュ計算の際の入力に、証明するステートメントに関するすべての公開値（ランダムなコミットメント値を含む）を含める必要があるということ（↑の例だと入力は、G、V、P、UserID、OtherInfo）。</description></item><item><title>File System</title><link>https://anko9801.github.io/blog/other/Application/Structure/FAT32/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://anko9801.github.io/blog/other/Application/Structure/FAT32/</guid><description>ファイルシステム VFS
File Allocation Table (FAT) FAT32 NTFS ExFAT FAT32 FAT とは Microsoft によって開発されたいくつかのファイルシステム(FAT12, FAT16, FAT32, VFAT, exFAT)の総称です。</description></item><item><title>Forensics</title><link>https://anko9801.github.io/blog/misc/forensics/forensics/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://anko9801.github.io/blog/misc/forensics/forensics/</guid><description>MITRE ATT&amp;amp;CK
AutoPsy
Detecting Linux Anti-Forensics: Timestomping (inversecos.com) Virus Total</description></item><item><title>Franklin-Reiter Related Message Attack</title><link>https://anko9801.github.io/blog/crypto/RSA/Franklin-ReiterRelatedMessageAttack/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://anko9801.github.io/blog/crypto/RSA/Franklin-ReiterRelatedMessageAttack/</guid><description>説明 $f(m_1) = m_2$ $m_1 = pad_1 + m, m_2 = pad_2 + m, m_2 = m_1 + (pad_2 - pad_1)$</description></item><item><title>Frozen Heart</title><link>https://anko9801.github.io/blog/crypto/cryptography/FrozenHeart/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://anko9801.github.io/blog/crypto/cryptography/FrozenHeart/</guid><description>Frozen Heartは、Fiat-Shamir変換でチャレンジのハッシュ計算の際の入力に、証明するステートメントに関するすべての公開値（ランダムなコミットメント値を含む）を含める必要があるということ（↑の例だと入力は、G、V、P、UserID、OtherInfo）を遵守していないプロトコルや実装による脆弱性。
詳しいことはすべてここに
Fiat-Shamir変換の安全でない適用による脆弱性Frozen Heart - Develop with pleasure! (hatenablog.com) Coordinated disclosure of vulnerabilities affecting Girault, Bulletproofs, and PlonK | Trail of Bits Blog</description></item><item><title>Fujisaki-Okamoto Transformation</title><link>https://anko9801.github.io/blog/crypto/cryptography/Fujisaki-Okamoto_Transformation/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://anko9801.github.io/blog/crypto/cryptography/Fujisaki-Okamoto_Transformation/</guid><description>説明 証明 参考文献 The Fujisaki-Okamoto Transformation (uni-paderborn.de)</description></item><item><title>Fuzzing</title><link>https://anko9801.github.io/blog/rev/fuzzing/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://anko9801.github.io/blog/rev/fuzzing/</guid><description>説明 参考 オレオレFuzzerもどきを利用してCTFのpwnableを解こう - CTFするぞ (hatenablog.com)
fuzzuf/algorithm_en.md at master · fuzzuf/fuzzuf (github.com) Ricerca Security: Fuzzing Farm #1: fuzzufを使ったGEGLのファジング Ricerca Security: Fuzzing Farm #2: ファザーの性能評価の考え方 Ricerca Security: Fuzzing Farm #3: パッチ解析とPoC開発 Ricerca Security: fuzzuf: Fuzzing Unification Framework Ricerca Security: ARM CoreSightを用いた効率的なBinary-only Fuzzing</description></item><item><title>GHS Attack</title><link>https://anko9801.github.io/blog/crypto/ECC/GHS-Attack/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://anko9801.github.io/blog/crypto/ECC/GHS-Attack/</guid><description>Weil descent 攻撃とも呼ばれる</description></item><item><title>glibc malloc</title><link>https://anko9801.github.io/blog/pwn/glibc/malloc/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://anko9801.github.io/blog/pwn/glibc/malloc/</guid><description>説明 malloc動画と呼ばれている The 67th Yokohama kernel reading party - YouTube は必見です！
glibc のデータ領域に main_arena malloc_state
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 struct malloc_state { /* Serialize access.</description></item><item><title>Gram-Schmidt の直交化 (GSO: Gram-Schmidt Orthonormalization)</title><link>https://anko9801.github.io/blog/crypto/Lattice/GSO/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://anko9801.github.io/blog/crypto/Lattice/GSO/</guid><description>説明 Gram-Schmidt の直交化 (GSO: Gram-Schmidt Orthonormalization) 任意の $R$ ベクトル空間直交化 ベクトルをGSO化させることで任意の2つのベクトルの内積が0となる、つまり直交化できます。イメージは Wikipediaのgifがわかりやすいです。$\mathbf{b}n$ の直交化は $\mathbf{b}{1},\ldots, \mathbf{b}_{n-1}$ までと直行するように高さを保持しながら移動させる。
$$ \begin{aligned} \begin{dcases} \mathbf{b}_1^* = \mathbf{b}_1 \ \mathbf{b}i^* = \mathbf{b}i - \sum\limits{j=1}^{i-1} \mu{i, j}\mathbf{b}j^* \qquad \left( \mu{i, j} = \frac{\langle \mathbf{b}_i, \mathbf{b}_j^* \rangle}{| \mathbf{b}_j^* |^2} \right) \ \end{dcases} \end{aligned} $$</description></item><item><title>House of botcake</title><link>https://anko9801.github.io/blog/pwn/HouseOfXXX/House_of_botcake/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://anko9801.github.io/blog/pwn/HouseOfXXX/House_of_botcake/</guid><description>unsorted binの fd は main_arena.top を指す。 libc内の main_arena.top のオフセットが分かれば libc base address</description></item><item><title>House of lore</title><link>https://anko9801.github.io/blog/pwn/HouseOfXXX/house_of_lore/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://anko9801.github.io/blog/pwn/HouseOfXXX/house_of_lore/</guid><description/></item><item><title>House of Orange</title><link>https://anko9801.github.io/blog/pwn/HouseOfXXX/house_of_orange/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://anko9801.github.io/blog/pwn/HouseOfXXX/house_of_orange/</guid><description>本質: top chunk のサイズを書き換えることで _int_free を呼び出す. 応用: https://ptr-yudai.hatenablog.com/entry/2019/10/12/181931</description></item><item><title>House of spirit</title><link>https://anko9801.github.io/blog/pwn/HouseOfXXX/house_of_spirit/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://anko9801.github.io/blog/pwn/HouseOfXXX/house_of_spirit/</guid><description/></item><item><title>Håstad’s Broadcast Attack</title><link>https://anko9801.github.io/blog/crypto/RSA/H%C3%A5stadsBroadcastAttack/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://anko9801.github.io/blog/crypto/RSA/H%C3%A5stadsBroadcastAttack/</guid><description>説明 平文を互いに素な $N_1, \ldots, N_e$ で暗号化された暗号文が分かっているとき、中国剰余定理を用いて $m$ を求められる。
$$ \begin{aligned} c_1 &amp;amp;≡ m^e \pmod{N_1} \ c_2 &amp;amp;≡ m^e \pmod{N_2} \ \vdots \ c_e &amp;amp;≡ m^e \pmod{N_e} \ m^e &amp;amp;≡ CRT(c_1, c_2, \dots , c_e) \pmod{N_1N_2\cdots N_e} \ m^e &amp;amp;= CRT(c_1, c_2, \dots , c_e) \end{aligned} $$</description></item><item><title>Ignoring Notes</title><link>https://anko9801.github.io/blog/notes/ignore-notes/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://anko9801.github.io/blog/notes/ignore-notes/</guid><description>Quartz Ignore Edit ignoreFiles in config.toml to include paths you&amp;rsquo;d like to exclude from being rendered.
1 2 3 4 5 6 .</description></item><item><title>Invalid Curve Attack</title><link>https://anko9801.github.io/blog/crypto/ECC/Invalid-Curve-Attack/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://anko9801.github.io/blog/crypto/ECC/Invalid-Curve-Attack/</guid><description>説明 ざっくり言うと楕円曲線上に点が乗っていないときに位数が低くなることを利用する攻撃です。
適当に選んだ数は小さな素数で割れやすい のと同じように
Google CTF Tiramisu write up (zenn.dev)</description></item><item><title>Kernel Exploit用テンプレート</title><link>https://anko9801.github.io/blog/pwn/Kernel/kernel_exploit/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://anko9801.github.io/blog/pwn/Kernel/kernel_exploit/</guid><description>説明 pwnのKernel Exploit時に使うテンプレート
実装 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 from ptrlib import * import time import base64 import os def run(cmd): sock.</description></item><item><title>Lagrange 基底簡約 (Gauss 基底簡約)</title><link>https://anko9801.github.io/blog/crypto/Lattice/Lagrange/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://anko9801.github.io/blog/crypto/Lattice/Lagrange/</guid><description>説明 任意の $q \in \mathbb{Z}$ に対して
$$ |\mathbf{b}_1| \leq |\mathbf{b}_2| \leq |\mathbf{b}_1 + q\mathbf{b}_2| $$
を満たすとき、2次元格子の基底 $\{\mathbf{b}_1, \mathbf{b}_2\}$ はLagrange 簡約されているという。</description></item><item><title>LLL 基底簡約</title><link>https://anko9801.github.io/blog/crypto/Lattice/LLL/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://anko9801.github.io/blog/crypto/Lattice/LLL/</guid><description>説明 $n$ 次元格子 $L$ の基底 $\lbrace\mathbf{b_1},\ldots,\mathbf{b_n}\rbrace$ について以下の条件を満たすとき、その基底は LLL 簡約されている (Lenstra-Lenstra-Lovasz(LLL)-reduced)と呼ぶ。
基底 $\lbrace\mathbf{b_1},\ldots,\mathbf{b_n}\rbrace$ がサイズ簡約されている。 Lovasz条件: 任意の $2 \leq k \leq n$ に対して $\delta|\mathbf{b}{k-1}^*| \leq |\pi{k-1}(\mathbf{b}_{k-1})|$ を満たす。ただし、各 $1 \leq l \leq n$ に対して、$\pi_l$ は $\mathbb{R}$-ベクトル空間 $\langle\mathbf{b} _1,\ldots,\mathbf{b} _{l-1}\rangle _\mathbb{R}$ の直交補空間への直交射影とする。 これに対し、LLL 基底簡約アルゴリズムは次のように行う。</description></item><item><title>LSB Decryption Oracle Attack</title><link>https://anko9801.github.io/blog/crypto/RSA/LSB-DecryptionOracleAttack/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://anko9801.github.io/blog/crypto/RSA/LSB-DecryptionOracleAttack/</guid><description>説明 全てが分かっていなくとも偶奇さえ分かれば任意の暗号文を復号できる。 ある暗号文 $c$ に対し、$2^e$ をx回掛けた値を復号した下位1bitを得て平文を求めます。得られる下位1bitは次の関数 $f(x)$ を用いて $f(x) \bmod 2$ と表せられます。decは復号化関数です。
$$ \begin{aligned} f(x) &amp;amp;= Dec(2^{ex}c \bmod N) = 2^xm \bmod N \ \end{aligned} $$</description></item><item><title>Millar</title><link>https://anko9801.github.io/blog/crypto/ECC/Millar/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://anko9801.github.io/blog/crypto/ECC/Millar/</guid><description/></item><item><title>Modint</title><link>https://anko9801.github.io/blog/arithmetic/modulo/modint/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://anko9801.github.io/blog/arithmetic/modulo/modint/</guid><description>説明 計算量 実装 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 #include &amp;lt;cstdint&amp;gt;#include &amp;lt;istream&amp;gt;#include &amp;lt;type_traits&amp;gt;#include &amp;lt;vector&amp;gt; using ll = long long; using u64 = std::uint_fast64_t; const ll MOD = 1000000007; const ll MODD = 998244353; constexpr u64 Modulus = MOD; class Modint { public: u64 num = 0; constexpr Modint() noexcept {} constexpr Modint(const u64 x) noexcept : num(x % Modulus) {} inline constexpr operator ll() const noexcept { return num; } inline constexpr Modint &amp;amp;operator+=(const Modint rhs) noexcept { num += rhs.</description></item><item><title>MOV/FR Reduction</title><link>https://anko9801.github.io/blog/crypto/ECC/MOV-FR-Reduction/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://anko9801.github.io/blog/crypto/ECC/MOV-FR-Reduction/</guid><description>MOV Reduction $R=dP$ となるECDLPを解く
Weil pairing $e_n: E[n]\times E[n]\to \mu_n\subseteq \mathbb{F}_{p^k}^*$
$E[n]\subseteq E(\mathbb{F}_{p^k})$ となる最小の $k$ を持ってくる 位数 $n$ の $\alpha=e_n(P, Q)$ となるように $Q \in E[n]$ を取ってくる $\beta = e_n(dP, Q)$ $\mathbb{F}_{p^k}^*$ 上のDLPを $\alpha, \beta$ を用いて解く $k$ は多くとも6まで $E(\mathbb{F}{p^k}^*)\cong\mathbb{Z}{c_1n_1}\oplus\mathbb{Z}_{c_2n_1}$</description></item><item><title>Network</title><link>https://anko9801.github.io/blog/other/Application/Network/network/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://anko9801.github.io/blog/other/Application/Network/network/</guid><description>ネットワーク 1990年 10BASE-T
Ethernet 米Xerox のパロアルト研究所(PARC)に所属していたロバート・メカトーフ氏によって発明された。 初期実験は3Mbps 現在は最大400Gbpsの規格がある フレーム構造の規格 IEEE 802.3
TCP/IP TCP BBR QUIC shigeki/ask_nishida_about_quic_jp: QUICトランスポート機能に関して tcpm/mptcp wg chair の西田先生にいろいろ聞いてみる会 (github.</description></item><item><title>Nginx (リバースプロキシ)チューニング</title><link>https://anko9801.github.io/blog/other/Application/Server/reverse-proxy-optimization/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://anko9801.github.io/blog/other/Application/Server/reverse-proxy-optimization/</guid><description>サーバー分割 DB分ける リクエストのロードバランス ロードバランサー セッションパーシステンス
worker_processesにそれぞれ均等にworker_connectionsが分配される訳ではないので余裕をもって設定すべき https://nrok81.hatenablog.com/entry/2014/11/12/191240
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 worker_processesauto;# コア数と同じ数まで増やすと良いかも # nginx worker の設定 worker_rlimit_nofile4096;events{worker_connections1024;# 128より大きくするなら、 5_os にしたがって max connection 数を増やす必要あり（デフォルトで`net.</description></item><item><title>NIC (Network Interface Card)</title><link>https://anko9801.github.io/blog/other/Application/OS/NIC/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://anko9801.github.io/blog/other/Application/OS/NIC/</guid><description>マザボに差して動くもの: PCI デバイス USBに差して動くもの: USB デバイス</description></item><item><title>Note</title><link>https://anko9801.github.io/blog/crypto/Note/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://anko9801.github.io/blog/crypto/Note/</guid><description>Crypto in CTF writeup Crypto in CTF :: Mystify (mystiz.hk) を解いていく。
Q3 2021 Pwn2Win CTF 2021 t00 rare ECDSAで署名/検証ができるが、特定のハッシュ値のときは不可 $q=q_1q_2+1$ として秘密鍵が $x=(7^{q_2})^y$, $P = kG$, $s=\frac{h+rx}{k}\iff P=\frac{h+rx}{s}G\iff g^yG=r^{-1}(sP-hG)$ である 特定のハッシュ値のとき $kP=G$ を求める 解法 $h+q$ でバイパス BSGSで $g^yG$ の $y$ を求める 高速なライブラリfastecdsaを使う A2S AESのラウンドを10回から2回に変更 解法 0CTF 2021 Quals zer0lfsr- Crypto CTF 2022</description></item><item><title>OS</title><link>https://anko9801.github.io/blog/other/Application/OS/OS/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://anko9801.github.io/blog/other/Application/OS/OS/</guid><description>PXE(Preboot eXecution Environment) Boot
システムコール Basic Input/Output System: BIOS ハードウェアの初期化 OS や bootloader へのサービスの提供 Unified Extensible Firmware Interface: UEFI 割り込みの仕組みを知りたい io_uring mem_info</description></item><item><title>OSINT</title><link>https://anko9801.github.io/blog/misc/osint/tools/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://anko9801.github.io/blog/misc/osint/tools/</guid><description>OSINT (Open Source INTelligence)
消された投稿を探す https://archive.org/web/ twitter [https://twilog.org twilog] Reverse Image Search Google Lens Fake news debunker by InVID &amp;amp; WeVerify - Chrome ウェブストア (google.</description></item><item><title>Partial Key Exposure Attack</title><link>https://anko9801.github.io/blog/crypto/RSA/PartialKeyExposureAttack/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://anko9801.github.io/blog/crypto/RSA/PartialKeyExposureAttack/</guid><description>説明 秘密鍵を部分的に知っていさえいれば、Coppersmith Method を用いて解けてしまう。 $n$ を $N$ のビット数とする。
$p, q$ のどちらかを $n/4$ ビット程度知っているとき $$ \begin{aligned} f(x) &amp;amp;= p_{upper} + x &amp;amp; \pmod p \ f(x) &amp;amp;= 2^{k}x + p_{lower} &amp;amp; \pmod p \ f(x,y) &amp;amp;= 2^kx + p_{mid} + y &amp;amp; \pmod p \ \end{aligned} $$</description></item><item><title>Pohlig-Hellman</title><link>https://anko9801.github.io/blog/crypto/DLP/Pohlig_Hellman/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://anko9801.github.io/blog/crypto/DLP/Pohlig_Hellman/</guid><description>説明 中国剰余定理を用いて大きな群を複数の小さな群の直積に分割する。
実装 1 2 3 4 5 6 7 8 9 fact = factor(G.order()) ord = int(G.order()) dlogs = [] for p, e in fact: t = ord // p ^ e dlog = discrete_log(t * Q, t * G, operation=&amp;#34;+&amp;#34;) dlogs += [dlog] print(crt(dlogs, primes)) 使用例 参考</description></item><item><title>Pohlig-Hellman Attack</title><link>https://anko9801.github.io/blog/crypto/ECC/Pohlig-Hellman/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://anko9801.github.io/blog/crypto/ECC/Pohlig-Hellman/</guid><description>説明 中国剰余定理を用いて大きな群を複数の小さな群の直積に分ける。
楕円曲線暗号の楕円曲線の位数は細かく素因数分解できることが多い。
楕円曲線の位数 $#E = p_1^{e_1}p_2^{e_2}\ldots p_k^{e_k}$ と素因数分解できる。$Q = dP$ となるとき次のように $d_i$ を置く。
$$ \begin{aligned} d_1 &amp;amp;= d \pmod{p_1^{e_1}} \ d_2 &amp;amp;= d \pmod{p_2^{e_2}} \ &amp;amp;\vdots \ d_k &amp;amp;= d \pmod{p_k^{e_k}} \ \end{aligned} $$</description></item><item><title>Pollard's rho 法</title><link>https://anko9801.github.io/blog/crypto/DLP/Pollard_rho/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://anko9801.github.io/blog/crypto/DLP/Pollard_rho/</guid><description>説明 初期点 $x_0$ と適当な副作用のない疑似乱数関数 $f(x)$ を決めて $x_{i+1} = f(x_i)$ となるように数列 $(x_0, x_1, \ldots)$ を生成する。このとき $0 \leq \exists i &amp;lt; \exists j &amp;lt; N$, $x_i = x_j$ となる $i,j$ を見つけられたらDLPが解けるという仕組みです。</description></item><item><title>Prototype Pollution</title><link>https://anko9801.github.io/blog/web/PrototypePollution/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://anko9801.github.io/blog/web/PrototypePollution/</guid><description>グローバル変数 Object.prototype と任意のオブジェクトの変数 &amp;lt;obj&amp;gt;.__proto__ が一致することからの脆弱性</description></item><item><title>pwn</title><link>https://anko9801.github.io/blog/pwn/template/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://anko9801.github.io/blog/pwn/template/</guid><description>説明 CTFのpwn分野で使うテンプレート。pwntoolsパッケージを使用する。
実装 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 from pwn import * import sys binary_path = &amp;#39;.</description></item><item><title>Pyjail</title><link>https://anko9801.github.io/blog/misc/Pyjail/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://anko9801.github.io/blog/misc/Pyjail/</guid><description>PythonはASCIIだけではなくUnicode全部使える 合字を使うと文字数節約出来る Pythonの識別子におけるUnicode正規化(NFKC)とpyjail - Satoooonの物置 (hatenablog.com)</description></item><item><title>Quartz Philosophy</title><link>https://anko9801.github.io/blog/notes/philosophy/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://anko9801.github.io/blog/notes/philosophy/</guid><description>“[One] who works with the door open gets all kinds of interruptions, but [they] also occasionally gets clues as to what the world is and what might be important.</description></item><item><title>RDBMS</title><link>https://anko9801.github.io/blog/other/Application/Server/RDBMS/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://anko9801.github.io/blog/other/Application/Server/RDBMS/</guid><description>データベースとは B-Tree/B+TreeLSMツリーと呼ばれる平衡N分木で構築されたデータの集合。メモリ/実行時間最適化、排他制御をよしなにやってくれます。 やり取りに人間がわかりやすい言葉DDL(Data Definition Language) DML(Data Manipulation Language) DCL(Data Control Language)を使ってDBを操作します。例えばStructured Query Language(SQL)などがあります。 データベースシステムとSQLはごっちゃにして言われやすいので注意。例えば、MariaDBはMySQLから派生したRelational Database Management System(RDBMS)の一種だとか、Not only SQL(NoSQL)はクラウドのDBに対してネットワーク伝送コストを避けて最適化された非RDBMSで、MongoDBやAWSのDynamoDB, Redisがそれに含まるなど。 具体的にどんな処理がされているのか 工事中 :::spoiler https://zenn.</description></item><item><title>Rendering Engine</title><link>https://anko9801.github.io/blog/other/Application/Rendering/Rendering/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://anko9801.github.io/blog/other/Application/Rendering/Rendering/</guid><description>DirectX Vulkan</description></item><item><title>Return Of Coppersmith Attack</title><link>https://anko9801.github.io/blog/crypto/RSA/ROCA/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://anko9801.github.io/blog/crypto/RSA/ROCA/</guid><description>説明 主要な暗号ハードウェアメーカで使われているライブラリ RSALib の鍵生成アルゴリズムの欠陥。
$$ \begin{aligned} p &amp;amp;= kM + (e^a \bmod M) \ q &amp;amp;= lM + (e^b \bmod M) \ N &amp;amp;= pq = e^{a + b} \pmod M \end{aligned} $$</description></item><item><title>rev</title><link>https://anko9801.github.io/blog/rev/rev/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://anko9801.github.io/blog/rev/rev/</guid><description>idiom 2倍+2をアロケート -&amp;gt; wide char + null終端</description></item><item><title>Root kit</title><link>https://anko9801.github.io/blog/other/Circuit/Rootkit/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://anko9801.github.io/blog/other/Circuit/Rootkit/</guid><description>North bridge dsn2021.pdf (xgao-work.github.io)
PCI Rootkit Implementing and Detecting a PCI Rootkit
Peripheral Component Interconnect: PCI はマザーボード</description></item><item><title>RSA-CRT Fault Attack</title><link>https://anko9801.github.io/blog/crypto/RSA/RSA-CRT-FaultAttack/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://anko9801.github.io/blog/crypto/RSA/RSA-CRT-FaultAttack/</guid><description>説明 RSAの復号をする際に $c^d$ を計算しますが、 $d = e^{-1} \pmod {\phi (N)}$ は比較的大きいので処理が重くなります。これに対してRSA-CRTは中国剰余定理(CRT)を利用して高速化を図っています。
$$ \begin{aligned} m_p &amp;amp;= c^{d \ \bmod \ p−1} &amp;amp; \pmod p \ m_q &amp;amp;= c^{d \ \bmod \ q−1} &amp;amp; \pmod q \ m &amp;amp;= \mathrm{CRT}(m_p, m_q) &amp;amp; \pmod {N} \ &amp;amp;= m_q + (m_p - m_q) (q^{-1} \bmod p) q &amp;amp; \pmod {N} \ \end{aligned} $$</description></item><item><title>RSA暗号</title><link>https://anko9801.github.io/blog/crypto/RSA/RSA/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://anko9801.github.io/blog/crypto/RSA/RSA/</guid><description>説明 暗号化 $c = m^{e} \pmod N$ を計算します。
秘密鍵である大きな素数 $p, q$ を生成し、公開鍵 $N = pq$ を公開します。 そして数値化した平文 $m$ に対して暗号文 $c$ は $c = m^e \pmod N$ となります。 復号化 $m = c^{e^{-1}} \pmod N$ を計算します。</description></item><item><title>SageMath チートシート</title><link>https://anko9801.github.io/blog/crypto/SageMath/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://anko9801.github.io/blog/crypto/SageMath/</guid><description>説明 SageMathのプログラムを書くときに参照したいと思うチートシートを作成したい。
実装 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 # import load(&amp;#39;coppersmith.</description></item><item><title>SAT SMT</title><link>https://anko9801.github.io/blog/other/Application/SAT-SMT/SAT-SMT/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://anko9801.github.io/blog/other/Application/SAT-SMT/SAT-SMT/</guid><description>SAT SAT (SATisfiability Problem) SATを解くには指数時間掛かると信じられている. 指数時間の中でも高速化していく技術を学ぶ.
$((a\land\lnot b\land\lnot c)\lor(b\land c\land\lnot d))\land(\lnot b\lor\lnot c) \to (a,b,c,d)=(t,f,f,t)$
単純な探索 まずは SAT に関する全探索を考える. 以下の方法は DPLL (Davis Putnam Logemann Loveland) アルゴリズムと呼ばれている.</description></item><item><title>Schnorr Signatures</title><link>https://anko9801.github.io/blog/crypto/cryptography/Schnorr/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://anko9801.github.io/blog/crypto/cryptography/Schnorr/</guid><description>説明 非対話型ゼロ知識証明な署名の一種。
巡回群 $G$ 上で署名を行う。各パラメータは次のように定義する。
生成元 $g$ 秘密鍵 $x$ 公開鍵 $y = g^x$ メッセージ $M$ 署名 乱数 $k$ を生成し、次の値を計算する。</description></item><item><title>Schoof Algorithm</title><link>https://anko9801.github.io/blog/crypto/ECC/Schoof/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://anko9801.github.io/blog/crypto/ECC/Schoof/</guid><description>Hasse-Weil 定理より
$$ q+1-2\sqrt{q}\leq#E(\mathbb{F}_q)\leq q+1+2\sqrt{q} $$
$#E(\mathbb{F}_q)=q+1+t$ とおける。$\mathbb{F}_q$ のフロベニウス写像 $\sigma$ のトレース $t$ を計算できれば位数が求まる。しかし $t$ は $2\sqrt{q}$ のオーダーであるため、直接計算できない。そこで素数 $l$ を剰余にとってそれぞれの $t$ の値を求め、中国剰余定理によって $t$ を求める。</description></item><item><title>Search</title><link>https://anko9801.github.io/blog/notes/search/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://anko9801.github.io/blog/notes/search/</guid><description>Quartz supports two modes of searching through content.
Full-text Full-text search is the default in Quartz. It produces results that exactly match the search query.</description></item><item><title>Segment tree beats</title><link>https://anko9801.github.io/blog/data_structure/segtree/segtreebeats/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://anko9801.github.io/blog/data_structure/segtree/segtreebeats/</guid><description>説明 計算量 実装 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 #include &amp;lt;algorithm&amp;gt;#include &amp;lt;cassert&amp;gt;#include &amp;lt;iostream&amp;gt;#include &amp;lt;vector&amp;gt;using namespace std; using ll = long long; #define N 10003 class SegmentTreeBeats { const ll inf = 1e18; int n, n0; ll max_v[4 * N], smax_v[4 * N]; ll sum[4 * N], max_c[4 * N]; void update_node_max(int k, ll x) { sum[k] += (x - max_v[k]) * max_c[k]; max_v[k] = x; } void push(int k) { if (max_v[k] &amp;lt; max_v[2 * k + 1]) update_node_max(2 * k + 1, max_v[k]); if (max_v[k] &amp;lt; max_v[2 * k + 2]) update_node_max(2 * k + 2, max_v[k]); } void update(int k) { sum[k] = sum[2 * k + 1] + sum[2 * k + 2]; if (max_v[2 * k + 1] &amp;lt; max_v[2 * k + 2]) { max_v[k] = max_v[2 * k + 2]; max_c[k] = max_c[2 * k + 2]; smax_v[k] = max(max_v[2 * k + 1], smax_v[2 * k + 2]); } else if (max_v[2 * k + 1] &amp;gt; max_v[2 * k + 2]) { max_v[k] = max_v[2 * k + 1]; max_c[k] = max_c[2 * k + 1]; smax_v[k] = max(smax_v[2 * k + 1], max_v[2 * k + 2]); } else { max_v[k] = max_v[2 * k + 1]; max_c[k] = max_c[2 * k + 1] + max_c[2 * k + 2]; smax_v[k] = max(smax_v[2 * k + 1], smax_v[2 * k + 2]); } } void _update_min(ll x, int a, int b, int k, int l, int r) { if (b &amp;lt;= l || r &amp;lt;= a || max_v[k] &amp;lt;= x) return; if (a &amp;lt;= l &amp;amp;&amp;amp; r &amp;lt;= b &amp;amp;&amp;amp; smax_v[k] &amp;lt; x) { update_node_max(k, x); return; } push(k); _update_min(x, a, b, 2 * k + 1, l, (l + r) / 2); _update_min(x, a, b, 2 * k + 2, (l + r) / 2, r); update(k); } ll _query_max(int a, int b, int k, int l, int r) { if (b &amp;lt;= l || r &amp;lt;= a) return 0; if (a &amp;lt;= l &amp;amp;&amp;amp; r &amp;lt;= b) return max_v[k]; push(k); ll lv = _query_max(a, b, 2 * k + 1, l, (l + r) / 2); ll rv = _query_max(a, b, 2 * k + 2, (l + r) / 2, r); return max(lv, rv); } ll _query_sum(int a, int b, int k, int l, int r) { if (b &amp;lt;= l || r &amp;lt;= a) return 0; if (a &amp;lt;= l &amp;amp;&amp;amp; r &amp;lt;= b) return sum[k]; push(k); ll lv = _query_sum(a, b, 2 * k + 1, l, (l + r) / 2); ll rv = _query_sum(a, b, 2 * k + 2, (l + r) / 2, r); return lv + rv; } public: SegmentTreeBeats(int n) { SegmentTreeBeats(n, nullptr); } SegmentTreeBeats(int n, ll *a) : n(n) { n0 = 1; while (n0 &amp;lt; n) n0 &amp;lt;&amp;lt;= 1; for (int i = 0; i &amp;lt; n; ++i) { max_v[n0 - 1 + i] = sum[n0 - 1 + i] = (a !</description></item><item><title>Showcase</title><link>https://anko9801.github.io/blog/notes/showcase/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://anko9801.github.io/blog/notes/showcase/</guid><description>Want to see what Quartz can do? Here are some cool community gardens :)
Quartz Documentation (this site!) Jacky Zhao&amp;rsquo;s Garden Scaling Synthesis - A hypertext research notebook AWAGMI Intern Notes Shihyu&amp;rsquo;s PKM Chloe&amp;rsquo;s Garden SlRvb&amp;rsquo;s Site Course notes for Information Technology Advanced Theory Brandon Boswell&amp;rsquo;s Garden Siyang&amp;rsquo;s Courtyard Data Dictionary 🧠 sspaeti.</description></item><item><title>Slope Trick</title><link>https://anko9801.github.io/blog/data_structure/slope_trick/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://anko9801.github.io/blog/data_structure/slope_trick/</guid><description>説明 計算量 実装 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 #include &amp;lt;iostream&amp;gt;#include &amp;lt;queue&amp;gt;#include &amp;lt;vector&amp;gt; template &amp;lt;typename T&amp;gt; using pq = std::priority_queue&amp;lt;T, std::vector&amp;lt;T&amp;gt;, std::greater&amp;lt;T&amp;gt;&amp;gt;; struct SlopeTrick { const long long LINF = 0x1fffffffffffffff; long long minf = -1; std::priority_queue&amp;lt;long long&amp;gt; L; pq&amp;lt;long long&amp;gt; R; long long shift_left = -1; long long shift_right = -1; SlopeTrick() {} private: void L_push(long long a) { L.</description></item><item><title>Small Common Private Exponent Attack</title><link>https://anko9801.github.io/blog/crypto/RSA/SmallCommonPrivateExponentAttack/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://anko9801.github.io/blog/crypto/RSA/SmallCommonPrivateExponentAttack/</guid><description>説明 実装 使用例 参考</description></item><item><title>Software Defined Radio</title><link>https://anko9801.github.io/blog/other/Application/Network/SDR/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://anko9801.github.io/blog/other/Application/Network/SDR/</guid><description>無線機
![[Pasted image 20220924223810.png]]
GNU Radio
USRP B205mini-i HackRF GNU Radioで遊ぶ超高速ディジタル無線スタータキット “USRP B205mini-i” (zep.co.jp)</description></item><item><title>SSH</title><link>https://anko9801.github.io/blog/crypto/SSH/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://anko9801.github.io/blog/crypto/SSH/</guid><description>OpenSSH 9.0 ポスト量子暗号化時代への対応として、格子暗号系の「Streamlined NTRU Prime」と、楕円曲線暗号系の「x25519」からなるハイブリッド手法がデフォルトとなっている。
ed448 ed25519
Gnu Privacy Guard: GPG master key sub key Pritty Good Privacy: PGP鍵 GPGで自分用の秘密鍵を1つに統一する · JoeMPhilips</description></item><item><title>SSSA Attack</title><link>https://anko9801.github.io/blog/crypto/ECC/SSSA-Attack/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://anko9801.github.io/blog/crypto/ECC/SSSA-Attack/</guid><description>説明 $$ \newcommand{\calO}{\mathcal{O}} \newcommand{\FF}{\mathbb{F}} \newcommand{\tE}{\tilde{E}} \newcommand{\ZZ}{\mathbb{Z}} \newcommand{\QQ}{\mathbb{Q}} \DeclareMathOperator{\Ker}{Ker} \DeclareMathOperator{\ord}{ord} $$
Definition $\FF_p$ 素数$p$に対して$p$個の元からなる有限体 素数$p$の剰余群 $\mathbb{Z}/p\mathbb{Z}$ $\mathbb{Q}_p$ p進数体 $27=2.</description></item><item><title>TEE</title><link>https://anko9801.github.io/blog/other/Circuit/HIEE/TEE/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://anko9801.github.io/blog/other/Circuit/HIEE/TEE/</guid><description>Trusted Execution Environment: TEE とはプロセッサ上に隔離された実行環境を用意することでセキュリティを高める技術です。 より広義にHIEE: Hardware-assisted Isolated Execution Environment
Normal Mode Secure Mode TEE の機能
OSやアプリケーションの改竄を検知 公開鍵証明書による端末識別，認証 ストレージデータの安全な暗号化 ほぼほぼ暗号化処理をするため, 秘密鍵をそこにppm Intel SGX Enclave では Ring 3 でしか動作しない, つまり syscall が使えない</description></item><item><title>TFHE (Torus Fully Homomorphic Encryption)</title><link>https://anko9801.github.io/blog/crypto/Lattice/TFHE/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://anko9801.github.io/blog/crypto/Lattice/TFHE/</guid><description>説明 完全準同型暗号の1つ
完全なる Zero Trust なサーバーを作れる。
参考 セキュキャンの資料</description></item><item><title>Tour of Lattice</title><link>https://anko9801.github.io/blog/crypto/Lattice/tour_of_Lattice/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://anko9801.github.io/blog/crypto/Lattice/tour_of_Lattice/</guid><description>格子暗号を極める！ 無限工事編
はじめに // TODO 説明 耐量子暗号です！あとはセキュキャンで話題のTFHEとか紹介したいな
これは大学1年で習う線形代数を前提知識として扱います。
量子アルゴリズムはどこで解説すべき？ 暗号関連で解説すべきなのはGroverとShorのアルゴリズムの2つだけやが量子コンピューター上の演算や量子フーリエが前提知識無しやとキツイかもしれん。 量子コンピュータという題材で分けた方が良さそう？本に頼ればいいは一理あるが論文以外の文献は未だ少なく暗号専門の解説がほしいところ 自分の文章力と時間に要相談ということで 格子 (Lattice) 図でイメージ掴むのが速い</description></item><item><title>Tour of RSA</title><link>https://anko9801.github.io/blog/crypto/RSA/tour-of-RSA/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://anko9801.github.io/blog/crypto/RSA/tour-of-RSA/</guid><description>RSA暗号を極める！(理論編) というか無限工事編です(文章が拙くて申し訳ない)
はじめに すぐそこに秘密の世界があります。この記事を読んでいるなら、あなたは暗号化された通信を通してサーバーから電気線を通り、遥々その端末に届いている文字を読んでいます。
こんなことを考えてみてほしい。機器から暗号を使って通信をしていますが、私達が触れていないだけで暗号は誰でも解けるものであり、近くを通った人が自分の通信を盗聴しているかもしれない。ゾクッとしませんか。
そんなことが2017年に起こりました。ROCA攻撃と呼ばれるものです。暗号の中でも最も世界で活躍していると言われる「RSA暗号」が簡単に解けてしまうというものです。
その「RSA暗号」の本当の世界を覗いてみましょう。
CryptoはCTF特有のメタ的な能力よりかは数学力に重きが置かれる分野です。最近では発想だけではなくテクニックを知らないと解けないような問題が多くなってきました。そこでこの記事ではRSA関連の問題でよく使うテクニックを体系的に1から習得します。
テクニック GCD, 中国剰余定理, 終結式, グレブナー基底, LLL, Approximate GCD, Coppersmith
前提知識は出来る限り高校数学に絞っていますが、それでも少し大学での数学が出てきますので適宜補ってほしいです。
時計の世界 RSA暗号を語る上で最も根幹を成すのが、Nを自然数として「Nを法とする」算術です。</description></item><item><title>TPM</title><link>https://anko9801.github.io/blog/other/Circuit/HIEE/TPM/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://anko9801.github.io/blog/other/Circuit/HIEE/TPM/</guid><description>TPM 2.0 TPM (Trusted Platform Module)
暗号化用アルゴリズムエンジン、ハッシュエンジン、鍵生成器、乱数生成器、不揮発性メモリ(鍵などを保管)などを備えたモジュールで、TPM内への暗号キーの作成や使用制限をするために利用される。
TPM (Trust) ハードウェアとして開発
Windows BitLocker A Bad Dream TPM 2.</description></item><item><title>Troubleshooting and FAQ</title><link>https://anko9801.github.io/blog/notes/troubleshooting/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://anko9801.github.io/blog/notes/troubleshooting/</guid><description>Still having trouble? Here are a list of common questions and problems people encounter when installing Quartz.
While you&amp;rsquo;re here, join our Discord :)</description></item><item><title>UnionFind</title><link>https://anko9801.github.io/blog/data_structure/unionfind/unionfind/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://anko9801.github.io/blog/data_structure/unionfind/unionfind/</guid><description>説明 素集合を管理するデータ構造。内部的には森となっていて同じルートを持つ木の要素は同じ素集合にあると解釈して併合/比較を行う。
以下の工夫により高速化できる。
経路圧縮 (path compression) 再帰的に根を調べる際に根に直接つなぎ直す。 併合の工夫 併合時に木の高さ/大きさが小さい方を大きい方へ繋げる。 木の高さのときunion by rankと呼び、木の大きさのときunion by sizeと呼ぶ。 計算量 経路圧縮のみ $O(\log{N})$ 併合の工夫のみ $O(\log{N})$ 両方 $O(\alpha(N))$ 実装 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 #include &amp;lt;vector&amp;gt; struct UnionFind { std::vector&amp;lt;int&amp;gt; rank, parents; UnionFind() {} UnionFind(int n) { rank.</description></item><item><title>Updating</title><link>https://anko9801.github.io/blog/notes/updating/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://anko9801.github.io/blog/notes/updating/</guid><description>Haven&amp;rsquo;t updated Quartz in a while and want all the cool new optimizations? On Unix/Mac systems you can run the following command for a one-line update!</description></item><item><title>Wiener's Attack</title><link>https://anko9801.github.io/blog/crypto/RSA/WienersAttack/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://anko9801.github.io/blog/crypto/RSA/WienersAttack/</guid><description>説明 $3d &amp;lt; N^{\frac{1}{4}}$ のとき ( $d$ が小さすぎるか $e$ が大きすぎるとき)、$e/N$ に対し主近似分数を並べると $k/d$ がある。
$$ \begin{aligned} ed &amp;amp;≡ 1 = k\phi(N) + 1 = k(N - p - q + 1) + 1 \ \frac{e}{N} &amp;amp;= \frac{k}{d}\left(1-\frac{p + q - 1 - \frac{1}{k}}{N}\right) \approx \frac{k}{d} \ \frac{e}{N} &amp;amp;\approx q_0 + \cfrac{1}{q_1 + \cfrac{1}{q_2 + \cfrac{1}{\ddots \cfrac{}{q_{m-1} + \cfrac{1}{q_m}}}}} = \frac{k_m}{d_m} \ \end{aligned} $$</description></item><item><title>windows log</title><link>https://anko9801.github.io/blog/misc/forensics/windows/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://anko9801.github.io/blog/misc/forensics/windows/</guid><description>実行されたPowershell スクリプトのログ Event Viewer Applications and Services Logs &amp;gt; Microsoft &amp;gt; Windows &amp;gt; PowerShell &amp;gt; Operational Prefetchファイルを閲覧するにはWinPrefetchView
PowerShell版Mimikatz などのPowerShellを用いたスクリプトはここに記録されている。
LSASS (LSA Server Service)</description></item><item><title>ZIP</title><link>https://anko9801.github.io/blog/other/Application/Structure/ZIP/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://anko9801.github.io/blog/other/Application/Structure/ZIP/</guid><description>1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 [local file header 1] [file data 1] [data descriptor 1] .</description></item><item><title>その他の暗号</title><link>https://anko9801.github.io/blog/crypto/cryptography/other/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://anko9801.github.io/blog/crypto/cryptography/other/</guid><description>GoogleがTLSでの採用を提唱している共通鍵暗号方式「ChaCha」についてまとめた - sonickun.log (hatenablog.com) ChaCha RFC 7538 Salsa20
Integer factorization
Benaloh Blum–Goldwasser Cayley–Purser Damgård–Jurik GMR Goldwasser–Micali Naccache–Stern Paillier Rabin RSA Okamoto–Uchiyama Schmidt–Samoa Discrete logarithm</description></item><item><title>エミュレータ</title><link>https://anko9801.github.io/blog/other/Application/Virtualization/Emulator/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://anko9801.github.io/blog/other/Application/Virtualization/Emulator/</guid><description>エミュレータとはハードウェアをソフトウェアで再現するプログラム。</description></item><item><title>コンテナ仮想化技術</title><link>https://anko9801.github.io/blog/other/Application/Virtualization/Container/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://anko9801.github.io/blog/other/Application/Virtualization/Container/</guid><description>マルチステージビルド ビルド環境と実行環境のコンテナを分けることでサイズを抑えられる.
Kubernetes q3k/cve-2019-5736-poc: Unweaponized Proof of Concept for CVE-2019-5736 (Docker escape) (github.com) Dragon Sector: CVE-2019-5736: Escape from Docker and Kubernetes containers to root on host Security Camp B6 (notion.</description></item><item><title>サイズ基底簡約</title><link>https://anko9801.github.io/blog/crypto/Lattice/size_reduction/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://anko9801.github.io/blog/crypto/Lattice/size_reduction/</guid><description>説明 $n$ 次元格子 $L$ の基底 $\{\mathbf{b_1},\ldots,\mathbf{b_n}\}$ を GSO 係数 $\mu_{i,j}$ が
$$ |\mu_{i,j}| \leq \frac{1}{2} \quad (1 \leq \forall j &amp;lt; \forall i \leq n) $$</description></item><item><title>シェル芸</title><link>https://anko9801.github.io/blog/other/Application/Programming/Shell/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://anko9801.github.io/blog/other/Application/Programming/Shell/</guid><description>雰囲気でシェルを使っている人のためのシェル入門 | κeenのHappy Hacκing Blog (keens.github.io) A Tutorial on Portable Makefiles (nullprogram.com)</description></item><item><title>シェーダー</title><link>https://anko9801.github.io/blog/other/Application/Rendering/Shader/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://anko9801.github.io/blog/other/Application/Rendering/Shader/</guid><description>シェーダ言語 GLSL
つぶやきGLSL</description></item><item><title>シンボリック実行エンジン</title><link>https://anko9801.github.io/blog/other/Application/SAT-SMT/symbolic_execution/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://anko9801.github.io/blog/other/Application/SAT-SMT/symbolic_execution/</guid><description>説明 プログラム上で目的の地点に到達したいとき、それに当てはまるような入力値の条件を数学的に解くプログラム。条件分岐ごとに条件式を追加してそれをSMTソルバに解かせる。
Concolic Execution SSA形式とCFGが対応する Taint 解析
計算量 条件分岐数を $N$ として $O(2^N)$
実装 レジスタ, メモリに関する制約とSSA形式のIRを条件式としてSMTソルバで解く。
Rustでの実装 (mini_symbolic) 使用例 シンボリック実行エンジンのプロジェクト angr のサンプルコード。</description></item><item><title>セグメント木</title><link>https://anko9801.github.io/blog/data_structure/segtree/segtree/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://anko9801.github.io/blog/data_structure/segtree/segtree/</guid><description>説明 計算量 実装 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 #include &amp;lt;algorithm&amp;gt;#include &amp;lt;cassert&amp;gt;#include &amp;lt;vector&amp;gt; template &amp;lt;class S, S (*op)(S, S), S (*e)()&amp;gt; struct segtree { private: int _n, size, log; std::vector&amp;lt;S&amp;gt; d; public: segtree() : segtree(0) {} explicit segtree(int n) : segtree(std::vector&amp;lt;S&amp;gt;(n, e())) {} explicit segtree(const std::vector&amp;lt;S&amp;gt; &amp;amp;v) : _n(int(v.</description></item><item><title>セグメント木</title><link>https://anko9801.github.io/blog/data_structure/segtree/sparse_table/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://anko9801.github.io/blog/data_structure/segtree/sparse_table/</guid><description>説明 計算量 構築 O(NlogN) クエリ O(1)
実装 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 template &amp;lt;typename T&amp;gt; struct SparseTable { vector&amp;lt;vector&amp;lt;T&amp;gt;&amp;gt; st; vector&amp;lt;int&amp;gt; lookup; SparseTable(const vector&amp;lt;T&amp;gt; &amp;amp;v) { int b = 0; while ((1 &amp;lt;&amp;lt; b) &amp;lt;= v.</description></item><item><title>ゼロ知識証明</title><link>https://anko9801.github.io/blog/crypto/cryptography/ZeroKnowledgeProof/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://anko9801.github.io/blog/crypto/cryptography/ZeroKnowledgeProof/</guid><description>ゼロ知識証明の性質
完全性（Completeness） 証明者の主張が真であるならば、検証者は真であることが必ずわかること。 健全性（Soundness） 証明者の主張が偽であれば、検証者はかなり高い確率でそれが偽であること見抜けること。 ゼロ知識性（Zero Knowledge） あらゆる場合において、検証者が証明者から何らかの知識（情報）を盗もうとしても、証明者の主張が真であること以上の知識は得られない 名前の通り対話型は有名な洞窟の例のように証明者と検証者がやりとりを繰り返し、証明者が本当に正しい情報を持っているかを確率的に検証する方です。</description></item><item><title>ツール</title><link>https://anko9801.github.io/blog/other/Application/Tools/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://anko9801.github.io/blog/other/Application/Tools/</guid><description>Mac
Raycast Windows
PowerToys ImHex Ear Trumpet WizTree Obsidian XP-PEN
ある単語について検索結果の要約をポップアップで表示する拡張機能
Splunk
PEGを正規表現の拡張として使えるようなもの
デスクトップアプリ
Electron (TS) Dioxus (Rust) トークナイザ</description></item><item><title>ツールチェーン</title><link>https://anko9801.github.io/blog/other/Application/Programming/toolchain/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://anko9801.github.io/blog/other/Application/Programming/toolchain/</guid><description>toolchain ツールチェーンとはソースコードを実行する一連の処理に必要なソフトウェアのこと。要はどんな開発にも必要なツールセットである。
![[toolchain.svg]]
コンパイラ ![[compiler.svg]]
glibc musl libc コンパイル中にコンパイルする「コンパイル時Cコンパイラ」をつくった話 - kw-udonの日記 (hatenablog.com) keiichiw/constexpr-8cc: Compile-time C Compiler implemented as C++14 constant expressions (github.</description></item><item><title>ディープラーニング</title><link>https://anko9801.github.io/blog/other/Application/DeepLearning/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://anko9801.github.io/blog/other/Application/DeepLearning/</guid><description>モデル GPT BERT Tiiiger/bert_score: BERT score for text generation (github.com)
Transformer 作って理解する Transformer / Attention - Qiita
AI security バックドア 特定の入力データ(トリガー)を意図したクラスに誤分類させる トリガー以外の入力データは正しく分類されるので検知は困難 Mitigation</description></item><item><title>デバッガ</title><link>https://anko9801.github.io/blog/pwn/Debugger/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://anko9801.github.io/blog/pwn/Debugger/</guid><description>ptrace
gdb
gdb-peda
pwndbg
rust-gdb
Ghidra
IDA Pro
Binary Ninja</description></item><item><title>ハイパーバイザー</title><link>https://anko9801.github.io/blog/other/Application/Virtualization/Hypervisor/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://anko9801.github.io/blog/other/Application/Virtualization/Hypervisor/</guid><description>x86を仮想化可能なアーキテクチャへ拡張したものVT-x (Vanderpool Technology)
ハイパーバイザの作り方 (syuu1228.github.io)</description></item><item><title>ハッシュ関数</title><link>https://anko9801.github.io/blog/crypto/Hash/hash/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://anko9801.github.io/blog/crypto/Hash/hash/</guid><description>説明 原像計算困難性 与えられた $h$ に対して $H(m) = h$ となる $m$ を見つけることが困難である． 第二原像計算困難性 $m1$ が与えられたときに $H(m1) = H(m2)$ となる $m2(̸= m1)$ を求めるのが困難である． 衝突困難性 相異なる $m1$ と $m2$ で，$H(m1) = H(m2)$ となるメッセージを見つけることが困難である． HMAC (Hash-based MAC)</description></item><item><title>バックエンド最適化</title><link>https://anko9801.github.io/blog/other/Application/Server/rdbms-optimization/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://anko9801.github.io/blog/other/Application/Server/rdbms-optimization/</guid><description>Cache
Copy on Write An Overview of Query Optimization in Relational Systems 論文紹介 - Google スライド
O/R Mapper
ISUCONメモ https://github.</description></item><item><title>ビームサーチ</title><link>https://anko9801.github.io/blog/heuristic/beam_search/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://anko9801.github.io/blog/heuristic/beam_search/</guid><description>説明 幅優先探索の各階層においてスコアが高い順に $d$ 個のみを採用していく。$d$ をビーム幅と呼ぶ。
実装 参考 chokudaiサーチ</description></item><item><title>フロントエンド最適化</title><link>https://anko9801.github.io/blog/other/Application/Server/frontend-optimization/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://anko9801.github.io/blog/other/Application/Server/frontend-optimization/</guid><description>Web Performance lighthouse
先読み/遅延読み込み Resource Hints Priority Hints リソースの優先度をブラウザに認識させ、読み込み順序を最適化できます。初期画面に必要なリソースの読み込みが後方にある場合、その分LCPやFIDが遅延することになります。 link rel=preload script async/defer img/iframe loading=&amp;quot;lazy&amp;quot;
配信削減 圧縮 gzip brotli圧縮</description></item><item><title>ブロックチェーン</title><link>https://anko9801.github.io/blog/other/Application/Blockchain/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://anko9801.github.io/blog/other/Application/Blockchain/</guid><description>トランザクションをgit管理する。 H( H(transaction | prev_hash | created_at) | nonce) = 0000,,, 疑問 ある部分から先頭まで整合するように改変すれば改ざんできそうじゃない？
多くの人が何か価値があると思っているから価値がある。</description></item><item><title>プログラミング言語</title><link>https://anko9801.github.io/blog/other/Application/Programming/Programming/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://anko9801.github.io/blog/other/Application/Programming/Programming/</guid><description>プログラミング言語入門 任意の実行はデータとアクションで構成されている。 それを人間にとってわかりやすく書きやすい形にするがプログラミング言語が必要とされる理由であり、データとアクションの関係性における多様なデザインがプログラミング言語の多様性の理由である。
データとアクションの関係性はロジックや階層構造によって表現される。 そして計算モデルに意味を与える意味論的な解釈を取り込みつつ解説する。
最初は抽象的で簡単なところから始まり、具体的で難しい問題に立ち向かう。 対象者
任意の言語を素早く習得したい方 基礎から理解して安心したい方 新しい言語を実装したい方 情報に踊らされずちゃんと軸を持つには論理で情報を作り出さないといけない。
第一章 型 TODO: なぜここで型を説明するのか 馴染み深いから？前提知識として持っていないと抽象論を展開できないから？あいまいな定義や同義な言葉が各言語にあるのでまとめて扱う為に一回必要
ここでは公理的に計算するところはつまらんので省いて、なるべく実践的、アイデアが得られる点を紹介する。何故かというと私は計算より抽象的なことの方が好きだからです。不足分については型理論の方で説明します。($\lambda, \pi, \mu$ 計算, 線形型, Boehm-Berarducci encodingなど)</description></item><item><title>プロセッサ</title><link>https://anko9801.github.io/blog/other/Application/Processor/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://anko9801.github.io/blog/other/Application/Processor/</guid><description>CPU 概要 CPU
LGA BGA QFP GPU iGPU(internal) CPU内にあるグラボ dGPU(discrete) NVMe/SATA/PCIeなどで接続する外付けのグラボ eGPU(external) Thunderbolt 3/4などで接続する外付けのグラボ TPU 行列積演算 FPU GPGPU</description></item><item><title>ポテンシャル付きUnionFind</title><link>https://anko9801.github.io/blog/data_structure/unionfind/potential_unionfind/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://anko9801.github.io/blog/data_structure/unionfind/potential_unionfind/</guid><description>説明 各頂点はポテンシャルを管理する。ポテンシャルの差がインターフェースとなる。重み付きUnionFindとも言う。
計算量 $O(\alpha(N))$
実装 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 struct PotentialUnionFindTree { vec&amp;lt;ll&amp;gt; par, diff; PotentialUnionFindTree(ll n) { par.</description></item><item><title>マルウェア</title><link>https://anko9801.github.io/blog/other/Application/Malware/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://anko9801.github.io/blog/other/Application/Malware/</guid><description>CTF Radiooo - Episodes
マルウェア分類 Warez
非合法的に配布・販売されている商用ソフトウェア 日本では「ワレズ」と呼び、それが派生して「割れ」となった WannaCry
マルウェアの1種 EternalBlue システム管理ツール PowerShell, PsExec ペネトレーションテストツール Cobalt Strike Beacon クラウドサービス Dropbox, OneDrive</description></item><item><title>メルセンヌ ツイスタ</title><link>https://anko9801.github.io/blog/crypto/PRNG/MersenneTwister/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://anko9801.github.io/blog/crypto/PRNG/MersenneTwister/</guid><description>説明 長い周期 $2^{19937}-1$ を持つ疑似乱数生成器。連続した624回の32ビット出力から内部状態を復元できてしまう。 2つの値で十分のときもあるらしい https://www.ambionics.io/blog/php-mt-rand-prediction
参考 メルセンヌ・ツイスタをわかった気になる Mersenne Twisterの出力を推測してみる</description></item><item><title>リバースプロキシ</title><link>https://anko9801.github.io/blog/other/Application/Server/reverse-proxy/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://anko9801.github.io/blog/other/Application/Server/reverse-proxy/</guid><description>ロードバランサ OCSP stapling</description></item><item><title>レイトレーシング, パストレーシング</title><link>https://anko9801.github.io/blog/other/Application/Rendering/RayTracing/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://anko9801.github.io/blog/other/Application/Rendering/RayTracing/</guid><description>説明 レイトレーシング(Ray Tracing)とはCGを作成する技術の一つ。視点からレイ(Ray)と呼ばれる仮想の光線を飛ばし, 反射・屈折を繰り返して, 光源に当たればそこから逆算して画素を表示する仕組みです。
ガンマ補正 $(R^{2.2}, G^{2.2}, B^{2.2})$
PPM画像というASCIIで画素を表現する規格を用いると楽
物理ベースレンダリング理論 ある波長 $\lambda$ の光のエネルギー $$e_\lambda=\frac{hc}{\lambda}$$ スペクトル放射エネルギー $$ \begin{aligned} Q_\lambda&amp;amp;=ne_\lambda \ Q&amp;amp;=\int_0^\infty Q_\lambda d\lambda \end{aligned} $$ スペクトル放射束 $$ \begin{aligned} \Phi_\lambda&amp;amp;=\frac{dQ_\lambda}{dt} \ \Phi&amp;amp;=\frac{dQ}{dt} \end{aligned} $$ 放射輝度 $$L(x,\vec\omega)=\frac{d^2\Phi}{\cos\theta dAd\vec\omega}$$</description></item><item><title>中国剰余定理</title><link>https://anko9801.github.io/blog/arithmetic/crt/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://anko9801.github.io/blog/arithmetic/crt/</guid><description>説明 Garnerのアルゴリズム
計算量 $O(n^2 + n\log(\max p_i))$
実装 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 #include &amp;lt;vector&amp;gt; // x % m[i] = r[i] % m[i] を満たす正で最小の x を返す // mは互いに素であると仮定 // とりあえず解の存在判定は保留 template &amp;lt;typename T&amp;gt; T CRT(std::vector&amp;lt;T&amp;gt; r, std::vector&amp;lt;T&amp;gt; m) { ll n = r.</description></item><item><title>任意Modint</title><link>https://anko9801.github.io/blog/arithmetic/modulo/arbitrary_modint/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://anko9801.github.io/blog/arithmetic/modulo/arbitrary_modint/</guid><description>説明 計算量 実装 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 #include &amp;lt;cstdint&amp;gt;#include &amp;lt;istream&amp;gt;#include &amp;lt;vector&amp;gt; using ll = long long; class runtime_modint { using u64 = std::uint_fast64_t; static u64 &amp;amp;mod() { static u64 mod_ = 0; return mod_; } public: u64 a; runtime_modint(const u64 x = 0) : a(x % get_mod()) {} u64 &amp;amp;value() noexcept { return a; } const u64 &amp;amp;value() const noexcept { return a; } inline constexpr operator ll() const noexcept { return a; } runtime_modint operator+(const runtime_modint rhs) const { return runtime_modint(*this) += rhs; } runtime_modint operator-(const runtime_modint rhs) const { return runtime_modint(*this) -= rhs; } runtime_modint operator*(const runtime_modint rhs) const { return runtime_modint(*this) *= rhs; } runtime_modint operator/(const runtime_modint rhs) const { return runtime_modint(*this) /= rhs; } runtime_modint &amp;amp;operator+=(const runtime_modint rhs) { a += rhs.</description></item><item><title>体論</title><link>https://anko9801.github.io/blog/science/math/%E4%BD%93%E8%AB%96/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://anko9801.github.io/blog/science/math/%E4%BD%93%E8%AB%96/</guid><description>$$ \newcommand{\Ker}{\operatorname{Ker}} \newcommand{\Image}{\operatorname{Im}} \newcommand{\ch}{\operatorname{ch}} \newcommand{\Hom}{\operatorname{Hom}} \newcommand{\Aut}{\operatorname{Aut}} \newcommand{\id}{\mathrm{id}} \newcommand{\NN}{\mathbb{N}} \newcommand{\ZZ}{\mathbb{Z}} \newcommand{\QQ}{\mathbb{Q}} \newcommand{\RR}{\mathbb{R}} \newcommand{\CC}{\mathbb{C}} \newcommand{\FF}{\mathbb{F}} $$
輪読会 復習 Def. 標数 $\phi: \ZZ\to K$, $n \mapsto n\cdot 1$ 整数は全順序集合なので順序を与えて次のように $\phi$ を定義する.</description></item><item><title>全点対最短路 (Floyd-Warshall)</title><link>https://anko9801.github.io/blog/graph/shortest_path/floyd_warshall/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://anko9801.github.io/blog/graph/shortest_path/floyd_warshall/</guid><description>説明 不安なら3回やればいい
計算量 $O(V^3)$
実装 1 2 3 4 5 6 7 8 9 10 #include &amp;lt;vector&amp;gt; std::vector&amp;lt;std::vector&amp;lt;int&amp;gt;&amp;gt; d; int V; void floyd_warshall() { for (int k = 0; k &amp;lt; V; k++) for (int i = 0; i &amp;lt; V; i++) for (int j = 0; j &amp;lt; V; j++) d[i][j] = std::min(d[i][j], d[i][k] + d[k][j]); } 使用例</description></item><item><title>単一始点最短路 (Bellman-Ford)</title><link>https://anko9801.github.io/blog/graph/shortest_path/bellman_ford/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://anko9801.github.io/blog/graph/shortest_path/bellman_ford/</guid><description>説明 全ての辺を更新できなくなるまで更新する。 $V$ 回目のループで更新が発生するなら負閉路が存在する。
計算量 $O(EV)$
実装 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 #include &amp;lt;vector&amp;gt; const long long LINF = 0x1fffffffffffffff; struct Edge { int from, to, cost; }; class BellmanFord { std::vector&amp;lt;Edge&amp;gt; edges; std::vector&amp;lt;long long&amp;gt; d; int V, E; BellmanFord(int v) : V(v), E(0) {} void add_edge(int from, int to, int cost) { edges.</description></item><item><title>単一始点最短路 (Dijkstra)</title><link>https://anko9801.github.io/blog/graph/shortest_path/dijkstra/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://anko9801.github.io/blog/graph/shortest_path/dijkstra/</guid><description>説明 有向グラフに負の辺が存在しないとき次の事がいえる。 「まだ最短距離が確定していない点の中で、始点からの距離が最小 $\iff$ 最短距離として確定」
計算量 疎グラフ ヒープを用いる $O(E\log{V})$ 密グラフ 単純に探索 $O(V^2)$
実装 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 #include &amp;lt;queue&amp;gt;#include &amp;lt;vector&amp;gt; using ll = long long; using pll = std::pair&amp;lt;ll, ll&amp;gt;; template &amp;lt;class T&amp;gt; using pq = std::priority_queue&amp;lt;T, std::vector&amp;lt;T&amp;gt;, std::greater&amp;lt;T&amp;gt;&amp;gt;; const long long LINF = 0x1fffffffffffffff; struct Edge { int to, cost; }; int V; std::vector&amp;lt;ll&amp;gt; d; std::vector&amp;lt;std::vector&amp;lt;Edge&amp;gt;&amp;gt; G; void dijkstra(int s) { pq&amp;lt;pll&amp;gt; q; for (int i = 0; i &amp;lt; V; i++) d[i] = LINF; d[s] = 0; q.</description></item><item><title>参考資料</title><link>https://anko9801.github.io/blog/crypto/books/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://anko9801.github.io/blog/crypto/books/</guid><description>Crypto books 暗号理論入門―暗号アルゴリズム、署名と認証、その数学的基礎 （原書第３版）ブーフマン Buchmann (著)
The Block Cipher Companion
現代暗号の誕生と発展：ポスト量子暗号・仮想通貨・新しい暗号 岡本 龍明 (著)</description></item><item><title>圏論</title><link>https://anko9801.github.io/blog/science/math/%E5%9C%8F%E8%AB%96/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://anko9801.github.io/blog/science/math/%E5%9C%8F%E8%AB%96/</guid><description>淡中圏 ガロア理論 テイト・シャファレヴィッチ群
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 \usepackage{tikz-cd} \begin{document} \begin{tikzcd} T \arrow[drr, bend left, &amp;#34;x&amp;#34;] \arrow[ddr, bend right, &amp;#34;y&amp;#34;] \arrow[dr, dotted, &amp;#34;{(x,y)}&amp;#34; description] &amp;amp; &amp;amp; \\ K &amp;amp; X \times_Z Y \arrow[r, &amp;#34;p&amp;#34;] \arrow[d, &amp;#34;q&amp;#34;] &amp;amp; X \arrow[d, &amp;#34;f&amp;#34;] \\ &amp;amp; Y \arrow[r, &amp;#34;g&amp;#34;] &amp;amp; Z \end{tikzcd} \quad \quad \begin{tikzcd}[row sep=2.</description></item><item><title>型理論</title><link>https://anko9801.github.io/blog/other/Application/Programming/Type/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://anko9801.github.io/blog/other/Application/Programming/Type/</guid><description>型理論 型はグロタンディーク宇宙の中であることを断っておく。
論理 最小述語論理+矛盾律 = 直観主義論理 直観主義論理+排中律 = 古典論理: ゲンツェンの自然演繹(NK)
型無しラムダ計算 α-変換 : 束縛変数の名前は重要ではない β-簡約 : 関数適用 η-変換 : 2つの関数について任意の引数を関数適用した値が等しいならば、2つの関数は等しい</description></item><item><title>定理証明支援系</title><link>https://anko9801.github.io/blog/other/Application/SAT-SMT/proof_assistant/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://anko9801.github.io/blog/other/Application/SAT-SMT/proof_assistant/</guid><description>説明 計算量 実装 使用例 参考 一人Computer Science Advent Calendar 2017</description></item><item><title>山登り法</title><link>https://anko9801.github.io/blog/heuristic/hill_climbing/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://anko9801.github.io/blog/heuristic/hill_climbing/</guid><description>説明 初めに初期状態を設定し、近傍へ状態遷移したとき最も成績の良い解を新しい状態とし、これを繰り返すことで極値が見つかる。
実装 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 #include &amp;lt;sys/time.</description></item><item><title>幾何ライブラリ</title><link>https://anko9801.github.io/blog/geometry/geometry/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://anko9801.github.io/blog/geometry/geometry/</guid><description>説明 幾何ライブラリ 複素平面
計算量 実装 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 #include &amp;lt;bits/stdc++.</description></item><item><title>強連結成分分解</title><link>https://anko9801.github.io/blog/graph/scc/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://anko9801.github.io/blog/graph/scc/</guid><description>説明 有向グラフにおいて、ある部分グラフが強連結であるとは任意の2点が互いに行き来可能であること。
深さ優先探索の帰りがけ順(トポロジカルソート順)に逆グラフを探索したときそれらが通る点は強連結成分となる。
計算量 $O(V + E)$
実装 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 #include &amp;lt;algorithm&amp;gt;#include &amp;lt;set&amp;gt;#include &amp;lt;vector&amp;gt; class SCC { int n; std::vector&amp;lt;std::vector&amp;lt;int&amp;gt;&amp;gt; G, rG; // order: 帰りがけ順の逆順 == トポ順 // comp: 強連結をグループ化 std::vector&amp;lt;int&amp;gt; order, comp; std::vector&amp;lt;bool&amp;gt; used; void dfs(int v) { used[v] = true; for (auto nv : G[v]) { if (!</description></item><item><title>指数計算法 (Index Calculus Algorithm)</title><link>https://anko9801.github.io/blog/crypto/DLP/IndexCalculus/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://anko9801.github.io/blog/crypto/DLP/IndexCalculus/</guid><description>説明 実装 使用例 参考</description></item><item><title>数体ふるい法</title><link>https://anko9801.github.io/blog/crypto/DLP/NumberFieldSieve/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://anko9801.github.io/blog/crypto/DLP/NumberFieldSieve/</guid><description>説明 実装 使用例 参考</description></item><item><title>数学</title><link>https://anko9801.github.io/blog/science/math/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://anko9801.github.io/blog/science/math/</guid><description>数学 各単元を下の階層で証明する. ここでは重要な定義と本質をまとめる.
数学基礎論 数学基礎論ノート
集合論 全順序集合 同値類 濃度 群論 群・正規部分群 群: 単位元, 逆元のある結合的な演算を持つ集合 ラグランジュの定理 $|G_1|=|G_2|(G_1:G_2)$ 準同型 準同型定理 $G/\Ker(\phi)\cong\Image(\phi)$ 群の作用 Sylow の定理 p-Sylow 部分群の数 $s=|G|/|N_G(H)|=1\pmod{p}$ 有限アーベル群の構造定理 $G\cong\ZZ/a_1\ZZ\times\ldots\times\ZZ/a_n\ZZ$ 環・加群 環・イデアル 環準同型定理 $A/\Ker(\phi)\cong\Image(\phi)$ 多項式環 素イデアル・極大イデアル 中国剰余定理 局所化 一意分解環, 単項イデアル整域, ユークリッド環 環$\impliedby$可換環$\impliedby$整域$\impliedby$正規環$\impliedby$UFD(一意分解環)$\impliedby$PID(単項イデアル整域)$\impliedby$ユークリッド環$\impliedby$体 加群 体論 代数拡大・超越拡大 有限次拡大$\iff$有限生成の代数拡大 代数閉包 Steinitz の定理 分離拡大・正規拡大 既約な非分離多項式 $f(x)\in K$ $\iff$$\ch K=p&amp;gt;0$ であり, 既約な分離多項式 $g(x)\in K$ と $n&amp;gt;0$ があり, $f(x)=g(x^{p^n})$ となる.</description></item><item><title>数論変換</title><link>https://anko9801.github.io/blog/arithmetic/ntt/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://anko9801.github.io/blog/arithmetic/ntt/</guid><description>説明 複素数上のFFTを有限体上に取り替えたのがNTT。乗法群の位数が大きな2のべき乗を持っていると精度を落とさずに計算できて嬉しい。
計算量 $O(N\log{N})$
実装 使用例</description></item><item><title>数論的関数/進数変換</title><link>https://anko9801.github.io/blog/arithmetic/arithmetical_function/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://anko9801.github.io/blog/arithmetic/arithmetical_function/</guid><description>オイラーの$\phi$関数 メビウスの$\mu$関数 カーマイケルの$\lambda$関数</description></item><item><title>最大公約数・最小公倍数</title><link>https://anko9801.github.io/blog/arithmetic/gcd/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://anko9801.github.io/blog/arithmetic/gcd/</guid><description>説明 ユークリッドの互除法
計算量 $O(\log{N})$
実装 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 template &amp;lt;typename T&amp;gt; T gcd(T a, T b) { T r; while (b &amp;gt; 0) { r = a % b; a = b; b = r; } return a; } template &amp;lt;typename T&amp;gt; T lcm(T a, T b) { return a / gcd(a, b) * b; } template &amp;lt;typename T&amp;gt; T extgcd(T a, T b, T &amp;amp;x, T &amp;amp;y) { T g = a; x = 1; y = 0; if (b) { g = extgcd(b, a % b, y, x); y -= a / b * x; } return g; } 使用例</description></item><item><title>最大流 (Dinic)</title><link>https://anko9801.github.io/blog/graph/flow/dinic/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://anko9801.github.io/blog/graph/flow/dinic/</guid><description>説明 計算量 $O(EV^2)$
実装 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 #include &amp;lt;queue&amp;gt;#include &amp;lt;vector&amp;gt; struct Dinic { struct edge { long long to, cap, rev; }; long long n; std::vector&amp;lt;std::vector&amp;lt;edge&amp;gt;&amp;gt; G; std::vector&amp;lt;long long&amp;gt; level, iter; // level[i] = sからiへの最短距離(Dijkstra法) void bfs(long long s) { level.</description></item><item><title>最大流 (Ford Fulkerson)</title><link>https://anko9801.github.io/blog/graph/flow/ford_fulkerson/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://anko9801.github.io/blog/graph/flow/ford_fulkerson/</guid><description>説明 計算量 $O(FE)$
実装 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 #include &amp;lt;vector&amp;gt; class FordFulkerson { struct edge { long long to, cap, rev; }; const long long INF = 1 &amp;lt;&amp;lt; 60; long long n; std::vector&amp;lt;std::vector&amp;lt;edge&amp;gt;&amp;gt; G; std::vector&amp;lt;bool&amp;gt; used; long long dfs(long long s, long long t, long long f) { if (s == t) return f; used[s] = true; for (edge &amp;amp;e : G[s]) { if (!</description></item><item><title>木の直径</title><link>https://anko9801.github.io/blog/graph/tree/diameter/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://anko9801.github.io/blog/graph/tree/diameter/</guid><description>説明 木の直径とはある2点間が最大となる距離である。
どの頂点から始めても、そこから最も遠い頂点は直径の端点の1つになる。端点から最も遠い頂点はもう1つの端点になる。その2点の距離が木の直径となる。
計算量 $O(V + E)$
実装 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 #include &amp;lt;vector&amp;gt; template &amp;lt;typename T&amp;gt; struct Edge { int to; T cost; }; using Graph = std::vector&amp;lt;std::vector&amp;lt;Edge&amp;lt;long long&amp;gt;&amp;gt;&amp;gt;; template &amp;lt;typename T&amp;gt; std::pair&amp;lt;T, int&amp;gt; dfs(const Graph &amp;amp;G, int u, int par) { auto ret = {0, u}; for (auto &amp;amp;e : G) { if (e.</description></item><item><title>格子</title><link>https://anko9801.github.io/blog/crypto/Lattice/Lattice/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://anko9801.github.io/blog/crypto/Lattice/Lattice/</guid><description>説明 格子 (Lattice) 図でイメージ掴むのが速い
線形独立な $n$ 個のベクトル $\mathbf{b}_1, \mathbf{b}_2, \ldots , \mathbf{b}_n \in \mathbb{R}^m$ について整数係数の線形結合によって生成されるベクトルの集合を格子 $L$ と定義します。
$$ L = \left{ \sum_{i=0}^{n} a_i\mathbf{b}_i \ \middle| \ a_i \in \mathbb{Z} \right} $$</description></item><item><title>楕円曲線暗号</title><link>https://anko9801.github.io/blog/crypto/ECC/ECC/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://anko9801.github.io/blog/crypto/ECC/ECC/</guid><description>楕円曲線暗号 楕円曲線 $K$ を任意の体、 $f(x) \in K[x]$ を3次方程式とする。ただし $f(x)$ の3解は相異なる。ここで次の方程式を考える。
$$ y^2 = f(x) $$
$x, y$ 線形変換によって2次の項は消すことができ、
$$ y^2 = x^3 + ax + b $$</description></item><item><title>永続UnionFind</title><link>https://anko9801.github.io/blog/data_structure/unionfind/persist_unionfind/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://anko9801.github.io/blog/data_structure/unionfind/persist_unionfind/</guid><description>説明 計算量 実装 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 struct PartiallyParsistUnionFind { vector&amp;lt;ll&amp;gt; rank, par, time; PartiallyParsistUnionFind(ll n) { rank.</description></item><item><title>永続セグメント木</title><link>https://anko9801.github.io/blog/data_structure/segtree/persistent_segtree/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://anko9801.github.io/blog/data_structure/segtree/persistent_segtree/</guid><description>説明 計算量 実装 参考文献 つくってなぐろ (永続配列/永続Union-Find木/永続セグメント木の作り方と意義、具体例) - Qiita</description></item><item><title>準同型暗号</title><link>https://anko9801.github.io/blog/crypto/cryptography/homomorphism/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://anko9801.github.io/blog/crypto/cryptography/homomorphism/</guid><description>レベルn準同型 = 加法準同型 + n回の乗算準同型
乗算回数に制約がある完全準同型 レベルnはn次方程式を計算できる レベル2準同型なら乗算が1度だけ可能 Unpadded RSA 乗法準同型 $$ \begin{aligned} \mathcal{E}(m_1)\times\mathcal{E}(m_2) &amp;amp;= m_1^em_2^e &amp;amp; \bmod n \ &amp;amp;= (m_1m_2)^e &amp;amp; \bmod n \ &amp;amp;= \mathcal{E}(m_1m_2) \end{aligned} $$</description></item><item><title>無線</title><link>https://anko9801.github.io/blog/other/Application/Network/%E9%AB%98%E5%91%A8%E6%B3%A2-%E7%84%A1%E7%B7%9A-%E9%80%9A%E4%BF%A1/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://anko9801.github.io/blog/other/Application/Network/%E9%AB%98%E5%91%A8%E6%B3%A2-%E7%84%A1%E7%B7%9A-%E9%80%9A%E4%BF%A1/</guid><description/></item><item><title>焼きなまし法</title><link>https://anko9801.github.io/blog/heuristic/simulated_annealing/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://anko9801.github.io/blog/heuristic/simulated_annealing/</guid><description>説明 山登り法は常にスコアが最大のものを採用するが、焼きなまし法では遷移確率関数を用いてスコアに応じて確率的に遷移させるようにする。
温度関数は最初は大きく、時間が経つにつれて小さくなるような関数で、温度が高いほど発散し、低いほど収束するように遷移確率関数を調整する。
実装 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 #include &amp;lt;sys/time.</description></item><item><title>物理学</title><link>https://anko9801.github.io/blog/science/phys/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://anko9801.github.io/blog/science/phys/</guid><description>物理学 ベクトル解析 ベクトル解析ノート
電磁気学 解析力学 波動方程式の離散化
$$ \begin{aligned} \frac{\partial^2u}{\partial t^2} &amp;amp;= v^2\left(\frac{\partial^2u}{\partial x^2} + \frac{\partial^2u}{\partial y^2}\right) \ \frac{u_{i,j}^{n+1}-2u_{i,j}^n+u_{i,j}^{n-1}}{\Delta t^2} &amp;amp;= v^2\left(\frac{u_{i,j}^{n+1}-2u_{i,j}^n+u_{i,j}^{n-1}}{\Delta x^2} + \frac{u_{i,j}^{n+1}-2u_{i,j}^n+u_{i,j}^{n-1}}{\Delta y^2}\right) \ u_{i,j}^{n+1} &amp;amp;= 2u_{i,j}^n - u_{i,j}^{n-1} + \Delta t^2v^2\left(\frac{u_{i,j}^{n+1}-2u_{i,j}^n+u_{i,j}^{n-1}}{\Delta x^2} + \frac{u_{i,j}^{n+1}-2u_{i,j}^n+u_{i,j}^{n-1}}{\Delta y^2}\right) \end{aligned} $$</description></item><item><title>生物学</title><link>https://anko9801.github.io/blog/science/%E7%94%9F%E7%89%A9%E5%AD%A6/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://anko9801.github.io/blog/science/%E7%94%9F%E7%89%A9%E5%AD%A6/</guid><description/></item><item><title>競プロテンプレート</title><link>https://anko9801.github.io/blog/other/template/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://anko9801.github.io/blog/other/template/</guid><description>説明 競プロで使うテンプレート
実装 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 #ifndef LOCAL #pragma GCC optimize(&amp;#34;Ofast&amp;#34;) #pragma GCC optimize(&amp;#34;unroll-loops&amp;#34;) #endif #include &amp;lt;bits/stdc++.</description></item><item><title>素因数分解</title><link>https://anko9801.github.io/blog/arithmetic/primes/factorize/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://anko9801.github.io/blog/arithmetic/primes/factorize/</guid><description>説明 計算量 実装 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 #include &amp;lt;vector&amp;gt; template &amp;lt;typename T&amp;gt; std::vector&amp;lt;std::pair&amp;lt;T, int&amp;gt;&amp;gt; factors(T N) { std::vector&amp;lt;std::pair&amp;lt;T, int&amp;gt;&amp;gt; res; for (T a = 2; a * a &amp;lt;= N; ++a) { if (N % a !</description></item><item><title>素数列挙</title><link>https://anko9801.github.io/blog/arithmetic/primes/primes/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://anko9801.github.io/blog/arithmetic/primes/primes/</guid><description>説明 エラトステネスの篩
計算量 実装 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 #include &amp;lt;vector&amp;gt; std::vector&amp;lt;int&amp;gt; primes; std::vector&amp;lt;bool&amp;gt; Eratosthenes(int N) { std::vector&amp;lt;bool&amp;gt; isprime(N + 1, true); isprime[0] = isprime[1] = false; for (int p = 2; p &amp;lt;= N; ++p) { if (!</description></item><item><title>行列</title><link>https://anko9801.github.io/blog/arithmetic/matrix/matrix/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://anko9801.github.io/blog/arithmetic/matrix/matrix/</guid><description>説明 計算量 実装 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 #include &amp;lt;bits/stdc++.</description></item><item><title>逆元が存在しないとき</title><link>https://anko9801.github.io/blog/crypto/RSA/NoInverse/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://anko9801.github.io/blog/crypto/RSA/NoInverse/</guid><description>説明 乗法群の位数が $\phi(N) = se^n = 0 \pmod e$ のとき $e$ の逆元が取れない。このとき、位数 $s$ の乗法群に落として逆元を取り、位数 $se^n$ の元を $e^n$ 回掛けて全探索すると平文が見つかる。
計算量 $O(e^n)$</description></item><item><title>遅延セグメント木</title><link>https://anko9801.github.io/blog/data_structure/segtree/lazysegtree/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://anko9801.github.io/blog/data_structure/segtree/lazysegtree/</guid><description>説明 計算量 実装 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 #include &amp;lt;algorithm&amp;gt;#include &amp;lt;cassert&amp;gt;#include &amp;lt;iostream&amp;gt;#include &amp;lt;vector&amp;gt; namespace internal { int ceil_pow2(int n) { int x = 0; while ((1U &amp;lt;&amp;lt; x) &amp;lt; (unsigned int)(n)) x++; return x; } } // namespace internal template &amp;lt;class S, S (*op)(S, S), S (*e)(), class F, S (*mapping)(F, S), F (*composition)(F, F), F (*id)()&amp;gt; struct lazy_segtree { private: int _n, size, log; std::vector&amp;lt;S&amp;gt; node; std::vector&amp;lt;F&amp;gt; lazy; public: lazy_segtree() : lazy_segtree(0) {} explicit lazy_segtree(int n) : lazy_segtree(std::vector&amp;lt;S&amp;gt;(n, e())) {} explicit lazy_segtree(const std::vector&amp;lt;S&amp;gt; &amp;amp;v) : _n(int(v.</description></item><item><title>離散対数問題 (DLP)</title><link>https://anko9801.github.io/blog/crypto/DLP/DLP/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://anko9801.github.io/blog/crypto/DLP/DLP/</guid><description>説明 離散対数問題 (DLP: Discrete Logarithm Problem) とは巡回群 $G$ について $a, b\in G$ が与えられるので $a^n = b$ となる最小の $n\in \mathbb{N}$ を求める問題である。</description></item><item><title>音声コーデック</title><link>https://anko9801.github.io/blog/other/Application/Network/%E9%9F%B3%E5%A3%B0%E3%82%B3%E3%83%BC%E3%83%87%E3%83%83%E3%82%AF/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://anko9801.github.io/blog/other/Application/Network/%E9%9F%B3%E5%A3%B0%E3%82%B3%E3%83%BC%E3%83%87%E3%83%83%E3%82%AF/</guid><description/></item><item><title>高速ゼータ変換・高速メビウス変換</title><link>https://anko9801.github.io/blog/arithmetic/zeta/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://anko9801.github.io/blog/arithmetic/zeta/</guid><description>説明 計算量 実装 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 #include &amp;lt;vector&amp;gt; template &amp;lt;typename T&amp;gt; class Eratosthenes { public: std::vector&amp;lt;bool&amp;gt; isprime; // 素数 std::vector&amp;lt;T&amp;gt; minfactor; // 最小の素因数 // メビウス関数 μ // μ(1)=1 // n がある素数pで2回以上割り切れるとき、μ(n)=0 // n=p1×p2×…pK と素因数分解できるとき、μ(n)=(−1)^K // f(1)=∑[i=1~N]μ(i)F(i) 約数系包除原理 std::vector&amp;lt;T&amp;gt; mobius; // エラトステネスの篩 O(NloglogN) Eratosthenes(int N) : isprime(N + 1, true), minfactor(N + 1, -1), mobius(N + 1, 1) { isprime[1] = false; minfactor[1] = 1; for (T p = 2; p &amp;lt;= N; ++p) { if (!</description></item><item><title>高速フーリエ変換 (FFT)</title><link>https://anko9801.github.io/blog/arithmetic/fft/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://anko9801.github.io/blog/arithmetic/fft/</guid><description>説明 次の記事がわかりやすいです。
【競プロer向け】FFT を習得しよう！ | 東京工業大学デジタル創作同好会traP
計算量 $O(N\log{N})$
実装 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 #include &amp;lt;complex&amp;gt;#include &amp;lt;vector&amp;gt; using namespace std; using ll = long long; using ld = long double; using Complex = complex&amp;lt;ld&amp;gt;; const ld PI = 3.</description></item><item><title>高速素因数分解 (Pollard-ρ法/Miller-Rabin法)</title><link>https://anko9801.github.io/blog/arithmetic/primes/fast_factorize/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://anko9801.github.io/blog/arithmetic/primes/fast_factorize/</guid><description>説明 Pollard-$\rho$ 法と Miller-Rabin 法を用いて $O(n^{\frac{1}{4}}\log^3n)$ で素因数分解できる。
Miller–Rabin 素数判定法 Miller-Rabin 素数判定法は与えられた数 $n$ が素数かどうかを計算時間 $O(k\log^3 n)$ で誤り率 $4^{-k}$ 以下で判定する確率的素数判定アルゴリズムである。
フェルマーの小定理について考える。素数である剰余 $n$ について、その乗法群の位数 $n-1$ はそれを $2$ で割れるだけ割った数を $d$ として $n-1 = 2^sd$ と書ける。</description></item><item><title>🪴 Quartz 3.</title><link>https://anko9801.github.io/blog/_index_old/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://anko9801.github.io/blog/_index_old/</guid><description>Host your second brain and digital garden for free. Quartz features
Extremely fast natural-language [[notes/search]] Customizable and hackable design based on Hugo Automatically generated backlinks, link previews, and local graph Built-in [[notes/CJK + Latex Support (测试) | CJK + Latex Support]] and [[notes/callouts | Admonition-style callouts]] Support for both Markdown Links and Wikilinks Check out some of the amazing gardens that community members have published with Quartz or read about why I made Quartz to begin with.</description></item></channel></rss>