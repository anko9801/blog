<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Graphs on</title><link>https://anko9801.github.io/blog/graph/</link><description>Recent content in Graphs on</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><atom:link href="https://anko9801.github.io/blog/graph/index.xml" rel="self" type="application/rss+xml"/><item><title>グラフ</title><link>https://anko9801.github.io/blog/graph/graph/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://anko9801.github.io/blog/graph/graph/</guid><description>説明 グラフ (Graph) とは頂点の集合 $V$ と辺の集合 $E$ の組 $(V, E)$ です. 頂点 (Node) は点と見なせるオブジェクトの概念で, 辺 (Edge) は頂点 $u$ から頂点 $v$ へ向かう組 $(u, v)$ です.</description></item><item><title>全点対最短路 (Floyd-Warshall)</title><link>https://anko9801.github.io/blog/graph/shortest_path/floyd_warshall/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://anko9801.github.io/blog/graph/shortest_path/floyd_warshall/</guid><description>説明 不安なら3回やればいい
計算量 $O(V^3)$
実装 1 2 3 4 5 6 7 8 9 10 #include &amp;lt;vector&amp;gt; std::vector&amp;lt;std::vector&amp;lt;int&amp;gt;&amp;gt; d; int V; void floyd_warshall() { for (int k = 0; k &amp;lt; V; k++) for (int i = 0; i &amp;lt; V; i++) for (int j = 0; j &amp;lt; V; j++) d[i][j] = std::min(d[i][j], d[i][k] + d[k][j]); } 使用例</description></item><item><title>単一始点最短路 (Bellman-Ford)</title><link>https://anko9801.github.io/blog/graph/shortest_path/bellman_ford/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://anko9801.github.io/blog/graph/shortest_path/bellman_ford/</guid><description>説明 全ての辺を更新できなくなるまで更新する。 $V$ 回目のループで更新が発生するなら負閉路が存在する。
計算量 $O(EV)$
実装 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 #include &amp;lt;vector&amp;gt; const long long LINF = 0x1fffffffffffffff; struct Edge { int from, to, cost; }; class BellmanFord { std::vector&amp;lt;Edge&amp;gt; edges; std::vector&amp;lt;long long&amp;gt; d; int V, E; BellmanFord(int v) : V(v), E(0) {} void add_edge(int from, int to, int cost) { edges.</description></item><item><title>単一始点最短路 (Dijkstra)</title><link>https://anko9801.github.io/blog/graph/shortest_path/dijkstra/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://anko9801.github.io/blog/graph/shortest_path/dijkstra/</guid><description>説明 有向グラフに負の辺が存在しないとき次の事がいえる。 「まだ最短距離が確定していない点の中で、始点からの距離が最小 $\iff$ 最短距離として確定」
計算量 疎グラフ ヒープを用いる $O(E\log{V})$ 密グラフ 単純に探索 $O(V^2)$ 実装 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 #include &amp;lt;queue&amp;gt;#include &amp;lt;vector&amp;gt; using ll = long long; using pll = std::pair&amp;lt;ll, ll&amp;gt;; template &amp;lt;class T&amp;gt; using pq = std::priority_queue&amp;lt;T, std::vector&amp;lt;T&amp;gt;, std::greater&amp;lt;T&amp;gt;&amp;gt;; const long long LINF = 0x1fffffffffffffff; struct Edge { int to, cost; }; int V; std::vector&amp;lt;ll&amp;gt; d; std::vector&amp;lt;std::vector&amp;lt;Edge&amp;gt;&amp;gt; G; void dijkstra(int s) { pq&amp;lt;pll&amp;gt; q; for (int i = 0; i &amp;lt; V; i++) d[i] = LINF; d[s] = 0; q.</description></item><item><title>強連結成分分解</title><link>https://anko9801.github.io/blog/graph/scc/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://anko9801.github.io/blog/graph/scc/</guid><description>説明 有向グラフにおいて、ある部分グラフが強連結であるとは任意の2点が互いに行き来可能であること。
深さ優先探索の帰りがけ順(トポロジカルソート順)に逆グラフを探索したときそれらが通る点は強連結成分となる。
計算量 $O(V + E)$
実装 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 #include &amp;lt;algorithm&amp;gt;#include &amp;lt;set&amp;gt;#include &amp;lt;vector&amp;gt; class SCC { int n; std::vector&amp;lt;std::vector&amp;lt;int&amp;gt;&amp;gt; G, rG; // order: 帰りがけ順の逆順 == トポ順 // comp: 強連結をグループ化 std::vector&amp;lt;int&amp;gt; order, comp; std::vector&amp;lt;bool&amp;gt; used; void dfs(int v) { used[v] = true; for (auto nv : G[v]) { if (!</description></item><item><title>最大流 (Dinic)</title><link>https://anko9801.github.io/blog/graph/flow/dinic/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://anko9801.github.io/blog/graph/flow/dinic/</guid><description>説明 計算量 $O(EV^2)$
実装 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 #include &amp;lt;queue&amp;gt;#include &amp;lt;vector&amp;gt; struct Dinic { struct edge { long long to, cap, rev; }; long long n; std::vector&amp;lt;std::vector&amp;lt;edge&amp;gt;&amp;gt; G; std::vector&amp;lt;long long&amp;gt; level, iter; // level[i] = sからiへの最短距離(Dijkstra法) void bfs(long long s) { level.</description></item><item><title>最大流 (Ford Fulkerson)</title><link>https://anko9801.github.io/blog/graph/flow/ford_fulkerson/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://anko9801.github.io/blog/graph/flow/ford_fulkerson/</guid><description>説明 計算量 $O(FE)$
実装 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 #include &amp;lt;vector&amp;gt; class FordFulkerson { struct edge { long long to, cap, rev; }; const long long INF = 1 &amp;lt;&amp;lt; 60; long long n; std::vector&amp;lt;std::vector&amp;lt;edge&amp;gt;&amp;gt; G; std::vector&amp;lt;bool&amp;gt; used; long long dfs(long long s, long long t, long long f) { if (s == t) return f; used[s] = true; for (edge &amp;amp;e : G[s]) { if (!</description></item><item><title>木の直径</title><link>https://anko9801.github.io/blog/graph/tree/diameter/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://anko9801.github.io/blog/graph/tree/diameter/</guid><description>説明 木の直径とはある2点間が最大となる距離である。
どの頂点から始めても、そこから最も遠い頂点は直径の端点の1つになる。端点から最も遠い頂点はもう1つの端点になる。その2点の距離が木の直径となる。
計算量 $O(V + E)$
実装 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 #include &amp;lt;vector&amp;gt; template &amp;lt;typename T&amp;gt; struct Edge { int to; T cost; }; using Graph = std::vector&amp;lt;std::vector&amp;lt;Edge&amp;lt;long long&amp;gt;&amp;gt;&amp;gt;; template &amp;lt;typename T&amp;gt; std::pair&amp;lt;T, int&amp;gt; dfs(const Graph &amp;amp;G, int u, int par) { auto ret = {0, u}; for (auto &amp;amp;e : G) { if (e.</description></item></channel></rss>