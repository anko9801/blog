<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Graphs on</title><link>https://anko9801.github.io/blog/graph/</link><description>Recent content in Graphs on</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><atom:link href="https://anko9801.github.io/blog/graph/index.xml" rel="self" type="application/rss+xml"/><item><title/><link>https://anko9801.github.io/blog/graph/flow/flow/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://anko9801.github.io/blog/graph/flow/flow/</guid><description>最大流 始点から終点へ水を流すと最大でどれくらい流せるかという問題.
各辺には容量 $c$ があり流量はこれを超えない. 流量は入ってくる量と出ていく量が保存される. $s$-$t$ カット 頂点 $V$ を分割して, 始点 $s$ 側の集合 $S$ と終点 $t$ 側の集合 $T$ をおく.</description></item><item><title>グラフ</title><link>https://anko9801.github.io/blog/graph/graph/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://anko9801.github.io/blog/graph/graph/</guid><description>説明 グラフ (Graph) とは頂点の集合 $V$ と辺の集合 $E$ の組 $(V, E)$ です. 頂点 (Node) は点と見なせるオブジェクトの概念で, 辺 (Edge) は頂点 $u$ から頂点 $v$ へ向かう組 $(u, v)$ です.</description></item><item><title>全点対最短路 (Floyd-Warshall)</title><link>https://anko9801.github.io/blog/graph/shortest_path/floyd_warshall/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://anko9801.github.io/blog/graph/shortest_path/floyd_warshall/</guid><description>説明 不安なら3回やればいい
計算量 $O(V^3)$
実装 1 2 3 4 5 6 7 8 9 10 #include &amp;lt;vector&amp;gt; std::vector&amp;lt;std::vector&amp;lt;int&amp;gt;&amp;gt; d; int V; void floyd_warshall() { for (int k = 0; k &amp;lt; V; k++) for (int i = 0; i &amp;lt; V; i++) for (int j = 0; j &amp;lt; V; j++) d[i][j] = std::min(d[i][j], d[i][k] + d[k][j]); } 使用例</description></item><item><title>単一始点最短路 (Bellman-Ford)</title><link>https://anko9801.github.io/blog/graph/shortest_path/bellman_ford/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://anko9801.github.io/blog/graph/shortest_path/bellman_ford/</guid><description>説明 全ての辺を更新できなくなるまで更新する。 $V$ 回目のループで更新が発生するなら負閉路が存在する。
計算量 $O(EV)$
実装 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 #include &amp;lt;vector&amp;gt; const long long LINF = 0x1fffffffffffffff; struct Edge { int from, to, cost; }; class BellmanFord { std::vector&amp;lt;Edge&amp;gt; edges; std::vector&amp;lt;long long&amp;gt; d; int V, E; BellmanFord(int v) : V(v), E(0) {} void add_edge(int from, int to, int cost) { edges.</description></item><item><title>単一始点最短路 (Dijkstra)</title><link>https://anko9801.github.io/blog/graph/shortest_path/dijkstra/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://anko9801.github.io/blog/graph/shortest_path/dijkstra/</guid><description>説明 有向グラフに負の辺が存在しないとき次の事がいえる。
「まだ最短距離が確定していない点の中で、始点からの距離が最小 $\iff$ 最短距離として確定」
仕様 ShortestPath&amp;lt;T&amp;gt; 始点から終点までの距離 dist 始点からの最短路のパスで終点の1つ前の点 from ShortestPath&amp;lt;T&amp;gt; dijkstra(const Graph&amp;lt;T&amp;gt; &amp;amp;g, int s) グラフ g について始点 s からの最短経路を計算する.</description></item><item><title>強連結成分分解</title><link>https://anko9801.github.io/blog/graph/scc/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://anko9801.github.io/blog/graph/scc/</guid><description>説明 有向グラフにおいて、ある部分グラフが強連結であるとは部分グラフの任意の2点が互いに行き来可能であること。深さ優先探索の帰りがけ順(トポロジカルソート順)に逆グラフを探索したときそれらが通る点は強連結成分となる。
仕様 dag g の強連結成分を1つの頂点として見たグラフ. DAGとなる. comp 各頂点に強連結成分は同じ値となるように値を割り当てる. group 強連結成分の頂点のリスト. void build() dag, comp, group を計算する.</description></item><item><title>最大流 (Dinic)</title><link>https://anko9801.github.io/blog/graph/flow/dinic/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://anko9801.github.io/blog/graph/flow/dinic/</guid><description>説明 計算量 $O(V^2E)$
実装 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 #include &amp;lt;queue&amp;gt;#include &amp;lt;vector&amp;gt; struct Dinic { struct edge { long long to, cap, rev; }; long long n; std::vector&amp;lt;std::vector&amp;lt;edge&amp;gt;&amp;gt; G; std::vector&amp;lt;long long&amp;gt; level, iter; // level[i] = sからiへの最短距離(Dijkstra法) void bfs(long long s) { level.</description></item><item><title>最大流 (Ford Fulkerson)</title><link>https://anko9801.github.io/blog/graph/flow/ford_fulkerson/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://anko9801.github.io/blog/graph/flow/ford_fulkerson/</guid><description>説明 計算量 $O(FE)$
実装 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 #include &amp;lt;vector&amp;gt; class FordFulkerson { struct edge { long long to, cap, rev; }; const long long INF = 1 &amp;lt;&amp;lt; 60; long long n; std::vector&amp;lt;std::vector&amp;lt;edge&amp;gt;&amp;gt; G; std::vector&amp;lt;bool&amp;gt; used; long long dfs(long long s, long long t, long long f) { if (s == t) return f; used[s] = true; for (edge &amp;amp;e : G[s]) { if (!</description></item><item><title>木の直径</title><link>https://anko9801.github.io/blog/graph/tree/diameter/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://anko9801.github.io/blog/graph/tree/diameter/</guid><description>説明 木の直径とはある2点間が最大となる距離である。
どの頂点から始めても、そこから最も遠い頂点は直径の端点の1つになる。端点から最も遠い頂点はもう1つの端点になる。その2点の距離が木の直径となる。
計算量 $O(V + E)$
実装 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 #include &amp;lt;vector&amp;gt; template &amp;lt;typename T&amp;gt; struct Edge { int to; T cost; }; using Graph = std::vector&amp;lt;std::vector&amp;lt;Edge&amp;lt;long long&amp;gt;&amp;gt;&amp;gt;; template &amp;lt;typename T&amp;gt; std::pair&amp;lt;T, int&amp;gt; dfs(const Graph &amp;amp;G, int u, int par) { auto ret = {0, u}; for (auto &amp;amp;e : G) { if (e.</description></item></channel></rss>