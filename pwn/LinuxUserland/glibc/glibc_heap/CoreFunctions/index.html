<!doctype html><html lang=en><head><meta charset=utf-8><meta name=description content="void * _int_malloc (mstate av, size_t bytes)   Updates bytes to take care of alignments, etc.
  Checks if av is NULL or not."><title>Core Functions</title><meta name=viewport content="width=device-width,initial-scale=1"><link rel="shortcut icon" type=image/png href=https://anko9801.github.io/blog//icon.png><link href=https://anko9801.github.io/blog/styles.708c2658f93e3a9d323a1f9fded8f4b2.min.css rel=stylesheet><link href=https://anko9801.github.io/blog/styles/_light_syntax.86a48a52faebeaaf42158b72922b1c90.min.css rel=stylesheet id=theme-link><script src=https://anko9801.github.io/blog/js/darkmode.5777cdbea4ccb2b68cacc7e904cabb5c.min.js></script>
<script src=https://anko9801.github.io/blog/js/util.9825137f5e7825e8553c68ce39ac9e44.min.js></script>
<link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/katex.min.css integrity=sha384-R4558gYOUz8mP9YWpZJjofhk+zx0AS11p36HnD2ZKj/6JR5z27gSSULCNHIRReVs crossorigin=anonymous><script defer src=https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/katex.min.js integrity=sha384-z1fJDqw8ZApjGO3/unPWUPsIymfsJmyrDVWC8Tv/a1HeOtGmkwNd/7xUS0Xcnvsx crossorigin=anonymous></script>
<script defer src=https://cdn.jsdelivr.net/npm/katex@0.15.1/dist/contrib/auto-render.min.js integrity=sha384-+XBljXPPiv+OzfbB3cVmLHf4hdUFHlWNZN5spNQ7rmHTXpd7WvJum6fIACpNNfIR crossorigin=anonymous></script>
<script defer src=https://cdn.jsdelivr.net/npm/katex@0.16.2/dist/contrib/copy-tex.min.js integrity=sha384-ww/583aHhxWkz5DEVn6OKtNiIaLi2iBRNZXfJRiY1Ai7tnJ9UXpEsyvOITVpTl4A crossorigin=anonymous></script>
<script src=https://unpkg.com/@floating-ui/core@0.7.3></script>
<script src=https://unpkg.com/@floating-ui/dom@0.5.4></script>
<script src=https://anko9801.github.io/blog/js/popover.9b72b70bd35617d0635e9d15463662b2.min.js></script>
<script src=https://anko9801.github.io/blog/js/code-title.b35124ad8db0ba37162b886afb711cbc.min.js></script>
<script src=https://anko9801.github.io/blog/js/clipboard.c20857734e53a3fb733b7443879efa61.min.js></script>
<script src=https://anko9801.github.io/blog/js/callouts.7723cac461d613d118ee8bb8216b9838.min.js></script>
<script>const BASE_URL="https://anko9801.github.io/blog/",fetchData=Promise.all([fetch("https://anko9801.github.io/blog/indices/linkIndex.9eb8c3393707fa458fa0411e31d900bd.min.json").then(e=>e.json()).then(e=>({index:e.index,links:e.links})),fetch("https://anko9801.github.io/blog/indices/contentIndex.379638ac4bcdc384be519e7692c0cf32.min.json").then(e=>e.json())]).then(([{index:e,links:t},n])=>({index:e,links:t,content:n})),render=()=>{const e=new URL(BASE_URL),t=e.pathname,n=window.location.pathname,s=t==n;addCopyButtons(),addTitleToCodeBlocks(),addCollapsibleCallouts(),initPopover("https://anko9801.github.io/blog",!0,!0);const o=document.getElementById("footer");if(o){const e=document.getElementById("graph-container");if(!e)return requestAnimationFrame(render);e.textContent="";const t=s&&!1;drawGraph("https://anko9801.github.io/blog",t,[{"/moc":"#4388cc"}],t?{centerForce:1,depth:-1,enableDrag:!0,enableLegend:!1,enableZoom:!0,fontSize:.5,linkDistance:1,opacityScale:3,repelForce:1,scale:1.4}:{centerForce:1,depth:1,enableDrag:!0,enableLegend:!1,enableZoom:!0,fontSize:.6,linkDistance:1,opacityScale:3,repelForce:2,scale:1.2})}},init=(e=document)=>{addCopyButtons(),addTitleToCodeBlocks(),renderMathInElement(e.body,{delimiters:[{left:"$$",right:"$$",display:!0},{left:"$",right:"$",display:!1}],macros:{'‚Äô':"'"},throwOnError:!1})}</script><script type=module>
    import { attachSPARouting } from "https:\/\/anko9801.github.io\/blog\/js\/router.9d4974281069e9ebb189f642ae1e3ca2.min.js"
    attachSPARouting(init, render)
  </script></head><script async src="https://www.googletagmanager.com/gtag/js?id=G-XYFD95KB4J"></script>
<script>var doNotTrack=!1;if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-XYFD95KB4J",{anonymize_ip:!1})}</script><body><div id=search-container><div id=search-space><input autocomplete=off id=search-bar name=search type=text aria-label=Search placeholder="Search for something..."><div id=results-container></div></div></div><script defer src=https://anko9801.github.io/blog/js/semantic-search.2c776550faf6cf14399b47e62a8e9782.min.js></script><div class=singlePage><header><h1 id=page-title><a href=https://anko9801.github.io/blog/>ü™¥ „ÅÇ„ÇÑ„ÇÅHex</a></h1><div class=spacer></div><div id=search-icon><p>Search</p><svg tabindex="0" aria-labelledby="title desc" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 19.9 19.7"><title id="title">Search Icon</title><desc id="desc">Icon to open search</desc><g class="search-path" fill="none"><path stroke-linecap="square" d="M18.5 18.3l-5.4-5.4"/><circle cx="8" cy="8" r="7"/></g></svg></div><div class=darkmode><input class=toggle id=darkmode-toggle type=checkbox tabindex=-1>
<label id=toggle-label-light for=darkmode-toggle tabindex=-1><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" id="dayIcon" viewBox="0 0 35 35" style="enable-background:new 0 0 35 35"><title>Light Mode</title><path d="M6 17.5C6 16.672 5.328 16 4.5 16h-3C.672 16 0 16.672.0 17.5S.672 19 1.5 19h3C5.328 19 6 18.328 6 17.5zM7.5 26c-.414.0-.789.168-1.061.439l-2 2C4.168 28.711 4 29.086 4 29.5 4 30.328 4.671 31 5.5 31c.414.0.789-.168 1.06-.44l2-2C8.832 28.289 9 27.914 9 27.5 9 26.672 8.329 26 7.5 26zm10-20C18.329 6 19 5.328 19 4.5v-3C19 .672 18.329.0 17.5.0S16 .672 16 1.5v3C16 5.328 16.671 6 17.5 6zm10 3c.414.0.789-.168 1.06-.439l2-2C30.832 6.289 31 5.914 31 5.5 31 4.672 30.329 4 29.5 4c-.414.0-.789.168-1.061.44l-2 2C26.168 6.711 26 7.086 26 7.5 26 8.328 26.671 9 27.5 9zM6.439 8.561C6.711 8.832 7.086 9 7.5 9 8.328 9 9 8.328 9 7.5c0-.414-.168-.789-.439-1.061l-2-2C6.289 4.168 5.914 4 5.5 4 4.672 4 4 4.672 4 5.5c0 .414.168.789.439 1.06l2 2.001zM33.5 16h-3c-.828.0-1.5.672-1.5 1.5s.672 1.5 1.5 1.5h3c.828.0 1.5-.672 1.5-1.5S34.328 16 33.5 16zM28.561 26.439C28.289 26.168 27.914 26 27.5 26c-.828.0-1.5.672-1.5 1.5.0.414.168.789.439 1.06l2 2C28.711 30.832 29.086 31 29.5 31c.828.0 1.5-.672 1.5-1.5.0-.414-.168-.789-.439-1.061l-2-2zM17.5 29c-.829.0-1.5.672-1.5 1.5v3c0 .828.671 1.5 1.5 1.5s1.5-.672 1.5-1.5v-3C19 29.672 18.329 29 17.5 29zm0-22C11.71 7 7 11.71 7 17.5S11.71 28 17.5 28 28 23.29 28 17.5 23.29 7 17.5 7zm0 18c-4.136.0-7.5-3.364-7.5-7.5s3.364-7.5 7.5-7.5 7.5 3.364 7.5 7.5S21.636 25 17.5 25z"/></svg></label><label id=toggle-label-dark for=darkmode-toggle tabindex=-1><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" id="nightIcon" viewBox="0 0 100 100" style="enable-background='new 0 0 100 100'"><title>Dark Mode</title><path d="M96.76 66.458c-.853-.852-2.15-1.064-3.23-.534-6.063 2.991-12.858 4.571-19.655 4.571C62.022 70.495 50.88 65.88 42.5 57.5 29.043 44.043 25.658 23.536 34.076 6.47c.532-1.08.318-2.379-.534-3.23-.851-.852-2.15-1.064-3.23-.534-4.918 2.427-9.375 5.619-13.246 9.491-9.447 9.447-14.65 22.008-14.65 35.369.0 13.36 5.203 25.921 14.65 35.368s22.008 14.65 35.368 14.65c13.361.0 25.921-5.203 35.369-14.65 3.872-3.871 7.064-8.328 9.491-13.246C97.826 68.608 97.611 67.309 96.76 66.458z"/></svg></label></div></header><article><h1>Core Functions</h1><p class=meta>Last updated
Nov 19, 2022
<a href=https://github.com/anko9801/blog/tree/hugo/content/pwn/LinuxUserland/glibc/glibc_heap/CoreFunctions.md rel=noopener>Edit Source</a></p><ul class=tags></ul><aside class=mainTOC><details><summary>Table of Contents</summary><nav id=TableOfContents><ol><li><a href=#void--_int_malloc-mstate-av-size_t-bytes><code>void * _int_malloc (mstate av, size_t bytes)</code></a></li><li><a href=#__libc_malloc-size_t-bytes><code>__libc_malloc (size_t bytes)</code></a></li><li><a href=#_int_free-mstate-av-mchunkptr-p-int-have_lock><code>_int_free (mstate av, mchunkptr p, int have_lock)</code></a></li><li><a href=#__libc_free-void-mem><code>__libc_free (void *mem)</code></a></li></ol></nav></details></aside><a href=#void--_int_malloc-mstate-av-size_t-bytes><h2 id=void--_int_malloc-mstate-av-size_t-bytes><span class=hanchor arialabel=Anchor># </span><code>void * _int_malloc (mstate av, size_t bytes)</code></h2></a><ol><li><p>Updates <code>bytes</code> to take care of alignments, etc.</p></li><li><p>Checks if <code>av</code> is NULL or not.</p></li><li><p>In the case of absence of usable arena (when <code>av</code> is NULL), calls <code>sysmalloc</code> to obtain chunk using mmap. If successful, calls <code>alloc_perturb</code>. Returns the pointer.</p></li><li><ul><li><p>If size falls in the fastbin range:</p><ol><li>Get index into the fastbin array to access an appropriate bin according to the request size.</li><li>Removes the first chunk in that bin and make <code>victim</code> point to it.</li><li>If <code>victim</code> is NULL, move on to the next case (smallbin).</li><li>If <code>victim</code> is not NULL, check the size of the chunk to ensure that it belongs to that particular bin. An error (&ldquo;malloc(): memory corruption (fast)&rdquo;) is thrown otherwise.</li><li>Calls <code>alloc_perturb</code> and then returns the pointer.</li></ol></li><li><p>If size falls in the smallbin range:</p><ol><li>Get index into the smallbin array to access an appropriate bin according to the request size.</li><li>If there are no chunks in this bin, move on to the next case. This is checked by comparing the pointers <code>bin</code> and <code>bin->bk</code>.</li><li><code>victim</code> is made equal to <code>bin->bk</code> (the last chunk in the bin). If it is NULL (happens during <code>initialization</code>), call <code>malloc_consolidate</code> and skip this complete step of checking into different bins.</li><li>Otherwise, when <code>victim</code> is non NULL, check if <code>victim->bk->fd</code> and <code>victim</code> are equal or not. If they are not equal, an error (&ldquo;malloc(): smallbin double linked list corrupted&rdquo;) is thrown.</li><li>Sets the PREV_INSUSE bit for the next chunk (in memory, not in the doubly linked list) for <code>victim</code>.</li><li>Remove this chunk from the bin list.</li><li>Set the appropriate arena bit for this chunk depending on <code>av</code>.</li><li>Calls <code>alloc_perturb</code> and then returns the pointer.</li></ol></li><li><p>If size does not fall in the smallbin range:</p><ol><li>Get index into the largebin array to access an appropriate bin according to the request size.</li><li>See if <code>av</code> has fastchunks or not. This is done by checking the <code>FASTCHUNKS_BIT</code> in <code>av->flags</code>. If so, call <code>malloc_consolidate</code> on <code>av</code>.</li></ol></li></ul></li><li><p>If no pointer has yet been returned, this signifies one or more of the following cases:</p></li><li><p>Size falls into &lsquo;fastbin&rsquo; range but no fastchunk is available.</p></li><li><p>Size falls into &lsquo;smallbin&rsquo; range but no smallchunk is available (calls <code>malloc_consolidate</code> during initialization).</p></li><li><p>Size falls into &rsquo;largbin&rsquo; range.</p></li><li><p>Next, unsorted chunks are checked and traversed chunks are placed into bins. This is the only place where chunks are placed into bins. Iterate the unsorted bin from the &lsquo;TAIL&rsquo;.</p></li><li><p><code>victim</code> points to the current chunk being considered.</p></li><li><p>Check if <code>victim</code>&rsquo;s chunk size is within minimum (<code>2*SIZE_SZ</code>) and maximum (<code>av->system_mem</code>) range. Throw an error (&ldquo;malloc(): memory corruption&rdquo;) otherwise.</p></li><li><p>If (size of requested chunk falls in smallbin range) and (<code>victim</code> is the last remainder chunk) and (it is the only chunk in the unsorted bin) and (the chunks size >= the one requested):
Break the chunk into 2 chunks:</p><ul><li>The first chunk matches the size requested and is returned.</li><li>Left over chunk becomes the new last remainder chunk. It is inserted back into the unsorted bin.<ol><li>Set <code>chunk_size</code> and <code>chunk_prev_size</code> fields appropriately for both chunks.</li><li>The first chunk is returned after calling <code>alloc_perturb</code>.</li></ol></li></ul></li><li><p>If the above condition is false, control reaches here. Remove <code>victim</code> from the unsorted bin. If the size of <code>victim</code> matches the size requested exactly, return this chunk after calling <code>alloc_perturb</code>.</p></li><li><p>If <code>victim</code>&rsquo;s size falls in smallbin range, add the chunk in the appropriate smallbin at the <code>HEAD</code>.</p></li><li><p>Else insert into appropriate largebin while maintaining sorted order:
* First checks the last chunk (smallest). If <code>victim</code> is smaller than the last chunk, insert it at the last.
* Otherwise, loop to find a chunk with size >= size of <code>victim</code>. If size is exactly same, always insert in the second position.</p></li><li><p>Repeat this whole step a maximum of <code>MAX_ITERS</code> (10000) times or till all chunks in unsorted bin get exhausted.</p></li><li><p>After checking unsorted chunks, check if requested size does not fall in the smallbin range, if so then check largebins.</p></li><li><p>Get index into largebin array to access an appropriate bin according to the request size.</p></li><li><p>If the size of the largest chunk (the first chunk in the bin) is greater than the size requested:
1. Iterate from &lsquo;TAIL&rsquo; to find a chunk (<code>victim</code>) with the smallest size >= the requested size.
2. Call <code>unlink</code> to remove the <code>victim</code> chunk from the bin.
3. Calculate <code>remainder_size</code> for the <code>victim</code>&rsquo;s chunk (this will be <code>victim</code>&rsquo;s chunk size - requested size).
4. If this <code>remainder_size</code> >= <code>MINSIZE</code> (the minimum chunk size including the headers), split the chunk into two chunks. Otherwise, the entire <code>victim</code> chunk will be returned. Insert the remainder chunk in the unsorted bin (at the &lsquo;TAIL&rsquo; end). A check is made in unsorted bin whether <code>unsorted_chunks(av)->fd->bk == unsorted_chunks(av)</code>. An error is thrown otherwise (&ldquo;malloc(): corrupted unsorted chunks&rdquo;).
5. Return the <code>victim</code> chunk after calling <code>alloc_perturb</code>.</p></li><li><p>Till now, we have checked unsorted bin and also the respective fast, small or large bin. Note that a single bin (fast or small) was checked using the <strong>exact</strong> size of the requested chunk. Repeat the following steps till all bins are exhausted:</p></li><li><p>The index into bin array is incremented to check the next bin.</p></li><li><p>Use <code>av->binmap</code> map to skip over bins that are empty.</p></li><li><p><code>victim</code> is pointed to the &lsquo;TAIL&rsquo; of the current bin.</p></li><li><p>Using the binmap ensures that if a bin is skipped (in the above 2nd step), it is definitely empty. However, it does not ensure that all empty bins will be skipped. Check if the victim is empty or not. If empty, again skip the bin and repeat the above process (or &lsquo;continue&rsquo; this loop) till we arrive at a nonempty bin.</p></li><li><p>Split the chunk (<code>victim</code> points to the last chunk of a nonempty bin) into two chunks. Insert the remainder chunk in unsorted bin (at the &lsquo;TAIL&rsquo; end). A check is made in the unsorted bin whether <code>unsorted_chunks(av)->fd->bk == unsorted_chunks(av)</code>. An error is thrown otherwise (&ldquo;malloc(): corrupted unsorted chunks 2&rdquo;).</p></li><li><p>Return the <code>victim</code> chunk after calling <code>alloc_perturb</code>.</p></li><li><p>If still no empty bin is found, &rsquo;top&rsquo; chunk will be used to service the request:</p></li><li><p><code>victim</code> points to <code>av->top</code>.</p></li><li><p>If size of &rsquo;top&rsquo; chunk >= &lsquo;requested size&rsquo; + <code>MINSIZE</code>, split it into two chunks. In this case, the remainder chunk becomes the new &rsquo;top&rsquo; chunk and the other chunk is returned to the user after calling <code>alloc_perturb</code>.</p></li><li><p>See if <code>av</code> has fastchunks or not. This is done by checking the <code>FASTCHUNKS_BIT</code> in <code>av->flags</code>. If so, call <code>malloc_consolidate</code> on <code>av</code>. Return to step 6 (where we check unsorted bin).</p></li><li><p>If <code>av</code> does not have fastchunks, call <code>sysmalloc</code> and return the pointer obtained after calling <code>alloc_perturb</code>.</p></li></ol><a href=#__libc_malloc-size_t-bytes><h2 id=__libc_malloc-size_t-bytes><span class=hanchor arialabel=Anchor># </span><code>__libc_malloc (size_t bytes)</code></h2></a><ol><li>Calls <code>arena_get</code> to get an <code>mstate</code> pointer.</li><li>Calls <code>_int_malloc</code> with the arena pointer and the size.</li><li>Unlocks the arena.</li><li>Before returning the pointer to the chunk, one of the following should be true:<ul><li>Returned pointer is NULL</li><li>Chunk is MMAPPED</li><li>Arena for chunk is the same as the one found in 1.</li></ul></li></ol><a href=#_int_free-mstate-av-mchunkptr-p-int-have_lock><h2 id=_int_free-mstate-av-mchunkptr-p-int-have_lock><span class=hanchor arialabel=Anchor># </span><code>_int_free (mstate av, mchunkptr p, int have_lock)</code></h2></a><ol><li>Check whether <code>p</code> is before <code>p + chunksize(p)</code> in the memory (to avoid wrapping). An error (&ldquo;free(): invalid pointer&rdquo;) is thrown otherwise.</li><li>Check whether the chunk is at least of size <code>MINSIZE</code> or a multiple of <code>MALLOC_ALIGNMENT</code>. An error (&ldquo;free(): invalid size&rdquo;) is thrown otherwise.</li><li>If the chunk&rsquo;s size falls in fastbin list:<ol><li>Check if next chunk&rsquo;s size is between minimum and maximum size (<code>av->system_mem</code>), throw an error (&ldquo;free(): invalid next size (fast)&rdquo;) otherwise.</li><li>Calls <code>free_perturb</code> on the chunk.</li><li>Set <code>FASTCHUNKS_BIT</code> for <code>av</code>.</li><li>Get index into fastbin array according to chunk size.</li><li>Check if the top of the bin is not the chunk we are going to add. Otherwise, throw an error (&ldquo;double free or corruption (fasttop)&rdquo;).</li><li>Check if the size of the fastbin chunk at the top is the same as the chunk we are adding. Otherwise, throw an error (&ldquo;invalid fastbin entry (free)&rdquo;).</li><li>Insert the chunk at the top of the fastbin list and return.</li></ol></li><li>If the chunk is not mmapped:<ol><li>Check if the chunk is the top chunk or not. If yes, an error (&ldquo;double free or corruption (top)&rdquo;) is thrown.</li><li>Check whether next chunk (by memory) is within the boundaries of the arena. If not, an error (&ldquo;double free or corruption (out)&rdquo;) is thrown.</li><li>Check whether next chunk&rsquo;s (by memory) previous in use bit is marked or not. If not, an error (&ldquo;double free or corruption (!prev)&rdquo;) is thrown.</li><li>Check whether the size of next chunk is between the minimum and maximum size (<code>av->system_mem</code>). If not, an error (&ldquo;free(): invalid next size (normal)&rdquo;) is thrown.</li><li>Call <code>free_perturb</code> on the chunk.</li><li>If previous chunk (by memory) is not in use, call <code>unlink</code> on the previous chunk.</li><li>If next chunk (by memory) is not top chunk:<ol><li>If next chunk is not in use, call <code>unlink</code> on the next chunk.</li><li>Merge the chunk with previous, next (by memory), if any is free and add it to the head of unsorted bin. Before inserting, check whether <code>unsorted_chunks(av)->fd->bk == unsorted_chunks(av)</code> or not. If not, an error (&ldquo;free(): corrupted unsorted chunks&rdquo;) is thrown.</li></ol></li><li>If next chunk (by memory) was a top chunk, merge the chunks appropriately into a single top chunk.</li></ol></li><li>If the chunk was mmapped, call <code>munmap_chunk</code>.</li></ol><a href=#__libc_free-void-mem><h2 id=__libc_free-void-mem><span class=hanchor arialabel=Anchor># </span><code>__libc_free (void *mem)</code></h2></a><ol><li>Return if <code>mem</code> is NULL.</li><li>If the corresponding chunk is mmapped, call <code>munmap_chunk</code> if the dynamic brk/mmap threshold needs adjusting.</li><li>Get arena pointer for that corresponding chunk.</li><li>Call <code>_int_free</code>.</li></ol></article><hr><div class=page-end id=footer><div class=backlinks-container><h3>Backlinks</h3><ul class=backlinks><li>No backlinks found</li></ul></div><div><script src=https://cdn.jsdelivr.net/npm/d3@6.7.0/dist/d3.min.js integrity="sha256-+7jaYCp29O1JusNWHaYtgUn6EhuP0VaFuswhNV06MyI=" crossorigin=anonymous></script><h3>Interactive Graph</h3><div id=graph-container></div><style>:root{--g-node:var(--secondary);--g-node-active:var(--primary);--g-node-inactive:var(--visited);--g-link:var(--outlinegray);--g-link-active:#5a7282}</style><script src=https://anko9801.github.io/blog/js/graph.abd4bc2af3869a96524d7d23b76152c7.js></script></div></div><div id=contact_buttons><footer><p>Made by Jacky Zhao using <a href=https://github.com/jackyzha0/quartz>Quartz</a>, ¬© 2022</p><ul><li><a href=https://anko9801.github.io/blog/>Home</a></li><li><a href=https://twitter.com/Anko_9801>Twitter</a></li><li><a href=https://github.com/anko9801>Github</a></li></ul></footer></div></div></body></html>