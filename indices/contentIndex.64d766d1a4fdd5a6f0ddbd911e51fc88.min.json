{"/":{"title":"🪴 あやめHex","content":"\n# ayame library\n\n# これはなに？\n\nCTF のライブラリ/知識集らしいです。(現在は LYT に近い思想で書いてる)\n\n競プロはライブラリ化されたものがよく出回ってるけど、CTF の方はほとんど閉じた場所でしか共有されてないよな～と思ったのであんこ(将来的に traP の CTF 班)が CTF に関するライブラリや CTF に必要な知識をまとめたものです。編集したい方は大歓迎です！気軽にプルリク投げてください～\n\nこれらは CC0 ライセンスとします。自由にコピペして OK です！\n\n## 競プロ\n\n- [テンプレート](./other/template.md)\n\n## データ構造\n\n- [UnionFind](./data_structure/unionfind/unionfind.md)\n  - [ポテンシャル付きUnionFind](./data_structure/unionfind/potential_unionfind.md)\n  - [永続UnionFind](./data_structure/unionfind/persist_unionfind.md)\n- [BIT (Binary-Indexed-Tree) / Fenwick Tree](./data_structure/bit/bit.md)\n- [セグメント木](./data_structure/segtree/segtree.md)\n  - [遅延セグメント木](./data_structure/segtree/lazysegtree.md)\n  - [Segment Tree Beats](./data_structure/segtree/segtreebeats.md)\n- 平衡二分探索木\n  - 赤黒木\n  - AVL木\n  - Splay木\n  - Treap\n- Wavelet Matrix\n- 座標圧縮\n- スライド最小値\n- [slope trick](./data_structure/slope_trick.md)\n\n## グラフ\n\n- 最短路\n  - [単一始点最短路 $O(E\\log V)$ (Dijkstra)](./graph/shortest_path/dijkstra.md)\n  - [単一始点最短路 $O(EV)$ (Bellman-Ford)](./graph/shortest_path/bellman_ford.md)\n  - k-最短路\n  - [全点対間最短路 $O(V^3)$ (Floyd Warshall)](./graph/shortest_path/floyd_warshall.md)\n  - 全点対間最短路 $O((V + E)V\\log V)$ (Johnson)\n- 全域木\n  - 最小全域森 (Kruskal)\n  - 行列木定理\n- フロー\n  - [最大流 (Dinic)](./graph/flow/dinic.md)\n  - [最大流 (Ford Fulkerson)](./graph/flow/ford_fulkerson.md)\n- マッチング\n  - 二部グラフ判定\n  - 最大マッチング\n- ツリー\n  - [木の直径](./graph/tree/diameter.md)\n  - 最小共通祖先\n- Functional Graph\n- 最大クリーク\n- [強連結成分分解](./graph/scc.md)\n\n## 算数\n\n- bit trick\n  - XOR swap\n- 整数\n  - [Euclid の互除法](./arithmetic/gcd.md)\n  - [数論的関数/進数変換](./arithmetic/arithmetical_function)\n  - 素数\n    - [素因数分解](./arithmetic/primes/factorize.md)\n    - [高速素因数分解 (Pollard-$\\rho$法/Millar-Rabin)](./arithmetic/primes/fast_factorize.md)\n    - [素数列挙 (エラトステネスの篩)](./arithmetic/primes/primes.md)\n    - 素数判定\n  - 剰余\n    - [Modint](./arithmetic/modulo/modint.md)\n    - [任意Modint](./arithmetic/modulo/arbitrary_modint.md)\n  - [中国剰余定理](./arithmetic/crt.md)\n  - floor sum\n- [行列](./arithmetic/matrix/matrix.md)\n- [高速ゼータ変換/高速メビウス変換](./arithmetic/zeta.md)\n- [高速フーリエ変換(FFT)](./arithmetic/fft.md)\n- [数論変換(NTT)](./arithmetic/ntt.md)\n- 多項式GCD\n- 形式的冪級数\n- 任意mod畳み込み\n\n## 幾何\n\n- [幾何ライブラリ](./geometry/geometry.md)\n- 偏角ソート\n\n## 文字列\n\n- Z algorithm\n- Rabin-Karp 法\n- 最長増加部分列\n- ローリングハッシュ\n- Boyer-Moore\n- LL(1) parser\n\n## ヒューリスティック\n\n- [山登り法](./heuristic/hill_climbing.md)\n- [焼きなまし法](./heuristic/simulated_annealing.md)\n- [ビームサーチ](./heuristic/beam_search.md)\n- [chokudai サーチ](./heuristic/chokudai_search.md)\n\n## Pwn\n\n使用言語はPythonまたはC言語です。\n\n- Linux Userland\n  - [テンプレート](pwn/template.md)\n  - Format String Attack\n  - Stack Exploit\n    - ret2xxx\n      - ret2libc\n    - ROP: Return Oriented Programming\n  - GOT overwrite\n  - [glibc](./pwn/glibc/glibc.md)\n    - [malloc](./pwn/glibc/malloc.md)\n    - セキュリティ機構\n  - Heap Exploit\n    - Use after Free\n      - tcache poisoning\n    - fastbin attack\n    - overlapping chunks\n    - mmap overlapping chunks\n    - House of XXX\n      - [House of Orange](./pwn/HouseOfXXX/house_of_orange.md)\n      - [House of botcake](./pwn/HouseOfXXX/House_of_botcake.md)\n      - House of Spirit\n      - House of Lore\n      - House of Storm\n      - House of Force\n- Linux Kernel\n  - [テンプレート](./pwn/kernel_exploit.md)\n  - Kernel Code Reading\n    - セキュリティ機構\n  - カーネルモジュール\n  - Heap Spray\n  - Dirty Pipe\n  - Race Condition\n- Windows Userland\n- Windows Kernel\n- VM Escape\n  - Container Escape\n- [Automatic Exploit Generation](./pwn/AEG.md)\n\n## Crypto\n\n使用言語はPythonまたはSageMathです。それぞれの暗号自体を取り扱うのではなく、Cryptoの背景にある理論を取り扱っていきます。\n\n- 暗号構成基盤\n  - [Diffie-Hellman 鍵交換](./crypto/cryptography/Diffie-Hellman.md)\n  - [Fiat-Shamir 変換](./crypto/cryptography/Fiat-Shamir.md)\n    - [Schnorr 署名](./crypto/cryptography/Schnorr.md)\n    - [Frozen Heart](./crypto/cryptography/FrozenHeart.md)\n  - Lamport 署名\n  - [ゼロ知識証明](./crypto/cryptography/ZeroKnowledgeProof.md)\n  - [Fujisaki-Okamoto Transformation](./crypto/cryptography/Fujisaki-Okamoto_Transformation.md)\n  - [準同型暗号](./crypto/cryptography/homomorphism.md)\n- [SageMathチートシート](./crypto/sagemath.md)\n- [格子](./crypto/Lattice/tour_of_Lattice.md)\n  - [Gram-Schmidt](./crypto/Lattice/GSO.md)\n  - SVP (Shortest Vector Problem)\n    - [Lagrange 基底簡約 (Gauss 基底簡約)](./crypto/Lattice/Lagrange.md)\n    - [サイズ基底簡約](./crypto/Lattice/size_reduction.md)\n    - [LLL 基底簡約](./crypto/Lattice/LLL.md)\n    - BKZ 基底簡約 / HKZ 基底簡約\n    - Kannan’s embedding method\n  - CVP (Closest Vector Problem)\n    - Babai’s Algorithm\n  - Merkle-Hellmanナップサック暗号\n    - LO法\n    - CLOS法\n  - LWE (Learning with Errors) 暗号\n    - LWE\n      - BDD (Bounded Distance Decoding) Attack\n      - SIS (Short Integer Solution) Attack\n      - BKW Attack\n      - Arora-Ge Attack\n    - Ring-LWE\n    - Module-LWE\n      - CRYSTALS\n    - LWR\n  - [TFHE (Torus Fully Homomorphic Encryption)](./crypto/Lattice/TFHE.md)\n- 多項式\n  - [Coppersmith Method](./crypto/coppersmith.md)\n  - グレブナー基底\n  - 終結式\n  - MQ 問題\n  - Matsumoto-Imai 暗号 / HFE 暗号\n  - NTRU 暗号\n  - Rainbow 署名\n  - UOV 署名 / QR-UOV 署名\n- 数論\n  - ディオファントス方程式\n    - 二平方和\n    - ペル方程式\n  - [離散対数問題 (DLP)](./crypto/DLP/DLP.md)\n    - [Baby-step Giant-step](./crypto/DLP/BSGS.md)\n    - [Pollard's rho 法](./crypto/DLP/Pollard_rho.md)\n    - 指数計算法 (Index Calculus Algorithm)\n    - 数体ふるい法\n    - [Pohlig-Hellman](./crypto/DLP/Pohlig_Hellman.md)\n- [RSA暗号](./crypto/RSA/RSA.md)\n  - [Wiener's Attack](./crypto/RSA/WienersAttack.md)\n  - [Boneh-Durfee Attack](./crypto/RSA/Boneh-DurfeeAttack.md)\n  - [Common Modulus Attack](./crypto/RSA/CommonModulusAttack.md)\n  - [Håstad's Broadcast Attack](./crypto/RSA/HåstadsBroadcastAttack.md)\n  - [Small Common Private Exponent Attack](./crypto/RSA/SmallCommonPrivateExponentAttack.md)\n  - [適応的選択暗号文攻撃](./crypto/RSA/RSA-CCA.md)\n  - [LSB Decryption Oracle Attack](./crypto/RSA/LSB-DecryptionOracleAttack.md)\n  - [RSA-CRT Fault Attack](./crypto/RSA/RSA-CRT-FaultAttack.md)\n  - [Franklin-Reiter Related Message Attack](./crypto/RSA/Franklin-ReiterRelatedMessageAttack.md)\n  - [Partial Key Exposure Attack](./crypto/RSA/PartialKeyExposureAttack.md)\n  - [逆元が存在しないとき](./crypto/RSA/NoInverse.md)\n  - [ROCA Attack](./crypto/RSA/ROCA.md)\n- [楕円曲線暗号](./crypto/ECC/ECC.md)\n  - 楕円曲線\n    - Millar のアルゴリズム\n    - [Schoof のアルゴリズム](./crypto/ECC/Schoof.md)\n    - Tate pairing / Weil pairing\n    - [ECFFT](./crypto/ECC/ECFFT.md)\n    - 超楕円曲線\n  - 攻撃\n    - [Pohlig-Hellman Attack](./crypto/ECC/Pohlig-Hellman.md)\n    - [MOV/FR Reduction](./crypto/ECC/MOV-FR-Reduction.md)\n    - [SSSA Attack](./crypto/ECC/SSSA-Attack.md)\n    - [Invalid Curve Attack](./crypto/ECC/Invalid-Curve-Attack.md)\n    - [GHS Attack](./crypto/ECC/GHS-Attack.md)\n    - Dual EC DRBG\n    - [Attacks on SIKE](./crypto/ECC/SIKE.md)\n- [AES](./crypto/AES/AES.md)\n  - Padding Oracle Attack\n  - BEAST Attack\n  - Lucky Thirteen Attack\n  - POODLE Attack\n  - ghash\n  - Integral Cryptanalysis\n- [その他の暗号](./crypto/cryptography/other.md)\n- [Hash](./crypto/Hash/hash.md)\n  - 誕生日攻撃\n  - [Differencial cryptanalysis](./crypto/Hash/DifferencialCryptoanalysis.md)\n- 疑似乱数生成器 (PRNG)\n  - Xorshift\n  - [Mersenne twister](./crypto/PRNG/MersenneTwister.md)\n- ブロックチェーン\n  - Flash Loan Attack\n- [参考文献](./crypto/books.md)\n\n## Web\n\nWebに関してはよわよわなので読み込むと良いかもしれない資料リストを集めています。(これ読むといいよみたいなのがあったら教えてくださると助かります！)\n\n- [Prototype Pollution](./web/PrototypePollution.md)\n- [CTFにおけるWebセキュリティ入門とまとめ](https://blog.hamayanhamayan.com/entry/2021/12/01/194114)\n- 常設Web問\n  - [Web Security Academy](https://portswigger.net/web-security/all-labs)\n  - [KENRO](https://kenro.flatt.tech)\n  - [wargame.kr](http://wargame.kr)\n  - [XSS Game](https://xss-game.appspot.com)\n  - [The Lord of the SQLI](https://los.rubiya.kr)\n- [SQL Injection list](https://github.com/payloadbox/sql-injection-payload-list)\n\n## Misc\n\n- [Pyjail](./misc/Pyjail.md)\n- [Forensics](./misc/forensics/forensics.md)\n  - [Windows](./misc/forensics/windows.md)\n- [OSINT](./misc/osint/tools.md)\n\n## コンピュータ・アーキテクチャ\n\n- [数学](./science/math.md)\n- [物理](./science/phys.md)\n- 素子\n- アナログ回路\n- デジタル回路\n- [CPU / GPU](./other/Application/Processor.md)\n  - Spectre / Meltdown\n  - [TEE](./other/Circuit/TEE.md)\n  - [rootkit](./other/Circuit/Rootkit.md)\n- 論理\n- マイクロアーキテクチャ\n- アーキテクチャ\n- 仮想化技術\n  - [コンテナ仮想化技術](./other/Application/Container.md)\n  - [ハイパーバイザの作り方](https://syuu1228.github.io/howto_implement_hypervisor/)\n- [OS](./other/Application/OS.md)\n- サーバー\n  - [RDBMS](./other/Application/Server/RDBMS.md)\n  - [RDBMS 最適化](./other/Application/Server/rdbms-optimization.md)\n  - [リバースプロキシ](./other/Application/Server/reverse-proxy.md)\n  - [リバースプロキシ最適化](./other/Application/Server/reverse-proxy-optimization.md)\n  - [フロントエンド最適化](./other/Application/Server/frontend-optimization.md)\n- [ネットワーク構成](./other/Application/Network/network.md)\n  - [SDR](./other/Application/Network/SDR.md)\n\n## 量子アルゴリズム\n\n- 各ゲートの紹介と量子計算の方法\n- Shor のアルゴリズム\n- 量子暗号通信\n- 量子中継ネットワーク\n\n## 雑学\n\n- ピッキング\n- Tamper Evident\n- Social Engineering\n- Car Hacking\n- 航空技術\n- [プログラミング言語](./other/Application/Programming.md)\n  - [型推論](./other/Application/Type.md)\n  - 未定義動作\n- 電子回路\n  - SPI\n  - I2C\n  - UART\n  - JTAG\n- 構造探検隊\n  - [ELF](./other/Application/Structure/ZIP.md)\n  - JPEG\n  - [FAT32](./other/Application/Structure/FAT32.md)\n  - [ZIP](./other/Application/Structure/ZIP.md)\n- [デバッガ](./pwn/Debugger.md)\n- [SAT/SMT](./other/Application/SAT-SMT/SAT-SMT.md)\n  - [シンボリック実行エンジン](./other/Application/SAT-SMT/symbolic_execution.md)\n  - [定理証明支援系](./other/Application/SAT-SMT/proof_assistant.md)\n- [レンダリング](./other/Application/Rendering/Rendering.md)\n  - [レイトレーシング](./other/Application/Rendering/RayTracing.md)\n  - [シェーダー](./other/Application/Rendering/Shader.md)\n- [ブロックチェーン](other/Application/Blockchain.md)\n- [Deep Learning](./other/Application/DeepLearning.md)\n- [【画像処理入門】アルゴリズム＆プログラミング](https://algorithm.joho.info/programming/image-processing/)\n- 超解像\n\n## 脆弱性集\n\n- [CVEs for the Rust standard library](https://rustrepo.com/repo/Qwaz-rust-cve-rust-security-tools)\n  - [Rustのunsound hole issue #25860を理解する](https://speakerdeck.com/moratorium08/rustfalseunsound-hole-issue-number-25860woli-jie-suru)\n  - [str::repeat - stable wildcopy exploit](https://saaramar.github.io/str_repeat_exploit/)","lastmodified":"2022-10-26T11:26:57.35593449Z","tags":null},"/_index_old":{"title":"🪴 Quartz 3.","content":"\nHost your second brain and [digital garden](https://jzhao.xyz/posts/networked-thought) for free. Quartz features\n\n1. Extremely fast natural-language [[notes/search]]\n2. Customizable and hackable design based on [Hugo](https://gohugo.io/)\n3. Automatically generated backlinks, link previews, and local graph\n4. Built-in [[notes/CJK + Latex Support (测试) | CJK + Latex Support]] and [[notes/callouts | Admonition-style callouts]]\n5. Support for both Markdown Links and Wikilinks\n\nCheck out some of the [amazing gardens that community members](notes/showcase.md) have published with Quartz or read about [why I made Quartz](notes/philosophy.md) to begin with.\n\n## Get Started\n\u003e 📚 Step 1: [Setup your own digital garden using Quartz](notes/setup.md)\n\nReturning user? Figure out how to [[notes/updating|update]] your existing Quartz garden.\n\nIf you prefer browsing the contents of this site through a list instead of a graph, you see a list of all [setup-related notes](/tags/setup).\n\n### Troubleshooting\n- 🚧 [Troubleshooting and FAQ](notes/troubleshooting.md)\n- 🐛 [Submit an Issue](https://github.com/jackyzha0/quartz/issues)\n- 👀 [Discord Community](https://discord.gg/cRFFHYye7t)\n\n","lastmodified":"2022-10-26T11:26:57.35593449Z","tags":null},"/arithmetic/arithmetical_function":{"title":"数論的関数/進数変換","content":"\nオイラーの$\\phi$関数\nメビウスの$\\mu$関数\nカーマイケルの$\\lambda$関数","lastmodified":"2022-10-26T11:26:57.35593449Z","tags":null},"/arithmetic/crt":{"title":"中国剰余定理","content":"\n## 説明\n\nGarnerのアルゴリズム\n\n## 計算量\n\n$O(n^2 + n\\log(\\max p_i))$\n\n## 実装\n\n```cpp\n#include \u003cvector\u003e\n\n// x % m[i] = r[i] % m[i] を満たす正で最小の x を返す\n// mは互いに素であると仮定\n// とりあえず解の存在判定は保留\ntemplate \u003ctypename T\u003e\nT CRT(std::vector\u003cT\u003e r, std::vector\u003cT\u003e m) {\n  ll n = r.size();\n  ll m_prod = 1;\n  ll x = r[0] % m[0];\n  for (ll i = 1; i \u003c n; i++) {\n    m_prod *= m[i - 1];\n    ll t = ((r[i] - x) * invmod(m_prod, m[i])) % m[i];\n    if (t \u003c 0)\n      t += m[i];\n    x += t * m_prod;\n  }\n  return x;\n}\n```\n\n## 使用例\n","lastmodified":"2022-10-26T11:26:57.35593449Z","tags":null},"/arithmetic/fft":{"title":"高速フーリエ変換 (FFT)","content":"\n## 説明\n\n次の記事がわかりやすいです。\n\n[【競プロer向け】FFT を習得しよう！ | 東京工業大学デジタル創作同好会traP](https://trap.jp/post/1386/)\n\n## 計算量\n\n$O(N\\log{N})$\n\n## 実装\n\n```cpp\n#include \u003ccomplex\u003e\n#include \u003cvector\u003e\n\nusing namespace std;\nusing ll = long long;\nusing ld = long double;\nusing Complex = complex\u003cld\u003e;\nconst ld PI = 3.1415926535897932;\n\nvector\u003cComplex\u003e FFT(vector\u003cComplex\u003e \u0026A) {\n  const int N = A.size();\n  vector\u003cComplex\u003e even(N / 2), odd(N / 2);\n  for (int i = 0; i \u003c N / 2; i++) {\n    even[i] = A[2 * i];\n    odd[i] = A[2 * i + 1];\n  }\n  even = FFT(even);\n  odd = FFT(odd);\n  for (int i = 0; i \u003c N / 2; i++) {\n    odd[i] *= polar(1.0L, 2 * PI * i / N);\n    A[i] = even[i] + odd[i];\n    A[N / 2 + i] = even[i] - odd[i];\n  }\n  return A;\n}\n```\n\n## 使用例\n","lastmodified":"2022-10-26T11:26:57.35593449Z","tags":null},"/arithmetic/gcd":{"title":"最大公約数・最小公倍数","content":"\n## 説明\n\nユークリッドの互除法\n\n## 計算量\n\n$O(\\log{N})$\n\n## 実装\n\n```cpp\ntemplate \u003ctypename T\u003e\nT gcd(T a, T b) {\n  T r;\n  while (b \u003e 0) {\n    r = a % b;\n    a = b;\n    b = r;\n  }\n  return a;\n}\n\ntemplate \u003ctypename T\u003e\nT lcm(T a, T b) {\n  return a / gcd(a, b) * b;\n}\n\ntemplate \u003ctypename T\u003e\nT extgcd(T a, T b, T \u0026x, T \u0026y) {\n  T g = a;\n  x = 1;\n  y = 0;\n  if (b) {\n    g = extgcd(b, a % b, y, x);\n    y -= a / b * x;\n  }\n  return g;\n}\n```\n\n## 使用例","lastmodified":"2022-10-26T11:26:57.35593449Z","tags":null},"/arithmetic/matrix/matrix":{"title":"行列","content":"\n## 説明\n\n\n## 計算量\n\n\n## 実装\n\n```cpp\n#include \u003cbits/stdc++.h\u003e\n#include \u003cgcd.hpp\u003e\nusing namespace std;\n\nusing ll = long long;\nusing ull = uint_fast64_t;\nusing pll = pair\u003cll, ll\u003e;\nusing i64 = int_fast64_t;\nusing u64 = uint_fast64_t;\n\nconst ll MOD = 1e9 + 7;\nconst ll MODD = 998244353;\n\nll invmod(ll a, ll mod) {\n  ll x, y;\n  extgcd(a, mod, x, y);\n  x %= mod;\n  if (x \u003c 0)\n    x += mod;\n  return x;\n}\n\nconstexpr ll mx = 4;\nclass Matrix {\npublic:\n  using T = ll;\n  T m[mx][mx];\n  // コンストラクタ\n  constexpr Matrix() noexcept {}\n  // アクセス\n  const T *operator[](const ll i) const { return m[i]; } // read\n  T *operator[](const ll i) { return m[i]; }             // write\n  // 演算\n  inline constexpr Matrix \u0026operator+=(const Matrix \u0026x) noexcept {\n    for (ll i = 0; i \u003c mx; i++)\n      for (ll j = 0; j \u003c mx; j++)\n        m[i][j] += x[i][j];\n    return *this;\n  }\n  inline constexpr Matrix operator+(const Matrix x) const noexcept {\n    return Matrix(*this) += x;\n  }\n  inline constexpr Matrix \u0026operator-=(const Matrix \u0026x) noexcept {\n    for (ll i = 0; i \u003c mx; i++)\n      for (ll j = 0; j \u003c mx; j++)\n        m[i][j] -= x[i][j];\n    return *this;\n  }\n  inline constexpr Matrix operator-(const Matrix \u0026x) noexcept {\n    return Matrix(*this) -= x;\n  }\n  // O(N^3)\n  inline constexpr Matrix \u0026operator*=(Matrix \u0026x) noexcept {\n    *this = *this * x;\n    return *this;\n  }\n  inline constexpr Matrix operator*(Matrix \u0026x) {\n    Matrix c;\n    for (ll i = 0; i \u003c mx; i++)\n      for (ll j = 0; j \u003c mx; j++)\n        for (ll k = 0; k \u003c mx; k++) {\n          T a = m[i][j] * x[j][k];\n          c[i][k] += a;\n        }\n    return c;\n  }\n  // E^M O(N^3logM)\n  inline constexpr Matrix pow(ll b) const noexcept {\n    Matrix a = *this, c = E();\n    while (b) {\n      if (b \u0026 1)\n        c *= a;\n      if (b \u003e\u003e= 1)\n        a *= a;\n    }\n    return c;\n  }\n  inline constexpr Matrix static E() noexcept {\n    Matrix a;\n    for (ll i = 0; i \u003c mx; i++)\n      a[i][i] = 1;\n    return a;\n  }\n  inline constexpr bool operator==(const Matrix \u0026a) {\n    bool flg = true;\n    for (ll i = 0; i \u003c mx; i++)\n      for (ll j = 0; j \u003c mx; j++)\n        if (m[i][j] != a[i][j])\n          flg = false;\n    return flg;\n  }\n  // 行列とスカラの演算\n  inline constexpr Matrix \u0026operator+=(const T \u0026a) {\n    for (ll i = 0; i \u003c mx; i++)\n      for (ll j = 0; j \u003c mx; j++)\n        m[i][j] += a;\n    return *this;\n  }\n  inline constexpr Matrix \u0026operator-=(const T \u0026a) {\n    for (ll i = 0; i \u003c mx; i++)\n      for (ll j = 0; j \u003c mx; j++)\n        m[i][j] -= a;\n    return *this;\n  }\n  inline constexpr Matrix \u0026operator*=(const T \u0026a) {\n    for (ll i = 0; i \u003c mx; i++)\n      for (ll j = 0; j \u003c mx; j++)\n        m[i][j] *= a;\n    return *this;\n  }\n  inline constexpr Matrix \u0026operator/=(const T \u0026a) {\n    for (ll i = 0; i \u003c mx; i++)\n      for (ll j = 0; j \u003c mx; j++)\n        m[i][j] /= a;\n    return *this;\n  }\n  inline constexpr Matrix operator+(const T \u0026a) const {\n    return Matrix(*this) += a;\n  }\n  inline constexpr Matrix operator-(const T \u0026a) const {\n    return Matrix(*this) -= a;\n  }\n  inline constexpr Matrix operator*(const T \u0026a) const {\n    return Matrix(*this) *= a;\n  }\n  inline constexpr Matrix operator/(const T \u0026a) const {\n    return Matrix(*this) /= a;\n  }\n  // 転置行列\n  inline constexpr Matrix t() {\n    Matrix m2;\n    for (ll i = 0; i \u003c mx; i++)\n      for (ll j = 0; j \u003c mx; j++)\n        m2[i][j] = m[j][i];\n    return m2;\n  }\n\n  inline constexpr void show() {\n    for (ll i = 0; i \u003c mx; i++) {\n      for (ll j = 0; j \u003c mx; j++) {\n        if (j != 0)\n          cout \u003c\u003c \" \";\n        cout \u003c\u003c m[i][j];\n      }\n      cout \u003c\u003c endl;\n    }\n    return;\n  }\n};\n```\n```cpp\n\nusing D = double;\nconst D EPS = 1e-10;\n\n// matrix\ntemplate\u003cclass T\u003e struct Matrix {\n    vector\u003cvector\u003cT\u003e \u003e val;\n    Matrix(int n, int m, T x = 0) : val(n, vector\u003cT\u003e(m, x)) {}\n    void init(int n, int m, T x = 0) {val.assign(n, vector\u003cT\u003e(m, x));}\n    size_t size() const {return val.size();}\n    inline vector\u003cT\u003e\u0026 operator [] (int i) {return val[i];}\n};\n\ntemplate\u003cclass T\u003e int GaussJordan(Matrix\u003cT\u003e \u0026A, bool is_extended = false) {\n    int m = A.size(), n = A[0].size();\n    int rank = 0;\n    for (int col = 0; col \u003c n; ++col) {\n        // 拡大係数行列の場合は最後の列は掃き出ししない\n        if (is_extended \u0026\u0026 col == n-1) break;\n\n        // ピボットを探す\n        int pivot = -1;\n        T ma = EPS;\n        for (int row = rank; row \u003c m; ++row) {\n            if (abs(A[row][col]) \u003e ma) {\n                ma = abs(A[row][col]);\n                pivot = row;\n            }\n        }\n        // ピボットがなかったら次の列へ\n        if (pivot == -1) continue;\n\n        // まずは行を swap\n        swap(A[pivot], A[rank]);\n\n        // ピボットの値を 1 にする\n        auto fac = A[rank][col];\n        for (int col2 = 0; col2 \u003c n; ++col2) A[rank][col2] /= fac;\n\n        // ピボットのある列の値がすべて 0 になるように掃き出す\n        for (int row = 0; row \u003c m; ++row) {\n            if (row != rank \u0026\u0026 abs(A[row][col]) \u003e EPS) {\n                auto fac = A[row][col];\n                for (int col2 = 0; col2 \u003c n; ++col2) {\n                    A[row][col2] -= A[rank][col2] * fac;\n                }\n            }\n        }\n        ++rank;\n    }\n    return rank;\n}\n\nconst int MAX_ROW = 510; // to be set appropriately\nconst int MAX_COL = 510; // to be set appropriately\nstruct BitMatrix {\n    int H, W;\n    bitset\u003cMAX_COL\u003e val[MAX_ROW];\n    BitMatrix(int m = 1, int n = 1) : H(m), W(n) {}\n    inline bitset\u003cMAX_COL\u003e\u0026 operator [] (int i) {return val[i];}\n};\n\nint GaussJordan(BitMatrix \u0026A, bool is_extended = false) {\n    int rank = 0;\n    for (int col = 0; col \u003c A.W; ++col) {\n        if (is_extended \u0026\u0026 col == A.W - 1) break;\n        int pivot = -1;\n        for (int row = rank; row \u003c A.H; ++row) {\n            if (A[row][col]) {\n                pivot = row;\n                break;\n            }\n        }\n        if (pivot == -1) continue;\n        swap(A[pivot], A[rank]);\n        for (int row = 0; row \u003c A.H; ++row) {\n            if (row != rank \u0026\u0026 A[row][col]) A[row] ^= A[rank];\n        }\n        ++rank;\n    }\n    return rank;\n}\n\nint linear_equation(BitMatrix A, vector\u003cint\u003e b, vector\u003cint\u003e \u0026res) {\n    int m = A.H, n = A.W;\n    BitMatrix M(m, n + 1);\n    for (int i = 0; i \u003c m; ++i) {\n        for (int j = 0; j \u003c n; ++j) M[i][j] = A[i][j];\n        M[i][n] = b[i];\n    }\n    int rank = GaussJordan(M, true);\n\n    // check if it has no solution\n    for (int row = rank; row \u003c m; ++row) if (M[row][n]) return -1;\n\n    // answer\n    res.assign(n, 0);\n    for (int i = 0; i \u003c rank; ++i) res[i] = M[i][n];\n    return rank;\n}\n```\n\n## 使用例\n\n","lastmodified":"2022-10-26T11:26:57.35593449Z","tags":null},"/arithmetic/modulo/arbitrary_modint":{"title":"任意Modint","content":"\n## 説明\n\n## 計算量\n\n## 実装\n\n```cpp\n#include \u003ccstdint\u003e\n#include \u003cistream\u003e\n#include \u003cvector\u003e\n\nusing ll = long long;\n\nclass runtime_modint {\n  using u64 = std::uint_fast64_t;\n\n  static u64 \u0026mod() {\n    static u64 mod_ = 0;\n    return mod_;\n  }\n\npublic:\n  u64 a;\n\n  runtime_modint(const u64 x = 0) : a(x % get_mod()) {}\n  u64 \u0026value() noexcept { return a; }\n  const u64 \u0026value() const noexcept { return a; }\n  inline constexpr operator ll() const noexcept { return a; }\n  runtime_modint operator+(const runtime_modint rhs) const {\n    return runtime_modint(*this) += rhs;\n  }\n  runtime_modint operator-(const runtime_modint rhs) const {\n    return runtime_modint(*this) -= rhs;\n  }\n  runtime_modint operator*(const runtime_modint rhs) const {\n    return runtime_modint(*this) *= rhs;\n  }\n  runtime_modint operator/(const runtime_modint rhs) const {\n    return runtime_modint(*this) /= rhs;\n  }\n  runtime_modint \u0026operator+=(const runtime_modint rhs) {\n    a += rhs.a;\n    if (a \u003e= get_mod()) {\n      a -= get_mod();\n    }\n    return *this;\n  }\n  runtime_modint \u0026operator-=(const runtime_modint rhs) {\n    if (a \u003c rhs.a) {\n      a += get_mod();\n    }\n    a -= rhs.a;\n    return *this;\n  }\n  runtime_modint \u0026operator*=(const runtime_modint rhs) {\n    a = a * rhs.a % get_mod();\n    return *this;\n  }\n  runtime_modint \u0026operator/=(runtime_modint rhs) {\n    u64 exp = get_mod() - 2;\n    while (exp) {\n      if (exp % 2) {\n        *this *= rhs;\n      }\n      rhs *= rhs;\n      exp /= 2;\n    }\n    return *this;\n  }\n\n  template \u003cclass T\u003e inline constexpr runtime_modint \u0026operator+=(T x) noexcept {\n    return operator+=(runtime_modint(x));\n  }\n  template \u003cclass T\u003e inline constexpr runtime_modint \u0026operator+(T x) noexcept {\n    return runtime_modint(*this) += x;\n  }\n  template \u003cclass T\u003e inline constexpr runtime_modint \u0026operator-=(T x) noexcept {\n    return operator-=(runtime_modint(x));\n  }\n  template \u003cclass T\u003e inline constexpr runtime_modint \u0026operator-(T x) noexcept {\n    return runtime_modint(*this) -= x;\n  }\n  template \u003cclass T\u003e inline constexpr runtime_modint \u0026operator*=(T x) noexcept {\n    return operator*=(runtime_modint(x));\n  }\n  template \u003cclass T\u003e inline constexpr runtime_modint \u0026operator*(T x) noexcept {\n    return runtime_modint(*this) *= x;\n  }\n  template \u003cclass T\u003e inline constexpr runtime_modint \u0026operator/=(T x) noexcept {\n    return operator/=(runtime_modint(x));\n  }\n  template \u003cclass T\u003e inline constexpr runtime_modint \u0026operator/(T x) noexcept {\n    return runtime_modint(*this) /= x;\n  }\n\n  static void set_mod(const u64 x) { mod() = x; }\n  static u64 get_mod() { return mod(); }\n};\n\nll n, m;\nbool used[100000];\nstd::vector\u003cstd::pair\u003cll, runtime_modint\u003e\u003e G[100000];\n\nruntime_modint dfs(ll x) {\n  used[x] = true;\n  bool end = true;\n  runtime_modint res = 1;\n  for (auto \u0026p : G[x]) {\n    if (used[p.first] == true)\n      continue;\n    end = false;\n    if (p.second != 0) {\n      res *= p.second;\n    } else {\n      p.second = dfs(p.first);\n      // cout \u003c\u003c x MM p.fi MM p.se \u003c\u003c endl;\n      res *= p.second;\n    }\n  }\n  used[x] = false;\n  return res + 1;\n}\n```\n\n## 使用例\n\n## 関連項目\n- [Modint](./modint)","lastmodified":"2022-10-26T11:26:57.35593449Z","tags":null},"/arithmetic/modulo/modint":{"title":"Modint","content":"\n## 説明\n\n## 計算量\n\n## 実装\n\n```cpp\n#include \u003ccstdint\u003e\n#include \u003cistream\u003e\n#include \u003ctype_traits\u003e\n#include \u003cvector\u003e\n\nusing ll = long long;\nusing u64 = std::uint_fast64_t;\n\nconst ll MOD = 1000000007;\nconst ll MODD = 998244353;\n\nconstexpr u64 Modulus = MOD;\nclass Modint {\npublic:\n\tu64 num = 0;\n\tconstexpr Modint() noexcept {}\n\tconstexpr Modint(const u64 x) noexcept : num(x % Modulus) {}\n\tinline constexpr operator ll() const noexcept { return num; }\n\tinline constexpr Modint \u0026operator+=(const Modint rhs) noexcept { num += rhs.num; if (num \u003e= Modulus) num -= Modulus; return *this; }\n\tinline constexpr Modint operator+(const Modint rhs) const noexcept { return Modint(*this) += rhs; }\n\tinline constexpr Modint \u0026operator-=(const Modint rhs) noexcept { if (num \u003c rhs.num) num += Modulus; num -= rhs.num; return *this; }\n\tinline constexpr Modint operator-(const Modint rhs) const noexcept { return Modint(*this) -= rhs; }\n\tinline constexpr Modint \u0026operator*=(const Modint rhs) noexcept { num = num * rhs.num % Modulus; return *this; }\n\tinline constexpr Modint operator*(const Modint rhs) const noexcept { return Modint(*this) *= rhs; }\n\tinline constexpr Modint \u0026operator/=(const Modint rhs) noexcept { return operator*=(rhs.inv()); }\n\tconstexpr Modint operator/(const Modint rhs) const noexcept { return Modint(*this) /= rhs; }\n\tinline constexpr Modint\u0026 operator++() noexcept { if (num == Modulus - 1) num = 0; else num++; return *this; }\n\tinline constexpr Modint operator++(int) noexcept { Modint ans(*this); operator++(); return ans; }\n\tinline constexpr Modint\u0026 operator--() noexcept { if (num == 0) num = Modulus - 1; else num--; return *this; }\n\tinline constexpr Modint operator--(int) noexcept { Modint ans(*this); operator--(); return ans; }\n\tinline constexpr Modint operator-() noexcept { return Modint(0) -= *this; }\n\ttemplate\u003cclass T\u003e inline constexpr Modint \u0026operator+=(T x) noexcept { return operator+=(Modint(x)); }\n\ttemplate\u003cclass T\u003e inline constexpr Modint \u0026operator+(T x) noexcept { return Modint(*this) += x; }\n\ttemplate\u003cclass T\u003e inline constexpr Modint \u0026operator-=(T x) noexcept { return operator-=(Modint(x)); }\n\ttemplate\u003cclass T\u003e inline constexpr Modint \u0026operator-(T x) noexcept { return Modint(*this) -= x; }\n\ttemplate\u003cclass T\u003e inline constexpr Modint \u0026operator*=(T x) noexcept { return operator*=(Modint(x)); }\n\ttemplate\u003cclass T\u003e inline constexpr Modint \u0026operator*(T x) noexcept { return Modint(*this) *= x; }\n\ttemplate\u003cclass T\u003e inline constexpr Modint \u0026operator/=(T x) noexcept { return operator/=(Modint(x)); }\n\ttemplate\u003cclass T\u003e inline constexpr Modint \u0026operator/(T x) noexcept { return Modint(*this) /= x; }\n\tinline constexpr Modint inv() const noexcept { ll x = 0, y = 0; extgcd(num, Modulus, x, y); return x; }\n\tstatic inline constexpr ll extgcd(ll a, ll b, ll \u0026x, ll \u0026y) noexcept { ll g = a; x = 1; y = 0; if(b){ g = extgcd(b, a % b, y, x); y -= a / b * x; } return g; }\n\tinline constexpr Modint pow(u64 x) const noexcept { Modint ans = 1, cnt = *this; while(x){ if(x \u0026 1) ans *= cnt; cnt *= cnt; x /= 2; } return ans; }\n\ttemplate\u003cclass T\u003e constexpr Modint(T x) noexcept {\n\t\tusing U = typename std::conditional\u003csizeof(T) \u003e= 4, T, int\u003e::type;\n\t\tU y = x; y %= U(Modulus); if(y \u003c 0) y += Modulus; num = uint(y);\n\t}\n};\nstd::istream\u0026 operator\u003e\u003e(std::istream\u0026 is, Modint\u0026 x){ ll a; is \u003e\u003e a; x = a; return is; }\n// inline constexpr Modint operator\"\"_M(ull x) noexcept { return Modint(x); }\nstd::vector\u003cModint\u003e fac(1, 1), inv(1, 1);\ninline void reserve(ll a){\n\tif(fac.size() \u003e= a) return;\n\tif(a \u003c fac.size() * 2) a = fac.size() * 2;\n\tif(a \u003e= Modulus) a = Modulus;\n\twhile(fac.size() \u003c a) fac.push_back(fac.back() * Modint(fac.size()));\n\tinv.resize(fac.size());\n\tinv.back() = fac.back().inv();\n\tfor(ll i = inv.size() - 1; !inv[i - 1]; i--) inv[i - 1] = inv[i] * i;\n}\ninline Modint fact(ll n){ if(n \u003c 0) return 0; reserve(n + 1); return fac[n]; }\ninline Modint perm(ll n, ll r){\n\tif(r \u003c 0 || n \u003c r) return 0;\n\tif(n \u003e\u003e 24){ Modint ans = 1; for(ll i = 0; i \u003c r; i++) ans *= n--; return ans; }\n\treserve(n + 1); return fac[n] * inv[n - r];\n}\n// 階乗やその逆元をメモ化すると速い\n// modを取りたくないならnCk/2^Nをパスカルの三角形で作る\ninline Modint comb(ll n, ll r){ if(r \u003c 0 || n \u003c r) return 0; reserve(r + 1); return perm(n, r) * inv[r]; }\ninline Modint Mcomb(ll n, ll r){ return comb(n + r - 1, n - 1); } // r balls into n boxes\ninline Modint catalan(ll n){ reserve(n * 2 + 1); return fac[n * 2] * inv[n] * inv[n + 1]; }\n```\n\n## 使用例\n\n[ABC262 D - I Hate Non-integer Number](https://atcoder.jp/contests/abc262/submissions/33693576)\n\n## 関連項目\n- [任意Modint](./arbitrary_modint)","lastmodified":"2022-10-26T11:26:57.35593449Z","tags":null},"/arithmetic/ntt":{"title":"数論変換","content":"\n## 説明\n\n複素数上のFFTを有限体上に取り替えたのがNTT。乗法群の位数が大きな2のべき乗を持っていると精度を落とさずに計算できて嬉しい。\n\n## 計算量\n\n$O(N\\log{N})$\n\n## 実装\n\n\n## 使用例\n","lastmodified":"2022-10-26T11:26:57.35593449Z","tags":null},"/arithmetic/primes/factorize":{"title":"素因数分解","content":"\n## 説明\n\n\n## 計算量\n\n\n## 実装\n\n```cpp\n#include \u003cvector\u003e\n\ntemplate \u003ctypename T\u003e\nstd::vector\u003cstd::pair\u003cT, int\u003e\u003e factors(T N) {\n  std::vector\u003cstd::pair\u003cT, int\u003e\u003e res;\n  for (T a = 2; a * a \u003c= N; ++a) {\n    if (N % a != 0)\n      continue;\n    int e = 0;\n    while (N % a == 0) {\n      ++e;\n      N /= a;\n    }\n    res.push_back({a, e});\n  }\n  if (N != 1)\n    res.push_back({N, 1});\n  return res;\n}\n```\n\n## 使用例\n\n\n## 関連項目\n- [高速素因数分解 (Pollard-ρ法/Miller-Rabin法)](/arithmetic/primes/fast_factorize)\n- [素数列挙](/arithmetic/primes/primes)\n","lastmodified":"2022-10-26T11:26:57.35593449Z","tags":null},"/arithmetic/primes/fast_factorize":{"title":"高速素因数分解 (Pollard-ρ法/Miller-Rabin法)","content":"\n## 説明\n\nPollard-$\\rho$ 法と Miller-Rabin 法を用いて $O(n^{\\frac{1}{4}}\\log^3n)$ で素因数分解できる。\n\n### Miller–Rabin 素数判定法\n\nMiller-Rabin 素数判定法は与えられた数 $n$ が素数かどうかを計算時間 $O(k\\log^3 n)$ で誤り率 $4^{-k}$ 以下で判定する確率的素数判定アルゴリズムである。\n\nフェルマーの小定理について考える。素数である剰余 $n$ について、その乗法群の位数 $n-1$ はそれを $2$ で割れるだけ割った数を $d$ として $n-1 = 2^sd$ と書ける。\n\n$$\n\\begin{aligned}\na^{n-1} \u0026= a^{2^sd} ≡ 1 \\quad \\pmod n \\\\\na^{2^sd}-1 \u0026= (a^d-1)(a^d+1)(a^{2d}+1)(a^{4d}+1)\\cdots(a^{2^{s-1}d}+1)\\\\\n\u0026≡ 0 \\\\\n\\iff\u0026\\begin{cases}\na^d \u0026≡ 1 \u0026 \\pmod n \\\\\na^{2^rd} \u0026≡ -1 \u0026 \\pmod n \u0026 (\\exists r \\in \\mathbb{Z}, 0\\leq r\\leq s-1)\n\\end{cases}\n\\end{aligned}\n$$\n\nこの対偶をとると、「次の2式を満たす $a$ が存在するならば\n\n$$\n\\begin{aligned}\n\\begin{cases}\na^d \u0026\\neq 1 \u0026 \\pmod n \\\\\na^{2^rd} \u0026\\neq -1 \u0026 \\pmod n \u0026 (\\forall r \\in \\mathbb{Z}, 0\\leq r\\leq s-1)\n\\end{cases}\n\\end{aligned}\n$$\n\n$n$ は合成数である」と言える。\n\nこれを用い、次のステップを実行することで確率的な素数判定ができる。\n\n1. ランダムに $a \\in [1, n-1]$ をとってくる\n2. 上の条件を満たしたら composite と返す\n3. 満たさなければ probably prime と返す\n\nこれを繰り返すことで判定の精度が高まります。この処理をMiller–Rabin素数判定法と呼びます。\n\n2, 325, 9375, 28178, 450775, 9780504, 1795265022\n\n## 計算量\n\n$O(k\\log^3 n)$ 、FFTベースの乗算を用いると $Õ(k\\log^2 n)$\n\n## 実装\n\n## 使用例\n\n## 参考\n[Deterministic variants of the Miller-Rabin primality test](http://miller-rabin.appspot.com/)\n\n## 関連項目\n- [素因数分解](/arithmetic/primes/factorize)\n- [素数列挙](/arithmetic/primes/primes)","lastmodified":"2022-10-26T11:26:57.35593449Z","tags":null},"/arithmetic/primes/primes":{"title":"素数列挙","content":"\n## 説明\n\nエラトステネスの篩\n\n## 計算量\n\n\n## 実装\n\n```cpp\n#include \u003cvector\u003e\n\nstd::vector\u003cint\u003e primes;\nstd::vector\u003cbool\u003e Eratosthenes(int N) {\n  std::vector\u003cbool\u003e isprime(N + 1, true);\n  isprime[0] = isprime[1] = false;\n\n  for (int p = 2; p \u003c= N; ++p) {\n    if (!isprime[p])\n      continue;\n    primes.push_back(p);\n    for (int q = p * 2; q \u003c= N; q += p) {\n      isprime[q] = false;\n    }\n  }\n  return isprime;\n}\n```\n\n## 使用例\n\n\n## 関連項目\n- [素因数分解](/arithmetic/primes/factorize)\n- [高速素因数分解 (Pollard-ρ法/Miller-Rabin法)](/arithmetic/primes/fast_factorize)","lastmodified":"2022-10-26T11:26:57.35593449Z","tags":null},"/arithmetic/zeta":{"title":"高速ゼータ変換・高速メビウス変換","content":"\n## 説明\n\n\n\n## 計算量\n\n\n## 実装\n\n```cpp\n#include \u003cvector\u003e\n\ntemplate \u003ctypename T\u003e\nclass Eratosthenes {\npublic:\n  std::vector\u003cbool\u003e isprime; // 素数\n  std::vector\u003cT\u003e minfactor;  // 最小の素因数\n  // メビウス関数 μ\n  // μ(1)=1\n  // n がある素数pで2回以上割り切れるとき、μ(n)=0\n  // n=p1×p2×…pK と素因数分解できるとき、μ(n)=(−1)^K\n  // f(1)=∑[i=1~N]μ(i)F(i) 約数系包除原理\n  std::vector\u003cT\u003e mobius;\n\n  // エラトステネスの篩 O(NloglogN)\n  Eratosthenes(int N)\n      : isprime(N + 1, true), minfactor(N + 1, -1), mobius(N + 1, 1) {\n    isprime[1] = false;\n    minfactor[1] = 1;\n\n    for (T p = 2; p \u003c= N; ++p) {\n      if (!isprime[p])\n        continue;\n      minfactor[p] = p;\n      mobius[p] = -1;\n      for (T q = p * 2; q \u003c= N; q += p) {\n        isprime[q] = false;\n        if (minfactor[q] == -1)\n          minfactor[q] = p;\n        if ((q / p) % p == 0)\n          mobius[q] = 0;\n        else\n          mobius[q] = -mobius[q / p];\n      }\n    }\n  }\n\n  // 高速素因数分解 O(NlogN)\n  std::vector\u003cpT\u003e factorize(int n) {\n    std::vector\u003cpT\u003e res;\n    while (n \u003e 1) {\n      T p = minfactor[n];\n      T exp = 0;\n\n      while (minfactor[n] == p) {\n        n /= p;\n        ++exp;\n      }\n      res.emplace_back(p, exp);\n    }\n    return res;\n  }\n\n  // 高速約数列挙 O(\\sigma n)\n  std::vector\u003cT\u003e divisors(T n) {\n    std::vector\u003cT\u003e res({1});\n    std::vector\u003cpT\u003e pf = factorize(n);\n\n    for (auto [p, e] : pf) {\n      T s = (T)res.size();\n      for (T i = 0; i \u003c s; ++i) {\n        T v = res[i];\n        for (T j = 0; j \u003c e; ++j) {\n          v *= p;\n          res.push_back(v);\n        }\n      }\n    }\n    return res;\n  }\n\n  // 高速ゼータ変換 O(NloglogN)\n  // F(n)=∑[n|i]f(i)\n  template \u003cclass T\u003e\n  void fast_zeta(std::vector\u003cT\u003e \u0026f) {\n    T N = f.size();\n    for (T p = 2; p \u003c N; ++p) {\n      if (!isprime[p])\n        continue;\n      for (T k = (N - 1) / p; k \u003e= 1; --k) {\n        f[k] += f[k * p];\n      }\n    }\n  }\n\n  // 高速メビウス変換 O(NloglogN)\n  // f(n)=∑[n|i]μ(i/n)F(i)\n  template \u003cclass T\u003e\n  void fast_mobius(std::vector\u003cT\u003e \u0026F) {\n    T N = F.size();\n    for (T p = 2; p \u003c N; ++p) {\n      if (!isprime[p])\n        continue;\n      for (T k = 1; k * p \u003c N; ++k) {\n        F[k] -= F[k * p];\n      }\n    }\n  }\n\n  // 添字GCD畳み込み O(NloglogN)\n  // h(n)=∑[GCD(i,j)=n]f(i)g(j)\n  // H(n)=F(n)G(n)\n  template \u003cclass T\u003e\n  std::vector\u003cT\u003e gcd_conv(const std::vector\u003cT\u003e \u0026f, const std::vector\u003cT\u003e \u0026g) {\n    T N = max(f.size(), g.size());\n    std::vector\u003cT\u003e F(N, 0), G(N, 0), H(N);\n    for (T i = 0; i \u003c f.size(); ++i)\n      F[i] = f[i];\n    for (T i = 0; i \u003c g.size(); ++i)\n      G[i] = g[i];\n\n    fast_zeta(F);\n    fast_zeta(G);\n\n    for (T i = 1; i \u003c N; ++i)\n      H[i] = F[i] * G[i];\n\n    fast_mobius(H);\n\n    return H;\n  }\n};\n```\n\n## 使用例\n","lastmodified":"2022-10-26T11:26:57.35593449Z","tags":null},"/blog/Vim":{"title":"","content":"### Matering Vim Language\nhttps://www.youtube.com/watch?v=wlR5gYd6um0\n\nhttps://vim.help/12-clever-tricks#12.2\nhttps://career.levtech.jp/guide/knowhow/article/29/\n\n### 僕がVimで愛用しているプラグイン30連発\nhttps://liginc.co.jp/469142\n\n### Vim の operator プラグインをまとめた\nhttps://qiita.com/rbtnn/items/a47ed6684f1f0bc52906\n\n### vimcolorschemes\nhttps://vimcolorschemes.com\n\n競プロのライブラリをネットからインポート、スニペットを入れる必要がない\nワンラインif/forをブロックに展開するoperator\n","lastmodified":"2022-10-26T11:26:57.35593449Z","tags":null},"/blog/security_camp":{"title":"","content":"セキュリティ・キャンプ全国大会2022 オンライン\n専門コース C【脅威解析クラス】応募課題\n\n以下の問1から問8について、それぞれ5,000文字以内で回答してください。\n\n問5および問6については配布ファイルを使用します。以下に配布ファイルのSHA-256ハッシュ値を記載しますので、正しいファイルを取得できていることを確認した上で課題に取り組んでください。\n\n- sc2022_challenge05.zip\n  - 0292b1972845b6c3a57129acfd0de403f6f8080a4e2a3eef93c3913c63efe0df\n\n- sc2022_20220322T230402.zip\n  - 088e8fb04f486bae5d2dca1ccf9e5b971044c297bd03f7a5bd05bfaded6f27c3\n\nなお、正解がある設問については、\"正解していること\"よりも\"正解にたどり着くまでのプロセスや熱意\"を重要視しています。答えにたどり着くまでの試行錯誤や自分なりの工夫等を書いて、精一杯アピールしてください。\n\n## 問1\nあなたがセキュリティ・キャンプ全国大会に応募する理由を教えてください。受講生や講師とのコミュニケーション、受講したい講義、なりたい自分など、何でも構いません。\n\n私は大学のサークルでCTF班と呼ばれる班に所属し、毎週CTFに参加し、セキュリティについて学んでいます。先月、そのサークルが主催するCTFの問題の作成から開発、運営まで携わる機会を頂き、それらを経験した結果、自分がセキュリティについて知らないことがあまりにも多く、知っていても表面的で断片的なことに過ぎないことを痛感しました。それでセキュリティについて、徹底的に勉強したいと強く思ったことがセキュキャンに応募する理由です。\n\n箇条書きにすると以下の通りです。\n\n- CTFに強くなりたい\n- 強い人や知らない分野と出会って刺激されたい`\n- カーネルエクスプロイトを出来るようになってカーネルの脆弱性を見つけ、修正、報告したい\n- ウイルスを実際に読んでAnti Virusソフトを自作してみたい\n- 物理レイヤーへの攻撃や複数レイヤーを通じた攻撃、他分野と合わせた攻撃(シーケンサーの脆弱性を踏むようなDNAの生成など)、最近の技術であるTEEやeBPFへの攻撃について知りたい\n- 攻撃/防御を抽象化したい\n\n欲張りですが、何でも学んで経験してみたいです。\n\n## 問2\n今までに解析したことのあるソフトウェアやハードウェアにはどのようなものがありますか？解析の目的や解析方法、結果として得られた知見などを含めて教えてください。\n\nCTFで実行ファイルを読んだりすることはありますが、世のソフトウェアのバイナリを読むと言った経験が乏しくて本当の解析の例を出せません。ただ、ソースコードを読むという体験なら幾つかあります。\n\nLinuxカーネルを知りたいという欲求からサークルの2人でLinuxカーネルを読むことをしています。syscallの実装やスケジューラ、メモリ管理やKASLRなどの実装を読んでいました。高速化の為に読みにくく雑(?)な実装になるのが面白いなと感じます。得られた知見というと大きなコードを読む力です。自分はどんなコードであれ、気になった機能を一番下まで深掘りして読みたくなってしまうのですが、もう1人の方が途中で切り上げてくださり、丁度いい塩梅で読むことが出来ていると思います。(それでも抑えきれず、途中から読んでる場所が全然違ってきて知見を共有できないことが多々ありました笑)\n\n後は必要に応じて OSS 例えば python や golang などの言語の実装だったり V8 だったり CTF では Crypto を担当してるので SageMath の実装だったりをよく読みます。\n\nハードウェア系であれば購入してきたLEDランプの光量が少ない為、回路を読んではんだ付けして光量を増やしました。また物を分解する癖があり、キーボード、ラジオ、タップ、ルーターなどを分解したりしました。\n\n## 問3\n今までに作成したソフトウェアやハードウェアにはどのようなものがありますか？\nどんな言語やライブラリ、パーツを使って作ったのか、どこにこだわって作ったのか、などたくさん自慢してください。\n\n- 自作プログラミング言語\n2018年度のSecHack365に参加し、IoT向け言語として安全性と手軽さ、速度を持ち合わせた言語を作りました。C++のライブラリを用い、LLVMベースの言語で、C++, Rust, Kotlinに影響されていて、他とは違う所はライフタイムに関連する機能を実装したりした所です。その当時はそれで満足していたようですが、今の視点からするとおもちゃなのでより安全で心地よい言語を書きたいなと思います。\n\n- 量子コンピュータ用のC++ライブラリ\nJOIの夏季合宿でqasmと呼ばれる言語へのトランスパイラと古典コンピュータ上でのシミュレート(もちろんqubit数に対し指数時間/メモリ)をIBM Qにある演算に対し実装しました。\n\n- 将棋AI\n高校生のころ、ディープラーニングを用いて何か作りたいと思い、将棋AIを学習させました。どこかのサイトにある棋譜を元に Chainer で書いたものに学習させました。その当時は探索アルゴリズムに弱く、アルファベータ法などを知らなかった為、序盤/中盤は強いですが終盤はかなり弱いというものになりました。最近では GPT-3 などの Transformer が流行っていて、もう一度勉強し直して音声変換技術やブラウザのタブについてカテゴリに応じて自動的にグループ化するもの、あとは文章を書くのが苦手なのでブログを書くお手伝いをしてくれるものなどを作りたいなと思っています。\n\n- 水中ロボット\n高校のときに水中ロボットをチームで開発し、水中ロボコンinJAMSTECに芝浦工業大学附属高校として参加し、優勝しました。自分はプログラムを書いただけなのでほぼ他の方のおかげですが、それがきっかけとなり、今は水中ロボコンのサークルで回路を組む手伝いをしています。\n\n- レイトレーシング\nシェーダーについてあまり理解できてなかったのでレイトレーシング技術が面白そうと思いそのエンジンを開発しました。Ray Tracing in One Weekend という記事を参考にしてRustで書き、ppmと呼ばれる形式で出力して表示するというものを作りました。レイマーチングはまだ出来てないのでやりたいなと思っています。\n\n- ELF解析ツール\nELFの静的解析と動的解析ができるツールです。ELFファイルをバイナリで直読みできるようになりたいと思い開発しました。\n静的解析は ELF header, Program header table, Section header table などを読んで Spotify TUI などで使われているライブラリ tui-rs で TUI 表示してもらうものです。動的解析は実質自作デバッガーでそれを実行するプロセスを起動してptraceでアタッチし、レジスタやアセンブリなどの情報を取ってきて表示してくれるものです。メモリの値から大体の型を決めてアドレスは参照先のも表示したり文字列は文字列として表示しました。\n\n- 自作シンボリック実行エンジン\nrev問をやっているとangrと呼ばれるシンボリック実行エンジンをよく使うのですが、その仕組みがあんまり理解できてなかったので自作しました。開発期間が3日間なのでx64アーキテクチャで本当に小規模なものを作りました(本当はボーっと生きてたら3日後にLTがあることに気付き、やばいと思いつつ、この無謀なネタにしたら作れてしまったという締切駆動開発の凄さと恐ろしさを知りました)。\nシンボリック実行エンジン自体の仕組みは命令列をSMTに投げるだけというものです。実際はSMTまで自作したかったですが、資料が見つからず、z3に任せることにしました。実装はx64アーキテクチャの必要最小限の命令を実装しました。ネタを考えたときにその時流行っていたCVE-2022-0778: OpenSSLの無限ループの脆弱性を検出しようと考えていましたが、普通にやると(よく考えればできそうですが)ループ回数に対し、指数時間掛かり、5,6回くらいのループで数時間のオーダーとなり、数十回までループすれば無限ループと決定できたのですが、その検出は不可能と後で気付きました。\nまた言語はRustで開発したのですが設計の段階で大きな間違いを犯していて、どのようにしても解決できないような循環参照に陥り、その修正にかなり悩ませられ、開発のほとんど時間はこれに注ぎ込みました。おかげでRustの設計思想が分かるようになり、ライフタイムに頭を抱えるということがほぼ無くなりました。\n\n- 競技プログラミングとCTFのコンテストの運営、開発、作問\n開発では Rust, React で競プロのコード実行とフロントを繋ぐ部分の修正をしたり、 Ansible を書きました。作問は Crypto 分野を主に作り、他は簡単なものを1つずつほど作りました。改めて CTFer としてよわいなと感じ、これから1年強くなろうと決意しました。\n\n- その他\nこれは車輪の再発明で開発には入らないと思いますが、理解したくなったら自作することがあり、OS, シェル, ALU, DB, ゲームエンジン などを自作しました。\n\n## 問4\nここ数年に発表された、以下のキーワードに関連するニュースや記事や学術論文から1つ選び、それに関して調べた内容を記述してください。内容には、1.選んだ理由、2.技術的詳細、3.被害規模または影響範囲、4.対策、の4点を必ず含めてください。なお、対策は今ある技術のみに捕われず、将来的な技術や法律など、自由な発想で書いてください。\n\nキーワード：\n- サイバーセキュリティインシデント\n- マルウェア\n- 攻撃キャンペーン\n- 脆弱性\n- 新たな攻撃手法\n- 未知の脅威\n\nサイバーセキュリティインシデントの1つとしてサプライチェーン攻撃があります。これはどうすれば攻撃を防ぐことができるか気になったため選びました。\nサプライチェーン攻撃とは例えばOSSであればライブラリに悪意のあるスクリプトが埋め込められるとそれに依存する全てのプロジェクトに被害が波及するような攻撃です。今年3月にもnpmでサプライチェーン攻撃がありました。ハードウェアであれば、部品のボードに微小なチップが埋め込まれていたり、ハードウェアトロイと呼ばれる集積回路に不正な処理が埋め込まれていたりする可能性があり、それをベースに組んだ製品は機密情報を盗まれたり妨害されることが考えられます。\nこれらに対しセキュリティを担保するためには、悪意のあるスクリプトを検知する手法やハードウェアトロイを検出する手法を開発する必要があり、それが出来なければ DevSecOps の思想のように部品調達からサービス化まで全体を通じたセキュリティの評価手法を社会的な仕組みや制度を通して行えればよいと思います。\nまた、これは実現可能かどうかは分かりませんが、私はより進んだ攻撃/防御の概念の理解によって言語側からサポートできると思っています。\n\n## 問5\n配布ファイル（sc2022_challenge05.zip）に含まれるsafe.exe.gzfは解析対象のPEプログラムをGhidraデータベース形式に変換したものです。data.datは解析対象のプログラムが使用するデータです。safe.exe.gzfを解析して以下の問題に対して回答してください。\n\n※Ghidraのインストールおよびgzfに関する補足: https://hackmd.io/@qKyR9Y4rS7y7ytUCRr6FRg/H188XOvXq\n\n### 問5-1 \nこのプログラムの目的、挙動を説明せよ。\n\nWindows関連の様々な関数があることがわかり、 WinMain 関数についてデコンパイラを用いて調べると、 'C:\\Users\\Public\\KB59E7269.log' というファイルを開き、その内容を暗号化したものをアプリのディレクトリ名としてウィンドウを起動しているようです。他の関数はライブラリや内部情報を取得してプロセスの起動準備を行うイニシャライザのような関数群などがありましたがプログラムとは関係がなさそうなのでこれらは無視します。\nつまり、このプログラムはWindowsのログファイルを暗号化するプログラムです。\n\n### 問5-2 \ndata.datがどのような形式で暗号化されているか答えよ。また、復号されるデータの内容がどのようなものか答えよ。\n\n察するに暗号化されたものが data.dat に書かれてあると考えられます。\n暗号化の手法について読んでみると、まずファイルを16バイトのヘッダとそれ以外に分割し、ヘッダは共通鍵として、具体的には内部状態(S-box)を生成するのに使い、内部状態を用いて後半の内容を暗号化します。内部状態は0x00から0xffまでの値の順列となっており具体的な生成方法は以下の通りです。ただし演算は $\\mathbb{Z}/256\\mathbb{Z}$ 上で行うこととします。\n\n1. 256バイトの内部状態に0x00から0xffまで書き込む。\n2. 数 w をおき、現在見ている内部状態の値とヘッダの値を w に足し、内部状態の w の位置にある値とスワップする。\n3. 2を内部状態の最初から順番に最後まで繰り返す。\n\n暗号化の具体的な方法は以下の通りです。\n\n1. 数 p をおき、現在見ている内部状態の値を p に足し、内部状態の p の位置にある値とスワップする。\n2. スワップしたそれぞれの数を足した位置にある内部状態の値の位置にある内部状態の値を暗号化したい内容とxorする。\n3. 1,2を暗号化したい内容の最初から順番に最後まで繰り返す。\n\n復号することについて考えます。この暗号は共通鍵方式のストリーム暗号に属し、秘密鍵であるヘッダさえ分かれば内部状態が分かり復号することができます。つまり復号する方法は2つあり、1つは秘密鍵を当てる方法、もう1つはこの暗号の脆弱性を発見する方法があります。\nまず秘密鍵を直接当てる方法です。気付いたことはログファイルということなのでまず ASCII で書かれている可能性が高いということがあります。これで128ビット全探索が約112ビット全探索となりましたが目標は大体32ビット全探索なのでこれは誤差です。他にもWindowsのログファイル特有の性質を調べましたが無さそうでした。また以下のように定式化しても構造が複雑で秘密鍵の特定が難しかったです。\n\n$$\n\\begin{aligned}\n\u0026\\begin{cases}\np_{i+1} = p_i + s_i + h_i \\\\\ns_i \\iff s_{p_{i}} \\\\\n\\end{cases} \\\\\n\u0026\\begin{cases}\np_{i+1} = p_i + s_i \\\\\ns_i \\iff s_{p_{i}} \\\\\nm_{i} = c_i \\oplus ss(s_i + s_{p_{i}}) \\\\\n\\end{cases}\n\\end{aligned}\n$$\n\nそこで2つ目、暗号の規則性を発見することを考えます。調べてみると差分解析法や線形解読法が当てはまりそうなのでそれをやろうとしたのですが、文献の少なさと難しさから応募するまでに試すことが出来ませんでした。\n\n### 問5-3\ndata.datを復号するスクリプト作成して提出せよ。\n\n秘密鍵を全探索するスクリプトを書きました。\n\n```python\nfrom string import printable\n\nstrs = printable\n\ndef search(h):\n    if len(h) == 16:\n        dec = decrypt(list(reversed(h)))\n        m = []\n        for i in range(size):\n            c = next(dec)\n            m.append(cipher[i] ^ c)\n            if chr(m[i]) not in strs:\n                if i \u003e 5:\n                    print(bytes(reversed(h)), bytes(m))\n                break\n        return\n    for s in strs:\n        h.append(ord(s))\n        search(h)\n        h.pop()\n\ndef decrypt(h):\n    sbox = [0] * 0x100\n    for i in range(0x100):\n        sbox[i] = i\n    swap = 0\n    for i in range(0x100):\n        swap += h[i \u0026 0xf] + sbox[i]\n        swap \u0026= 0xff\n        sbox[i], sbox[swap] = sbox[swap], sbox[i]\n    swap = 0\n    i = 0\n    while True:\n        swap += sbox[i]\n        swap \u0026= 0xff\n        sbox[i], sbox[swap] = sbox[swap], sbox[i]\n        yield sbox[sbox[(sbox[i] + sbox[swap]) \u0026 0xff]]\n        i = (i + 1) \u0026 0xff\n\nwith open('data.dat', 'rb') as f:\n    cipher = f.read()\n    size = len(cipher)\n    search([])\n```\n\n## 問6\n配布ファイル（sc2022_20220322T230402.zip）は、Windows 10 PCのユーザsc2022のホームディレクトリ(C:¥Users¥sc2022¥)以下を取得し、zip形式で圧縮したファイルです。このユーザは、あるファイルサーバ上のファイルにアクセスしていたこと、あるオンラインストレージサービスを利用していたこと、が判明しています。\n\n以下の問題に対して、配布ファイルをどのように解析したかも含めて回答してください。\n\n### 問6-1\nユーザがアクセスしたファイルサーバー上のファイルに関連する情報を可能な限り記載してください(例: ファイル名、ファイルパス、日時等)。\n\nまず一通り見て関係がないと断言できるものを見つけます。以下のようなものは関係ないと言えます。\n\n- NTUSER.DATなど: Windowsレジストリの実体\n- desktop.ini: デスクトップの表示方法\n\nこれよりAppData以下が怪しいことがわかるのでそれらを中心に調べます。まず cloud, storage, drive, file などのストレージサービスで使われていそうな単語で grep し、ブラウザの閲覧履歴にありそうというアタリを付けました。\n\n```\n$ rg \"storage\" --binary -M 1 -m 1\n```\n\nそしてFireFoxの閲覧履歴を保存している以下のファイルから使ったファイルサーバーは firestorage だということがわかります。\n\n`C/Users/sc2022/AppData/Roaming/Mozilla/Firefox/Profiles/hc93rfhn.default-release/places.sqlite`\n\nhttps://fire.st/ZM7Nt1u などからcanary.txtというファイルにアクセスし、last_visit_dateから2022-03-22 22:35に閲覧していることがわかります。\n\n### 問6-2 \nユーザが利用していたオンラインストレージサービスに関連する情報を可能な限り記載してください(例: サービス名、アクセス方法、日時等)。\n\nユーザーが利用していたオンラインストレージサービスは FireStorage で WindowsSearch のよくみるサイトなどから FireFox を起動し、2022年03月22日の22:35に閲覧した。\n\n### 問6-3\nユーザは、ファイルサーバ上のファイルをオンラインストレージサービスにアップロードしたか、していた場合はどのファイルであったかを回答してください。\n\nアップロードしたファイルはこのようなファイルである。\ncanary.txt\n```\nFDGG\n\n```\n\n## 問7\nBinary Exploitに関して、次の各問に回答してください。\n\n### 問7-1\nHeap Buffer Overflowとはどのような脆弱性かを簡潔に説明してください。また、この脆弱性を攻撃者がどのように攻撃に利用するかを説明してください。\n\nコンピュータは様々な方法でメモリを管理しています。その中でプロセスごとに持つメモリ領域として スタック(Stack) と ヒープ(Heap) があります。また、Buffer Overflowとは想定されるサイズ以上に書き込むことができてしまう脆弱性です。つまり、Heap Buffer Overflowとはヒープというメモリ領域で必要以上に書き込みが出来てしまう脆弱性です。\n具体的な攻撃方法はヒープの構造について知らなければ説明できないので先にそれについて整理します。\n\nヒープはメモリを動的に確保、解放する仕組みをもつメモリ領域です。プログラムは malloc()/free() 関数によって確保/解放します。\n最初に malloc() が呼ばれると syscall の1つである sbrk() が呼び出され、ヒープ領域を作ります。malloc() で確保され続け、ヒープ領域に空きが少なくなってくると sbrk syscall によってヒープ領域を拡張します。基本戦略としてそれぞれの空き領域をチャンクとして管理し、それらチャンクをいかに上手く使い回すかで速度が変わります。例えば、図書館の事務を想像してもらって、借りて返した本をもう一度借りるということが頻繁に起こるときに、いちいち元にあった場所に戻してまた取ってくるというのは手間で、手元に置いておく方が便利です。ただ全ての本を手元に置いておける訳ではありません。どうやって制限された場所で効率よく管理するか。これと同じようにチャンクを一旦保持しておくということをします。また、フラグメンテーションが起こるとそのチャンク free lilst と呼ばれる連結リストとして管理しています。この malloc()/free() は確保するメモリサイズを指定できるのですがサイズによって格納方法を変えています。\n以下64bitのシステムを前提にして考えます。\n\n- tcache\n始めの7つのチャンクはtcacheでキャッシュされます。per-thread cache の略らしいです。\n- fastbins\n128B(`global_max_fast`)までの小さな領域は fastbins によってキャッシュされます。fastbins ではサイズに応じて16Bおきにリストを作成しています。これにより best-fit allocator となります。実装は main_arena にあるfastbinsY からチャンクが伸びています。\n- unsorted bins\nmalloc_consolidate() などで他の bin で管理されなくなったものを保持します。これらは確保されるか bin に登録されるまで残り続けます。\n- smallbins\n1KB(`MIN_LARGE_SIZE`)までの領域は smallbins によって管理されます。8Bおきにリストを作ります。\n- largebins\n1KB(`MIN_LARGE_SIZE`)以上の大きな領域は largebins によって管理されます。サイズに対し指数的に間隔を広く取ってリストで管理します。\n- mmap/munmap\n128KB(`M_MMAP_THRESHOLD`)以上の場合は mmap/munmap によりカーネルから直接確保されます。\n\nそして Heap Buffer Overflow はそれを使うことでデータの上書きができ、それによってヒープの管理構造を乗っ取ることができることがあります。\n\nまた、OSの核であるカーネルもヒープ領域を持ち、それに対しての BOF はKernel Heap Buffer Overflow と呼びます。ここら辺はあまり試したことがなく説明できるものが少ないですが、1回だけ meowmow という問題で Kernel Exploit を勉強していたときに kmalloc がサイズごとに分けられ、Slabと呼ばれるページ単位を小分けにして管理しているものに HBOF が出来る構造体と tty_struct 構造体を載せ、 tty_struct を書き換えて攻撃できるというものを知りました。それ以外の攻撃手法は全く知らないのでこれから理解していこうと思います。\n\n### 問7-2\nUse-after-Freeとはどのような脆弱性かを簡潔に説明してください。また、この脆弱性を攻撃者がどのように攻撃に利用するかを説明してください。\n\nヒープ領域のチャンクを解放した後でも使えてしまう脆弱性です。例えば、unsorted bin で Use-after-Free ができると管理領域の情報を覗くことができ、例えば fd から libc base が分かったりします。libc base が分かれば、libc 上のガジェットから Stack Buffer Overflow などで ROP を組む事ができ、シェルを起動できます。\n\n### 問7-3\n以下のx64アーキテクチャのROP gadgetを組み合わせ、後の各処理を実現するROP chainを構築してください。ROP chainは、64-bitのアドレスや値をカンマ(,)区切りで書いてください。ただし、関数A, Bのアドレスはそれぞれ0x401aa0, 0x401bb0、64-bit非負整数型変数xのアドレスは0x602080とします。また、関数A, Bの呼び出し規約はAMD64 ABIに従っており、引数・戻り値ともに64-bitの非負整数値とします。\n\nこのROP gadgetの組み合わせだけでは実現できないと判断した場合は、その理由を書いてください。\n\n0x401027: pop rdi; ret;\n0x40103a: pop rcx; ret;\n0x4011f2: pop rsi; pop r12; ret;\n0x40132a: mov rdi, rax; rep movsq; ret;\n0x401401: xchg eax, edi; ret;\n\n(例) A(1); B(2);\n--\u003e 0x401027, 1, 0x401aa0, 0x401027, 2, 0x401bb0\n\n(1) A(1, 2); B(3);\n(2) A(B(0));\n(3) A(x);\n(4) x = 0xdeadbeefcafebabe;\n\n問題の意味が分からない場合はReturn Oriented Programmingについて調べ、ROPについてあなたが理解した内容を書いてください。\n\n(1) A(1, 2); B(3);\n0x401027, 1, 0x4011f2, 2, 0, 0x401aa0, 0x401027, 3, 0x401bb0\n\n(2) A(B(0));\n0x401027, 0, 0x401bb0, 0x401401, 0x401aa0\n\n(3) A(x);\nメモリ参照のガジェットが無いため、xの値をレジスタに格納することが出来ず、実現できません。\n\n(4) x = 0xdeadbeefcafebabe;\nスタックのアドレスが分からず、スタック上に書き込みたい値を書いてもストリング命令の転送前のアドレスを指定することが出来ないため、実現できません。\n\nA: 0x401aa0, B: 0x401bb0\nx: 0x602080\n\n## 問8\neBPF(extended Berkeley Packet Filter)はLinuxカーネルが提供する機能の名前です。eBPFについて次の各問に答えてください。\n\n### 問8-1\neBPFとはどのような機能かを「JIT」という言葉を用いて説明してください。\n\neBPF は extended Berkley Packet Filter の略で、カーネルの特定のポイントでフックさせて実行するコードを安全に仕込める技術です。これを利用することで安全で高速にカーネルの制御や活用ができます。例えばカーネルのトレースをしたり、内部情報を取得したり、パケットフィルタリングさせたり、syscallに制限を掛けたりすることができます。eBPF の中身は BPF 独自の命令セットを解釈する仮想マシンとカーネル空間とユーザー空間で共有するストレージオブジェクトがあります。ストレージオブジェクトによってカーネルの情報をユーザーにわたすことが出来ます。\n\nプログラムは次のようにロードします。\n\nC言語のBPFプログラム -\u003e BPFバイトコード -\u003e マシンコード\n\nC言語のBPFプログラムからBPFバイトコードへはLLVM/Clangを用いてコンパイルします。生成されたBPFバイトコードは bpf syscall によりカーネルに渡され、BPF Verifierと呼ばれる検査機を用いて安全に実行できるか確認してから、マシンコードへJIT (Just In Time) コンパイラでコンパイルし、ロードされます。これによりカーネルを再起動せずにカーネル内で安全にサンドボックス化されたプログラムを実行できます。\n\n### 問8-2\nあなたが身近に使っているアプリケーションでBPF/eBPFを利用するものを探し、どのような使われ方がしているかを説明してください。見つからない場合は、普段使っていないアプリケーションでも構いません。\n\n普段使っているアプリケーションにeBPFは用いられていなかったので、Pixieと呼ばれるアプリケーションについて調べました。\nPixie は Kubernetes クラスタのプロファイラやメトリクスの可視化を行うアプリケーションです。eBPFを用いることで様々なレイヤーでのスループットやレイテンシ、エラーを収集することができ、それらの情報を統合させてHTTPリクエストやネットワークトラフィック、それらのフロー、スロークエリ、NodeやPodのモニタリングなどをしてくれます。\n","lastmodified":"2022-10-26T11:26:57.35593449Z","tags":null},"/crypto/AES/AES":{"title":"AES","content":"\n- AES-ECB (Electronic Codeblock)\n- AES-CBC (Cipher Block Chaining)\n- AES-CTR\n- PCBC (Propagating Cipher Block Chaining)\n- CFB (Cipher Feedback)\n- AES-GCM (Galois/Counter Mode)\n\nAES-NI\n\n","lastmodified":"2022-10-26T11:26:57.35593449Z","tags":null},"/crypto/AES/Symmetric_cryptography":{"title":"","content":"最新の状況はこの発表を見ればすべてわかる\n[Invited talk: Symmetric Cryptography for Long Term Security, by Maria Naya Plasencia - YouTube](https://www.youtube.com/watch?v=kcaPL2xxXiY)\n軽量な\nセキュリティ vs. 効率\n応用に合わせた性質\n- ZK-friendly\n- FHE-friendly\n- low latency\n- easy-masking\n- quantum safe\n\n最近の大きな研究10選\n- SHA-1 collision and Chosen-prefix collision\n- Practical attacks on 15-year old operating mode and ISO standard OCB2\n- Attacks on $\\approx2^{40}$ on GEA-1(back door) and GEA-2\n- Division property: Generalization of integrals, higher order diff.\n\t- Can be combined with cube attacks\n\t- Provides best known attacks on several stream ciphers\n\t- First full break of MISTY1, a widely implemented primitive\n- Partial non-linear layers: Zorro, LowMC attacks, Malicious, Hades/Poseidon\n- Stream cipher based: Kreyvium, FLIP\n- Large fields: MiMC round $x^3$\n![[Pasted image 20221024224251.png]]\n\nPost-Quantum Cryptography\nAsymmetric (e.g. RSA)\nShor's algorithm: Polynomial time\nSolution: lattice-based, code-based,...\n\nSymmetric (e.g. AES)\nGrover's algorithm: $2^{K}\\to 2^{K/2}$\n鍵長を倍の長さにすることで同じセキュリティを担保できる。","lastmodified":"2022-10-26T11:26:57.35593449Z","tags":null},"/crypto/DLP/BSGS":{"title":"Baby-step Giant-step","content":"\n## 説明\n\n半分全列挙を用いて $O(\\sqrt{N}\\log{N})$ でDLPが解ける。\n\n位数 $N$ の巡回群 $G$ について $a, b\\in G$ が与えられるので $a^n = b$ となる最小の $n\\in \\mathbb{N}$ を求める問題を考える。このとき $m = \\lceil\\sqrt{N}\\rceil$ とおき、$n$ を $m$ で割ると $n = qm + r \\ (q, r\\in[0, \\lceil\\sqrt{N}\\rceil)\\ )$ と表せられる。すると $r$ に対して $ba^{-r}$ を全列挙し、そのリストに対して $a^{qm}$ が含まれているような $q$ を探索すると高速に解が求まる。\n\n例えば、有限体 $\\mathbb{F}_p$ 上なら乗法群の位数 $p-1$ から\n\n楕円曲線 $E$ 上であれば加法群の位数 $\\#E$ から\n\n## 計算量\n$O(\\sqrt{N}\\log N)$\n\n## 実装\n\n## 使用例\n\n## 参考\n","lastmodified":"2022-10-26T11:26:57.35593449Z","tags":null},"/crypto/DLP/DLP":{"title":"離散対数問題 (DLP)","content":"\n## 説明\n\n離散対数問題 (DLP: Discrete Logarithm Problem) とは巡回群 $G$ について $a, b\\in G$ が与えられるので $a^n = b$ となる最小の $n\\in \\mathbb{N}$ を求める問題である。\n\n例えば、有限体 $\\mathbb{F}_q$ のDLP\n\n楕円曲線 $E$ 上でのDLP\n\n## 実装\n\n## 使用例\n\n## 参考\n\n- [General purpose integer factoring](https://eprint.iacr.org/2017/1087)","lastmodified":"2022-10-26T11:26:57.35593449Z","tags":null},"/crypto/DLP/IndexCalculus":{"title":"指数計算法 (Index Calculus Algorithm)","content":"\n## 説明\n\n## 実装\n\n## 使用例\n\n## 参考\n","lastmodified":"2022-10-26T11:26:57.35593449Z","tags":null},"/crypto/DLP/NumberFieldSieve":{"title":"数体ふるい法","content":"\n## 説明\n\n## 実装\n\n## 使用例\n\n## 参考\n","lastmodified":"2022-10-26T11:26:57.35593449Z","tags":null},"/crypto/DLP/Pohlig_Hellman":{"title":"Pohlig-Hellman","content":"\n## 説明\n\n中国剰余定理を用いて大きな群を複数の小さな群の直積に分割する。\n\n## 実装\n\n```python\nfact = factor(G.order())\nord = int(G.order())\ndlogs = []\nfor p, e in fact:\n    t = ord // p ^ e\n    dlog = discrete_log(t * Q, t * G, operation=\"+\")\n    dlogs += [dlog]\n\nprint(crt(dlogs, primes))\n```\n\n## 使用例\n\n## 参考\n","lastmodified":"2022-10-26T11:26:57.35593449Z","tags":null},"/crypto/DLP/Pollard_rho":{"title":"Pollard's rho 法","content":"\n## 説明\n\n初期点 $x_0$ と適当な副作用のない疑似乱数関数 $f(x)$ を決めて $x_{i+1} = f(x_i)$ となるように数列 $(x_0, x_1, \\ldots)$ を生成する。このとき $0 \\leq \\exists i \u003c \\exists j \u003c N$, $x_i = x_j$ となる $i,j$ を見つけられたらDLPが解けるという仕組みです。\n\nよく用いられる関数 $f(x)$ は次のようなものがあります。ただし、$G_1, G_2, G_3$ は巡回群 $G$ の集合をランダムに振り分けられるように3つに区別したものです。\n\n$$\nf(x)=\n\\begin{cases}\nbx \u0026 (x \\in G_1 \\mathrm{のとき}) \\\\\nx^2 \u0026 (x \\in G_2 \\mathrm{のとき}) \\\\\nax \u0026 (x \\in G_3 \\mathrm{のとき}) \\\\\n\\end{cases}\n$$\n\nこのとき $x_0 = a$ とすると $x_i$ は $x_i = a^{s_i}b^{t_i}$, $s_i, t_i \\in \\mathbb{N}$ と表せられる。すると $x_i = x_j$ において $n$ は巡回群の位数 $N$ を用いて次のように表せられる。\n\n$$\n\\begin{aligned}\nx_i \u0026= a^{s_i}b^{t_i} = a^{s_i + nt_i} \\\\\nx_j \u0026= a^{s_j + nt_j} \\\\\na^{s_i - s_j} \u0026= a^{n(t_j - t_i)} \\\\\nn \u0026= \\frac{s_i - s_j}{t_j - t_i} \\pmod N\n\\end{aligned}\n$$\n\nこれよりDLPが解ける。\nPollard-$\\rho$ 法の $\\rho$ は文字 $\\rho$ の形が由来となっている。\n\n\u003c!-- Pollard's Kangaroo 法 (Lambda 法)\n$\\rho$ 法は動く点が1つの値だったのに対し、 $\\lambda$ 法は2つの値がランダムに動いていき、一方がもう一方の点に衝突したときDLPが解ける。\n\n$$\n\\begin{aligned}\nx_0 \u0026= g^{a_0} \u0026 y_0 \u0026= g^{b_0} \\\\\nx_{i+1} \u0026= x_ig^{r(x_i)} \u0026 y_{i+1} \u0026= y_i g^{r(y_i)} \\\\\n\\end{aligned}\n$$\n\n$x_i = y_j$ となるとき --\u003e\n\n## 計算量\n\n$O(\\sqrt{N})$\n\n計算量の期待値集合 $S$ に対してそれぞれ相違な $x_0, x_1, \\ldots, x_{k-1}$ を選ぶ事象 $A$ と\n\n$$\n\\begin{aligned}\nP(A) \u0026= \\prod_{i = 0}^{k-1}\\left(1-\\frac{i}{N}\\right) \\approx \\prod_{i = 0}^{k-1}e^{-i/N} \\approx e^{-k^2/2N} \\\\\nP(B) \u0026= \\frac{k}{N}e^{-k^2/2N} \\\\\nE(B) \u0026= \\sum_{k=1}^N k\\cdot\\frac{k}{N}e^{-k^2/2N} \\\\\n\u0026\\approx \\sqrt{N}\\int_0^\\infty t^2e^{-t^2/2} dt \\\\\n\u0026= \\sqrt{\\frac{\\pi N}{2}}\n\\end{aligned}\n$$\n\n\n## 実装\n\n## 使用例\n\n## 参考\n\n- The Arithmetic of Elliptic Curves. p.383","lastmodified":"2022-10-26T11:26:57.35593449Z","tags":null},"/crypto/ECC/ECC":{"title":"楕円曲線暗号","content":"\n# 楕円曲線暗号\n\n## 楕円曲線\n$K$ を任意の体、 $f(x) \\in K[x]$ を3次方程式とする。ただし $f(x)$ の3解は相異なる。ここで次の方程式を考える。\n\n$$\ny^2 = f(x)\n$$\n\n$x, y$ 線形変換によって2次の項は消すことができ、\n\n$$\ny^2 = x^3 + ax + b\n$$\n\n- グラフ(一般性なし)\n- 特異性 -\u003e 無限遠点\n- 和\n\n![[Pasted image 20220907220335.png]]\n\n$C: F(x, y) = 0$ について\n$C$ が点 $(x_0, y_0)$ で非特異であるとは2つの偏微分 $\\partial F/\\partial x, \\partial F/\\partial y$ のうちの1つが $(x_0, y_0)$ で $0$ でないということである。$K'$ が実数体 $\\mathbb{R}$ であるとき $C$ がその点で接線を持つための条件と一致する。 $F(x, y) = y^2 - f(x)$ の場合、偏微分は $- f'(x_0)$ と $2y_0$ である。2つの微分が同時に $0$ であるためには、 $y_0 = 0$ かつ $x_0$ は $f(x)$ の重解であることが必要十分である。この理由の為に楕円曲線の定義において、$f(x)$ が相違なる根を持つということを仮定したのである。つまり楕円曲線はすべての点において非特異である。\n\n楕円曲線上の点全体に加えてその曲線上に存在すると考えたいきわめて重要な無限遠点と呼ばれるものがある。これは複素関数論において、複素平面に無限遠点を添加してリーマン球面を形成することと同じようなものである。このことを正確に扱う為に今、射影座標を導入する。\n\n単項式 $x^iy^j$ の全次数(total degree) とは $i + j$ を意味する。多項式 $F(x,y)$ の全次数とは、 $0$ でない係数を持って出てくる単項式の全次数の最大値を意味する。$F(x,y)$ の全次数が $n$ のとき、対応する $3$ 変数の同次多項式 $\\widetilde{F}(x,y,z)$ を $F(x,y)$ における各多項式 $x^iy^j$ に、 $x, y, z$ に関する全次数が $n$ になるように $z^{n-i-j}$ を掛けて得られる多項式と定義する。言い換えると\n\n$$\n\\widetilde{F}(x,y,z) = z^nF\\left(\\frac{x}{z}, \\frac{y}{z}\\right)\n$$\n\nとなる。例えば楕円曲線の1つ $F(x, y) = y^2 - (x^3 + ax + b)$\n\n$$\n\\begin{aligned}\n\\widetilde{F}(x,y,z) \u0026= y^2z - x^3 - axz^2 - bz^3 \\\\\n\\end{aligned}\n$$\n\n$\\widetilde{F}(x, y, 1) = F(x, y)$ とか $\\widetilde{F}(\\lambda x,\\lambda y,\\lambda z) = \\lambda^n\\widetilde{F}(x, y, z)$ みたいな性質がある。\n\n無限遠点の解説\n自明な3つ組 $(0,0,0)$ を除いた射影平面 $\\mathbb{P}_K^2$ を非自明な3つ組の同値類を体のなす集合として定義する。\n射影平面を同値類で考えることが好きな正常な人間などいるわけないが、ありがたいことにこれを幾何学的に考えることができる。\n$(x,y,z)$ の同値類\n$\\{(x,1,0)\\ |\\ x \\in K\\}$ は $y = 1$ の直線と無限遠点 $(1,0,0)$ の和として視覚化できる。\n\n和の定義\n群構造をなす証明\n\n和の定義\n楕円曲線上の点 $P, Q$ に対し、直線 $PQ$ と曲線との交点の $y$ 座標を符号反転した点を $P + Q$ とします。\n\n![[Pasted image 20220907220413.png]]\n\nこの定義を踏まえて、具体的に式を立てて計算すると $P(x_1, y_1), Q(x_2, y_2)$ として $R(x_3, y_3) = P + Q$ は次のように計算できます。ただし、$P = Q$ のときの直線 $PQ$ は曲線に対する点 $P$ の接線と考えます。\n\n$$\n\\begin{aligned}\nx_3 \u0026= \\lambda^2 - x_1 - x_2 \\\\\ny_3 \u0026= \\lambda(x_1 - x_3) - y_1 \\\\\n\\lambda \u0026=\n\\begin{dcases}\n\\frac{y_2 - y_1}{x_2 - x_1} \\quad (P \\neq Q) \\\\\n\\frac{3x_1^2 + a}{2y_1} \\quad (P = Q)\n\\end{dcases}\n\\end{aligned}\n$$\n\n## 2重周期関数\n複素平面内の格子 $L$ とは、与えられた2つの複素数 $\\omega_1, \\omega_2$ の整数係数の1次結合全体のなす集合を意味する。ただし、$\\omega_1$ と $\\omega_2$ は原点を通る同一の直線状に無いものとする。\n例えば $\\omega_1 = 1, \\omega_2 = i$ の場合、ガウス整数全体のなす格子 $\\{m + ni\\ |\\ m, n \\in \\mathbb{Z}\\}$ を得る。\n基本平行四辺形\n\n$$\n\\begin{aligned}\nL \u0026= \\{m\\omega_1 + n\\omega_2\\ |\\ m, n \\in \\mathbb{Z}\\} \\\\\n\\Pi \u0026= \\{a\\omega_1 + b\\omega_2\\ |\\ 0 \\leq a \\leq 1, 0 \\leq b \\leq 1\\} \\\\\n\\end{aligned}\n$$\n\n与えられた格子 $L$ に対し、 $\\mathbb{C}$ 上の有理型関数 $f$ はすべての $\\lambda \\in L$ について $f(z + \\lambda) = f(z)$ になるとき、 $L$ に関する楕円関数と言われる。 $\\lambda = \\omega_1$ と $\\lambda = \\omega_2$ についてこの性質を確認すれば十分であることを注意しておく。\n\n2重周期関数\n複素多様体 トーラス\n実多様体 円\n\n楕円関数の重要な例となるものを定義する。この関数はワイエルシュトラスの $\\wp$ -関数(ペー関数)と呼ばれる。\n\n$$\n\\wp(z) = \\wp(z; L) = \\frac{1}{z^2} + \\sum_{\\lambda \\in L, \\lambda \\neq 0} \\left(\\frac{1}{(z-\\lambda)^2} - \\frac{1}{\\lambda^2} \\right)\n$$\n\n\n\n$$\n\\begin{aligned}\n\\wp(z) \u0026= \\frac{1}{z^2} + \\sum_{\\lambda \\in L, \\lambda \\neq 0} \\left(\\frac{1}{(z-\\lambda)^2} - \\frac{1}{\\lambda^2} \\right) \\\\\n\u0026= \\frac{1}{z^2} + \\sum_{\\lambda \\in L, \\lambda \\neq 0} \\frac{1}{\\lambda^2}\\left(\\frac{1}{(1-z/\\lambda)^2} - 1\\right) \\\\\n\u0026= \\frac{1}{z^2} + \\sum_{\\lambda \\in L, \\lambda \\neq 0} \\frac{1}{\\lambda^2}\\sum_{k=1}^{\\infty}(k+1)\\left(-\\frac{z}{\\lambda}\\right)^k \\\\\n\u0026= \\frac{1}{z^2} + \\sum_{k=1}^{\\infty}(k+1)(-1)^k\\sum_{\\lambda \\in L, \\lambda \\neq 0} \\frac{1}{\\lambda^{k+2}}z^k \\\\\n\u0026= \\frac{1}{z^2} + \\frac{g_2}{20}z^2 + \\frac{g_3}{28}z^4 + \\mathcal{O}(z^6) \\\\\ng_2 \u0026:= 60\\sum_{\\lambda \\in L}\\frac{1}{\\lambda^4}, \\quad\ng_3 := 140\\sum_{\\lambda \\in L}\\frac{1}{\\lambda^6} \\\\\n\\end{aligned}\n$$\n\n$$\n\\begin{aligned}\n\\wp'(z) \u0026= -2\\sum_{\\lambda \\in L} \\frac{1}{(z-\\lambda)^3} \\\\\n\u0026= - \\frac{2}{z^3} + 2\\sum_{\\lambda \\in L,\\lambda\\neq0} \\frac{1}{\\lambda^3}\\sum_{k=0}^{\\infty}(2k+1)\\left(\\frac{z}{\\lambda}\\right)^k \\\\\n\u0026= 2\\sum_{k=0}^{\\infty} (2k+1)\\sum_{\\lambda \\in L,\\lambda\\neq0}\\frac{1}{\\lambda^{k+3}}z^k\n\\end{aligned}\n$$\n\n$$\n\\begin{aligned}\n\\wp(z) \u0026= \\frac{1}{z^2} + \\frac{g_2}{20}z^2 + \\frac{g_3}{28}z^4 + \\mathcal{O}(z^6) \\\\\n\\wp'(z) \u0026= -\\frac{2}{z^3} + \\frac{g_2}{10}z + \\frac{g_3}{7}z^3 + \\mathcal{O}(z^5) \\\\\n\\wp^3(z) \u0026= \\frac{1}{z^6} + \\frac{3g_2}{20}\\frac{1}{z^2} + \\frac{3g_3}{28} + \\mathcal{O}(z^2) \\\\\n\\wp'^2(z) \u0026= \\frac{4}{z^6} - \\frac{2g_2}{5}\\frac{1}{z^2} - \\frac{4g_3}{7} + \\mathcal{O}(z^2) \\\\\n\\end{aligned}\n$$\n\n![[Pasted image 20220907220319.png]]\n\n\n![[Pasted image 20220907220303.png]]\n楕円関数体\n楕円曲線\n\n## ペアリング\nweil pairing\ntate pairing\n大人数\nペアリング\n\n## 超楕円曲線\n超楕円曲線\nヤコビ多様体\n\n## 保型形式\n上半平面 $\\mathbb{H}$\n\n$$\n\\gamma(x) = \\frac{ax + b}{cx + d}\n$$\n\nの変換について不変\n\n同型写像\nSIDH\n楕円曲線暗号をそこまで理解してないので、これから学ぶ人がより先へ開拓していき、よりよい記事が出されることを期待しています。\n\n### 楕円曲線暗号とは\n\n楕円曲線暗号 (ECC) はRSA暗号と同時期に開発された暗号で1985年頃に Victor S. Miller と Neal Koblitz が同時期かつ独立に発明しました(ちなみにMiller-Rabin素数判定法のMillerはGary L. Millerで別人です)。特徴としてRSA暗号よりも純粋に強い暗号であることや同じ強度のRSA暗号と比べて鍵長が短いなどがあります。\n\n楕円曲線というのは次の関数からなる曲線のことです。\n\n$$\ny^2 = x^3 + ax + b\n$$\n\nここにグラフ\n\n楕円曲線上の点 $P, Q$ に対し、直線 $PQ$ と曲線との交点の $y$ 座標を符号反転した点を $P + Q$ とします。\n\nここに図\n\nこの定義を踏まえて、具体的に式を立てて計算すると $P(x_1, y_1), Q(x_2, y_2)$ として $R(x_3, y_3) = P + Q$ は次のように計算できます。ただし、$P = Q$ のときの直線 $PQ$ は曲線に対する点 $P$ の接線と考えます。\n\n$$\n\\begin{aligned}\nx_3 \u0026= \\lambda^2 - x_1 - x_2 \\\\\ny_3 \u0026= \\lambda(x_1 - x_3) - y_1 \\\\\n\\lambda \u0026=\n\\begin{dcases}\n\\frac{y_2 - y_1}{x_2 - x_1} \\quad (P \\neq Q) \\\\\n\\frac{3x_1^2 + a}{2y_1} \\quad (P = Q)\n\\end{dcases}\n\\end{aligned}\n$$\n\nここに具体例\n\nまた加法について群となることが証明でき結合法則 $P + (Q + R) = (P + Q) + R$ が成り立つことが証明でき、$nP = \\underbrace{P + P + \\ldots + P}_n$ と書けます。これを楕円曲線上のスカラー積と呼びます。\n\nここに具体例\n\n$8P$\n\nここに実装\n\nさて、ここでこの楕円曲線上の加法を用いた次のような問題を作れます。\n\n---\n\n楕円曲線上の点 $P, Q$ に $Q=dP$ という関係があるとき $d$ を求めよ。\n\n---\n\nつまり楕円曲線の世界で「割り算」をしなさいという問題です。\n\n実はこの問題はとても難しく、これを解く効率的なアルゴリズムは現在見つかっていません。これを楕円曲線上の離散対数問題 (ECDLP : Elliptic Curve Discrete Logarithm Problem) と呼びます。この ECDLP を利用して暗号の形にしたものが楕円曲線暗号です。\n\n具体例としては色々ありますがCTFで最もよく出るのがECDHです。\n\n#### ECDH (Elliptic curve Diffie–Hellman key exchange)\n\n暗号通信をする為に使われる暗号プロトコルです。\n\nAlice と Bob は AES などの共通鍵暗号を用いて暗号通信しようとしていますが、始めに2人だけの秘密である共有鍵が必要です。しかしそれを直接共有してしまうと、第三者から鍵を盗聴されて通信を覗き見られてしまいます。そこで暗号を用いることで鍵を直接共有することなく共有鍵を構築することができます。この手法をディフィーヘルマン鍵共有 (DH) と呼び、DH の中でも ECDLP を安全性根拠とする DH を楕円曲線ディフィーヘルマン鍵共有 (ECDH) と呼びます。\n\n具体的には次のような方法で ECDH を実現します。\n\nここに図\n\n1. AliceとBobが楕円曲線のパラメータとベースポイント $G$ を共有する。\n2. AliceとBobはそれぞれランダムな値 $d_A, d_B$ を生成し、$d_A, d_B$ を秘密鍵、$Q_A = d_AG, Q_B = d_BG$ を公開鍵として公開する。\n3. AliceとBobは自分の秘密鍵と相手の公開鍵を掛けると $S = d_Ad_BG = d_AQ_B = d_BQ_A$ となり、$S$ の $x$ 座標をハッシュ化したものが Alice と Bob のみが知る共通鍵となる。\n\nこのように攻撃者は $(G, dG)$ が分かっても ECDLP が解けない為に $d$ が分からず、安全に共通鍵を共有することができます。\n\nここに実装\n\n暗号標準を定める国際機関によって楕円曲線が\nhttps://neuromancer.sk/std/\n\n### 楕円曲線とは\n\n掴みを見れたと思うのですがよく理解するには正確な定義が必要です。\n数学的な話はあんまり\n\n射影平面上の楕円曲線\n\n射影平面で定義する理由\n\n- 無限遠点を数学的に定義できる\n- 実装時に割り算の遅延ができ高速化できる\n\n\nさてそろそろ攻撃したくてムズムズし始めたんじゃないでしょうか？ではやっていきましょう！\n\n### 攻撃手法\n\nこの ECDLP を解くことができれば ECDH を含め、様々な楕円曲線暗号を解くことができます。さて主に攻撃対象となる楕円曲線暗号は以下のようなものがあります。\n\n1. 現在見つかっている最も高速なアルゴリズムで ECDLP を解く。計算量は $O(\\sqrt{\\#E/\\mathbb{F}_p})$ となる。\n2. $\\#E/\\mathbb{F}_p = p_1^{e_1}p_2^{e_2}\\ldots p_k^{e_k}$ (位数が Smooth number なとき) ならば位数 $p_i$ の小さな ECDLP に分解できる。それぞれ計算量は $O(\\sqrt{p_i})$ である。\n3. $\\#E/\\mathbb{F}_p = p$ (Anomalous なとき) ならば $\\mathbb{F}_p^+$ 上の DLP に帰着できる。\n4. $\\#E/\\mathbb{F}_p = p+1$ (Supersingular なとき) ならば埋め込み次数 $k$ を用いて $\\mathbb{F}_{p^k}^\\times$ 上の DLP に帰着できる。実践上 $k$ はそこまで大きくならない。\n5. $\\Delta(E/\\mathbb{F}_p) = 0$ (Singular なとき) ならば $\\mathbb{F}_p^+$ や $\\mathbb{F}_p^\\times, \\mathbb{F}_{p^2}^\\times$ 上の DLP に帰着できる。\n6. 楕円曲線上に存在しない点や位数の少ない点を指定できるならば秘密鍵の情報を取り出すことができる。\n\nそれぞれ\n\n### 1. ECDLP\n\n### 2. Polig-Hellman Attack\n\n### 3. MOV/FR Reduction\nMOV Reduction (Menezes-Okamoto-Vanstone Reduction)\nWeil-pairing\nFR Reduction (Frey-Rück Reduction)\nTate-pairing\n\nTate-pairing, Bilinear-pairingのいい資料がみつからない\n\n### 4. SSSA Attack / Supersingularな曲線を用いてはいけない\n$E/\\mathbb{F}_q, \\gcd(t, q) \u003e 1$ 埋め込み次数 $k\\leq6$ 全埋込み次数は既知\n$E[p]  \\mathbb{Z}/p\\mathbb{Z}$\n$\\pi:\\mathbb{P}^2(\\mathbb{Q}_p) \\to \\mathbb{P}^2(\\mathbb{F}_p)$\n$\\phi:\\ker\\pi \\to \\mathcal{E}(p\\mathbb{Z}_p)$\n\n\n### 5. Singularな曲線を用いてはいけない\n\nSingular な楕円曲線の場合、特異点が存在し、特異点には尖点 (cusp) 、節点 (node) の2種類がある。$c_4 = 0$ と尖点は同値である。\n\n$y = 0$ 上の特異点が原点 $O(0, 0)$ となるように平行移動させる。すると任意の Singular な楕円曲線は $y^2 = x^3 + kx^2$ の形となる。\n\n$$\n\\begin{aligned}\n\\begin{dcases}\nE(\\mathbb{F}_p) \\rightarrow \\mathbb{F}_p^+: (x,y)↦\\frac{x}{y},\u0026∞↦0 \u0026 (cuspのとき)\\\\\nE(\\mathbb{F}_p) \\rightarrow \\mathbb{F}_p^\\times: (x,y)↦\\frac{y + \\sqrt{k}x}{y - \\sqrt{k}x},\u0026∞↦1 \u0026 (nodeのとき) \\\\\n\\end{dcases}\n\\end{aligned}\n$$\n\n↑これはなぜ？\n\n### 6. Invalid Curve Attack\n\n\n### Weil decsent\n### ECFFT\n\n\nより面白い話題として楕円曲線暗号にバックドアが仕込まれていたという事件がある。\n- Dual EC DRBG\n\n構成\n- SIDH SIKE\n- ECDH\n- CSIDH\n\nhttps://blog.z.cash/new-snark-curve/ :  BLS12-381: New zk-SNARK Elliptic Curve Construction\nunefficient key recovery\n\nDiffie Hellman\nE/P/Q = E/Q/P\nECDDH\nE/P E/Q -\u003e E/PQ\n\nCall Stack Graph\nエラーが起きたところをいい感じにたどれる\n","lastmodified":"2022-10-26T11:26:57.35593449Z","tags":null},"/crypto/ECC/ECFFT":{"title":"ECFFT","content":"\n[ECFFT1.pdf (toronto.edu)](https://www.math.toronto.edu/swastik/ECFFT1.pdf)","lastmodified":"2022-10-26T11:26:57.35593449Z","tags":null},"/crypto/ECC/GHS-Attack":{"title":"GHS Attack","content":"Weil descent 攻撃とも呼ばれる","lastmodified":"2022-10-26T11:26:57.35593449Z","tags":null},"/crypto/ECC/Invalid-Curve-Attack":{"title":"Invalid Curve Attack","content":"\n## 説明\n\nざっくり言うと楕円曲線上に点が乗っていないときに位数が低くなることを利用する攻撃です。\n\n適当に選んだ数は小さな素数で割れやすい\nのと同じように\n\n\n[Google CTF Tiramisu write up (zenn.dev)](https://zenn.dev/kurenaif/articles/9cf509d9a15815)","lastmodified":"2022-10-26T11:26:57.35593449Z","tags":null},"/crypto/ECC/MOV-FR-Reduction":{"title":"MOV/FR Reduction","content":"\n## MOV Reduction\n$R=dP$ となるECDLPを解く\n\nWeil pairing $e_n: E[n]\\times E[n]\\to \\mu_n\\subseteq \\mathbb{F}_{p^k}^*$\n\n1. $E[n]\\subseteq E(\\mathbb{F}_{p^k})$ となる最小の $k$ を持ってくる\n2. 位数 $n$ の $\\alpha=e_n(P, Q)$ となるように $Q \\in E[n]$ を取ってくる\n3. $\\beta = e_n(dP, Q)$\n4. $\\mathbb{F}_{p^k}^*$ 上のDLPを $\\alpha, \\beta$ を用いて解く\n\n$k$ は多くとも6まで\n$E(\\mathbb{F}_{p^k}^*)\\cong\\mathbb{Z}_{c_1n_1}\\oplus\\mathbb{Z}_{c_2n_1}$\n\n","lastmodified":"2022-10-26T11:26:57.35593449Z","tags":null},"/crypto/ECC/Millar":{"title":"Millar","content":"","lastmodified":"2022-10-26T11:26:57.35593449Z","tags":null},"/crypto/ECC/Pohlig-Hellman":{"title":"Pohlig-Hellman Attack","content":"\n## 説明\n\n中国剰余定理を用いて大きな群を複数の小さな群の直積に分ける。\n\n楕円曲線暗号の楕円曲線の位数は細かく素因数分解できることが多い。\n\n楕円曲線の位数 $\\#E = p_1^{e_1}p_2^{e_2}\\ldots p_k^{e_k}$ と素因数分解できる。$Q = dP$ となるとき次のように $d_i$ を置く。\n\n$$\n\\begin{aligned}\nd_1 \u0026= d \\pmod{p_1^{e_1}} \\\\\nd_2 \u0026= d \\pmod{p_2^{e_2}} \\\\\n\u0026\\vdots \\\\\nd_k \u0026= d \\pmod{p_k^{e_k}} \\\\\n\\end{aligned}\n$$\n\nそれぞれの $d_i$ について次のように書ける。\n\n$$\nd_i=z_0+z_1p_i+z_2p_i^2+\\ldots+z_{e_i−1}p_i^{e_i−1} \\pmod{p_i^{e_i}} \\quad (∀k:z_k \\in [0,p_i))\n$$\n\nここで $P_{i,j}=\\frac{\\#E}{p_i^j}P, Q_i=\\frac{\\#E}{p_i^j}Q$ とおくと\n\n$$\nQ_{i,1} = d_{i,1}P_{i,1} = (z_0+z_1p_i+z_2p_i^2+\\ldots+z_{e_i−1}p_i^{e_i−1})P_{i,1} = z_0P_i\n$$\n\nとなり, $z_0 \u003c p_i$ である $Q_i = z_0P_i$ についてDLPを解けば良い。\n\n他については $Q_i' = (Q_i - z_0P_i) / p_i$ とおいて同様に解けると思っていたけど除算は ECC の DDH 問題から不可能っぽいので $p_i^{e_i}$ 全探索するしかないかも。\n\n## 実装\n\n```python\nfact = factor(G.order())\nord = int(G.order())\ndlogs = []\nfor p, e in fact:\n    t = ord // p ^ e\n    dlog = discrete_log(t * Q, t * G, operation=\"+\")\n    dlogs += [dlog]\n\nprint(crt(dlogs, primes))\n```\n\n## 使用例\n\n## 参考\n","lastmodified":"2022-10-26T11:26:57.35593449Z","tags":null},"/crypto/ECC/SIKE":{"title":"Attacks on SIKE","content":"\n[Attacks on SIDH/SIKE | ellipticnews (wordpress.com)](https://ellipticnews.wordpress.com/2022/08/12/attacks-on-sidh-sike/)\n[jack4818/Castryck-Decru-SageMath: A SageMath implementation of the Castryck-Decru Key Recovery attack on SIDH (github.com)](https://github.com/jack4818/Castryck-Decru-SageMath)","lastmodified":"2022-10-26T11:26:57.35593449Z","tags":null},"/crypto/ECC/SSSA-Attack":{"title":"SSSA Attack","content":"\n## 説明\n$$\n\\newcommand{\\calO}{\\mathcal{O}}\n\\newcommand{\\FF}{\\mathbb{F}}\n\\newcommand{\\tE}{\\tilde{E}}\n\\newcommand{\\ZZ}{\\mathbb{Z}}\n\\newcommand{\\QQ}{\\mathbb{Q}}\n\\DeclareMathOperator{\\Ker}{Ker}\n\\DeclareMathOperator{\\ord}{ord}\n$$\n## Definition\n- $\\FF_p$\n    - 素数$p$に対して$p$個の元からなる有限体\n    - 素数$p$の剰余群\n    - $\\mathbb{Z}/p\\mathbb{Z}$\n- $\\mathbb{Q}_p$\n    - p進数体\n    - $27=2.5+2.25 + 27.125 + O(5^4)$ 射影極限による導入\n    - $27 = 2 + 5^2 + O(5^3)$ p進展開による導入\n    - $\\mathbb{Q}$のp進付値による完備化をする導入\n    - $n\\times 100 = n.10^{-2}$\n- $\\mathbb{Z}_p$\n    - p進整数環\n    - $Q_p$の整数部分\n    - 論文にも注釈があるが$\\mathbb{Z}/n\\mathbb{Z}$の略記$\\mathbb{Z}_n$とは別物\n- $\\mathbb{Z}\\text{-algebra}$に対する$\\mathbb{P}^n(R)$\n    - $\\mathbb{Z}$から$R$への凖同型がある\n    - 雪江代数学2巻 Def. 1.3.13 (p.15)の定義\n      + $k, A$を環とする.　$k$から$A$への準同型があるとき, $A$を$k$代数, あるいは$k$上の代数という.\n- $\\calO=(0 : 1 : 0)$で楕円曲線の群演算に関する単位元\n- 持ち上げ\n    - 準同型の移動\n- Rが体のとき$E(R)$は群であることは受け入れる\n- $\\mathscr{L}$は同型写像\n\n$\\mathbb{Q}_p$, $\\mathbb{Z}_p$ はそれぞれp進体、p進整数環とする。\n\n次の同型写像 $\\lambda_E$ を用いて楕円曲線 $\\tilde{E}(\\mathbb{F}_p)$ 上が $\\mathbb{F}_p$ 上の DLP、つまり $\\bmod p$ の割り算に帰結する。\n\n$$\n\\lambda_E \\colon \\tilde{E}(\\mathbb{F}_p) \\overset{u}{\\to} E(\\mathbb{Q}_p)\\xrightarrow{p倍}\\ker\\pi \\xrightarrow{\\mathscr{L}} p\\mathbb{Z}_p\\xrightarrow{\\bmod p^2}p\\mathbb{Z}_p/p^2 \\mathbb{Z}_p\\simeq \\mathbb{F}_p\n$$\n\n\n\n## 参考\n\n[Fermat Quotient と Anomalous 楕円曲線の離散対数の多項式時間解法アルゴリズムについて(代数的整数論とその周辺)](https://repository.kulib.kyoto-u.ac.jp/dspace/bitstream/2433/61761/1/1026-15.pdf)\n","lastmodified":"2022-10-26T11:26:57.35593449Z","tags":null},"/crypto/ECC/Schoof":{"title":"Schoof Algorithm","content":"\nHasse-Weil 定理より\n\n$$\nq+1-2\\sqrt{q}\\leq\\#E(\\mathbb{F}_q)\\leq q+1+2\\sqrt{q}\n$$\n\n$\\#E(\\mathbb{F}_q)=q+1+t$ とおける。$\\mathbb{F}_q$ のフロベニウス写像 $\\sigma$ のトレース $t$ を計算できれば位数が求まる。しかし $t$ は $2\\sqrt{q}$ のオーダーであるため、直接計算できない。そこで素数 $l$ を剰余にとってそれぞれの $t$ の値を求め、中国剰余定理によって $t$ を求める。\n\n具体的には特性多項式の $t$ に $0,\\ldots,\\frac{l-1}{2}$ の値を代入して確かめる。\n\n$$\n\\begin{aligned}\n\\sigma_q^2-t\\sigma_q+q \u0026= 0 \\\\\n\\pm[t_l]\\circ\\sigma_q \u0026= \\sigma_q^2+[q_l]\n\\end{aligned}\n$$\n\n1つの $l$ 等分点 $P$ に対して成り立てばすべての $l$ 等分点に対して成り立つ。\n","lastmodified":"2022-10-26T11:26:57.35593449Z","tags":null},"/crypto/Hash/DifferencialCryptoanalysis":{"title":"Differencial cryptoanalysis","content":"\n\nhttps://github.com/aappleby/smhasher/wiki/MurmurHash2Flaw\n\nDifferencial cryptanalysis\nこれはハッシュ関数の実装に踏み込む手法である. スケッチとしては何かしらのパラメータが同じなどの特殊な場合のとき, 簡約化ができ, 単純な算術演算による条件式をいくつか生成できる. これを SMT で解くらしい.\n","lastmodified":"2022-10-26T11:26:57.35593449Z","tags":null},"/crypto/Hash/hash":{"title":"ハッシュ関数","content":"\n## 説明\n\n- 原像計算困難性 与えられた $h$ に対して $H(m) = h$ となる $m$ を見つけることが困難である．\n- 第二原像計算困難性 $m1$ が与えられたときに $H(m1) = H(m2)$ となる $m2(̸= m1)$ を求めるのが困難である．\n- 衝突困難性 相異なる $m1$ と $m2$ で，$H(m1) = H(m2)$ となるメッセージを見つけることが困難である．\n\nHMAC (Hash-based MAC)\n\n伸長攻撃\n- Merkle-Damgård construction","lastmodified":"2022-10-26T11:26:57.35593449Z","tags":null},"/crypto/Lattice/BKZ":{"title":"BKZ(Block Korkine-Zolotareff) 基底簡約","content":"\n## 説明\n\nHKZ(Hermite-Korkine-Zolotareff) 基底簡約\n\n1. サイズ基底簡約\n2. 条件に合うように基底ベクトルの交換\n\n## 計算量\n\n\n## 実装\n\n\n## 使用例\n\n## 参考\n","lastmodified":"2022-10-26T11:26:57.35593449Z","tags":null},"/crypto/Lattice/GSO":{"title":"Gram-Schmidt の直交化 (GSO: Gram-Schmidt Orthonormalization)","content":"\n## 説明\n\n### Gram-Schmidt の直交化 (GSO: Gram-Schmidt Orthonormalization)\n\n任意の $R$ ベクトル空間直交化\nベクトルをGSO化させることで任意の2つのベクトルの内積が0となる、つまり直交化できます。イメージは[Wikipedia](https://ja.wikipedia.org/wiki/%E3%82%B0%E3%83%A9%E3%83%A0%E3%83%BB%E3%82%B7%E3%83%A5%E3%83%9F%E3%83%83%E3%83%88%E3%81%AE%E6%AD%A3%E8%A6%8F%E7%9B%B4%E4%BA%A4%E5%8C%96%E6%B3%95)のgifがわかりやすいです。$\\mathbf{b}_n$ の直交化は $\\mathbf{b}_{1},\\ldots, \\mathbf{b}_{n-1}$ までと直行するように高さを保持しながら移動させる。\n\n$$\n\\begin{aligned}\n\\begin{dcases}\n\\mathbf{b}_1^* = \\mathbf{b}_1 \\\\\n\\mathbf{b}_i^* = \\mathbf{b}_i - \\sum\\limits_{j=1}^{i-1} \\mu_{i, j}\\mathbf{b}_j^* \\qquad \\left( \\mu_{i, j} = \\frac{\\langle \\mathbf{b}_i, \\mathbf{b}_j^* \\rangle}{\\| \\mathbf{b}_j^* \\|^2} \\right) \\\\\n\\end{dcases}\n\\end{aligned}\n$$\n\n$$\n\\begin{aligned}\nB \u0026=\n\\begin{pmatrix}\n\\mathbf{b}_1 \\\\\n\\mathbf{b}_2 \\\\\n\\mathbf{b}_3 \\\\\n\\mathbf{b}_4 \\\\\n\\end{pmatrix}\n\u0026 U \u0026=\n\\begin{pmatrix}\n1 \u0026 0 \u0026 0 \u0026 0 \\\\\n\\mu_{2,1} \u0026 1 \u0026 0 \u0026 0 \\\\\n\\mu_{3,1} \u0026 \\mu_{3,2} \u0026 1 \u0026 0 \\\\\n\\mu_{4,1} \u0026 \\mu_{4,2} \u0026 \\mu_{4,3} \u0026 1 \\\\\n\\end{pmatrix}\n\u0026 B^* \u0026=\n\\begin{pmatrix}\n\\mathbf{b}_1^* \\\\\n\\mathbf{b}_2^* \\\\\n\\mathbf{b}_3^* \\\\\n\\mathbf{b}_4^* \\\\\n\\end{pmatrix} \\\\\n\\end{aligned}\n$$\n\n$$\nB = UB^*\n$$\n\nこれらをGSOベクトル $\\mathbf{b}_i^*$ , GSO係数 $\\mu_{i, j}$ と呼びます。\n\n\n\n## 計算量\n\n\n## 実装\n\n{% include python.html code=\"crypto/Lattice/LLL_reduction.sage\" %}\n\n## 使用例\n\n## 参考\n","lastmodified":"2022-10-26T11:26:57.35593449Z","tags":null},"/crypto/Lattice/LLL":{"title":"LLL 基底簡約","content":"\n## 説明\n\n$n$ 次元格子 $L$ の基底 $\\lbrace\\mathbf{b_1},\\ldots,\\mathbf{b_n}\\rbrace$ について以下の条件を満たすとき、その基底は LLL 簡約されている (Lenstra-Lenstra-Lovasz(LLL)-reduced)と呼ぶ。\n\n1. 基底 $\\lbrace\\mathbf{b_1},\\ldots,\\mathbf{b_n}\\rbrace$ がサイズ簡約されている。\n2. Lovasz条件: 任意の $2 \\leq k \\leq n$ に対して $\\delta\\|\\mathbf{b}_{k-1}^*\\| \\leq \\|\\pi_{k-1}(\\mathbf{b}_{k-1})\\|$ を満たす。ただし、各 $1 \\leq l \\leq n$ に対して、$\\pi_l$ は $\\mathbb{R}$-ベクトル空間 $\\langle\\mathbf{b} _1,\\ldots,\\mathbf{b} _{l-1}\\rangle _\\mathbb{R}$ の直交補空間への直交射影とする。\n\nこれに対し、LLL 基底簡約アルゴリズムは次のように行う。\n\n1. サイズ簡約する。\n2. Lovasz条件を満たすように隣り合う基底ベクトルを交換する。\n\n基底ベクトルを交換した際に GSO ベクトルも更新しなければならない。高速化出来る。\n\nさらに LLL について精度を上げたり、機能を拡張することができ、DeepLLLやMLLLなどの手法がある。\n\n- LLL は隣り合う基底ベクトルのみを比較するが、DeepLLL は全ての基底ベクトルを比較する。\n- MLLL は一次従属なベクトルでも適用できる。\n\n## 計算量\n\n\n## 実装\n\n```\ndef LLL(B, delta):\n    n = len(B)\n    assert 1 / 4 \u003c delta \u003c 1\n    B = matrix(B)\n    i = 1\n    G, mu = B.gram_schmidt()\n    while i \u003c n:\n        for j in range(i - 1, -1, -1):\n            print(i, j)\n            if mu[i][j].abs() \u003e 1 / 2:\n                q = mu[i][j].round()\n                B[i] -= q * B[j]\n                mu[i] -= q * mu[j]\n        if B[i].norm() \u003e= (delta - mu[i][i - 1] ^ 2) * B[i - 1].norm():\n            i += 1\n        else:\n            B[i - 1], B[i] = B[i], B[i - 1]\n            mu = GSOUpdate(B, mu, i)\n            i = max(i - 1, 1)\n    return B\n\n\ndef GSOUpdate(B, mu, i):\n    n = B.nrows()\n    nu = mu[i][i - 1]\n    b = B[i] + nu ^ 2 * B[i - 1]\n    print(nu, B[i - 1], b)\n    mu[i][i - 1] = nu * B[i - 1] / b\n    B[i] = B[i] * B[i - 1] / b\n    B[i - 1] = b\n    for j in range(i - 1):\n        mu[i - 1][j], mu[i][j] = mu[i][j], mu[i - 1][j]\n    for k in range(i + 1, n):\n        t = mu[k][i]\n        mu[k][i] = mu[k][i - 1] - nu * t\n        mu[k][i - 1] = t + mu[i][i - 1] * mu[k][i]\n    return mu\n```\n\n## 使用例\n\n```python\nB = [vector([5, -3, -7]), vector([2, -7, -7]), vector([3, -10, 0])]\nprint(LLL(B, 0.8))\n```\n\n## 参考\n\n","lastmodified":"2022-10-26T11:26:57.35593449Z","tags":null},"/crypto/Lattice/Lagrange":{"title":"Lagrange 基底簡約 (Gauss 基底簡約)","content":"\n## 説明\n\n任意の $q \\in \\mathbb{Z}$ に対して\n\n$$\n\\|\\mathbf{b}_1\\| \\leq \\|\\mathbf{b}_2\\| \\leq \\|\\mathbf{b}_1 + q\\mathbf{b}_2\\|\n$$\n\nを満たすとき、2次元格子の基底 $\\\\{\\mathbf{b}_1, \\mathbf{b}_2\\\\}$ はLagrange 簡約されているという。\n\nEuclidの互除法を2次元格子に対して行うことで Lagrange 簡約されているような基底を生み出せる。\n\n## 計算量\n\n$O(\\log{N})$\n\n\n## 実装\n\n```python\ndef lagrange(b1, b2):\n    if b1.norm() \u003e b2.norm():\n        b1, b2 = b2, b1\n    while b1.norm() \u003c b2.norm():\n        q = - round(b1.dot_product(b2) / b1.norm() ^ 2)\n        b1, b2 = b2 + q * b1, b1\n    return b2, b1\n```\n\n## 使用例\n\n## 参考\n","lastmodified":"2022-10-26T11:26:57.35593449Z","tags":null},"/crypto/Lattice/Lattice":{"title":"格子","content":"\n## 説明\n\n### 格子 (Lattice)\n\n図でイメージ掴むのが速い\n\n線形独立な $n$ 個のベクトル $\\mathbf{b}_1, \\mathbf{b}_2, \\ldots , \\mathbf{b}_n \\in \\mathbb{R}^m$ について整数係数の線形結合によって生成されるベクトルの集合を格子 $L$ と定義します。\n\n$$\nL = \\left\\{ \\sum_{i=0}^{n} a_i\\mathbf{b}_i \\ \\middle| \\ a_i \\in \\mathbb{Z} \\right\\}\n$$\n\n### Shortest Vector Problem(SVP)\n\n格子上の非零なベクトルの中で最もノルムが小さなベクトルを見つけ出す問題です。\nそのベクトルを $\\mathbf{v}$ とおくと次のように表せられます。\n\n$$\n\\mathbf{v} = v_1\\mathbf{b}_1 + \\ldots + v_n\\mathbf{b}_n \\qquad (\\exists v_1, \\ldots , v_n \\in \\mathbb{Z}) \\\\\n$$\n\nこの問題はNP困難\n\n#### 最短ベクトルの数え上げ\n\nまずは全探索してみます。\n考えてみると帰納的に求めるのでは正確な最短ベクトルは求められないでしょう。\n考えてみるとある基底 $\\mathbf{b}_i$ に対し、それ以下の基底 $\\mathbf{b}_1, \\ldots \\mathbf{b}_{i-1}$ で組み立てられたベクトル $\\mathbf{v}$ に対し、$\\mathbf{b}_i$ を用いて短くする\n\n効率的に数え上げる為には基底簡約すると良いということが知られています。\n\n\n## 使用例\n\n## 参考\n\n\n","lastmodified":"2022-10-26T11:26:57.35593449Z","tags":null},"/crypto/Lattice/TFHE":{"title":"TFHE (Torus Fully Homomorphic Encryption)","content":"\n## 説明\n\n完全準同型暗号の1つ\n\n完全なる Zero Trust なサーバーを作れる。\n\n## 参考\n\n- [セキュキャンの資料](https://nindanaoto.github.io/)\n","lastmodified":"2022-10-26T11:26:57.359934474Z","tags":null},"/crypto/Lattice/size_reduction":{"title":"サイズ基底簡約","content":"\n## 説明\n\n$n$ 次元格子 $L$ の基底 $\\\\{\\mathbf{b_1},\\ldots,\\mathbf{b_n}\\\\}$ を GSO 係数 $\\mu_{i,j}$ が\n\n$$\n|\\mu_{i,j}| \\leq \\frac{1}{2} \\quad (1 \\leq \\forall j \u003c \\forall i \\leq n)\n$$\n\nを満たすとき、基底 $\\\\{\\mathbf{b_1},\\ldots,\\mathbf{b_n}\\\\}$ はサイズ簡約されているという。\n\n## 計算量\n\n\n## 実装\n\n```python\ndef size_reduction(B):\n    n = len(B)\n    B = matrix(B)\n    G, mu = B.gram_schmidt()\n    for i in range(n):\n        for j in range(i - 1, -1, -1):\n            if mu[i][j].abs() \u003e 1 / 2:\n                q = mu[i][j].round()\n                B[i] -= q * B[j]\n                mu[i] -= q * mu[j]\n    return B\n```\n\n## 使用例\n\n```python\nB = [vector([5, -3, -7]), vector([2, -7, -7]), vector([3, -10, 0])]\nprint(size_reduction(B))\n```\n\n## 参考\n\n","lastmodified":"2022-10-26T11:26:57.359934474Z","tags":null},"/crypto/Lattice/tour_of_Lattice":{"title":"Tour of Lattice","content":"\n# 格子暗号を極める！\n\n無限工事編\n\n## はじめに\n\n// TODO 説明\n耐量子暗号です！あとはセキュキャンで話題のTFHEとか紹介したいな\n\nこれは大学1年で習う線形代数を前提知識として扱います。\n\n- 量子アルゴリズムはどこで解説すべき？\n\t- 暗号関連で解説すべきなのはGroverとShorのアルゴリズムの2つだけやが量子コンピューター上の演算や量子フーリエが前提知識無しやとキツイかもしれん。\n\t- 量子コンピュータという題材で分けた方が良さそう？本に頼ればいいは一理あるが論文以外の文献は未だ少なく暗号専門の解説がほしいところ\n\t- 自分の文章力と時間に要相談ということで\n\n## 格子 (Lattice)\n\n図でイメージ掴むのが速い\n\n線形独立な $n$ 個のベクトル $\\mathbf{b}_1, \\mathbf{b}_2, \\ldots , \\mathbf{b}_n \\in \\mathbb{R}^m$ について整数係数の線形結合によって生成されるベクトルの集合を格子 $L$ と定義します。\n\n$$\nL = \\left\\{ \\sum_{i=0}^{n} a_i\\mathbf{b}_i \\ \\middle| \\ a_i \\in \\mathbb{Z} \\right\\}\n$$\n\n化学の格子っぽいもの\n\n格子 $L$ に囲まれた空間を1つ\n具体例\n\n### 困難な問題\n\n今回のキーとなる問題です\n\nSVP\nCVP\n\nnear SVP\nnear CVP\n\n### LWE格子暗号\n\n機械学習理論から派生した求解困難な問題で、有限体 $\\mathbb{F}_q$ 上の秘密ベクトル $\\mathbf{s} \\in \\mathbb{F}_q^n$ に関するランダムな連立線形「近似」方程式が与えられたとき、その秘密ベクトルを復元する問題である。\n\n\n\n\n### Gram-Schmidt の直交化 (GSO: Gram-Schmidt Orthonormalization)\n\n任意の $R$ ベクトル空間直交化\nベクトルをGSO化させることで任意の2つのベクトルの内積が0となる、つまり直交化できます。イメージは[Wikipedia](https://ja.wikipedia.org/wiki/%E3%82%B0%E3%83%A9%E3%83%A0%E3%83%BB%E3%82%B7%E3%83%A5%E3%83%9F%E3%83%83%E3%83%88%E3%81%AE%E6%AD%A3%E8%A6%8F%E7%9B%B4%E4%BA%A4%E5%8C%96%E6%B3%95)のgifがわかりやすいです。$\\mathbf{b}_n$ の直交化は $\\mathbf{b}_{1},\\ldots, \\mathbf{b}_{n-1}$ までと直行するように高さを保持しながら移動させる。\n\n$$\n\\begin{aligned}\n\\begin{dcases}\n\\mathbf{b}_1^* = \\mathbf{b}_1 \\\\\n\\mathbf{b}_i^* = \\mathbf{b}_i - \\sum\\limits_{j=1}^{i-1} \\mu_{i, j}\\mathbf{b}_j^* \\qquad \\left( \\mu_{i, j} = \\frac{\\langle \\mathbf{b}_i, \\mathbf{b}_j^* \\rangle}{\\| \\mathbf{b}_j^* \\|^2} \\right) \\\\\n\\end{dcases}\n\\end{aligned}\n$$\n\n$$\n\\begin{aligned}\nB \u0026=\n\\begin{pmatrix}\n\\mathbf{b}_1 \\\\\n\\mathbf{b}_2 \\\\\n\\mathbf{b}_3 \\\\\n\\mathbf{b}_4 \\\\\n\\end{pmatrix}\n\u0026 U \u0026=\n\\begin{pmatrix}\n1 \u0026 0 \u0026 0 \u0026 0 \\\\\n\\mu_{2,1} \u0026 1 \u0026 0 \u0026 0 \\\\\n\\mu_{3,1} \u0026 \\mu_{3,2} \u0026 1 \u0026 0 \\\\\n\\mu_{4,1} \u0026 \\mu_{4,2} \u0026 \\mu_{4,3} \u0026 1 \\\\\n\\end{pmatrix}\n\u0026 B^* \u0026=\n\\begin{pmatrix}\n\\mathbf{b}_1^* \\\\\n\\mathbf{b}_2^* \\\\\n\\mathbf{b}_3^* \\\\\n\\mathbf{b}_4^* \\\\\n\\end{pmatrix} \\\\\n\\end{aligned}\n$$\n\n$$\nB = UB^*\n$$\n\nこれらをGSOベクトル $\\mathbf{b}_i^*$ , GSO係数 $\\mu_{i, j}$ と呼びます。\n\n具体例\n### Shortest Vector Problem(SVP)\n\n格子上の非零なベクトルの中で最もノルムが小さなベクトルを見つけ出す問題です。\nそのベクトルを $\\mathbf{v}$ とおくと次のように表せられます。\n\n$$\n\\mathbf{v} = v_1\\mathbf{b}_1 + \\ldots + v_n\\mathbf{b}_n \\qquad (\\exists v_1, \\ldots , v_n \\in \\mathbb{Z}) \\\\\n$$\n\nこの問題はNP困難\n\n#### 最短ベクトルの数え上げ\n\nまずは全探索してみます。\n考えてみると帰納的に求めるのでは正確な最短ベクトルは求められないでしょう。\n考えてみるとある基底 $\\mathbf{b}_i$ に対し、それ以下の基底 $\\mathbf{b}_1, \\ldots \\mathbf{b}_{i-1}$ で組み立てられたベクトル $\\mathbf{v}$ に対し、$\\mathbf{b}_i$ を用いて短くする\n\n効率的に数え上げる為には基底簡約すると良いということが知られています。\n\n#### Lagrange 基底簡約 (Gaussian Reduction)\n\nサイズ基底簡約\nGSO ベクトルを簡約 -\u003e 基底ベクトルを簡約\nGSO 係数 $μ_{i,j}$ について\n\n$$\n\\|μ_{i,j}\\| \\leq \\frac{1}{2} \\qquad (\\forall 0 \\leq i \u003c j \u003c n)\n$$\n\nEuclid の互除法を用いて基底の簡約化をする。\n具体例\n\n#### LLL(Lenstra-Lenstra-Lovasz) 基底簡約\n\nLagrange 基底簡約に Lovasz 条件を追加した基底簡約を LLL 基底簡約と呼びます。\nLovasz条件 $\\frac{1}{4} \u003c \\delta \u003c 1$ として\n\n$$\n\\delta \\|b_{k-1}^*\\|^2 \\leq \\|\\pi_{k-1}(b_k)\\|^2\n$$\n\n1. サイズ基底簡約\n2. 条件に合うように基底ベクトルの交換\n\n具体例\n\n#### BKZ(Block Korkine-Zolotareff) 基底簡約\n\nHKZ(Hermite-Korkine-Zolotareff) 基底簡約\n\n1. サイズ基底簡約\n2. 条件に合うように基底ベクトルの交換\n\n具体例\n\n### Closest Vector Problem(CVP)\n\n#### Babai’s Algorithm\n\n#### Kannan’s embedding method\n","lastmodified":"2022-10-26T11:26:57.359934474Z","tags":null},"/crypto/Note":{"title":"Note","content":"\n# Crypto in CTF writeup\n[Crypto in CTF :: Mystify (mystiz.hk)](https://mystiz.hk/crypto-in-ctf/) を解いていく。\n\n## Q3 2021\n## Pwn2Win CTF 2021\n### t00 rare\n- ECDSAで署名/検証ができるが、特定のハッシュ値のときは不可\n- $q=q_1q_2+1$ として秘密鍵が $x=(7^{q_2})^y$, $P = kG$, $s=\\frac{h+rx}{k}\\iff P=\\frac{h+rx}{s}G\\iff g^yG=r^{-1}(sP-hG)$ である\n- 特定のハッシュ値のとき $kP=G$ を求める\n\n#### 解法\n- $h+q$ でバイパス\n- BSGSで $g^yG$ の $y$ を求める\n- 高速なライブラリfastecdsaを使う\n\n### A2S\n- AESのラウンドを10回から2回に変更\n\n#### 解法\n\n## 0CTF 2021 Quals\n### zer0lfsr-\n\n\n## Crypto CTF 2022\n","lastmodified":"2022-10-26T11:26:57.359934474Z","tags":null},"/crypto/PRNG/MersenneTwister":{"title":"メルセンヌ ツイスタ","content":"\n## 説明\n\n長い周期 $2^{19937}-1$ を持つ疑似乱数生成器。連続した624回の32ビット出力から内部状態を復元できてしまう。\n2つの値で十分のときもあるらしい\nhttps://www.ambionics.io/blog/php-mt-rand-prediction\n\n## 参考\n\n- [メルセンヌ・ツイスタをわかった気になる](https://6715.jp/posts/5/)\n- [Mersenne Twisterの出力を推測してみる](https://inaz2.hatenablog.com/entry/2016/03/07/194147)","lastmodified":"2022-10-26T11:26:57.359934474Z","tags":null},"/crypto/RSA/Boneh-DurfeeAttack":{"title":"Boneh-Durfee Attack","content":"\n## 説明\n\n$e$ が大きすぎると以下の式に対し Coppersmith Method を用いて攻撃できる。\n\n$$\n\\begin{aligned}\ned \u0026= 1 \u0026 \\pmod{\\phi} \\\\\ned \u0026= k \\phi + 1 \u0026 (\\mathrm{over}\\ \\mathbb{Z}) \\\\\n0 \u0026= k \\phi + 1 \u0026 \\pmod e \\\\\n\u0026= k (N + 1 - p - q) + 1 \u0026 \\pmod e \\\\\n\u0026= 2k \\left(\\frac{N + 1}{2} + \\frac{-p -q}{2}\\right) + 1 \u0026 \\pmod e \\\\\n\\end{aligned}\n$$\n\n## 実装\n\n```python\nload('coppersmith.sage')\n\ndef boneh_durfee(N, e):\n    bounds = (floor(N^.25), 2^1024)\n    P.\u003ck, s\u003e = PolynomialRing(Zmod(e))\n    f = 2*k*((N+1)//2 - s) + 1\n    print(small_roots(f, bounds, m=3, d=4))\n```\n\n## 使用例\n","lastmodified":"2022-10-26T11:26:57.359934474Z","tags":null},"/crypto/RSA/CommonModulusAttack":{"title":"Common Modulus Attack","content":"\n## 説明\n\n共通の平文を異なる $e$ で暗号化した暗号文が分かっているとき平文を求められる。\n\n$$\n\\begin{aligned}\nc_1 \u0026≡ m^{e_1} \u0026 \\pmod N \\\\\nc_2 \u0026≡ m^{e_2} \u0026 \\pmod N \\\\\n\\gcd(e_1, e_2) \u0026= s_1e_1 + s_2e_2 \\\\\nc_1^{s_1} c_2^{s_2} \u0026= m^{s_1e_1 + s_2e_2} = m^{\\gcd(e_1, e_2)} \u0026 \\pmod N\n\\end{aligned}\n$$\n\n## 実装\n\n\n## 使用例\n","lastmodified":"2022-10-26T11:26:57.359934474Z","tags":null},"/crypto/RSA/Franklin-ReiterRelatedMessageAttack":{"title":"Franklin-Reiter Related Message Attack","content":"\n## 説明\n\n$f(m_1) = m_2$\n$m_1 = pad_1 + m, m_2 = pad_2 + m, m_2 = m_1 + (pad_2 - pad_1)$\n\n$$\n\\begin{aligned}\nc_1 \u0026= m_1^{e_1} \u0026 \\pmod N \\\\\nc_2 \u0026= m_2^{e_2} = f(m_1)^{e_2} \u0026 \\pmod N \\\\\nx - m_1 \u0026= \\gcd(x^{e_1} - c_1, f(x)^{e_2} - c_2) \u0026 \\pmod N \\\\\n\\end{aligned}\n$$\n\n## 実装\n\n\n## 使用例\n\n\n## 参考\n\n","lastmodified":"2022-10-26T11:26:57.359934474Z","tags":null},"/crypto/RSA/H%C3%A5stadsBroadcastAttack":{"title":"Håstad’s Broadcast Attack","content":"\n## 説明\n\n平文を互いに素な $N_1, \\ldots, N_e$ で暗号化された暗号文が分かっているとき、中国剰余定理を用いて $m$ を求められる。\n\n$$\n\\begin{aligned}\nc_1 \u0026≡ m^e \\pmod{N_1} \\\\\nc_2 \u0026≡ m^e \\pmod{N_2} \\\\\n\\vdots \\\\\nc_e \u0026≡ m^e \\pmod{N_e} \\\\\nm^e \u0026≡ CRT(c_1, c_2, \\dots , c_e) \\pmod{N_1N_2\\cdots N_e} \\\\\nm^e \u0026= CRT(c_1, c_2, \\dots , c_e)\n\\end{aligned}\n$$\n\n## 実装\n\n\n## 使用例\n\n## 関連\n\n- [They Were Eleven - BSides Ahmedabad CTF 2021 author's writeup](https://furutsuki.hatenablog.com/entry/2021/12/07/020611)\n","lastmodified":"2022-10-26T11:26:57.359934474Z","tags":null},"/crypto/RSA/LSB-DecryptionOracleAttack":{"title":"LSB Decryption Oracle Attack","content":"\n## 説明\n\n全てが分かっていなくとも偶奇さえ分かれば任意の暗号文を復号できる。\nある暗号文 $c$ に対し、$2^e$ をx回掛けた値を復号した下位1bitを得て平文を求めます。得られる下位1bitは次の関数 $f(x)$ を用いて $f(x) \\bmod 2$ と表せられます。decは復号化関数です。\n\n$$\n\\begin{aligned}\nf(x) \u0026= Dec(2^{ex}c \\bmod N) = 2^xm \\bmod N \\\\\n\\end{aligned}\n$$\n\n$x = 1$ のとき\nまず $0 \\leq m \u003c N$ であるから $f(1)$ は $2m \\bmod N = 2m, 2m - N$ のどちらかとなる。また $2m$ は偶数、$N$ は奇数であるから $f(1)$ が偶数か奇数かで $2m, 2m - N$ のどちらかが分かります。すると $m$ が存在する区間が分かります。\n\n$$\n\\begin{aligned}\n\u0026f(1) = 2m \\bmod N \\\\\n\u0026\n\\begin{cases}\n    f(1) \\bmod 2 = 1 \\Leftrightarrow f(1) = 2m - N \u0026 \\Leftrightarrow \\frac{N}{2} \\leq m \u003c N \\\\\n    f(1) \\bmod 2 = 0 \\Leftrightarrow f(1) = 2m \u0026 \\Leftrightarrow 0 \\leq m \u003c \\frac{N}{2} \\\\\n\\end{cases}\n\\end{aligned}\n$$\n\nつまり $m$ は $[0, N)$ の範囲に対して最下位ビットが1のとき区間の右半分、0のとき区間の左半分だと言えます。\n\n$x = 2$ のとき\n前の結果を用いて場合分けして考えると同様の考え方で次のように導けます。\n\n$$\n\\begin{aligned}\nf(2) \u0026= 2(2m \\bmod N) \\bmod N \\\\\nf(1) \u0026= 2m - N \\Rightarrow f(2) = 4m - 2N \\bmod N \\\\\n\u0026\n\\begin{cases}\n    f(2) \\bmod 2 = 1 \\Leftrightarrow f(2) = 4m - 3N \u0026 \\Leftrightarrow \\frac{3N}{4} \\leq m \u003c N \\\\\n    f(2) \\bmod 2 = 0 \\Leftrightarrow f(2) = 4m - 2N \u0026 \\Leftrightarrow \\frac{N}{2} \\leq m \u003c \\frac{3N}{4} \\\\\n\\end{cases}\n\\\\\nf(1) \u0026= 2m \\Rightarrow f(2) = 4m \\bmod N \\\\\n\u0026\n\\begin{cases}\n    f(2) \\bmod 2 = 1 \\Leftrightarrow f(2) = 4m - N \u0026 \\Leftrightarrow \\frac{N}{4} \\leq m \u003c \\frac{N}{2} \\\\\n    f(2) \\bmod 2 = 0 \\Leftrightarrow f(2) = 4m \u0026 \\Leftrightarrow 0 \\leq m \u003c \\frac{N}{4} \\\\\n\\end{cases}\n\\end{aligned}\n$$\n\nつまり $m$ は $[0, N/2)$ 、 $[N/2, N)$ のそれぞれの範囲に対して最下位ビットが1のとき区間の右半分、0のとき区間の左半分だと言えます。\n\n$x \\geq 3$ のときも同様に行って $m$ の値を求めることができます。\n\n## 実装\n\n\n## 使用例\n\n\n## 参考\n\n","lastmodified":"2022-10-26T11:26:57.359934474Z","tags":null},"/crypto/RSA/NoInverse":{"title":"逆元が存在しないとき","content":"\n## 説明\n\n乗法群の位数が $\\phi(N) = se^n = 0 \\pmod e$ のとき $e$ の逆元が取れない。このとき、位数 $s$ の乗法群に落として逆元を取り、位数 $se^n$ の元を $e^n$ 回掛けて全探索すると平文が見つかる。\n\n## 計算量\n\n$O(e^n)$\n\n## 実装\n\n\n## 使用例\n\n\n## 参考\n\n[p - 1 ≡ 0 (mod e) のときの RSA 復号方法](https://blog.y011d4.com/20201026-not-coprime-e-phi)\n","lastmodified":"2022-10-26T11:26:57.359934474Z","tags":null},"/crypto/RSA/PartialKeyExposureAttack":{"title":"Partial Key Exposure Attack","content":"\n## 説明\n\n秘密鍵を部分的に知っていさえいれば、Coppersmith Method を用いて解けてしまう。\n$n$ を $N$ のビット数とする。\n\n### $p, q$ のどちらかを $n/4$ ビット程度知っているとき\n\n$$\n\\begin{aligned}\nf(x) \u0026= p_{upper} + x \u0026 \\pmod p \\\\\nf(x) \u0026= 2^{k}x + p_{lower} \u0026 \\pmod p \\\\\nf(x,y) \u0026= 2^kx + p_{mid} + y \u0026 \\pmod p \\\\\n\\end{aligned}\n$$\n\n### 平文 $m$ のビットを $(1-1/e)n$ 程度知っているとき\n\n$$\n\\begin{aligned}\nf(x) \u0026= (m_{upper} + x)^e - c \u0026 \\pmod N \\\\\nf(x) \u0026= (2^kx + m_{lower})^e - c \u0026 \\pmod N \\\\\nf(x,y) \u0026= (2^kx + m_{mid} + y)^e - c \u0026 \\pmod N \\\\\n\\end{aligned}\n$$\n\n### $d$ を $n/4$ ビット程度知っているとき\n\n$e$ が総当り出来るくらい小さいときに $d$ を $n/4$ ビットだけ知っていれば元の $d$ を構成できる。大体の場合は $e = 65537$ であるから十分可能である。$d \u003c \\phi(N)$ より $0 \u003c k \\leq e$ となり、この $k$ に対して総当たりする。\n\n- 上位ビットの場合\n$d$ と $p, q$ の関係式を立てる。\n\n$$\n\\begin{aligned}\ned \u0026= 1 \u0026 \\pmod{\\phi(N)} \\\\\ned \u0026= 1 + k(N - p - q + 1) \\\\\nd \u0026= \\frac{kN}{e} - \\frac{k(p+q-1) -1}{e} \\\\\ne(d_{upper} + x) \u0026= - k (y - 1) + 1 \u0026 \\pmod N \\\\\n\\end{aligned}\n$$\n\n第三式について $p + q \\approx \\sqrt{N}$ より第二項は上位ビットに関連する情報を持たない。これより第一項の $k$ について総当りして上位ビットと一致する $k$ を見つければよい。すると第4式に対し Multivariate CopperSmith を用いて、$d$ がわかる。\n\n- 下位ビットの場合\n$d$ の下位ビットから $k$ について総当りして $p$ の下位ビットを求める。すると先程の問題に帰着できて $p$ がわかり $d$ がわかる。\n\n$$\n\\begin{aligned}\ned \u0026= 1 + k\\left(N - p - \\frac{N}{p} + 1\\right) \\\\\nedp \u0026= p + kp(N - p + 1) - kN \u0026 \\pmod {2^{n/4}} \\\\\n\\end{aligned}\n$$\n\n### CRTの秘密鍵 $d$ のビットを $n/4$ 程度知っているとき\n\n上と同様にして解けます。\n\n$$\n\\begin{aligned}\ned_p \u0026= 1 \u0026 \\pmod{p-1} \\\\\ned_p \u0026= 1 + k_p(p − 1) \\\\\n\\end{aligned}\n$$\n\n## 実装\n\n```python\nfrom Crypto.Util.number import *\n\np = getPrime(512)\nq = getPrime(512)\nn = p * q\ne = 3\n\nbeta = 0.5\nepsilon = beta^2/7\n\npbits = p.nbits()\nkbits = floor(n.nbits() * (beta^2 - epsilon))\n# p upper\npbar = p \u0026 (2^pbits - 2^kbits)\n\nprint(f\"upper {pbits - kbits} bits (of {pbits} bits) is given\")\n\nPR.\u003cx\u003e = PolynomialRing(Zmod(n))\nf = x + pbar\n\nprint(p)\nx0 = f.small_roots(X=2^kbits, beta=0.3)[0]\nprint(x0 + pbar)\n```\n\n## 使用例\n\n```python\ndef partial_p(p0, kbits, n):\n    PR.\u003cx\u003e = PolynomialRing(Zmod(n))\n    nbits = n.nbits()\n\n    f = 2^kbits*x + p0\n    f = f.monic()\n    roots = f.small_roots(X=2^(nbits//2-kbits), beta=0.3)  # find root \u003c 2^(nbits//2-kbits) with factor \u003e= n^0.3\n    if roots:\n        x0 = roots[0]\n        p = gcd(2^kbits*x0 + p0, n)\n        return ZZ(p)\n\ndef find_p(d0, kbits, e, n):\n    X = var('X')\n\n\t# edx - kx(n-x+1) + kn = x mod 2^k\n\t# (ed - 1)x - kx(n-x+1) + kn = 0 mod 2^k\n    for k in xrange(1, e+1):\n        results = solve_mod([e*d0*X - k*X*(n-X+1) + k*n == X], 2^kbits)\n        for x in results:\n            p0 = ZZ(x[0])\n            p = partial_p(p0, kbits, n)\n            if p:\n                return p\n\n\nif __name__ == '__main__':\n    n = 0x00bef498e6eb2cffe71312da47ab89d2c47db7438ea2cfa992ddddbc2a01978001fc51e286e6ebf028396cdb8b3323c60e6b9d50cd84187cf7f48e3875a2f0890f70b02333ad89db2923863ce146562286f63fb0a1d0198e3a6862ba5ac12e85a5c6d0d27cb1c81bdf69cc5bc95b8001a2f744517f9437b4ddd5a076fc0e9a5de1a7a268c40f31aa29e8dc27c0b3a182299ca7a9335b4bd4585452f6107c238e486c98dd73a5f9862e9e80b152f53381c72f897107551c281259ac3ee32c4b4f46cc03127d1bf699acd0266f3c6729253c70da0c69b1560fa172735709866b375b6eba294e1ce8b46fba798ba380080b4bf9603998cac199d9cd46e30ae8da9e7f\n    e = 3\n    d = 0x7f4dbb449cc8aa9a0cb73c2fc7b1372da924d7b46c8a710c93e9281c010faaabfd8bec59ef47f5702648925cccc284099d138b33ad65a8a54db425a3c1f5b0b4f5cac22273b13cc617aed340d98ec1af4ed5206be011097c459726e72b7459192f35e1a8768567ea46883d30e7aaabc1fa2d8baa62cfcde93915a4a809bc3e9547bb07e1ecca16e51078312e89f0561e31b55db8b0ea5bc87a6ca7464a3d7c28a68c60e2ba88fe6a7d2b300d723e549910a987da89fc0a1c0de197a3d62c501b1f0e819891b1c32a0d6c233f2a285df87bb9e5c6c72d983ff3e706696bba639f573f9c3646968f02f3a615a438e20bb7c38d53621079f2899547a95350f3abeb\n\n    beta = 0.5\n    epsilon = beta^2/7\n\n    nbits = n.nbits()\n    kbits = floor(nbits*(beta^2+epsilon))\n    d0 = d \u0026 (2^kbits-1)\n    print \"lower %d bits (of %d bits) is given\" % (kbits, nbits)\n\n    p = find_p(d0, kbits, e, n)\n    print \"found p: %d\" % p\n    q = n//p\n    print d\n    print inverse_mod(e, (p-1)*(q-1))\n```\n\n## 参考\n\n","lastmodified":"2022-10-26T11:26:57.359934474Z","tags":null},"/crypto/RSA/ROCA":{"title":"Return Of Coppersmith Attack","content":"\n## 説明\n\n主要な暗号ハードウェアメーカで使われているライブラリ RSALib の鍵生成アルゴリズムの欠陥。\n\n$$\n\\begin{aligned}\np \u0026= kM + (e^a \\bmod M) \\\\\nq \u0026= lM + (e^b \\bmod M) \\\\\nN \u0026= pq = e^{a + b} \\pmod M\n\\end{aligned}\n$$\n\nM の素因数分解して中国剰余定理からのDLPを適用\n$P_n = 2\\cdot 3\\cdot\\ldots\\cdot p_n$\n512bit RSA $M = P_{39}$, $k$ 37bit, $a$ 62bit\n1024bit RSA $M = P_{71}$\n2048bit RSA $M = P_{126}$\n\n## 実装\n\n\n## 使用例\n\n\n## 参考\n\n[The Return of Coppersmith's Attack:Practical Factorization of Widely Used RSA Moduli (acmccs.github.io)](https://acmccs.github.io/papers/p1631-nemecA.pdf)\n\n","lastmodified":"2022-10-26T11:26:57.359934474Z","tags":null},"/crypto/RSA/RSA":{"title":"RSA暗号","content":"\n## 説明\n\n暗号化\n$c = m^{e} \\pmod N$ を計算します。\n\n1. 秘密鍵である大きな素数 $p, q$ を生成し、公開鍵 $N = pq$ を公開します。\n2. そして数値化した平文 $m$ に対して暗号文 $c$ は $c = m^e \\pmod N$ となります。\n\n復号化\n$m = c^{e^{-1}} \\pmod N$ を計算します。\n\n1. まず秘密鍵 $\\phi(N) = (p - 1)(q - 1)$ を計算する。\n2. $c$ に対して $d = e^{-1} \\pmod{\\phi(N)}$ 乗することで復号できます。\n\n$$\n\\begin{aligned}\nc \u0026≡ m^e \u0026\\pmod N \\\\\nc^d \u0026≡ m^{ed} ≡ m \u0026\\pmod N\n\\end{aligned}\n$$\n\nこれはオイラーの定理より肩の数が $\\phi(N)$ を法として計算できるからです。\n\n$$\n\\begin{aligned}\nm^{\\phi(N)} \u0026≡ m^{(p - 1)(q - 1)} ≡ 1 \u0026 \\pmod N \\\\\nm^{ed} \u0026= m^{k\\phi(N) + 1} ≡ m^{k\\phi(N)}m ≡ m \u0026 \\pmod N \\\\\ned \u0026= k\\phi(N) + 1 ≡ 1 \u0026 \\pmod{\\phi(N)}\n\\end{aligned}\n$$\n\nここで $N, e$ を知っていても $p, q, d$ を知らないとき、暗号化は簡単でも復号化は難しいという事が知られています。これを用いた暗号をRSA暗号 (Rivest-Shamir-Adleman encryption) と呼びます。\n\n具体的には次の手順で暗号化された通信します。\n\n1. AliceがBobに公開鍵 $N, e$ を渡す\n2. Bobは公開鍵を用いて平文を暗号化\n3. BobからAliceへ暗号文を送る\n4. Aliceは秘密鍵 $p, q$ を用いて復号化し、平文を得る\n\nここに図\n\nこのようにして送っている最中に盗聴されても秘密鍵がなければ解読できず、安全な通信ができます。\nまたこれは一方向通信ですが、逆も同様に行えば双方向通信もできます。\n\n### RSA-CRT\n\nRSAの復号をする際に $c^d$ を計算しますが、 $d = e^{-1} \\pmod {\\phi (N)}$ は比較的大きいので処理が重くなります。これに対してRSA-CRTは中国剰余定理(CRT)を利用して高速化を図っています。\n\n$$\n\\begin{aligned}\nm_p \u0026= c^{d \\ \\bmod \\ p−1} \u0026 \\pmod p \\\\\nm_q \u0026= c^{d \\ \\bmod \\ q−1} \u0026 \\pmod q \\\\\nm \u0026= \\mathrm{CRT}(m_p, m_q) \u0026 \\pmod {N} \\\\\n\u0026= m_q + (m_p - m_q) (q^{-1} \\bmod p) q \u0026 \\pmod {N} \\\\\n\\end{aligned}\n$$\n\nこれより下の値を秘密鍵として持つことになります。\n\n$$\n\\begin{aligned}\nd_p \u0026= d \\bmod p−1 \\\\\nd_q \u0026= d \\bmod q−1 \\\\\nq_{inv} \u0026= q^{-1} \\bmod p \\\\\n\\end{aligned}\n$$\n\n### padding\nメッセージが改ざんされずに届けられていることを確認するのにパディングは用いられる。RSAでは主に次の3つのパディングが使われる。\n\nRFC 8017: PKCS #1 V2.2(RSA Cryptography Specifications Version 2.2)\n\n- PKCS#1 v1.5; Public-Key Cryptography Standards#1 v1.5\n- OAEP; Optimal Asymmetric Encryption Padding\n- PSS; Probabilistic Signature Scheme\n\nこのようなパディングを用いたRSAをRSA-[パディング名]などと呼んだりする。\n\n## 実装\n\n```python\nfrom Crypto.Util.number import *\n\np = getPrime(512)\nq = getPrime(512)\nN = p * q\nphi = (p - 1) * (q - 1)\ne = 65537\nd = pow(e, -1, phi)\n\n\ndef encrypt(plaintext):\n    m = bytes_to_long(plaintext)\n    c = pow(m, e, N)\n    cipher = long_to_bytes(c)\n    return cipher\n\n\ndef decrypt(cipher):\n    c = bytes_to_long(cipher)\n    m = pow(c, d, phi)\n    plaintext = long_to_bytes(m)\n    return plaintext\n\n\ncipher = encrypt(b\"This is RSA\")\nprint(cipher)\nplaintext = decrypt(cipher)\nprint(plaintext)\n```\n\n## 使用例\n\n## 関連項目\n- [Boneh-Durfee Attack](/crypto/RSA/Boneh-DurfeeAttack)\n- [Common Modulus Attack](/crypto/RSA/CommonModulusAttack)\n- [Franklin-Reiter Related Message Attack](/crypto/RSA/Franklin-ReiterRelatedMessageAttack)\n- [Håstad’s Broadcast Attack](/crypto/RSA/HåstadsBroadcastAttack)\n- [LSB Decryption Oracle Attack](/crypto/RSA/LSB-DecryptionOracleAttack)\n- [逆元が存在しないとき](/crypto/RSA/NoInverse)\n- [Partial Key Exposure Attack](/crypto/RSA/PartialKeyExposureAttack)\n- [Return Of Coppersmith Attack](/crypto/RSA/ROCA)\n- [RSA-CCA](/crypto/RSA/RSA-CCA)\n- [RSA-CRT Fault Attack](/crypto/RSA/RSA-CRT-FaultAttack)\n- [Small Common Private Exponent Attack](/crypto/RSA/SmallCommonPrivateExponentAttack)\n- [Wiener's Attack](/crypto/RSA/WienersAttack)","lastmodified":"2022-10-26T11:26:57.359934474Z","tags":null},"/crypto/RSA/RSA-CCA":{"title":"Chosen-ciphertext Attack","content":"\n## 説明\n\n任意の暗号を復号した結果を知っているとき、ある暗号文の復号結果を防がれていたとしても他の暗号を送ることで解読できます。\n$2^e$ を暗号文に掛けて復号した結果を $2$ で割ればその平文がわかります。\n\n$$\n\\begin{aligned}\nDec(2^ec) = 2m \\pmod N\n\\end{aligned}\n$$\n\nこれに対する防御方法として平文にパディングを施し、復号化した際にパディング形式が違うときは相手に渡さないようにするという方法があります。これによって正当な暗号文しか受け入れず、適応的選択暗号文攻撃を防げます。\n\nパディング形式の1つにPKCS #1 v1.5があります。\n\n`0002\u003crandom\u003e00\u003chashprefix\u003e\u003cmessage\u003e`\n\nこれについてパディングが合っているかどうかを相手に送ってしまうとPadding Oracle Attackで攻撃でき、PKCS #1 v1.5では200万程度送ると平文が読めてしまいます。\n\n対してPadding Oracle Attackで破られないようなパディング形式はInD-CCA2と呼びます。\n\nその1つであるOAEP(Optimal Asymmetric Encryption Padding)については次の記事を読むとよいです。\n\n## 実装\n\n\n## 使用例\n\n\n## 参考\n\n- [RSAに対する適応的選択暗号文攻撃とパディング方式](https://inaz2.hatenablog.com/entry/2016/01/26/222303)\n","lastmodified":"2022-10-26T11:26:57.359934474Z","tags":null},"/crypto/RSA/RSA-CRT-FaultAttack":{"title":"RSA-CRT Fault Attack","content":"\n## 説明\n\nRSAの復号をする際に $c^d$ を計算しますが、 $d = e^{-1} \\pmod {\\phi (N)}$ は比較的大きいので処理が重くなります。これに対してRSA-CRTは中国剰余定理(CRT)を利用して高速化を図っています。\n\n$$\n\\begin{aligned}\nm_p \u0026= c^{d \\ \\bmod \\ p−1} \u0026 \\pmod p \\\\\nm_q \u0026= c^{d \\ \\bmod \\ q−1} \u0026 \\pmod q \\\\\nm \u0026= \\mathrm{CRT}(m_p, m_q) \u0026 \\pmod {N} \\\\\n\u0026= m_q + (m_p - m_q) (q^{-1} \\bmod p) q \u0026 \\pmod {N} \\\\\n\\end{aligned}\n$$\n\nこれより下の値を秘密鍵として持つことになります。\n\n$$\n\\begin{aligned}\nd_p \u0026= d \\bmod p−1 \\\\\nd_q \u0026= d \\bmod q−1 \\\\\nq_{inv} \u0026= q^{-1} \\bmod p \\\\\n\\end{aligned}\n$$\n\nしかし $d_p, d_q$ のどちらかが何らかの方法で書き換えられてしまったとき次のようにできます。\n\n$$\n\\begin{aligned}\nm_p \u0026= c^{d_p} \\pmod p \\\\\nm_q' \u0026= c^{d_q'} \\pmod q \\\\\nm \u0026= CRT(m_p, m_q) = kp + m_p \\\\\nm' \u0026= CRT(m_p, m_q') = k'p + m_p \\\\\nm - m' \u0026= (k - k')p \\\\\np \u0026= \\gcd(m - m', N) \\\\\n\\end{aligned}\n$$\n\nこれより平文 $m, m'$ を知ることができれば解くことができます。\n\n## 実装\n\n\n## 使用例\n\n\n## 参考\n\n","lastmodified":"2022-10-26T11:26:57.359934474Z","tags":null},"/crypto/RSA/SmallCommonPrivateExponentAttack":{"title":"Small Common Private Exponent Attack","content":"\n## 説明\n\n\n## 実装\n\n\n## 使用例\n\n\n## 参考\n\n","lastmodified":"2022-10-26T11:26:57.359934474Z","tags":null},"/crypto/RSA/WienersAttack":{"title":"Wiener's Attack","content":"\n## 説明\n\n$3d \u003c N^{\\frac{1}{4}}$ のとき ( $d$ が小さすぎるか $e$ が大きすぎるとき)、$e/N$ に対し主近似分数を並べると $k/d$ がある。\n\n$$\n\\begin{aligned}\ned \u0026≡ 1 = k\\phi(N) + 1 = k(N - p - q + 1) + 1 \\\\\n\\frac{e}{N} \u0026= \\frac{k}{d}\\left(1-\\frac{p + q - 1 - \\frac{1}{k}}{N}\\right) \\approx \\frac{k}{d} \\\\\n\\frac{e}{N} \u0026\\approx q_0 + \\cfrac{1}{q_1 + \\cfrac{1}{q_2 + \\cfrac{1}{\\ddots \\cfrac{}{q_{m-1} + \\cfrac{1}{q_m}}}}} = \\frac{k_m}{d_m} \\\\\n\\end{aligned}\n$$\n\n次の漸化式を用いて主近似分数は求まる。\n\n$$\n\\begin{aligned}\nr_{-2} \u0026= e \u0026 k_{-2} \u0026= 0 \u0026d_{-2} \u0026= 1 \\\\\nr_{-1} \u0026= N \u0026 k_{-1} \u0026= 1 \u0026d_{-1} \u0026= 0 \\\\\nr_{i-2} \\div r_{i-1} \u0026= q_{i} \\cdots r_{i} \u0026 k_i \u0026= q_i k_{i−1} + k_{i−2} \u0026d_i \u0026= q_i d_{i−1}+d_{i−2} \\\\\n\\end{aligned}\n$$\n\n## 実装\n\n```python\nimport gmpy2\n\ndef convergents(a, b):\n    r0, r1 = a, b\n    a0, a1 = 0, 1\n    b0, b1 = 1, 0\n\n    i = 0\n    while r1 != 0:\n        i += 1\n        q = r0 // r1\n        r0, r1 = r1, r0 % r1\n        a0, a1 = a1, q*a1 + a0\n        b0, b1 = b1, q*b1 + b0\n\n        if i % 2 == 0:\n            a = a1 + a0\n            b = b1 + b0\n        else:\n            a = a1\n            b = b1\n\n        yield a, b\n\ndef has_integer_roots(a, b, c):\n    D = b*b - 4*a*c\n    if D \u003e 0:\n        sD = gmpy2.isqrt(D)\n        if sD * sD == D and (-b + sD) % (2*a) == 0:\n            return 2\n    elif D == 0 and b % (2*a) == 0:\n        return 1\n    return 0\n\ndef WienersAttack(n, e):\n    for d, k in convergents(n, e):\n        if k == 0 or (e * d - 1) % k != 0:\n            continue\n        phi = (e * d - 1) // k\n        if has_integer_roots(1, phi - n - 1, n) \u003e 0:\n            return d\n    return -1\n```\n\n## 使用例\n","lastmodified":"2022-10-26T11:26:57.359934474Z","tags":null},"/crypto/RSA/tour-of-RSA":{"title":"Tour of RSA","content":"\n# RSA暗号を極める！(理論編)\n\nというか無限工事編です(文章が拙くて申し訳ない)\n\n## はじめに\n\nすぐそこに秘密の世界があります。この記事を読んでいるなら、あなたは暗号化された通信を通してサーバーから電気線を通り、遥々その端末に届いている文字を読んでいます。\n\nこんなことを考えてみてほしい。機器から暗号を使って通信をしていますが、私達が触れていないだけで暗号は誰でも解けるものであり、近くを通った人が自分の通信を盗聴しているかもしれない。ゾクッとしませんか。\n\nそんなことが2017年に起こりました。ROCA攻撃と呼ばれるものです。暗号の中でも最も世界で活躍していると言われる「RSA暗号」が簡単に解けてしまうというものです。\n\nその「RSA暗号」の本当の世界を覗いてみましょう。\n\nCryptoはCTF特有のメタ的な能力よりかは数学力に重きが置かれる分野です。最近では発想だけではなくテクニックを知らないと解けないような問題が多くなってきました。そこでこの記事ではRSA関連の問題でよく使うテクニックを体系的に1から習得します。\n\nテクニック\nGCD, 中国剰余定理, 終結式, グレブナー基底, LLL, Approximate GCD, Coppersmith\n\n前提知識は出来る限り高校数学に絞っていますが、それでも少し大学での数学が出てきますので適宜補ってほしいです。\n\n## 時計の世界\n\nRSA暗号を語る上で最も根幹を成すのが、Nを自然数として「Nを法とする」算術です。\n\nこの算術は日々触れていて例えば時間についてこんな問題を考えてみましょう。\n\n午前10時に仕事を始めて、8時間働くとすると、仕事が終わるのはいつでしょうか？\n\n10 + 8 = 18 だから「18時に終わる」と答えるのが自然でしょうか。18から12を引き 18 - 12 = 6 で「午後6時に終わる」とも答えられますね。どちらにしても数はある範囲に入るように調整されます。午前午後で分ける方法であれば数は0から11の間に入り、24時間制であれば数は0から23の間に入ります。\n\n角度でもこの算術に出くわします。例えば2つの角度の和を求めるとき、360度を超えてしまった場合はそこから360を引いて1から360までの間に収まるようにします。例えば 450 - 360 = 90 だから、450度の回転は90度の回転に等しいです。\n\n他にも曜日や\n以上の出してきたものに共通していることは結果がある範囲に収まるようにしていることです。このようなタイプの計算をNを法とする算術と呼びます。先ほどの例だと午前午後であれば「12を法とする」足し算、角度であれば「360を法とする」足し算をしています。\n\n$$\n\\begin{aligned}\n10 + 8 \u0026= 6 \\pmod{12} \\\\\n450 \u0026= 90 \\pmod{360} \\\\\n810 \u0026= 90 \\pmod{360}\n\\end{aligned}\n$$\n\nより広く考えると810度は90度であるようにこの算術はNで割った余りが同じなら等しく扱う算術であるとも言えます。この算術の上では一般の自然数NでNを法とする足し算を考えることができます。\n\nこのNを法とする算術をしっかり考えるために定義を与えます。\n\nまず $0$ から $N-1$ までの数を集めた集合をもってきて、それを $\\mathbb{Z}/N\\mathbb{Z}$ と名付けます。\n\n$$\n\\mathbb{Z}/N\\mathbb{Z} := \\{0, 1, ..., N - 2, N - 1\\}\n$$\n\n例えば $\\mathbb{Z}/12\\mathbb{Z}$ はAM/PMで時間を表す数、$\\mathbb{Z}/24\\mathbb{Z}$ は24時間表記で時間を表す数となります。\n\nこれらの数の集合に対し、加法(足し算)を定義します。この集合の中から任意の2つの数が与えられたとして、それらを足したものが $N$ より大きくなるなら、$N$ を引いて計算結果が自分の中に入るようにします。\n\nこの集合にこう定義した加法を入れることで集合は群となります。群とは集合と1つの演算がよく馴染んでいるようなもので次のような条件を満たします。\n\n- 単位元の存在\n演算しても変わらない値 ex.) $a + 0 = a, a \\times 1 = a$\n- 逆元の存在\n演算して単位元となる値 ex.) $a + (- a) = 0, a \\times \\frac{1}{a} = 1$\n- 結合法則\nどこから演算しても同じ結果になる ex.) $(a + b) + c = a + (b + c)$\n\n群のうれしいことは、群であればどのような集合や演算であれ、必ず成り立つ法則があり、その法則を流用できることにあります。今回はそれらの法則をそれほど使いませんが暗号全般的に使われるので覚えておいて損は無いでしょう。\nさて、加法について群を満たすかチェックしてみます。\n\n- 加法の単位元　　 $0$\n- 加法の逆元　　　 $a + (-a) = 0 \\pmod N \\iff -a = N - a$\n- 加法の結合法則　 $(a + b) + c = a + (b + c) \\pmod N$\n\nこのように群の条件を満たすので $\\mathbb{Z}/N\\mathbb{Z}$ は加法について群となります。\n\n同じように乗法(掛け算)も定義してみます。集合から任意の2つの数を取ってきて、それらを掛けた後に $N$ で割った余りを計算します。乗法についても群を満たすかチェックしてみましょう。\n\n- 乗法の単位元　　 $1$\n- 乗法の逆元　　　 $aa^{-1} = 1 \\pmod N \\iff a^{-1} = \\frac{kN + 1}{a}$\n- 乗法の結合法則　 $(a \\times b) \\times c = a \\times (b \\times c) \\pmod N$\n\nよく考えると乗法の逆元が常に存在する訳ではないです。だから乗法については群になりません。\n\n乗法での逆元とは掛けて1になる数で具体的にはこのようになります。\n\n$$\n\\begin{aligned}\n1^{-1} \u0026= 1 \u0026\u0026 (1 \\times 1 = 1 = 1) \u0026 \\pmod{13} \\\\\n2^{-1} \u0026= 7 \u0026\u0026 (2 \\times 7 = 14 = 1) \u0026 \\pmod{13} \\\\\n3^{-1} \u0026= 9 \u0026\u0026 (3 \\times 9 = 27 = 1) \u0026 \\pmod{13} \\\\\n4^{-1} \u0026= 10 \u0026\u0026 (4 \\times 10 = 40 = 1) \u0026 \\pmod{13} \\\\\n5^{-1} \u0026= 8 \u0026\u0026 (5 \\times 8 = 40 = 1) \u0026 \\pmod{13} \\\\\n\\vdots\n\\end{aligned}\n$$\n\nではどういうときに逆元が存在しないのかを考えてみます。逆元 $x$ が存在する条件について式変形していくと( $\\gcd$ は最大公約数 (Greatest Common Divisor) とします)\n\n$$\n\\begin{aligned}\nax \u0026= 1 \u0026 \\pmod N \\\\\nax - kN \u0026= 1 \\\\\n\\gcd(a, N)(a'x - kN') \u0026= 1 \u0026 (a = \\gcd(a, N)a', N = \\gcd(a, N)N') \\\\\n\\gcd(a, N) \u0026= 1 \\\\\n\\end{aligned}\n$$\n\nとなります。つまり $a$ と $N$ とが互いに素であれば $\\bmod N$ で $a$ の逆元が存在します。逆に $a$ が $0$ や $N$ の約数である場合は逆元が存在しません。\n\n具体的に法に対して逆元が存在する数を羅列すると\n\n$$\n\\begin{aligned}\n\\bmod 10 \u0026\\to 1, 3, 7, 9 \\\\\n\\bmod 11 \u0026\\to 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 \\\\\n\\bmod 12 \u0026\\to 1, 5, 7, 11 \\\\\n\\bmod 13 \u0026\\to 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12 \\\\\n\\bmod 14 \u0026\\to 1, 3, 5, 9, 11, 13 \\\\\n\\end{aligned}\n$$\n\n意外と逆元を取れる元が少ないですね。その中で法の数が素数のときは $0$ 以外の数と互いに素となるので任意の $0$ ではない元に対して逆元が存在します。また、逆元の逆元は元の数となるため、逆元を取れる集合に対して逆元を取っても元の集合と等しくなります。\n\n$$\n\\begin{aligned}\n1^{-1} \u0026= 1 \\pmod{10} \\\\\n3^{-1} \u0026= 7 \\pmod{10} \\\\\n7^{-1} \u0026= 3 \\pmod{10} \\\\\n9^{-1} \u0026= 9 \\pmod{10} \\\\\n\\{1, 3, 7, 9\\} \u0026= \\{1, 7, 3, 9\\}\n\\end{aligned}\n$$\n\nここで逆元を取れる集合、つまり $\\mathbb{Z}/N\\mathbb{Z}$ から $0$ や $N$ の約数を除いた集合を $(\\mathbb{Z}/N\\mathbb{Z})^\\times$ と名付けます。そして $(\\mathbb{Z}/N\\mathbb{Z})^\\times$ は乗法について群となります。特に素数 $p$ として $(\\mathbb{Z}/p\\mathbb{Z})^\\times$ は $0$ のみ除いた集合でとても扱いやすいです。\n\n$$\n\\begin{aligned}\n(\\mathbb{Z}/p\\mathbb{Z})^\\times \u0026= \\{1, 2, ..., p - 2, p - 1\\} \\\\\n\\end{aligned}\n$$\n\nこのように加法も乗法も群となっている集合を体と呼びます。体であると面倒くさい場合分けをしなくて済むのでしばらくは法を素数として考えます。法が合成数でも互いに素なら逆元がありますし、その後の定義、定理も互いに素なら大体成り立ちます。\n\nでは逆元について一通り分かったので実装してみましょう。\nTODO: 拡張ユークリッドの互除法\n\n-----\n\n加法、乗法の他にも実数の世界で扱うような演算を $N$ を法とする世界でも定義できます。\n\n#### 平方根・累乗根\nある数 $a$ に対し $x^2 = a \\pmod N$ となるような $x$ を $a$ の平方根 $\\sqrt{a}$ とする。また $x^n = a \\pmod N$ となる $x$ を $a$ の累乗根 $\\sqrt[n]{a}$ とする。\n\n平方根や累乗根の解は存在しない場合や複数ある場合などがあります。後述する乗法と加法の関係を証明する際に補題として証明するものを用いて、$x^n = 1 \\pmod p$ の解の個数は $\\gcd(n, p-1)$ 個だけ存在することを示せます。\n# 本当ですか？\n\n#### 対数\nある数 $e, a$ に対し $e^x = a \\pmod N$ となるような $x$ を $e$ を底とする $a$ の対数 $\\log_e{a}$ とする。\n\n対数に関しては原始根を底にすると解が一意に決まります。原始根とはその値を $a$ とおいて $a^k \\bmod{p} \\ (k=0, \\ldots, p-2)$ がそれぞれ違う値を取る数です。\n\n具体例\n\n$$\n\\begin{aligned}\n3 + 4 \u0026= 0 \u0026 \\pmod 7 \\\\\n3 - 4 \u0026= -1 = 6 \u0026 \\pmod 7 \\\\\n3 \\times 4 \u0026= 12 = 5 \u0026 \\pmod 7 \\\\\n3 \\div 4 \u0026= 3 \\times 4^{-1} = 3 \\times 2 = 6 \u0026 \\pmod 7 \\\\\n3^4 \u0026= 9^2 = 2^2 = 4 \u0026 \\pmod 7 \\\\\n\\sqrt{4} \u0026= 2, 5 \u0026 \\pmod 7 \\\\\n\\sqrt[3]{6} \u0026= 3, 5, 6 \u0026 \\pmod 7 \\\\\n\\log_3{6} \u0026= 3 \u0026 \\pmod 7 \\\\\n\\end{aligned}\n$$\n\n-----\n\nこれで剰余上の演算は一通りできるようになりました。さてコンピューターはこれらをどのようにして計算するのでしょうか。代表的なアルゴリズムで組んだ場合だと以下の表のようになります。(簡単の為、基本的な演算の計算量はビット数に依らないとする)\n\n| 演算                   | 方法                          | 計算量                      |\n| :--------------------  | :---------------------------- | :-------------------------: |\n| 足し算   $a + b$       | 足してN以上になったらN引く    | $O(1)$            |\n| 引き算   $a - b$       | 引いて0未満になったらN足す    | $O(1)$            |\n| 掛け算   $a \\times b$  | 掛けてNで割った余り           | $O(1)$            |\n| 割り算   $a \\div b$    | 拡張ユークリッドの互除法      | $O(\\log^2 N)$   |\n| 累乗     $a ^ e$       | 繰り返し二乗法                | $O(\\log N)$       |\n| 平方根   $\\sqrt{a}$    | Tonelli Shanksのアルゴリズム  | $O(\\log^2 N)$   |\n| 累乗根   $\\sqrt[e]{a}$ | Tonelli Shanksのアルゴリズム     | $O(\\min(N^{1/4},\\sqrt{e})\\log{e}\\log^2{N})$     |\n| 対数     $\\log_e{a}$   | 離散対数問題            | $O(\\sqrt{N})$     |\n(参考: [整数論テクニック集のpdf](https://kirika-comp.hatenablog.com/entry/2018/03/12/210446) など)\n\nそれぞれのアルゴリズムは参考などの資料を見てください。累乗は多項式時間しか掛かりませんが、累乗根や対数は指数時間掛かるということを頭の隅に置いておいてください。\n\nそれと剰余と合わせて、普段よく使っている整数 $\\mathbb{Z}$ 上での演算は $\\bmod N$ と対比して $\\mathrm{over}\\ \\mathbb{Z}$ と書くことにします。\n\nまとめ\n実数で扱っている演算は剰余でも同じようにできることがある。\n\n## 剰余上の掛け算と足し算\n\n剰余のことが少しわかった所で累乗について少し深く掘り下げてみます。\n\n累乗に関する有名な定理としてフェルマーの小定理があります。\n\n-----\n\n#### フェルマーの小定理\n$p$ を素数として、$a \\neq 0 \\pmod p$ のとき次の式が成り立つ。\n\n$$\na^{p-1} = 1 \\pmod p\n$$\n\n証明\n$a \\neq 0 \\pmod p$ より同値な $a^p = a \\pmod p$ を示す。$a = 1$ は自明で、 $a = k$ を仮定すると\n\n$$\n(k + 1)^p = k^p + {}_p\\mathrm{C}_1k + ... + 1 = k^p + 1 = k + 1 \\pmod p\n$$\n\nより数学的帰納法から成り立つ。\n\n-----\n\n数式だけだとあまり良くわからないので具体的に $\\bmod 7$ で考えてみます。 $a^k$ を計算した表がこちらになります。\n\n| k ＼ a |  1  |  2  |  3  |  4  |  5  |  6  |\n|:-----:|:---:|:---:|:---:|:---:|:---:|:---:|\n|   1   |  1  |  2  |  3  |  4  |  5  |  6  |\n|   2   |  1  |  4  |  2  |  2  |  4  |  1  |\n|   3   |  1  |  1  |  6  |  1  |  6  |  6  |\n|   4   |  1  |  2  |  4  |  4  |  2  |  1  |\n|   5   |  1  |  4  |  5  |  2  |  3  |  6  |\n|   6   |  1  |  1  |  1  |  1  |  1  |  1  |\n\nこのようにどんな $a$ を使って計算しても必ず $a^6 = 1$ になります。これが一般の素数 $p$ で法を取ったなら必ず $p-1$ 乗で $1$ となるという不思議な定理です。\n\nここではこの定理についてもう少し膨らませてみます。\n\nフェルマーの小定理では指数について考えましたが逆に対数について考えてみます。具体例として先ほどの $\\bmod 7$ で $\\log_3 n$ を計算してみます。\n\n|     $n$    |   $1$   |   $2$   |   $3$   |   $4$   |   $5$   |   $6$   |\n|:----------:|:-----:|:-----:|:-----:|:-----:|:-----:|:-----:|\n|  $n = 3^k$ | $3^0$ | $3^2$ | $3^1$ | $3^4$ | $3^5$ | $3^3$ |\n| $\\log_3 n$ |   $0$   |   $2$   |   $1$   |   $4$   |   $5$   |   $3$   |\n\nじっくり見てみると、対数を取ったもの同士の $\\bmod 6$ での足し算はそれに対応する値同士の $\\bmod 7$ の掛け算と一致しているということが見えてきます。\n\n$$\n\\begin{aligned}\n4 \u0026\\times 6 = 3 \\pmod 7 \\\\\n\u0026\\downarrow \\log_3 \\\\\n4 \u0026+ 3 = 1 \\pmod 6 \\\\\n\\end{aligned}\n$$\n\n他の素数で考えてみても同じような法則が成り立ち、一般に $\\bmod p$ での乗法は対数を取れば $\\bmod p - 1$ での加法に変換できるということが成り立ちそうです。このような性質を同型と呼び、記号 $\\cong$ を使って $(\\mathbb{Z}/p\\mathbb{Z})^\\times \\cong \\mathbb{Z}/(p−1)\\mathbb{Z}$ と表します。\n\n-----\n\n#### 乗法と加法の関係\n\n$$\n(\\mathbb{Z}/p\\mathbb{Z})^\\times \\cong \\mathbb{Z}/(p−1)\\mathbb{Z}\n$$\n\n証明\n任意の素数 $p$ の法で原始根が存在することを示す。\nまず $n$ が $p - 1$ の約数であるとき $x^n = 1$ は $n$ 個の解を持つことを示す。仮定より $p - 1 = nk$ とおけ、次のそれぞれの式について解の個数について考える。\n\n$$\nx^{p-1} - 1 = (x^n - 1)((x^n)^{k-1} + \\ldots + x^n + 1)\n$$\n\n$x^{p-1} - 1 = 0$ はフェルマーの小定理より $p - 1$ 個\n$(x^n)^{k-1} + \\ldots + x^n + 1 = 0$ は代数学の基本定理より $n(k-1)$ 個以下\nよって $x^{n} - 1 = 0$ は解の個数を比較して $n$ 個存在する。\n\nこれより $p-1$ と互いに素な数の個数だけ原始根が存在する。\n\n原始根 $a$ を1つ選んでくると $a^k \\bmod{p} \\ (k=0, \\ldots, p-2)$ はそれぞれ違う値を取り、$(\\mathbb{Z}/p\\mathbb{Z})^\\times, \\mathbb{Z}/(p−1)\\mathbb{Z}$ を対応させる。そして剰余上の指数法則 $a^m \\times a^n = a^{m + n} \\pmod p$ は成り立つ。よって $(\\mathbb{Z}/p\\mathbb{Z})^\\times \\cong \\mathbb{Z}/(p−1)\\mathbb{Z}$ である。\n\n-----\n\n:::details\nまた、法の数を素数から一般の自然数に一般化することができます。\n\n-----\n\n#### カーマイケルの定理\n\n$$\n\\begin{aligned}\n(\\mathbb{Z}/p_1^{e_1}\\ldots p_n^{e_n}\\mathbb{Z})^\\times \u0026\\cong (\\mathbb{Z}/p_1^{e_1}\\mathbb{Z})^\\times \\times \\ldots \\times (\\mathbb{Z}/p_n^{e_n}\\mathbb{Z})^\\times\\\\\n(\\mathbb{Z}/2^e\\mathbb{Z})^× \u0026≅ \\left\\{\n\\begin{array}{ll}\n\\mathbb{Z}/1\\mathbb{Z} \u0026 (e = 1) \\\\\n\\mathbb{Z}/2\\mathbb{Z} \\times \\mathbb{Z}/2^{e-2}\\mathbb{Z} \u0026 (e \\geq 2)\n\\end{array}\n\\right.\\\\\n(\\mathbb{Z}/p^e\\mathbb{Z})^× \u0026≅ \\mathbb{Z}/p^{e-1}(p−1)\\mathbb{Z} \\\\\n\\end{aligned}\n$$\n\n証明\nせきゅーんさんの記事がおすすめです。\nhttps://integers.hatenablog.com/entry/2016/07/24/163831\nhttps://integers.hatenablog.com/entry/2017/06/08/191649\n\n-----\n:::\n\nこうして掛け算を足し算に置き換えられ、問題が簡単にできることが多いです。\n\n#### RSA暗号が解ける？\nRSA暗号はこれを使えば簡単に解けます。\nRSAは $c = m^e \\pmod {N}$ という式について $e, c$ が分かっているので累乗根を求める問題なのですが、原始根 $a$ で対数を取るとカーマイケルの定理より\n\n$$\n\\begin{aligned}\nc \u0026= m^e \u0026 \\pmod {N} \\\\\nm \u0026= c^{1/e} \u0026 \\pmod {N} \\\\\n\\end{aligned}\n$$\n\nと累乗根を計算できます。\n\nここまでは数学の話でしたが、ここから計算機科学に移ります。\n\n確かに、掛け算を足し算に変換することで簡単な問題になります。しかし、それ以前にコンピュータが剰余上の対数を計算する事は結構難しく、離散対数問題 (DLP: Discrete Logarithm Problem) と呼ばれ、現在見つかっている最も速いアルゴリズムでも完全指数時間も掛かります。\n\nでは諦めて掛け算だけで解く、というだけではなく他に1つ方法があります。直接数に対応させなくても、ある数だけ累乗すると $1$ や $-1$ になるという情報を使うことである程度情報を引き出すことができます。いわゆる平方剰余と呼ばれるものなどです。\n\n$$\nn^{\\frac{p-1}{2}}\n$$\n\n例えば Tonelli Shanks のアルゴリズムは平方剰余を使っています。\n\n剰余上の平方根を計算することについてじっくり考えてみます。定義より $x^2 = a \\pmod p$ となる $x$ を求めればよいです。\nまずは具体的に $\\bmod 13$ の場合について平方根を全て求めてみます。\n\n| $n$ | $2^0$ | $2^1$ | $2^2$ | $2^3$ | $2^4$ | $2^5$ | $2^6$ | $2^7$ | $2^8$ | $2^9$ | $2^{10}$ | $2^{11}$ |\n|:--------:|:-:|:-:|:--:|:--:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|\n| $\\sqrt{n}$ | $2^0, 2^6$ | なし | $2^1, 2^7$ | なし | $2^2, 2^8$ | なし | $2^3, 2^9$ | なし | $2^4, 2^{10}$ | なし | $2^5, 2^{11}$ | なし |\n\nとこのようになります。\n\n例えば $\\sqrt{10} \\pmod{13}$ については $\\sqrt{10} = \\sqrt{2^{10}} = 2^5, 2^{11} = 6, 7 \\pmod{13}$ となります。このように DLP が解けるとき、つまり肩の数がわかるなら、それを半分にするだけで平方根となります。\n\nでは DLP が解けないときはどうすればよいのでしょうか。\n\n最初に思いつくのは $2^{-1} \\bmod p-1$ 乗すれば平方根になるということです。しかし $2$ と $p-1$ は互いに素ではないので $2$ の逆数を定義できません。なので一旦逆数を定義できるところだけやって、後で定義できない部分を考えることにします。\n\n$$\n(\\mathbb{Z}/13\\mathbb{Z})^×≅\\mathbb{Z}/12\\mathbb{Z}≅\\mathbb{Z}/3\\mathbb{Z}\\times\\mathbb{Z}/2^2\\mathbb{Z}\n$$\n\n中国剰余定理から上のように分解でき、$\\bmod 3$ なら $2$ の逆数が定義できるので $2^{-1} \\bmod 3  = 2$ 乗します。すると $10^2 = 9 \\pmod{13}$ となり、これは $9 = 2^8 \\pmod{13}$ で下の表をみるとしっかり $8$ は $5, 11$ のある $2 \\bmod 3$ の行にあります。ここから上下に動かさずに左右だけを動かして本当の平方根を求めます。\n\n| $\\times$ | 0 | 1 |  2 |  3 |\n|:--------:|:-:|:-:|:--:|:--:|\n|     0    | 0 | 9 |  6 |  3 |\n|     1    | 4 | 1 | 10 |  7 |\n|     2    | 8 | 5 |  2 | 11 |\n\n本当の平方根を求める為に誤差を取り除くことが必要です。誤差とは $x$ が平方根であれば $a^{-1}x^2 = 1 \\pmod p$ となるのに対し、現在仮に求まっている平方根が $x=9$ であるから $a^{-1}x^2 = 10^{-1}9^2 = 2 \\pmod{13}$ と異なっているこの誤差です。\n\nこの誤差をより詳しく調べる為に累乗して情報、肩の数の trailing zero ( $\\bmod 2^n$ 上)を求めます。trailing zero とは2進数で考えたときに末尾に0が何個あるのかというものです。例えば 8 であれば 1000 より 3 となり、10 であれば 1010 で 1 となります。\n\n例えば $s = a^{-1}x^2$ についてこんなことが成り立つとします。\n\n$$\ns \\neq 1, s^2 \\neq 1, s^4 \\neq 1, s^8 = 1\n$$\n\nこの場合、肩の数は1,2,4倍しても0にはならず、ちょうど8倍して0になる数であることがわかります。つまり $\\underbrace{bb1000\\ldots}_n$ というようになっているはずです(分からないビットは $b$ としています)。これより trailing zero は $n - 3$ と分かります。\n\nこれに加えて平方剰余ではない数 $u$ をランダムに取ってきて $q$ 乗します。平方剰余ではないので肩の数は奇数、つまり一番下のビットが $1$ であることが分かってます。するとこの肩の数を $n - 4$ だけ左シフトすればその2乗は $\\underbrace{bb1000\\ldots}_n$ となり、それと $x$ を掛け合わせることで$bb1000\\ldots + bb1000\\ldots = bb0000\\ldots$ と最下位ビットを 0 にできて誤差の対数の trailing zero を増やしていくことができます。そして最終的に全て 0 になったとき、誤差はなくなります。\n\nつまり $\\sqrt{a} \\pmod{p}$ を計算するには次を行えばよいです。\n\n1. $p - 1 = q \\times 2^e$ から $2^{-1} \\pmod q = (q + 1)/2$ 乗する。\n2. $a^{-1}x^2$ の対数の trailing zero $t$ を求め、非平方剰余 $u$ を用いて $\\mathrm{pow}(u^q, 2^{e - t - 1})$ を $x$ に掛けることを繰り返す。\n\nこれを Tonelli Shanks のアルゴリズムと呼びます。\n\nまとめ\n累乗は様々な情報を持っている。\n\n## RSA暗号\n\nようやくRSA暗号です。\n\nRSA暗号とは剰余上での累乗は簡単でも累乗根は難しいという非対称性を使った暗号です。\n\n事前に大きな素数 $p, q$ と自然数 $e$ を生成し、$N = pq$ を公開します。(素数生成の方法はコラムへ)\nそして平文 $m$ に対して暗号文を $m^e \\bmod N$ とします。そして復号化については逆に $e^{-1}$ 乗します。具体的にはカーマイケルの定理から $(\\mathbb{Z}/pq\\mathbb{Z})^×≅\\mathbb{Z}/\\mathrm{lcm}((p−1), (q-1))\\mathbb{Z}$ より $\\phi(N) = (p - 1)(q - 1)$ として $d = e^{-1} \\pmod{\\phi(N)}$ 乗すれば $m$ を復号できます。\n\n$$\n\\begin{aligned}\nc \u0026= m^e \u0026\\pmod N \\\\\nm \u0026= c^{d} \u0026\\pmod N\n\\end{aligned}\n$$\n\nここで $N, e$ を知っていても $p, q, d$ いずれも知らないとき、素因数分解の計算困難性から復号化は難しいとされています。これを用いた暗号をRSA暗号 (Rivest-Shamir-Adleman encryption) と呼びます。\n\n具体的には次の手順で暗号化された通信します。\n\n1. AliceがBobに公開鍵 $N, e$ を渡す\n2. Bobは公開鍵を用いて平文を暗号化\n3. BobからAliceへ暗号文を送る\n4. Aliceは秘密鍵 $p, q$ を用いて復号化し、平文を得る\n\nここに図\n\nこのようにして送っている最中に盗聴されても秘密鍵がなければ解読できず、安全な通信ができます。またこれ自体は一方向通信ですが、逆も同様に行えば双方向通信もできます。\n\n実装するにはそれぞれの具体的なパラメータについて知っておきましょう。\n$e$ は慣例的に `0x10001 = 65537` が使われています。攻撃されないような丁度よい大きさの数であり、かつ暗号化する際にバイナリ法を用いると素早く計算できる数であるという理由が挙げられます。\n\n```python\nfrom Crypto.Util.number import getPrime, long_to_bytes, bytes_to_long\n\np = getPrime(512)\nq = getPrime(512)\nN = p * q\nphi = (p - 1) * (q - 1)\ne = 0x10001\nd = pow(e, -1, phi)\n\ndef encrypt(plaintext):\n    m = bytes_to_long(plaintext)\n    c = pow(m, e, N)\n    cipher = long_to_bytes(c)\n    return cipher\n\ndef decrypt(cipher):\n    c = bytes_to_long(cipher)\n    m = pow(c, d, phi)\n    plaintext = long_to_bytes(m)\n    return plaintext\n\ncipher = encrypt(b\"This is RSA\")\nprint(cipher)\n#\nplaintext = decrypt(cipher)\nprint(plaintext)\n# This is RSA\n```\n\n:::details ライブラリの説明\n| pycryptodomeライブラリの関数 | 説明                                          |\n| :--                          | :--                                           |\n| `getPrime(n)`                  | n bit長のランダムな素数を生成                 |\n| `bytes_to_long(bytes)`         | バイト文字列をASCIIとしてデコードし数に変換   |\n| `long_to_bytes(n)`             | 数をASCIIとしてエンコードしバイト文字列に変換 |\n:::\n\n## 素因数分解\n\nもし巨大な数の素因数分解が簡単に解けるとするつまり公開鍵 N を素因数分解して秘密鍵 p,q が求められるとどうなるか。 ϕ,d を求められ、任意の暗号文を復号化できてしまいます。\n\n暗号化は簡単でも復号化は難しいという非対称性を用いて暗号は作られます。\n\n代表的な暗号の安全性の根拠\n- RSA暗号 素因数分解\n- ElGamal暗号 DLP\n- 楕円曲線暗号 ECDLP\n\n## 素因数分解する方法はなにがあるのか\n\n素因数分解アルゴリズムは Pollard-$\\rho$ 法、p-1 法などがありますが、今回は比較的簡単で汎用的に適用できる Pollard-$\\rho$ 法を紹介します。\n\n誕生日のパラドックスを聞いたことありますか？ 誕生日が同じな2人を見つけたいときに人を何人集めればそうなる確率が50%を超えるのかという問題です。鳩ノ巣原理から366人いれば必ず同じ誕生日の人が出てきます。さて、同じ誕生日の組が 50% の確率でいる場合、何人いればよいでしょうか。\n\n答えは 23 人いれば十分です。\n\nこれを使って素因数分解する方法があります。\n\n$\\bmod p$ 上で同じ2つの数を見つけたいときに $\\sqrt{p\\ln 4} \\fallingdotseq 1.18\\sqrt{p}$ だけ集めれば 50% の確率で見つかります。そしてその差は $p$ の倍数となっているため、これと $N$ で最大公約数を取って素因数 $p$ を求めることができます。\n\nコンピュータ上ではランダムな数を集める為に擬似的な乱数を生成する関数 $f$ を用いて最大公約数が $p$ になるまで回し続けます。\n\n$$\n\\begin{aligned}\nf(x) \u0026= x^2 + c \\pmod N \\\\\nx_{i+1} \u0026= f(x_i) \\\\\ny_{i+1} \u0026= f(f(y_i)) \\\\\np \u0026= \\gcd(N, |x_i - y_i|) \\\\\n\\end{aligned}\n$$\n\n計算量は $O(\\sqrt{p})$ で $N \\approx 10^{20}$ くらいまでなら現実的な時間で素因数分解できます。\nほんまか？\n\n上の方法だと完全指数時間掛かりますがそれより速い準指数時間のアルゴリズム、Index calculus や数体ふるい法などがあります。\n整数をランダムに選んできたとき、それは小さい素数、たとえば 2, 3, 5, 7 などのべき乗を掛け合わせたもの、言い換えると、これらの小さい素数だけで生成されるものになる確率は高いことが知られています。これらの小さな素数を「ファクターベース」これらの数が暗号に使われている数に比べて大変小さく、たとえばその準指数関数のサイズ\n\n:::details 量子コンピュータ\n最近は量子コンピュータが開発されており、古典計算機では指数時間掛かる問題も多項式時間で解けるようになるという画期的な技術です。素因数分解もその範疇であり、Shorのアルゴリズムを用いて $O((\\log⁡N)^2)$ です。\nそこで量子コンピュータでも解けないような暗号、耐量子暗号が開発されています。代表的な暗号は格子暗号や符号暗号などがあります。詳しくは楕円曲線暗号\n:::\n\n#### 近い値の素数を使ってはいけない (Fermat's Method)\n\n$p, q$ が近いと中心から順に調べることで素数の組を見つけられます。様々な探索の方法がありますが、以下のような方法がよく用いられています。\n\n$$\n\\begin{aligned}\nN \u0026= pq \\\\\n  \u0026= (x + y)(x - y) \\\\\n  \u0026= x^2 - y^2 \\\\\ny^2 \u0026= x^2 - N \\\\\n\\end{aligned}\n$$\n\nより初期値を $x = \\lceil\\sqrt N\\rceil, y = 0$ として $x$ の値を1ずつ上げながら $y$ の値も上げていき、右辺と左辺の計算結果が一致したとき $p, q$ が求まるという仕掛けです。\n\n#### 近似比\n前の問題だと素数 $p, q$ が近い値のときしか対応できませんが、素数同士の近似比 $p:q \\approx a:b$ が与えられる場合だったらどうでしょうか。([RSA暗号攻撃で他でも使える n のこと](https://project-euphoria.dev/blog/27-rsa-attacks/) より)\n\n:::details 解法\n$$\n\\begin{aligned}\n\\frac{a}{b} \u0026\\approx \\frac{p}{q} \\\\\naq \u0026\\approx bp \\\\\naq \\times bp \u0026= abN\n\\end{aligned}\n$$\n\nこれより $abN$ に対し Fermat's method を適用することで $p, q$ が求まります。\n:::\n\n## 攻撃\n\n実際のRSAではこのような攻撃が発見されてきました。\n\n| アンチケース                                                              | 攻撃技                                                           | 方法                                                   |\n| --------------------------------------                                    | ---------------------------------------------------------------- | -------------------------------------------------      |\n| 公開鍵 $N$ の値が小さくてはいけない                                       | Pollard-$\\rho$ 素因数分解法                                      | 素因数分解                                             |\n| 近い値の素数を使ってはいけない                                            | Fermat's method                                                  | 素因数分解                                             |\n| $e$ の値が小さすぎてはいけない                                            | Low Public Exponent Attack                                       | 剰余ではなく整数上のe乗根となる                        |\n| $d$ の値が小さすぎてはいけない($e$の値が大きすぎてはいけない)             | Wiener's Attack, Boneh-Durfee Attack                             | 近似分数から見積もる, Coppersmith Method               |\n| 同一の平文を異なる $e$ で暗号化した暗号文を与えてはいけない               | Common Modulus Attack                                            | $e$ について拡張ユークリッドの互除法                   |\n| 同一の平文を異なる $N$ で暗号化した暗号文を与えてはいけない               | Håstad's Broadcast Attack                                        | 中国剰余定理                                           |\n| 同一の平文を同一の $d$ 異なる $e, N$ で暗号化した暗号文を与えてはいけない | Small Common Private Exponent Attack                             | Coppersmith Method                                     |\n| 任意の暗号文を復号した結果を知られてはいけない                            | 適応的選択暗号文攻撃                                             | $a^ec$ を復号すると $am$ となる                        |\n| 暗号文を復号した結果の偶奇を知られてはいけない                            | LSB Decryption Oracle Attack                                     | 二分探索                                               |\n| RSA-CRTにバグがあってはならない                                               | RSA-CRT Fault Attack                                             | 秘密鍵が書き換えれると平文の差分が $p, q$ の倍数となる |\n| 上位ビットが共通する二つの平文に対する暗号文を知られてはいけない          | Franklin-Reiter Related Message Attack                           | 最大公約式                                             |\n| 秘密鍵が部分的にでも知られてはならない                                    | Partial Key Exposure Attack                                      | Coppersmith Method                                     |\n(参考: [RSA暗号運用でやってはいけない n のこと](https://www.slideshare.net/sonickun/rsa-n-ssmjp))\n\nこれらの攻撃手法はCrypto問を解く上で基本的なアイデアとなります。解き方やソースコードなど詳しいことは実践編で取り扱いますが、ここではそれぞれのアイデアの中で特に重要な性質をここで紹介します。\n\n#### まとめ\nRSA暗号は素因数分解の困難性が安全性の根拠である。\nうまく実装しないと素因数分解を解かなくても攻撃が出来てしまう。\n\n## 中国剰余定理\n\n// TODO 中国剰余定理とは\nこれを使えば大きな問題を小さな問題に分割して計算することができます。\n\n$$\n\\bmod pq \\iff \\bmod p, \\bmod q\n$$\n\n-----\n\n#### 中国剰余定理 (CRT: Chinese Remainder Theorem)\n\n$$\n\\mathbb{Z}/p_1^{e_1}\\ldots p_n^{e_n}\\mathbb{Z} \\cong \\mathbb{Z}/p_1^{e_1}\\mathbb{Z}\\times\\ldots \\times\\mathbb{Z}/p_n^{e_n}\\mathbb{Z}\n$$\n\n証明\n//TODO\n\n$$\n\\mathbb{Z}/pq\\mathbb{Z} \\cong \\mathbb{Z}/p\\mathbb{Z}\\times\\mathbb{Z}/q\\mathbb{Z}\n$$\n\nをユークリッドの互除法で証明すれば大体証明できる。\n\n-----\n\n例えば $\\mathbb{Z}/15\\mathbb{Z} \\cong \\mathbb{Z}/3\\mathbb{Z}\\times\\mathbb{Z}/5\\mathbb{Z}$ となるので法が15の数と法が3, 5の数のペアは1対1に対応させることができます。\n\n| $\\times$ |  0  |  1  |  2  |  3  |  4  |\n|:--------:|:---:|:---:|:---:|:---:|:---:|\n|    0     |  0  |  6  | 12  |  3  |  9  |\n|    1     | 10  |  1  |  7  | 13  |  4  |\n|    2     |  5  | 11  |  2  |  8  | 14  |\n\n数自体だけではなく加法、乗法についても対応します。\n\n$$\n\\begin{aligned}\n8 \u0026+ 9 = 2 \u0026 \\pmod{15} \\\\\n\u0026\\downarrow \\\\\n(2, 3) \u0026+ (0, 4) = (2, 2) \u0026 \\pmod{(3, 5)} \\\\\n\\end{aligned}\n$$\n\n$$\n\\begin{aligned}\n8 \u0026\\times 9 = 12 \u0026 \\pmod{15} \\\\\n\u0026\\downarrow \\\\\n(2, 3) \u0026+ (0, 4) = (0, 2) \u0026 \\pmod{(3, 5)} \\\\\n\\end{aligned}\n$$\n\nコンピュータではどう計算するのでしょうか。\nまずは $\\bmod pq \\to \\bmod p, \\bmod q$ についてです。これは簡単で $a \\bmod p$ と $a \\bmod q$ を計算すればよいです。なぜかというと\n\n$$\n\\begin{aligned}\na \\bmod{pq} \\bmod{p} \u0026= (a - k_1pq) - k_2p \\\\\n\u0026= a - (k_1q + k_2)p \\\\\n\u0026= a \\bmod{p} \\\\\n\\end{aligned}\n$$\n\nとなるからです。注意すべきなのは2つが約数の関係となる剰余でしかこのような式は有効ではないです。例えば有効ではない式として $20 \\bmod 15 \\bmod 9 \\neq 20 \\bmod 9$ があります。\n\n逆に $\\bmod p, \\bmod q \\to \\bmod pq$ はどうやって計算するのでしょうか。この操作は持ち上げ(lift)とよばれていて、Garnerのアルゴリズムを用いて持ち上げます。\n\nこのような関係があるとします。\n\n$$\n\\begin{cases}\nx = r_1 \\pmod{m_1} \\\\\nx = r_2 \\pmod{m_2} \\\\\n\\end{cases}\n$$\n\nこれに対しては次のようにすることで持ち上げることができます。\n\n$$\n\\begin{aligned}\nx + q_1m_1 \u0026= r_2 \u0026 \\pmod{m_2} \\\\\nq_1m_1 \u0026= r_2 - x \u0026 \\pmod{m_2} \\\\\nq_1 \u0026= (r_2 - x)m_1^{-1} \u0026 \\pmod{m_2} \\\\\nx \u0026= x + (r_2 - x)(m_1^{-1} \\bmod{m_2})m_1 \u0026 \\pmod{m_1m_2} \\\\\n\\end{aligned}\n$$\n\n例えば「3 で割ったあまりが 2」かつ「5 で割ったあまりが 3」であるようなものは $2 + (3 - 2)2\\times3 = 8 \\pmod{15}$ となります。\n\nこれで中国剰余定理をコンピュータで再現できました。それではこれを使った代表的な攻撃について紹介します。\n\n#### 同一の平文を異なる $N$ で暗号化した暗号文を与えてはいけない(Håstad's Broadcast Attack)\n\n同一の平文を異なる $e$ 個の $N$ で暗号化した暗号文を与えられたとします。\n\n$$\n\\begin{cases}\nc_1 = m^e \\pmod{N_1} \\\\\nc_2 = m^e \\pmod{N_2} \\\\\n\\qquad \\vdots \\\\\nc_e = m^e \\pmod{N_e} \\\\\n\\end{cases}\n$$\n\nこれらの暗号文を中国剰余定理によって整数上の $m^e$ を作り $e$ 乗根して平文 $m$ を得られます。\n\n$$\n\\begin{aligned}\nm^e \u0026= \\mathrm{CRT}(c_1, c_2, \\ldots, c_e) \\pmod{N_1N_2\\ldots N_e} \\\\\n\u0026= \\mathrm{CRT}(c_1, c_2, \\ldots, c_e) \\quad (\\mathrm{over} \\ \\mathbb{Z}) \\\\\n\\end{aligned}\n$$\n\n#### Smooth な ElGamal暗号\n\n累乗を求めることは簡単でもDLPが難しいという非対称性を用いた暗号が ElGamal暗号 です。通常は素数を法としますが、多くの小さな素数で割り切れるようなsmoothな数を法とした場合はどうなるのか考えてみます。\n\n$$\nc = a^{m} \\pmod{p_1p_2\\ldots p_n}\n$$\n\nまずは素因数分解をします。今回はそれぞれの素数が小さいので Pollard-$\\rho$ 法を用いて素因数分解できます。そして暗号文をそれぞれの素因数について剰余を取ります。\n\n$$\n\\begin{aligned}\nc_1 \u0026= a^{m_1} \\pmod{p_1} \\\\\nc_2 \u0026= a^{m_2} \\pmod{p_2} \\\\\n\\vdots \\\\\nc_n \u0026= a^{m_n} \\pmod{p_n} \\\\\n\\end{aligned}\n$$\n\nそれぞれの式の法の数が小さいので DLP が解けます。\n\n$$\n\\begin{aligned}\nm_1\u0026 \\pmod{p_1 - 1} \\\\\nm_2\u0026 \\pmod{p_2 - 1} \\\\\n\\vdots \\\\\nm_n\u0026 \\pmod{p_n - 1} \\\\\n\\end{aligned}\n$$\n\nそれらを持ち上げることで平文を求めることができます。\n\n$$\nm = \\mathrm{CRT}(m_1, m_2, \\ldots, m_n)\n$$\n\n#### RSA-CRT Fault Attack\n\nRSAの復号をする際に $c^d$ を計算しますが、 $d = e^{-1} \\pmod {\\phi (N)}$ は比較的大きいので処理が重くなります。これに対してRSA-CRTは中国剰余定理(CRT)を用いて高速化を図っています。\n\n$$\n\\begin{aligned}\n\u0026\\begin{cases}\nd_p = d \u0026 \\pmod{p-1} \\\\\nd_q = d \u0026 \\pmod{q-1} \\\\\n\\end{cases} \\\\\n\u0026\\begin{cases}\nm_p = c^{d_p} \u0026 \\pmod p \\\\\nm_q = c^{d_q} \u0026 \\pmod q \\\\\n\\end{cases} \\\\\n\u0026\\quad \\ m = \\mathrm{CRT}(m_p, m_q) \u0026 \\pmod {N} \\\\\n\u0026\\qquad \\ = m_q + (m_p - m_q) (q^{-1} \\bmod p) q \u0026 \\pmod {N} \\\\\n\\end{aligned}\n$$\n\nこれより下の値を秘密鍵として持つことになります。\n\n$$\n\\begin{aligned}\nd_p \u0026= d \\bmod p−1 \\\\\nd_q \u0026= d \\bmod q−1 \\\\\nq_{inv} \u0026= q^{-1} \\bmod p \\\\\n\\end{aligned}\n$$\n\nしかし $d_p, d_q$ のどちらかが何らかの方法で書き換えられてしまったとき次のようにできます。\n\n$$\n\\begin{aligned}\nm_p \u0026= c^{d_p} \\pmod p \\\\\nm_q' \u0026= c^{d_q'} \\pmod q \\\\\nm \u0026= \\mathrm{CRT}(m_p, m_q) = kp + m_p \\\\\nm' \u0026= \\mathrm{CRT}(m_p, m_q') = k'p + m_p \\\\\n|m - m'| \u0026= |k - k'|p \\\\\np \u0026= \\gcd(|m - m'|, N) \\\\\n\\end{aligned}\n$$\n\nこれより元々の平文と書き換えられた平文の差が素数の倍数となり、解くことができます。\n\n## 一般の方程式を解く\n\nここからが本題です！！\nRSAというe次方程式の解を求めるだけに絞らず、任意の方程式を解くことができたらうれしいですよね。さっそく考えてみましょう。\n\n$$\n\\begin{cases}\n2x + 3y = 2 \u0026 \\pmod{13} \\\\\n3x + 5y = 1 \u0026 \\pmod{13} \\\\\n\\end{cases}\n$$\n\nまずは簡単そうな連立方程式を解くことを考えてみます。上の方程式を加減法を用いて解いてみます。中学生の頃を思い出しますね。\n\n$$\n\\begin{aligned}\n\u0026\\begin{cases}\n2x + 3y = 2 \u0026 \\pmod{13} \\\\\n3x + 5y = 1 \u0026 \\pmod{13} \\\\\n\\end{cases} \\\\\n\\iff\u0026\\begin{cases}\n6x + 9y = 6 \u0026 \\pmod{13} \\\\\n6x + 10y = 2 \u0026 \\pmod{13} \\\\\n\\end{cases} \\\\\n\\iff\u0026\\begin{cases}\nx = 7 \u0026 \\pmod{13} \\\\\ny = 9 \u0026 \\pmod{13} \\\\\n\\end{cases} \\\\\n\\end{aligned}\n$$\n\n普通の方程式と同様に解けました！\nより一般の連立方程式を解く為に行列を用いて解いてみます。拡大係数行列にしてガウスの消去法を行います！大学1年の復習ですね。\n\n$$\n\\begin{aligned}\n\\begin{pmatrix}\n2 \u0026 3 \\\\\n3 \u0026 5 \\\\\n\\end{pmatrix}\n\\begin{pmatrix}\nx \\\\\ny \\\\\n\\end{pmatrix}\n\u0026=\\begin{pmatrix}\n2 \\\\\n1 \\\\\n\\end{pmatrix} \\\\\n\n\\left(\n\\begin{array}{cc|c}\n2 \u0026 3 \u0026 2 \\\\\n3 \u0026 5 \u0026 1 \\\\\n\\end{array}\n\\right)\n\u0026\\to\n\\left(\n\\begin{array}{cc|c}\n0 \u0026 -1 \u0026 4 \\\\\n1 \u0026 2 \u0026 -1 \\\\\n\\end{array}\n\\right) \\\\\n\n\u0026\\to\n\\left(\n\\begin{array}{cc|c}\n1 \u0026 0 \u0026 7 \\\\\n0 \u0026 1 \u0026 9 \\\\\n\\end{array}\n\\right) \\\\\n\n\\begin{pmatrix}\nx \\\\\ny \\\\\n\\end{pmatrix}\n\u0026=\\begin{pmatrix}\n7 \\\\\n9 \\\\\n\\end{pmatrix} \\\\\n\\end{aligned}\n$$\n\n一般の連立方程式は次のように解けます。行列の次元が行数と一致すれば逆行列が存在します。\n\n$$\n\\begin{aligned}\nA\\mathbf{x} \u0026= \\mathbf{b} \\\\\n\\mathbf{x} \u0026= A^{-1}\\mathbf{b}\n\\end{aligned}\n$$\n\n$$\n\\begin{aligned}\nA = \\begin{pmatrix}\na_{11} \u0026 a_{12} \u0026 \\ldots \u0026 a_{1n} \\\\\na_{21} \u0026 a_{22} \u0026 \\ldots \u0026 a_{2n} \\\\\n\\vdots \u0026 \\vdots \u0026 \\ddots \u0026 \\vdots \\\\\na_{m1} \u0026 a_{m2} \u0026 \\ldots \u0026 a_{mn}\n\\end{pmatrix}\n\u0026\u0026\n\\mathbf{x} = \\begin{pmatrix}\nx_1 \\\\\n\\vdots \\\\\nx_n \\\\\n\\end{pmatrix}\n\u0026\u0026\n\\mathbf{b} = \\begin{pmatrix}\nb_1 \\\\\n\\vdots \\\\\nb_m \\\\\n\\end{pmatrix}\n\\pmod{p}\n\\end{aligned}\n$$\n\nなるほど。次元が式の数と一致する連立1次方程式は必ず解けそうですね。\n\nでは与えられる1次方程式が1つのみであればどうでしょうか。複数の解が出てきますが、その中で具体的な解を1つ返したいと思います。\n\n$$\na_1x_1 + a_2x_2 + \\ldots + a_nx_n = b \\pmod N\n$$\n\n1変数方程式であれば逆元を掛けて解けますが、2変数、3変数、n変数の場合だと難しそうです。\n\nこれに対抗し得るCrypto界最強の道具があります。LLL 基底簡約アルゴリズムです。詳しいことは格子暗号の回で紹介しますが、行列の値が全体的に小さくなるように変形してくれます。\n\nそれだけ？と言われそうですがこれがとても強くてRSA暗号以外にもナップサック暗号、格子暗号、楕円曲線暗号に使えたりします。\n\nこれをどうやって方程式に適用するかというと次のような行列を考えます。\n\n$$\n\\begin{pmatrix}\n1 \u0026 0 \u0026 0 \u0026 \\ldots \u0026 ? \u0026 ? \\\\\n0 \u0026 1 \u0026 0 \u0026 \\ldots \u0026 ? \u0026 ? \\\\\n0 \u0026 0 \u0026 1 \u0026 \\ldots \u0026 ? \u0026 ? \\\\\n\\vdots \u0026 \\vdots \u0026 \\vdots \u0026 \u0026 \\vdots \u0026 \\vdots \\\\\n0 \u0026 0 \u0026 0 \u0026 \\ldots \u0026 N \u0026 N \\\\\n\\end{pmatrix}\n$$\n\n例えば、\n\n$$\n8053x+343y+1362z\n$$\n\nの絶対値を小さくするような、全てが0ではない $x, y, z$ の値を求めたいときは、\n\n$$\n\\begin{pmatrix}\n1 \u0026 0 \u0026 0 \u0026 8053 \\\\\n0 \u0026 1 \u0026 0 \u0026 343 \\\\\n0 \u0026 0 \u0026 1 \u0026 1362 \\\\\n\\end{pmatrix}\n$$\n\nをLLLに投げれば良いです。実際に投げたら、次の答えが返ってきました。\n\n$$\n\\begin{pmatrix}\n0 \u0026 -4 \u0026 1 \u0026 -10 \\\\\n-3 \u0026 -5 \u0026 19 \u0026 4 \\\\\n-2 \u0026 35 \u0026 3 \u0026 -15 \\\\\n\\end{pmatrix}\n$$\n\n例えば2行目は、$x=−3, y=−5, z=19$ という解に対応しています。\n\n$$\n8053 \\times (−3) + 343 \\times (−5) + 1362 \\times 19 = 4\n$$\n\n応用すると解がある程度小さなことが分かっていると次のようにできます。\n\n$$\na_1x_1 + a_2x_2 + a_3x_3 + b = 0 \\pmod N \\\\\nx_1 \u003c 2^{32}, x_2 \u003c 2^{16}, x_3 \u003c 2^{8}\n$$\n\n定数は1回しか使ってはいけないという気持ちを込めて大きな数を設定して、他は解の制約に合わせて設定します。最下段は法の数を入れておくことで剰余上で計算してくれます。\n\n$$\n\\begin{pmatrix}\n1 \u0026 0 \u0026 0 \u0026 0 \u0026 a_1 \\\\\n0 \u0026 2^{16} \u0026 0 \u0026 0 \u0026 a_2 \\\\\n0 \u0026 0 \u0026 2^{24} \u0026 0 \u0026 a_3 \\\\\n0 \u0026 0 \u0026 0 \u0026 2^{32} \u0026 b \\\\\n0 \u0026 0 \u0026 0 \u0026 0 \u0026 N \\\\\n\\end{pmatrix}\n$$\n\n詳しくは次の記事で紹介されています。\n\nhttps://qiita.com/kusano_k/items/5509bff6e426e5043591\n\n一般の線形方程式は解けるようになりました！\nやったね！\n\nこうなってくると1次方程式だけではなく2次、3次、n次方程式も解いてみたいですね。\nまずは次のような方程式を考えてみます。\n\n$$\na_nx^n + \\ldots + a_1x + a_0 = 0 \\pmod N\n$$\n\n$x, y = x^2, z = x^3, \\ldots$ というように変数を設定してLLLで乗り切るという方法が1つあります。しかし $x, y, z$ には関係性という情報を失っています。それをうまく使ってあげたいですね。\nそこでHowgrave-Grahamの補題というものがあります。\n\n-----\n\n#### Thm. Howgrave-Grahamの補題\n$N$ を法、 $g(x) \\in \\mathbb{Z}[x]$ を整数多項式とし、含まれる単項式の数を $\\omega$ とする。$g(x)$ に対してある $X$ が存在し、$g(x_0) = 0 \\pmod{N}$ なる $x_0 \\in \\mathbb{Z}$ について $|x_0| \\leq X$ であると仮定する。このとき\n\n$$\n\\|g(xX)\\| \u003c \\frac{N}{\\sqrt{\\omega}}\n$$\n\nが成立するならば $g(x_0) = 0$ が整数方程式として成立する。ただし\n\n$$\n\\|g(x)\\| = \\left\\|\\sum_{i=0}^{\\deg g(x)}g_i\\right\\| = \\sqrt{\\sum_{i=0}^{\\deg g(x)}g_i^2}\n$$\n\nであり、 $\\deg g(x)$ は $g(x)$ の次数である。\n\n証明\n\n$$\n\\begin{aligned}\n|g(x_0)| \u0026= \\left|\\sum_{i=0}^{\\deg g(x_0)}g_ix_0^i\\right| \\\\\n\u0026\\leq \\sum_{i}|g_ix_0^i| \\\\\n\u0026\\leq \\sum_{i}|g_i|X^i \\\\\n\u0026= \\sum_{i}(1\\cdot|g_i|X^i) \\\\\n\u0026\\leq \\sqrt{\\sum_{i, g_i \\neq 0}1} \\sqrt{\\sum_{i}(|g_i|X^i)^2} \u0026\u0026 \\left(\\because \\text{コーシー＝シュワルツの不等式}\\right) \\\\\n\u0026= \\sqrt{\\omega}\\|g(xX)\\| \u003c N \u0026\u0026 \\left(\\because \\|g(xX)\\| \u003c \\frac{N}{\\sqrt{\\omega}}\\right)\n\\end{aligned}\n$$\n\n$g(x_0) = 0 \\pmod N$ より $g(x_0) = 0$ となる。\n\n-----\n\nつまり、「剰余の方程式は係数がある程度小さければそのまま整数方程式となるよ」と言っています。ここで勘のいい人はLLLを用いて係数を小さくすれば整数方程式に変換できて解けるのでは...！？と気付くでしょう。実際に考えてみましょう。\n\nとりあえず状況を整理すると、LLLに入れる値は各係数として、LLLを使う為には複数の方程式が必要になってきます。そしてそれらの方程式は同じ解を持つ必要があります。現在、その解が分からないのですが、どうしたらそんな方程式が作れるでしょうか。\n\n実は $\\bmod {N}$ では難しいので、$\\bmod {N^m}$ に持ち上げることで同じ解の方程式を増やすことができます。\n\n-----\n\n#### Lemma\n$N$ を法、$f(x)$ を多項式とする。自然数 $m, l$ について\n\n$$\ng_{i,j}(x) := N^{m−i}x^j f^i(x) \\ (0 \\leq i \\leq m, 0 \\leq j\\leq l)\n$$\n\nとおく。このとき、 $f(x_0) = 0 \\pmod N$ をみたす $x_0 \\in \\mathbb{Z}$ について、 $g_{i,j}(x_0) = 0 \\pmod{N^m}$ となる。\n\n証明\n\n$f(x_0) = 0 \\pmod N$ なので $f(x_0) = kN$ とおける。\n\n$$\n\\begin{aligned}\ng_{i,j}(x_0) \u0026= N^{m−i}x_0^j f^i(x_0) \\\\\n\u0026= N^{m−i}x_0^j (kN)^i \\\\\n\u0026= k^ix_0^j N^m \\\\\ng_{i,j}(x_0) \u0026= 0 \\pmod{N^m} \\\\\n\\end{aligned}\n$$\n\n-----\n\nこれで方程式を増やすことができました！ちゃんとLLLで動くかちょっと不安ですがとりあえずやってみます。\n\n小さくしたい方程式は $g_{i,j}(xX)$ であることに注意して。\n$g_{i,j}(x)$ の $k$ 次の係数のことを $g_{i,j}^{(k)}$ と表すことにします。\n\n$$\n\\begin{pmatrix}\ng_{0,0}^{(0)} \u0026 g_{0,0}^{(1)}X \u0026 g_{0,0}^{(2)}X^2 \u0026 g_{0,0}^{(3)}X^3 \u0026 g_{0,0}^{(4)}X^4 \u0026 g_{0,0}^{(5)}X^5 \\\\\ng_{0,1}^{(0)} \u0026 g_{0,1}^{(1)}X \u0026 g_{0,1}^{(2)}X^2 \u0026 g_{0,1}^{(3)}X^3 \u0026 g_{0,1}^{(4)}X^4 \u0026 g_{0,1}^{(5)}X^5 \\\\\ng_{1,0}^{(0)} \u0026 g_{1,0}^{(1)}X \u0026 g_{1,0}^{(2)}X^2 \u0026 g_{1,0}^{(3)}X^3 \u0026 g_{1,0}^{(4)}X^4 \u0026 g_{1,0}^{(5)}X^5 \\\\\ng_{1,1}^{(0)} \u0026 g_{1,1}^{(1)}X \u0026 g_{1,1}^{(2)}X^2 \u0026 g_{1,1}^{(3)}X^3 \u0026 g_{1,1}^{(4)}X^4 \u0026 g_{1,1}^{(5)}X^5 \\\\\ng_{2,0}^{(0)} \u0026 g_{2,0}^{(1)}X \u0026 g_{2,0}^{(2)}X^2 \u0026 g_{2,0}^{(3)}X^3 \u0026 g_{2,0}^{(4)}X^4 \u0026 g_{2,0}^{(5)}X^5 \\\\\ng_{2,1}^{(0)} \u0026 g_{2,1}^{(1)}X \u0026 g_{2,1}^{(2)}X^2 \u0026 g_{2,1}^{(3)}X^3 \u0026 g_{2,1}^{(4)}X^4 \u0026 g_{2,1}^{(5)}X^5 \\\\\n\\end{pmatrix}\n$$\n\nこれをLLLに通してあげると無事小さな値の方程式が返ってきます。これがHowgrave-Grahamの補題を満たしていれば整数方程式となります。後は適当に増減表書いたりして探索すれば解けます。\n\n### ほんまか？\n\nこれらの操作はCoppersmithの定理と呼ばれています。\n\n-----\n\n#### Thm. Coppersmithの定理\n$N$ を法とし $f(x)$ をモニックな 1変数 $\\delta$ 多項式とする。このとき $f(x_0) = 0 \\pmod{N}$ と次の条件を満たすような $x_0$ を効率よく求めることができる\n\n$$\n|x_0| \\leq N^{\\frac{1}{\\delta}}\n$$\n\n-----\n\nこれで一般のn次方程式について小さな解を求めることができるようになりました！\n\n// TODO ここに具体例\n\n$$\nax^5 + bx + c = 0\n$$\n\nさらにCoppersmithの定理には拡張できることが2つあります。\n\n- 未知の法について解ける。素因数分解が出来ないほど大きな数を法としたときに既知の法の約数を法とする式の解を求められます。法が小さいほど方程式に対する制約がゆるくなります。\n- 多変数の方程式も解ける。これは変数が1つだけでしたが、複数の変数でもできます。変数の数が多いほど方程式に対する制約がキツくなります。\n\nこれらは Howgrave-Grahamの補題 などを見直すことで簡単に拡張できます。興味ある方は考えてみてください。\n\nこれらをまとめてCoppersmith Methodと呼びます。\n\nこれを使って様々な攻撃ができます。\nCoppersmith Method はRSAをそのまま与えても解けませんが何かしらの値が一部分だけ分かっていると解けるというものです。\n\n解きたい方程式の法の数の下限 $\\beta$ と解が存在しうる上限 $X$ を決めて関数を与えると解が返ってきます。\n\n### Boneh-Durfee Attack\n\nまず以下のように変形します。\n\n$$\n\\begin{aligned}\ned \u0026= 1 \u0026 \\pmod{\\phi} \\\\\ned \u0026= k \\phi + 1 \u0026 (\\mathrm{over}\\ \\mathbb{Z}) \\\\\n0 \u0026= k \\phi + 1 \u0026 \\pmod e \\\\\n\u0026= k (N + 1 - p - q) + 1 \u0026 \\pmod e \\\\\n\u0026= 2k \\left(\\frac{N + 1}{2} + \\frac{-p -q}{2}\\right) + 1 \u0026 \\pmod e \\\\\n\\end{aligned}\n$$\n\nこの方程式について $f(x,y) = x (A + y) + 1$ とおき、関数 $f(x,y)$ に対して Coppersmith Method を用いることで $p + q$ が求まり、解くことができます。\n\n### 秘密鍵が部分的にでも知られてはいけない (Partial Key Exposure Attack)\n\n秘密鍵を部分的に知っていさえいれば、Coppersmith Method を用いて解けてしまう。\n$n$ を $N$ のビット数とする。\n\n#### p, q のどちらかを n/4 ビット程度知っているとき\n\n例えば p を部分的に知っているときこのような関数を作ります。\n\n$$\n\\begin{aligned}\nf(x) \u0026= p_{upper} + x \u0026 \\pmod N \\\\\nf(x) \u0026= 2^{k}x + p_{lower} \u0026 \\pmod N \\\\\nf(x,y) \u0026= 2^kx + p_{mid} + y \u0026 \\pmod N \\\\\n\\end{aligned}\n$$\n\nこれに対して法の数を $p$ としたいので $\\beta \\approx 0.3$ として、実行すると出てきます。\n\n#### d を n/4 ビット程度知っているとき\n\n$e$ が総当り出来るくらい小さいときに $d$ を $n/4$ ビットだけ知っていれば元の $d$ を構成できる。大体の場合は $e = 65537$ であるから十分可能である。$d \u003c \\phi(N)$ より $0 \u003c k \\leq e$ となり、この $k$ に対して総当たりする。\n\n##### 上位ビットの場合\n$d$ と $p, q$ の関係式を立てる。\n\n$$\n\\begin{aligned}\ned \u0026= 1 \u0026 \\pmod{\\phi(N)} \\\\\ned \u0026= 1 + k(N - p - q + 1) \\\\\nd \u0026= \\frac{kN}{e} - \\frac{k(p+q-1) -1}{e} \\\\\ne(d_{upper} + x) \u0026= - k (y - 1) + 1 \u0026 \\pmod N \\\\\n\\end{aligned}\n$$\n\n第三式について $p + q \\approx \\sqrt{N}$ より第二項は上位ビットに関連する情報を持たない。これより第一項の $k$ について総当りして上位ビットと一致する $k$ を見つければよい。すると第4式に対し Coppersmith Method を用いて、$d$ がわかる。\n\n##### 下位ビットの場合\nまずは $d$ の下位ビットから $p$ の下位ビットを求める。\n\n$$\n\\begin{aligned}\ned \u0026= 1 + k\\left(N - p - \\frac{N}{p} + 1\\right) \\\\\nedp \u0026= p + kp(N - p + 1) - kN \u0026 \\pmod {2^{n/4}} \\\\\n\\end{aligned}\n$$\n\n $k$ について総当りして $p$ の最下位ビットを求める。すると先程の問題に帰着できて $p$ がわかり $d$ がわかる。\n\n\n#### RSA-CRT の秘密鍵 d を n/4 ビット程度知っているとき\n\n$$\n\\begin{aligned}\ned_p \u0026= 1 \u0026 \\pmod{p-1} \\\\\ned_p \u0026= 1 + k_p(p − 1) \\\\\n\\end{aligned}\n$$\n\n上と同様です。\n\n#### 平文 m を (1-1/e)n ビット程度知っているとき\n\n次数が大きいのである程度知っていないと解けません。\n\n$$\n\\begin{aligned}\nf(x) \u0026= (m_{upper} + x)^e - c \u0026 \\pmod N \\\\\nf(x) \u0026= (2^kx + m_{lower})^e - c \u0026 \\pmod N \\\\\nf(x,y) \u0026= (2^kx + m_{mid} + y)^e - c \u0026 \\pmod N \\\\\n\\end{aligned}\n$$\n\n\nこのようにある程度知っているとCoppersmith Methodで解けるものが多いです。\n\nCoppersmith method を使ったより様々な攻撃を知りたければ次の資料を読むことををおすすめします。\n\nhttps://eprint.iacr.org/2020/1506.pdf\n\n### その他の道具\n\nさて多変数連立n次方程式の場合はどうでしょう。Coppersmithも使うこともできますが、精度は出にくいです。これに対して使われる道具は多項式GCD, 終結式, Gröbner基底があります。\n\n#### 多項式GCD\n\nまずは多項式GCDです。\n例えば $x$ について同じ解を持つ次のような方程式を考えてみましょう。\n\n$$\n\\begin{cases}\nf_1 = x^e - c_1 \u0026 \\pmod{N} \\\\\nf_2 = (x + y)^e - c_2 \u0026 \\pmod{N} \\\\\n\\end{cases} \\\\\n$$\n\nこれは多項式GCDを取ると解けます。その名の通り、ある2つの方程式に公約式があったとき、最も次数が大きい公約式を返します。Half-GCDというアルゴリズムを用いると $O(N(\\log{N})^2)$ でGCDが取れます。(N is 何)\n\n$$\n\\begin{aligned}\n\u0026\\begin{cases}\nf_1 = x^e - c_1 \u0026 \\pmod{N} \\\\\nf_2 = (x + y)^e - c_2 \u0026 \\pmod{N} \\\\\n\\end{cases} \\\\\n\\iff\n\u0026\\begin{cases}\nf_1 = (x - m)g_1 \u0026 \\pmod{N} \\\\\nf_2 = (x - m)g_2 \u0026 \\pmod{N} \\\\\n\\end{cases} \\\\\n\u0026\\gcd(f_1, f_2) = x - m\n\\end{aligned}\n$$\n\n#### 終結式\n式増やしてgcd\n\n#### Gröbner基底\n\nGröbner基底のお気持ちは多項式イデアルを格子にしたものに対して順序を与えて基底簡約するものです。\n\n\n\nBuchberger's Algorithmと呼ばれています。\n\n\n表に解き方をまとめるとこんな感じです。\n\n|            |           1変数          |               多変数              |\n|:----------:|:------------------------:|:---------------------------------:|\n| 線型方程式 | 拡張ユークリッドの互除法 |                LLL                |\n|  n次方程式 |    Coppersmith Method    | 多項式GCD, 終結式, Gröbner基底 |\n\n\n\n## 理論編まとめ\n\nこのようにしてRSA暗号は解くことは出来ます。\n\nこれらを知っておけばRSA暗号の研究論文が追えるようになっていると思います。\n興味がある人は暗号に特化した論文サイト [ePrint Archive](https://eprint.iacr.org/) を覗いてみると良いと思います。\n\n## コラム 素数生成\n\n暗号として機能する素数の大きさは $2^{512}$ や $2^{1024}$ 程度のオーダーとなっています。素数定理より、ある数 $n$ が素数である確率は約 $1/\\log n$ です。例えば $n=2^{512}$ で2.8%、 $n=2^{1024}$ で1.4%となります。つまり、500回乱数を生成すれば99.65%で素数を見つけられるということです。\n素数判定のアルゴリズムは多くありますが、ここではMiller-Rabin素数判定法を紹介します。\n\n#### Miller–Rabin 素数判定法\n\n素数判定法とはその名の通り、数を与えるとそれが素数かどうかが分かる判定法です。その中で Miller-Rabin 素数判定法は与えられた数 $n$ が素数かどうかを計算時間 $O(k\\log^3 n)$ で誤り率 $4^{-k}$ 以下で判定する確率的素数判定アルゴリズムです。\n\n$n$ が素数のとき、$n-1$ はそれを $2$ で割れるだけ割った数を $d$ として $n-1 = 2^sd$ と書けます。フェルマーの小定理より $a≠0 \\pmod n$ のとき\n\n$$\n\\begin{aligned}\na^{n-1} \u0026= a^{2^sd} ≡ 1 \\quad \\pmod n \\\\\na^{2^sd}-1 \u0026= (a^d-1)(a^d+1)(a^{2d}+1)(a^{4d}+1)\\cdots(a^{2^{s-1}d}+1)\\\\\n\u0026≡ 0 \\\\\n\\end{aligned}\n$$\n\nこれより次の2式のどちらかが成り立ちます。\n\n$$\n\\begin{aligned}\n\\left\\{\n\\begin{array}{ll}\na^d \u0026≡ 1 \u0026 \\pmod n \\\\\na^{2^rd} \u0026≡ -1 \u0026 \\pmod n \\qquad (\\exists r \\in \\mathbb{Z}, 0\\leq r\\leq s-1)\n\\end{array}\n\\right.\n\\end{aligned}\n$$\n\nこの対偶をとると、「ある $a$ をとってきて次の2式をどちらも満たすとき\n\n$$\n\\begin{aligned}\n\\left\\{\n\\begin{array}{ll}\na^d \u0026\\neq 1 \u0026 \\pmod n\\\\\na^{2^rd} \u0026\\neq -1 \u0026 \\pmod n \\qquad (\\forall r \\in \\mathbb{Z}, 0\\leq r\\leq s-1)\n\\end{array}\n\\right.\n\\end{aligned}\n$$\n\n$n$ は合成数である」と言えます。\n\nこれを用い、次のステップを実行することで確率的な素数判定ができます。\n1. $1\\leq a \\leq n-1$ でaの値をランダムにとってくる。\n2. 上の条件を満たしたらcompositeと返す。\n3. 満たさなければprobably primeと返す。\n\nこれを繰り返すことで判定の精度が高まります。この処理をMiller–Rabin素数判定法といって、実行時間は $O(k\\log^3 n)$ 、FFTベースの乗算で $Õ(k\\log^2 n)$ となります。\n\n具体例を考えてみましょう。\n判定時にprobably primeを返す時 p、compositeを返す時 c として具体値を入れると次のようになります。\n$n = 25$ (合成数)のとき\n$n-1 = 24 = 2^3 \\times 3$ より $s = 3, d = 3$\n\n| a | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10 | 11 | 12 | 13 | 14 | 15 | 16 | 17 | 18 | 19 | 20 | 21 | 22 | 23 | 24 |\n|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|\n| $a^3 \\bmod 25$ | 1 | 8 | 2 | 14 | 0 | 16 | 18 | 12 | 4 | 0 | 6 | 3 | 22 | 19 | 0 | 21 | 13 | 7 | 9 | 0 | 11 | 23 | 17 | 24 |\n| $a^6 \\bmod 25$ | 1 | 14 | 4 | 21 | 0 | 6 | 24 | 19 | 16 | 0 | 11 | 9 | 9 | 11 | 0 | 16 | 19 | 24 | 6 | 0 | 21 | 4 | 14 | 1 |\n| $a^{12} \\bmod 25$ | 1 | 21 | 16 | 16 | 0 | 11 | 1 | 11 | 6 | 0 | 21 | 6 | 6 | 21 | 0 | 6 | 11 | 1 | 11 | 0 | 16 | 16 | 21 | 1 |\n| 判定 | p | c | c | c | c | c | p | c | c | c | c | c | c | c | c | c | c | p | c | c | c | c | c | p |\n\n$n = 17$ (素数)のとき\n$n-1 = 16 = 2^4 \\times 1$ より $s = 4, d = 1$\n\n| a | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10 | 11 | 12 | 13 | 14 | 15 | 16 |\n|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|\n| $a \\bmod 17$ | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10 | 11 | 12 | 13 | 14 | 15 | 16 |\n| $a^2 \\bmod 17$ | 1 | 4 | 9 | 16 | 8 | 2 | 15 | 13 | 13 | 15 | 2 | 8 | 16 | 9 | 4 | 1 |\n| $a^4 \\bmod 17$ | 1 | 16 | 13 | 1 | 13 | 4 | 4 | 16 | 16 | 4 | 4 | 13 | 1 | 13 | 16 | 1 |\n| $a^8 \\bmod 17$ | 1 | 1 | 16 | 1 | 16 | 16 | 16 | 1 | 1 | 16 | 16 | 16 | 1 | 16 | 1 | 1 |\n| 判定 | p | p | p | p | p | p | p | p | p | p | p | p | p | p | p | p |\n\nかなり正確に判定できていることがわかるでしょう。\n\n素数については必ず成功し、合成数のときは誤る可能性が $1/4$ 以下ということが示せるので、 $k$ 回試行すれば誤り率は $4^{-k}$ 以下となります。つまり、ある値に対して10回素数判定法を回せば99.9999046%成功するということです。\n\n\n# RSA暗号を極める！(実践編)\n\n理論編を読んでRSA暗号で使われる道具たちを把握できたかと思います。(理論編を読んでない方は...読んでも読まなくてもどちらでもいいです。気になったときに読んだ方がたのしいです。)\n\nここでは実際にスクリプトを書いて攻撃していきます！攻撃したことない人はコードを書きながら勉強でき、CTFerにはライブラリ保管庫として使ってほしいと思って書いてます。\n// TODO ちゃんと書く\n\n### 紹介するRSA暗号の解読方法\n\n| アンチケース                                                              | 攻撃技                                                           | 方法                                                   |\n| --------------------------------------                                    | ---------------------------------------------------------------- | -------------------------------------------------      |\n| 公開鍵 $N$ の値が小さくてはいけない                                       | Pollard-$\\rho$ 素因数分解法                                      | 素因数分解                                             |\n| 近い値の素数を使ってはいけない                                            | Fermat's method                                                  | 素因数分解                                             |\n| $e$ の値が小さすぎてはいけない                                            | Low Public Exponent Attack                                       | 剰余ではなく整数上のe乗根となる                        |\n| $d$ の値が小さすぎてはいけない($e$の値が大きすぎてはいけない)             | Wiener's Attack, Boneh-Durfee Attack                             | 近似分数から見積もる, Coppersmith Method               |\n| 同一の平文を異なる $e$ で暗号化した暗号文を与えてはいけない               | Common Modulus Attack                                            | $e$ について拡張ユークリッドの互除法                   |\n| 同一の平文を異なる $N$ で暗号化した暗号文を与えてはいけない               | Håstad's Broadcast Attack                                        | 中国剰余定理                                           |\n| 同一の平文を同一の $d$ 異なる $e, N$ で暗号化した暗号文を与えてはいけない | Small Common Private Exponent Attack                             | Coppersmith Method                                     |\n| 任意の暗号文を復号した結果を知られてはいけない                            | 適応的選択暗号文攻撃                                             | $a^ec$ を復号すると $am$ となる                        |\n| 暗号文を復号した結果の偶奇を知られてはいけない                            | LSB Decryption Oracle Attack                                     | 二分探索                                               |\n| RSAにバグがあってはならない                                               | RSA-CRT Fault Attack                                             | 秘密鍵が書き換えれると平文の差分が $p, q$ の倍数となる |\n| 上位ビットが共通する二つの平文に対する暗号文を知られてはいけない          | Franklin-Reiter Related Message Attack                           | 最大公約式                                             |\n| 秘密鍵が部分的にでも知られてはならない                                    | Partial Key Exposure Attack                                      | Coppersmith Method                                     |\n\nそれとわかりやすいように暗号化, 復号化関数 $Enc, Dec$ を定義しておきます。\n\n$$\n\\begin{aligned}\nEnc(m) \u0026= m^e \u0026\\pmod N \\\\\nDec(c) \u0026= c^d \u0026\\pmod N \\\\\n\\end{aligned}\n$$\n\n#### N の値が小さくてはいけない (Pollard-rho 素因数分解法)\n\n公開鍵 $N$ が小さいと素因数分解されて秘密鍵 $p, q$ を求められてしまいます。素因数分解を行うアルゴリズムは多くありますが、今回はお手軽で高速に求められるアルゴリズムである Pollard-rho 法を解説します。\n\n以下のように擬似的にランダムな値を生成する関数 $f$ を用いて2つの値の差が $N$ との共通因数を持つまで繰り返します。これはパッと見、そこまで速いアルゴリズムに見えませんが、誕生日のパラドックスと同じようなカラクリになっていて平均計算量 $\\mathcal{O}(\\sqrt{N})$ で素因数を見つけられます。\n\n$$\n\\begin{aligned}\nf(x) \u0026= x^2 + c \\pmod N \\\\\nx_{i+1} \u0026= f(x_i) \\\\\ny_{i+1} \u0026= f(f(y_i)) \\\\\n\\end{aligned}\n$$\n\n:::details ライブラリ\n$c$ は $1$ とし、初期値は $2$ を用いることが多いらしいです。\n```python\ndef gcd(m, n):\n    while n:\n        m, n = n, m % n\n    return m\n\ndef pollard_rho(N):\n    f = lambda x: (x*x + 1) % N\n    x = y = 2\n    d = 1\n    while d == 1:\n        x = f(x)\n        y = f(f(y))\n        d = gcd(abs(x - y), N)\n    return d if d \u003c N else -1\n```\n:::\n\nまた素因数分解の結果をデータベースとして保管しているサイトがあって実戦で便利です。\nhttp://www.factordb.com/\n\n\n\n#### 近い値の素数を用いてはいけない (Fermat's method)\n\n$p, q$ が近いと中心から順に調べることで素数の組を見つけられます。様々な探索の方法がありますが、以下のような方法がよく用いられています。\n\n$$\n\\begin{aligned}\nN \u0026= pq \\\\\n  \u0026= (x + y)(x - y) \\\\\n  \u0026= x^2 - y^2 \\\\\ny^2 \u0026= x^2 - N \\\\\n\\end{aligned}\n$$\n\nより初期値を $x = \\lceil\\sqrt N\\rceil, y = 0$ として $x$ の値を1ずつ上げながら $y$ の値も上げていき、右辺と左辺の計算結果が一致したとき $p, q$ が求まるという仕掛けです。\n\nさらに、このままだと素数 $p, q$ が近い値のときしか対応できませんが、素数同士の近似比を与えればその付近で探索することが出来ます。素数 $p, q$ の近似比が $a : b$ と与えられれば次のように計算できます。\n\n$$\n\\begin{aligned}\n\\frac{a}{b} \u0026\\approx \\frac{p}{q} \\\\\naq \u0026\\approx bp \\\\\naq \\times bp \u0026= abN\n\\end{aligned}\n$$\n\nこれより $abN$ に対し Fermat's method を適用することで $p, q$ が求まります。\n\nまた、$p, q$ についてより複雑な関係がある場合には Coppersmith method が適用できます。\n\n:::details ライブラリ\n```python\ndef fermat(N):\n    x = floor(sqrt(N)) + 1\n    y = floor(sqrt(x * x - N))\n    while True:\n        w = x * x - N - y * y\n        if w == 0:\n            break\n        elif w \u003e 0:\n            y += 1\n        else:\n            x += 1\n    return (x - y, x + y)\n```\n:::\n\n#### eの値が小さすぎてはいけない (Low Public Exponent Attack)\n\n$e$ が小さいとき、$m^e \u003c N$ となって、累乗根を取ればそのまま平文になることがあります。\n\n$$\n\\begin{aligned}\nc \u0026≡ m^e \\pmod N \\\\\nc \u0026= m^e \\\\\nm \u0026= \\sqrt[e] c\n\\end{aligned}\n$$\n\n累乗根はニュートン法と呼ばれる近似法を用いると高速に求められます。これはPythonパッケージのgmpy2で実装されているのでそれを使います。\n\n$$\n\\begin{aligned}\nf(x) \u0026= x^e - c \\\\\n0 \u0026= f'(x_n)(x_n - x_{n+1}) + f(x_n) \\\\\nx_{n+1} \u0026= x_n - \\frac{f(x_n)}{f'(x_n)} \\\\\nx_{n+1} \u0026= x_n - \\frac{x_n}{e} + \\frac{c}{ex_n^{e-1}}\n\\end{aligned}\n$$\n\n\n:::details ライブラリ\n```python\nimport gmpy2\n\nm = gmpy2.iroot(c, e)[0]\n```\n:::\n\n#### eの値が大きすぎてはいけない (Wiener's Attack)\n\n$e$ が大きいとき $(e \\approx N)$ 、秘密鍵 $d = e^{-1}$ が小さくなり $d$ を求められます。\n\n次のように $e/N$ に対してユークリッドの互除法を用いて連分数展開し、適当な場所で打ち切って再構成することで近似分数を作ることが出来ます。そしてこの近似分数が $k/d$ と一致するとき秘密鍵 $d$ が求まります。\n\n$$\n\\begin{aligned}\ned \u0026≡ 1 \\pmod{\\phi(N)} \\\\\ned \u0026= k\\phi(N) + 1 = k(N - p - q + 1) + 1 \\\\\n\\frac{e}{N} \u0026= \\frac{k}{d}(1-\\delta) \u0026\\delta = \\frac{p + q - 1 - \\frac{1}{k}}{N} \\approx \\frac{1}{2^{512}} \\\\\n\\frac{e}{N} \u0026\\approx q_0 + \\cfrac{1}{q_1 + \\cfrac{1}{q_2 + \\cfrac{1}{\\ddots \\cfrac{}{q_{m-1} + \\cfrac{1}{q_m}}}}} = \\frac{k_m}{d_m} \\\\\n\\end{aligned}\n$$\n\n$q_i, k_i, d_i$ については次の漸化式を用いて計算できます。形式的に数列の $-1, -2$ 番目も定義することで分かりやすく計算できます。\n\n$$\n\\begin{aligned}\nr_{-2} \u0026= e \u0026 k_{-2} \u0026= 0 \u0026d_{-2} \u0026= 1 \\\\\nr_{-1} \u0026= N \u0026 k_{-1} \u0026= 1 \u0026d_{-1} \u0026= 0 \\\\\nr_{i-2} \\div r_{i-1} \u0026= q_{i} \\cdots r_{i} \u0026 k_i \u0026= q_i k_{i−1} + k_{i−2} \u0026d_i \u0026= q_i d_{i−1}+d_{i−2} \\\\\n\\end{aligned}\n$$\n\n$q_i, k_i, d_i$ の計算をどこで打ち切るかは2次方程式 $x^2 - (p + q)x + pq = 0$ の判別式を用いて判定します。判別式が正となるとき解 $p, q$ のが存在し、 $p+q$ が整数ならば $p, q$ も整数となるという方法です。\n\n$$\n\\begin{aligned}\np + q \u0026= N - \\frac{ed_i - 1}{k_i} + 1 \\in \\mathbb{N} \\\\\npq \u0026= N \\\\\nD \u0026= (p + q)^2 - 4N \\geq 0 \\\\\n\\end{aligned}\n$$\n\nこの攻撃は以下のように $d$ が十分小さいときしか成立しません。 $e$ が大きいと $d$ が小さくなりやすいという性質がある為、公開鍵 $e$ が大きいときと表現しますが、$d$ がこれ以上であれば攻撃は成立しません。\n\n$$\nd \u003c \\frac{N^{\\frac{1}{4}}}{3}\n$$\n\n:::details ライブラリ\n```python\nimport gmpy2\n\ndef WienersAttack(n, e):\n    r0, r1 = e, n\n    k0, k1 = 0, 1\n    d0, d1 = 1, 0\n\n    i = 0\n    while r1 != 0:\n        q = r0 // r1\n        r0, r1 = r1, r0 % r1\n        k0, k1 = k1, q*k1 + k0\n        d0, d1 = d1, q*d1 + d0\n\n        if i % 2 == 0:\n            k = k1 + k0\n            d = d1 + d0\n        else:\n            k = k1\n            d = d1\n\n        i += 1\n        if k == 0 or (e * d - 1) % k != 0:\n            continue\n        s = n - (e * d - 1) // k + 1\n        D = s*s - 4*n\n        sD = gmpy2.isqrt(D)\n        if D \u003e 0 and sD * sD == D:\n            return d\n    return -1\n```\n:::\n\nさらにWiener's Attackより強い攻撃としてBoneh-Durfee Attackがあります。まず以下のように変形します。\n\n$$\n\\begin{aligned}\ned \u0026= 1 \u0026 \\pmod{\\phi} \\\\\ned \u0026= k \\phi + 1 \u0026 (over \\ \\mathbb{Z}) \\\\\n0 \u0026= k \\phi + 1 \u0026 \\pmod e \\\\\n\u0026= k (N + 1 - p - q) + 1 \u0026 \\pmod e \\\\\n\u0026= 2k \\left(\\frac{N + 1}{2} + \\frac{-p -q}{2}\\right) + 1 \u0026 \\pmod e \\\\\n\\end{aligned}\n$$\n\nこの方程式について $f(x,y) = x (A + y) + 1$ とおき、関数 $f(x,y)$ に対して Multivariate Coppersmith Method を用いることで $p + q$ が求まり、解くことができます。\n\n:::details ライブラリ\nSageMath は標準に Multivariate Coppersmith Method を使うことができません。 [defund/coppersmith](https://github.com/defund/coppersmith) というリポジトリにそれが実装されているので、それを用いて攻撃することが多いです。\n\n```python\nload('coppersmith.sage')\n\ndef boneh_durfee(N, e):\n\tbounds = (floor(N^.25), 2^1024)\n\tP.\u003ck, s\u003e = PolynomialRing(Zmod(e))\n\tf = 2*k*((N+1)//2 - s) + 1\n\tprint(small_roots(f, bounds, m=3, d=4))\n```\n:::\n\n#### 同一の平文を異なるeで暗号化した暗号文を与えてはいけない (Common Modulus Attack)\n\n異なる $e$ で暗号化するとユークリッドの互除法を用いてより小さな $e$ の暗号文を作れて、解読できてしまいます。\n\n$$\n\\begin{aligned}\nc_1 \u0026≡ m^{e_1} \\pmod N \\\\\nc_2 \u0026≡ m^{e_2} \\pmod N \\\\\n\\end{aligned}\n$$\n\n$e_1, e_2$ について $\\gcd(e_1, e_2) = g$ のとき、拡張ユークリッドの互除法を用いることで次を満たす $s_1, s_2$ を求められます。\n\n$$\n\\begin{aligned}\ns_1e_1 + s_2e_2 \u0026= g \\\\\nc_1^{s_1} c_2^{s_2} = m^{s_1e_1 + s_2e_2} \u0026= m^g \\pmod N \\\\\n\\end{aligned}\n$$\n\nこれによって $e_1, e_2$ が互いに素のとき、または $g$ が小さいならばLow Public Exponent Attackを用いて $m$ を求められます。\n\n#### 同一の平文を異なるnで暗号化した暗号文を与えてはいけない (Håstad's Broadcast Attack)\n\n$n_1, \\ldots, n_e$ が互いに素ならば中国剰余定理を用いて $m$ を求められる。Garnerのアルゴリズムを用いて $m^e$ を計算する。\n\n$$\n\\begin{aligned}\nc_1 \u0026≡ m^e \\pmod{N_1} \\\\\nc_2 \u0026≡ m^e \\pmod{N_2} \\\\\n\\vdots \\\\\nc_e \u0026≡ m^e \\pmod{N_e} \\\\\nm^e \u0026≡ CRT(c_1, c_2, \\dots , c_e) \\pmod{N_1N_2\\cdots N_e} \\\\\nm^e \u0026= CRT(c_1, c_2, \\dots , c_e)\n\\end{aligned}\n$$\n\n:::details ライブラリ\n\n```python\nimport gmpy2\n\ne = 3\nc = [c1, c2, c3]\nN = [N1, N2, N3]\nme = crt(c, N)\nm = gmpy2.iroot(me, e)[0]\n```\n:::\n\n#### 任意の暗号文を復号した結果を知られてはいけない (適応的選択暗号文攻撃)\n\n任意の暗号を復号した結果を知っているとき、ある暗号文の復号結果を防がれていたとしても他の暗号を送ることで解読できます。\n$2^e$ を暗号文に掛けて復号した結果を $2$ で割ればその平文がわかります。\n\n$$\n\\begin{aligned}\nDec(2^ec) = 2m \\pmod N\n\\end{aligned}\n$$\n\nこれに対する防御方法として平文にパディングを施し、復号化した際にパディング形式が違うときは相手に渡さないようにするという方法があります。これによって正当な暗号文しか受け入れず、適応的選択暗号文攻撃を防げます。\n\nパディング形式の1つにPKCS #1 v1.5があります。\n\n`0002\u003crandom\u003e00\u003chashprefix\u003e\u003cmessage\u003e`\n\nこれについてパディングが合っているかどうかを相手に送ってしまうとPadding Oracle Attackで攻撃でき、PKCS #1 v1.5では200万程度送ると平文が読めてしまいます。\n\n対してPadding Oracle Attackで破られないようなパディング形式はInD-CCA2と呼びます。\n\nその1つであるOAEP(Optimal Asymmetric Encryption Padding)については次の記事を読むとよいです。\n\n##### 参考文献\nhttps://inaz2.hatenablog.com/entry/2016/01/26/222303\n\n#### 暗号文を復号した結果の偶奇を知られてはいけない (LSB Decryption Oracle Attack)\n\n全てが分かっていなくとも偶奇さえ分かれば任意の暗号文を復号できる。\nある暗号文 $c$ に対し、$2^e$ をx回掛けた値を復号した下位1bitを得て平文を求めます。得られる下位1bitは次の関数 $f(x)$ を用いて $f(x) \\bmod 2$ と表せられます。decは復号化関数です。\n\n$$\n\\begin{aligned}\nf(x) \u0026= Dec(2^{ex}c \\bmod N) = 2^xm \\bmod N \\\\\n\\end{aligned}\n$$\n\n$x = 1$ のとき\nまず $0 \\leq m \u003c N$ であるから $f(1)$ は $2m \\bmod N = 2m, 2m - N$ のどちらかとなる。また $2m$ は偶数、$N$ は奇数であるから $f(1)$ が偶数か奇数かで $2m, 2m - N$ のどちらかが分かります。すると $m$ が存在する区間が分かります。\n\n$$\n\\begin{aligned}\n\u0026f(1) = 2m \\bmod N \\\\\n\u0026\n\\begin{cases}\n    f(1) \\bmod 2 = 1 \\Leftrightarrow f(1) = 2m - N \u0026 \\Leftrightarrow \\frac{N}{2} \\leq m \u003c N \\\\\n    f(1) \\bmod 2 = 0 \\Leftrightarrow f(1) = 2m \u0026 \\Leftrightarrow 0 \\leq m \u003c \\frac{N}{2} \\\\\n\\end{cases}\n\\end{aligned}\n$$\n\nつまり $m$ は $[0, N)$ の範囲に対して最下位ビットが1のとき区間の右半分、0のとき区間の左半分だと言えます。\n\n$x = 2$ のとき\n前の結果を用いて場合分けして考えると同様の考え方で次のように導けます。\n\n$$\n\\begin{aligned}\nf(2) \u0026= 2(2m \\bmod N) \\bmod N \\\\\nf(1) \u0026= 2m - N \\Rightarrow f(2) = 4m - 2N \\bmod N \\\\\n\u0026\n\\begin{cases}\n    f(2) \\bmod 2 = 1 \\Leftrightarrow f(2) = 4m - 3N \u0026 \\Leftrightarrow \\frac{3N}{4} \\leq m \u003c N \\\\\n    f(2) \\bmod 2 = 0 \\Leftrightarrow f(2) = 4m - 2N \u0026 \\Leftrightarrow \\frac{N}{2} \\leq m \u003c \\frac{3N}{4} \\\\\n\\end{cases}\n\\\\\nf(1) \u0026= 2m \\Rightarrow f(2) = 4m \\bmod N \\\\\n\u0026\n\\begin{cases}\n    f(2) \\bmod 2 = 1 \\Leftrightarrow f(2) = 4m - N \u0026 \\Leftrightarrow \\frac{N}{4} \\leq m \u003c \\frac{N}{2} \\\\\n    f(2) \\bmod 2 = 0 \\Leftrightarrow f(2) = 4m \u0026 \\Leftrightarrow 0 \\leq m \u003c \\frac{N}{4} \\\\\n\\end{cases}\n\\end{aligned}\n$$\n\nつまり $m$ は $[0, N/2)$ 、 $[N/2, N)$ のそれぞれの範囲に対して最下位ビットが1のとき区間の右半分、0のとき区間の左半分だと言えます。\n\n$x \\geq 3$ のときも同様に行って $m$ の値を求めることができます。\n\n#### RSAにバグがあってはならない (RSA-CRT Fault Attack)\n\nRSAの復号をする際に $c^d$ を計算しますが、 $d = e^{-1} \\pmod {\\phi (N)}$ は比較的大きいので処理が重くなります。これに対してRSA-CRTは中国剰余定理(CRT)を利用して高速化を図っています。\n\n$$\n\\begin{aligned}\nm_p \u0026= c^{d \\ \\bmod \\ p−1} \u0026 \\pmod p \\\\\nm_q \u0026= c^{d \\ \\bmod \\ q−1} \u0026 \\pmod q \\\\\nm \u0026= \\mathrm{CRT}(m_p, m_q) \u0026 \\pmod {N} \\\\\n\u0026= m_q + (m_p - m_q) (q^{-1} \\bmod p) q \u0026 \\pmod {N} \\\\\n\\end{aligned}\n$$\n\nこれより下の値を秘密鍵として持つことになります。\n\n$$\n\\begin{aligned}\nd_p \u0026= d \\bmod p−1 \\\\\nd_q \u0026= d \\bmod q−1 \\\\\nq_{inv} \u0026= q^{-1} \\bmod p \\\\\n\\end{aligned}\n$$\n\nしかし $d_p, d_q$ のどちらかが何らかの方法で書き換えられてしまったとき次のようにできます。\n\n$$\n\\begin{aligned}\nm_p \u0026= c^{d_p} \\pmod p \\\\\nm_q' \u0026= c^{d_q'} \\pmod q \\\\\nm \u0026= CRT(m_p, m_q) = kp + m_p \\\\\nm' \u0026= CRT(m_p, m_q') = k'p + m_p \\\\\nm - m' \u0026= (k - k')p \\\\\np \u0026= \\gcd(m - m', N) \\\\\n\\end{aligned}\n$$\n\nこれより平文 $m, m'$ を知ることができれば解くことができます。\n\n#### 秘密鍵の上位ビットまたは下位ビットが知られてはいけない (Partial Key Exposure Attack)\n\n秘密鍵を部分的に知っていさえいれば、Coppersmith Method を用いて解けてしまう。\n$n$ を $N$ のビット数とする。\n\n##### p, q のどちらかを n/4 ビット程度知っているとき\n\n\n$$\n\\begin{aligned}\nf(x) \u0026= p_{upper} + x \u0026 \\pmod N \\\\\nf(x) \u0026= 2^{k}x + p_{lower} \u0026 \\pmod N \\\\\nf(x,y) \u0026= 2^kx + p_{mid} + y \u0026 \\pmod N \\\\\n\\end{aligned}\n$$\n\n##### d を n/4 ビット程度知っているとき\n\n$e$ が総当り出来るくらい小さいときに $d$ を $n/4$ ビットだけ知っていれば元の $d$ を構成できる。大体の場合は $e = 65537$ であるから十分可能である。$d \u003c \\phi(N)$ より $0 \u003c k \\leq e$ となり、この $k$ に対して総当たりする。\n\n- 上位ビットの場合\n$d$ と $p, q$ の関係式を立てる。\n\n$$\n\\begin{aligned}\ned \u0026= 1 \u0026 \\pmod{\\phi(N)} \\\\\ned \u0026= 1 + k(N - p - q + 1) \\\\\nd \u0026= \\frac{kN}{e} - \\frac{k(p+q-1) -1}{e} \\\\\ne(d_{upper} + x) \u0026= - k (y - 1) + 1 \u0026 \\pmod N \\\\\n\\end{aligned}\n$$\n\n第三式について $p + q \\approx \\sqrt{N}$ より第二項は上位ビットに関連する情報を持たない。これより第一項の $k$ について総当りして上位ビットと一致する $k$ を見つければよい。すると第4式に対し Multivariate CopperSmith を用いて、$d$ がわかる。\n\n- 下位ビットの場合\n$d$ の下位ビットから $k$ について総当りして $p$ の下位ビットを求める。すると先程の問題に帰着できて $p$ がわかり $d$ がわかる。\n\n$$\n\\begin{aligned}\ned \u0026= 1 + k\\left(N - p - \\frac{N}{p} + 1\\right) \\\\\nedp \u0026= p + kp(N - p + 1) - kN \u0026 \\pmod {2^{n/4}} \\\\\n\\end{aligned}\n$$\n\n\n\n##### CRTの秘密鍵 d のビットを n/4 程度知っているとき\n\n上と同様にして解けます。\n\n$$\n\\begin{aligned}\ned_p \u0026= 1 \u0026 \\pmod{p-1} \\\\\ned_p \u0026= 1 + k_p(p − 1) \\\\\n\\end{aligned}\n$$\n\n##### 平文 m のビットを (1-1/e)n 程度知っているとき\n\n$$\n\\begin{aligned}\nf(x) \u0026= (m_{upper} + x)^e - c \u0026 \\pmod N \\\\\nf(x) \u0026= (2^kx + m_{lower})^e - c \u0026 \\pmod N \\\\\nf(x,y) \u0026= (2^kx + m_{mid} + y)^e - c \u0026 \\pmod N \\\\\n\\end{aligned}\n$$\n\n```python\ndef partial_p(p0, kbits, n):\n    PR.\u003cx\u003e = PolynomialRing(Zmod(n))\n    nbits = n.nbits()\n\n    f = 2^kbits*x + p0\n    f = f.monic()\n    roots = f.small_roots(X=2^(nbits//2-kbits), beta=0.3)  # find root \u003c 2^(nbits//2-kbits) with factor \u003e= n^0.3\n    if roots:\n        x0 = roots[0]\n        p = gcd(2^kbits*x0 + p0, n)\n        return ZZ(p)\n\ndef find_p(d0, kbits, e, n):\n    X = var('X')\n\n\t# edx - kx(n-x+1) + kn = x mod 2^k\n\t# (ed - 1)x - kx(n-x+1) + kn = 0 mod 2^k\n    for k in xrange(1, e+1):\n        results = solve_mod([e*d0*X - k*X*(n-X+1) + k*n == X], 2^kbits)\n        for x in results:\n            p0 = ZZ(x[0])\n            p = partial_p(p0, kbits, n)\n            if p:\n                return p\n\n\nif __name__ == '__main__':\n    n = 0x00bef498e6eb2cffe71312da47ab89d2c47db7438ea2cfa992ddddbc2a01978001fc51e286e6ebf028396cdb8b3323c60e6b9d50cd84187cf7f48e3875a2f0890f70b02333ad89db2923863ce146562286f63fb0a1d0198e3a6862ba5ac12e85a5c6d0d27cb1c81bdf69cc5bc95b8001a2f744517f9437b4ddd5a076fc0e9a5de1a7a268c40f31aa29e8dc27c0b3a182299ca7a9335b4bd4585452f6107c238e486c98dd73a5f9862e9e80b152f53381c72f897107551c281259ac3ee32c4b4f46cc03127d1bf699acd0266f3c6729253c70da0c69b1560fa172735709866b375b6eba294e1ce8b46fba798ba380080b4bf9603998cac199d9cd46e30ae8da9e7f\n    e = 3\n    d = 0x7f4dbb449cc8aa9a0cb73c2fc7b1372da924d7b46c8a710c93e9281c010faaabfd8bec59ef47f5702648925cccc284099d138b33ad65a8a54db425a3c1f5b0b4f5cac22273b13cc617aed340d98ec1af4ed5206be011097c459726e72b7459192f35e1a8768567ea46883d30e7aaabc1fa2d8baa62cfcde93915a4a809bc3e9547bb07e1ecca16e51078312e89f0561e31b55db8b0ea5bc87a6ca7464a3d7c28a68c60e2ba88fe6a7d2b300d723e549910a987da89fc0a1c0de197a3d62c501b1f0e819891b1c32a0d6c233f2a285df87bb9e5c6c72d983ff3e706696bba639f573f9c3646968f02f3a615a438e20bb7c38d53621079f2899547a95350f3abeb\n\n    beta = 0.5\n    epsilon = beta^2/7\n\n    nbits = n.nbits()\n    kbits = floor(nbits*(beta^2+epsilon))\n    d0 = d \u0026 (2^kbits-1)\n    print \"lower %d bits (of %d bits) is given\" % (kbits, nbits)\n\n    p = find_p(d0, kbits, e, n)\n    print \"found p: %d\" % p\n    q = n//p\n    print d\n    print inverse_mod(e, (p-1)*(q-1))\n```\n\n\n\n:::details 例題\n```python\nfrom Crypto.Util.number import *\n\np = getPrime(512)\nq = getPrime(512)\nn = p * q\ne = 3\n\nbeta = 0.5\nepsilon = beta^2/7\n\npbits = p.nbits()\nkbits = floor(n.nbits() * (beta^2 - epsilon))\n# p upper\npbar = p \u0026 (2^pbits - 2^kbits)\n\nprint(f\"upper {pbits - kbits} bits (of {pbits} bits) is given\")\n\nPR.\u003cx\u003e = PolynomialRing(Zmod(n))\nf = x + pbar\n\nprint(p)\nx0 = f.small_roots(X=2^kbits, beta=0.3)[0]\nprint(x0 + pbar)\n```\n:::\n\n#### 上位ビットが共通する二つの平文に対する暗号文を知られてはいけない (Franklin-Reiter Related Message Attack)\n\n$f(m_1) = m_2$\n$m_1 = pad_1 + m, m_2 = pad_2 + m, m_2 = m_1 + (pad_2 - pad_1)$\n\n$$\n\\begin{aligned}\nc_1 \u0026= m_1^{e_1} \u0026 \\pmod N \\\\\nc_2 \u0026= m_2^{e_2} = f(m_1)^{e_2} \u0026 \\pmod N \\\\\nx - m_1 \u0026= \\gcd(x^{e_1} - c_1, f(x)^{e_2} - c_2) \u0026 \\pmod N \\\\\n\\end{aligned}\n$$\n\nHalf GCD\n\n#### Coppersmith's Short Pad Attack\n\n二つの暗号文について平文の上位bitがnのbit数の (1-1/e2) 程度共通する場合、これらからそれぞれの平文を求めることができる。 具体的には、次のような手順となる。\n\n1.  `g1 = x^e - c1`と`g2 = (x+y)^e - c2`の[終結式（resultant）](https://ja.wikipedia.org/wiki/%E7%B5%82%E7%B5%90%E5%BC%8F)を求め、その根としてyの値を得る\n2.  yの値を代入した上でg1(x)とg2(x)の最大公約式を求め、その根としてm1を得る\n3.  `m2 = m1 + y`よりm2を得る\n多項式GCD $O(n\\log^2n)$ を使う\nFranklin-Reiter Related Message Attack\n\n$$\n\\begin{aligned}\nm_1 \u0026= pad_1 + m \\\\\nm_2 \u0026= pad_2 + m \\\\\n\u0026= m_1 + pad_2 - pad_1 \\\\\nc_1 \u0026= m_1^e \\pmod N \\\\\nc_2 \u0026= m_2^e = (m_1 + pad_2 - pad_1)^e \\pmod N \\\\\nf_1(x) \u0026= x^e - c_1 \\\\\n\u0026= (x - m_1)h_1(x) \\\\\nf_2(x) \u0026= (x + pad_2 - pad_1)^e - c_2 \\\\\n\u0026= (x - m_1)h_2(x) \\\\\nx - m_1 \u0026= \\gcd(f_1, f_2) \\\\\n\\end{aligned}\n$$\n\nhttps://inaz2.hatenablog.com/entry/2016/01/20/022936\n\nRTACTF\nhttps://xagawa.hatenablog.com/entry/2021/12/20/232133\nCryptoのWriteupをまとめてる人\nhttps://mystiz.hk\n\n\n## 実践編まとめ\n\n今回はRSA暗号に絞りましたが実際のCTFはもっと広くて自由です！RSAに似てるけど解法が違う暗号やぱっと見RSAではなさそうな暗号もRSAに帰着させることが出来たりする暗号など様々あります。それでもここで扱った概念はそれらの基礎になります。\n\nあなたもCTFに出て暗号の世界を堪能してみませんか。\n\n### 参考文献\n[RSA暗号攻撃で他でも使える n のこと](https://project-euphoria.dev/blog/27-rsa-attacks/)\n[CTF crypto 逆引き](https://furutsuki.hatenablog.com/entry/2021/03/16/095021)\n[Recovering cryptographic keys from partial information, by example](https://eprint.iacr.org/2020/1506.pdf)\n[Twenty Years of Attacks on the RSA Cryptosystem](https://crypto.stanford.edu/~dabo/pubs/papers/RSA-survey.pdf)\n","lastmodified":"2022-10-26T11:26:57.359934474Z","tags":null},"/crypto/SSH":{"title":"SSH","content":"\nOpenSSH 9.0 ポスト量子暗号化時代への対応として、格子暗号系の「Streamlined NTRU Prime」と、楕円曲線暗号系の「x25519」からなるハイブリッド手法がデフォルトとなっている。\n\ned448\ned25519\n\n\nGnu Privacy Guard: GPG\nmaster key\nsub key\nPritty Good Privacy: PGP鍵\n[GPGで自分用の秘密鍵を1つに統一する · JoeMPhilips](http://joemphilips.com/post/gpg_memo/)\n\nSoloKey, Nitrokey","lastmodified":"2022-10-26T11:26:57.359934474Z","tags":null},"/crypto/SageMath":{"title":"SageMath チートシート","content":"\n## 説明\n\nSageMathのプログラムを書くときに参照したいと思うチートシートを作成したい。\n\n## 実装\n\n```python\n# import\nload('coppersmith.sage')\n\n# 整数環, 剰余環, 有限体\nZZ, Zmod(N), GF(q)\n\nR = GF(2 ^ m)\nR.fetch_int(12)\n# 多項式\nR = Zmod(N)\nP. \u003c x, y \u003e = PolynomialRing(R)\nf = x ^ 2 + 3*x + 3\nf.small_roots()\np /= p.leading_coefficient()  # 最高次項 モニック化\np = p.monic()\nideal(f).groebner_basis()\n\n# 行列\nM = matrix(QQ, [[1, 2], [3, 4]])\nM.LLL()\n\nA = matrix(Zn, [\n    [_a, _b, _c, _d, _e],\n    [1, 0, 0, 0, 0],\n    [0, 1, 0, 0, 0],\n    [0, 0, 1, 0, 0],\n    [0, 0, 0, 1, 0],\n])\n\nb11, b12, b13, b14, b15 = map(int, (A ^ e)[4])\n\nD, P = m.eigenmatrix_left()\nP ^ (-1)*D*P == m\n\nQ = diagonal_matrix(weights)\n\nB *= Q\nB = B.LLL()\nB /= Q\n\n# 素因数分解\nset(factor(n))\n\n# 楕円曲線\nEllipticCurve()\n```\n\n## 参考\n- [quickref](https://wiki.sagemath.org/quickref?action=AttachFile\u0026do=get\u0026target=quickref.pdf)\n- [quickref-linalg.pdf (shinshu-u.ac.jp)](http://math.shinshu-u.ac.jp/~nu/nora/sage/doc/refcard/quickref-linalg/200905/ja-utf8/quickref-linalg.pdf)\n","lastmodified":"2022-10-26T11:26:57.359934474Z","tags":null},"/crypto/books":{"title":"参考資料","content":"\n## Crypto books\n暗号理論入門―暗号アルゴリズム、署名と認証、その数学的基礎 （原書第３版）ブーフマン Buchmann (著)\nThe Block Cipher Companion\n現代暗号の誕生と発展：ポスト量子暗号・仮想通貨・新しい暗号 岡本 龍明 (著)\n現代暗号への招待 (ライブラリ情報学コア・テキスト) 黒澤 馨 (著)\n\n暗号理論のための格子の数学 絶版\n[Complexity of Lattice Problems | SpringerLink](https://link.springer.com/book/10.1007/978-1-4615-0897-7)\n\nThe Arithmetic of Elliptic Curves (著: Silverman)\n[kojima-shuron.pdf (kyoto-u.ac.jp)](https://www.math.kyoto-u.ac.jp/~yukie/kojima-shuron.pdf)\n\n[Mathematics of Public Key Cryptography (auckland.ac.nz)](https://www.math.auckland.ac.nz/~sgal018/crypto-book/crypto-book.html)\n[CRYSTALS - Kyber](https://eprint.iacr.org/2017/634.pdf)\n[Meet The Signature Standard of the Future … SPHINCS+ | by Prof Bill Buchanan OBE | ASecuritySite: When Bob Met Alice | Medium](https://medium.com/asecuritysite-when-bob-met-alice/meet-the-standard-of-the-future-sphincs-ee2b9e4c7b5e)\n\n[Advances in Elliptic Curve CryptographyLondon Mathematical Society Lecture Note Series ; 317 (preterhuman.net)](https://cdn.preterhuman.net/texts/cryptography/Cambridge%20University%20Press.%20Advances%20in%20Elliptic%20Curve%20Cryptography%20(2005).pdf)\n\n## Security\n- [Flatt Security Blog](https://blog.flatt.tech/)\n- [RET2 Systems Blog](https://blog.ret2.io/)\n\n## Mathematics books\n初学者のための代数幾何 (著: 永田雅宜)\n数学原論 (著: 斎藤 毅)\n岩波基礎数学選書 体とガロア理論 (著: 藤﨑源二郎)\n\n## Electric books\n[ELM by ChaN (elm-chan.org)](http://elm-chan.org/)\n[プロト基板の使いかた【電子工作】 - Niconico Video](https://www.nicovideo.jp/watch/sm22265444)\n\n## Event\n1月 SCIS (Symposium on Cryptography and Information Security)\n8月 DEFCON AVTOKYO\nCODE BLUE\nGCC\nSecHack365\nジュニア会員は学士3年まで\n\n## Crypto Paper\n[Breaking SIDH in polynomial time (iacr.org)](https://eprint.iacr.org/2022/1038)\n\n## Certification\neJPT Certification\nCISSP\nOSCP\nOSED\n\nINE Cyber Security Training","lastmodified":"2022-10-26T11:26:57.359934474Z","tags":null},"/crypto/coppersmith":{"title":"Coppersmith Method","content":"\n## 説明\n\n#### Thm. Howgrave-Grahamの補題\n$N$ を法、 $g(x) \\in \\mathbb{Z}[x]$ を整数多項式とし、含まれる単項式の数を $\\omega$ とする。$g(x)$ に対してある $X$ が存在し、$g(x_0) = 0 \\pmod{N}$ なる $x_0 \\in \\mathbb{Z}$ について $|x_0| \\leq X$ であると仮定する。このとき\n\n$$\n\\|g(xX)\\| \u003c \\frac{N}{\\sqrt{\\omega}}\n$$\n\nが成立するならば $g(x_0) = 0$ が整数方程式として成立する。ただし\n\n$$\n\\|g(x)\\| = \\left\\|\\sum_{i=0}^{\\deg g(x)}g_i\\right\\| = \\sqrt{\\sum_{i=0}^{\\deg g(x)}g_i^2}\n$$\n\nであり、 $\\deg g(x)$ は $g(x)$ の次数である。\n\n証明\n\n$$\n\\begin{aligned}\n|g(x_0)| \u0026= \\left|\\sum_{i=0}^{\\deg g(x_0)}g_ix_0^i\\right| \\\\\n\u0026\\leq \\sum_{i}|g_ix_0^i| \\\\\n\u0026\\leq \\sum_{i}|g_i|X^i \\\\\n\u0026= \\sum_{i}(1\\cdot|g_i|X^i) \\\\\n\u0026\\leq \\sqrt{\\sum_{i, g_i \\neq 0}1} \\sqrt{\\sum_{i}(|g_i|X^i)^2} \u0026\u0026 \\left(\\because \\text{コーシー＝シュワルツの不等式}\\right) \\\\\n\u0026= \\sqrt{\\omega}\\|g(xX)\\| \u003c N \u0026\u0026 \\left(\\because \\|g(xX)\\| \u003c \\frac{N}{\\sqrt{\\omega}}\\right)\n\\end{aligned}\n$$\n\n$g(x_0) = 0 \\pmod N$ より $g(x_0) = 0$ となる。\n\n-----\n\nつまり、「剰余の方程式は係数がある程度小さければそのまま整数方程式となるよ」と言っています。ここで勘のいい人はLLLを用いて係数を小さくすれば整数方程式に変換できて解けるのでは...！？と気付くでしょう。実際に考えてみましょう。\n\nとりあえず状況を整理すると、LLLに入れる値は各係数として、LLLを使う為には複数の方程式が必要になってきます。そしてそれらの方程式は同じ解を持つ必要があります。現在、その解が分からないのですが、どうしたらそんな方程式が作れるでしょうか。\n\n実は $\\bmod {N}$ では難しいので、$\\bmod {N^m}$ に持ち上げることで同じ解の方程式を増やすことができます。\n\n-----\n\n#### Lemma\n$N$ を法、$f(x)$ を多項式とする。自然数 $m, l$ について\n\n$$\ng_{i,j}(x) := N^{m−i}x^j f^i(x) \\ (0 \\leq i \\leq m, 0 \\leq j\\leq l)\n$$\n\nとおく。このとき、 $f(x_0) = 0 \\pmod N$ をみたす $x_0 \\in \\mathbb{Z}$ について、 $g_{i,j}(x_0) = 0 \\pmod{N^m}$ となる。\n\n証明\n\n$f(x_0) = 0 \\pmod N$ なので $f(x_0) = kN$ とおける。\n\n$$\n\\begin{aligned}\ng_{i,j}(x_0) \u0026= N^{m−i}x_0^j f^i(x_0) \\\\\n\u0026= N^{m−i}x_0^j (kN)^i \\\\\n\u0026= k^ix_0^j N^m \\\\\ng_{i,j}(x_0) \u0026= 0 \\pmod{N^m} \\\\\n\\end{aligned}\n$$\n\n-----\n\nこれで方程式を増やすことができました！ちゃんとLLLで動くかちょっと不安ですがとりあえずやってみます。\n\n小さくしたい方程式は $g_{i,j}(xX)$ であることに注意して。\n$g_{i,j}(x)$ の $k$ 次の係数のことを $g_{i,j}^{(k)}$ と表すことにします。\n\n$$\n\\begin{pmatrix}\ng_{0,0}^{(0)} \u0026 g_{0,0}^{(1)}X \u0026 g_{0,0}^{(2)}X^2 \u0026 g_{0,0}^{(3)}X^3 \u0026 g_{0,0}^{(4)}X^4 \u0026 g_{0,0}^{(5)}X^5 \\\\\ng_{0,1}^{(0)} \u0026 g_{0,1}^{(1)}X \u0026 g_{0,1}^{(2)}X^2 \u0026 g_{0,1}^{(3)}X^3 \u0026 g_{0,1}^{(4)}X^4 \u0026 g_{0,1}^{(5)}X^5 \\\\\ng_{1,0}^{(0)} \u0026 g_{1,0}^{(1)}X \u0026 g_{1,0}^{(2)}X^2 \u0026 g_{1,0}^{(3)}X^3 \u0026 g_{1,0}^{(4)}X^4 \u0026 g_{1,0}^{(5)}X^5 \\\\\ng_{1,1}^{(0)} \u0026 g_{1,1}^{(1)}X \u0026 g_{1,1}^{(2)}X^2 \u0026 g_{1,1}^{(3)}X^3 \u0026 g_{1,1}^{(4)}X^4 \u0026 g_{1,1}^{(5)}X^5 \\\\\ng_{2,0}^{(0)} \u0026 g_{2,0}^{(1)}X \u0026 g_{2,0}^{(2)}X^2 \u0026 g_{2,0}^{(3)}X^3 \u0026 g_{2,0}^{(4)}X^4 \u0026 g_{2,0}^{(5)}X^5 \\\\\ng_{2,1}^{(0)} \u0026 g_{2,1}^{(1)}X \u0026 g_{2,1}^{(2)}X^2 \u0026 g_{2,1}^{(3)}X^3 \u0026 g_{2,1}^{(4)}X^4 \u0026 g_{2,1}^{(5)}X^5 \\\\\n\\end{pmatrix}\n$$\n\nこれをLLLに通してあげると無事小さな値の方程式が返ってきます。これがHowgrave-Grahamの補題を満たしていれば整数方程式となります。後は増減表書いたりして探索すれば解けます。\n\nこれらの操作はCoppersmithの定理と呼ばれています。\n\n---\n\n#### Thm. Coppersmithの定理\n$N$ を法とし $f(x)$ をモニックな 1変数 $\\delta$ 多項式とする。このとき $f(x_0) = 0 \\pmod{N}$ と次の条件を満たすような $x_0$ を効率よく求めることができる\n\n$$\n|x_0| \\leq N^{\\frac{1}{\\delta}}\n$$\n\n---\n\nさらにCoppersmithの定理には拡張できることが2つあります。\n\n- 未知の法について解ける。素因数分解が出来ないほど大きな数を法としたときに既知の法の約数を法とする式の解を求められます。法が小さいほど方程式に対する制約がゆるくなります。\n- 多変数の方程式も解ける。これは変数が1つだけでしたが、複数の変数でもできます。変数の数が多いほど方程式に対する制約がキツくなります。\n\nこれらは Howgrave-Grahamの補題 などを見直すことで簡単に拡張できます。興味ある方は考えてみてください。\n\nこれらをまとめてCoppersmith Methodと呼びます。\n\nBerlekamp-Zassenhause法\n\n## 実装\n\n## 使用例\n\n## 参考\n- [元論文](https://static.aminer.org/pdf/PDF/000/192/854/finding_a_small_root_of_a_univariate_modular_equation.pdf)\n- [katagaitai workshop 2018 winter](http://elliptic-shiho.github.io/slide/katagaitai_winter_2018.pdf)\n","lastmodified":"2022-10-26T11:26:57.359934474Z","tags":null},"/crypto/cryptography/AttackModel":{"title":"Attack Model","content":"\nランダムオラクルモデル\n\n- 選択平文攻撃(Chosen-plaintext attack; CPA)\n- 適応的選択平文攻撃(Adaptive chosen-plaintext attack; CPA2)\n- 選択暗号文攻撃(Chosen-ciphertext attack; CCA1)\n- 適応的選択暗号文攻撃(Adaptive Chosen-ciphertext attack; CCA2)\n- Side-channel attack\n\n↓めちゃくちゃわかりにくい、といってわかりやすさが上がる方法とは？定理証明だと思う.\n\n- 一方向性(Onewayness; OW)\n\t- 暗号文から平文を求めるのが困難\n- 強秘匿性(Semantic Security; SS)\n\t- 暗号文から平文のどんな部分情報も漏れない\n- 識別不可能性(Indistinguishability; IND)\n\t- 暗号文が平文AとBのどちらのものかを区別できない\n- 頑強性(Non-Malleability; NM)\n\t- 暗号文が与えられた時、ある関係性を持った別の暗号文の生成が不可\n\t- stream cipher\n\t- RSA暗号 $Enc(m)\\cdot t^e \\bmod n = Enc(mt)$ padding(OAEP, PKCS 1)\n\n","lastmodified":"2022-10-26T11:26:57.359934474Z","tags":null},"/crypto/cryptography/Diffie-Hellman":{"title":"Diffie-Hellman 鍵交換","content":"\n## 説明\n\n共有鍵を作る為の操作である。共有鍵を作ることができれば共有鍵暗号を用いて通信できる。\n\n1. AliceとBobが巡回群 $G$ とその生成元 $g$ を共有する。\n2. AliceとBobはそれぞれ秘密鍵 $x_a, x_b$ を生成し、公開鍵 $y_a = g^{x_a}, y_b = g^{x_b}$ を公開する。\n3. AliceとBobは自分の秘密鍵と相手の公開鍵を掛けると $s = g^{x_ax_b} = y_b^{x_a} = y_a^{x_b}$ となり、$s$ はAliceとBobのみが知る共有鍵となる。\n\nECDH だと $s$ の $x$ 座標をハッシュ化したものを共有鍵として使う。\n","lastmodified":"2022-10-26T11:26:57.359934474Z","tags":null},"/crypto/cryptography/Fiat-Shamir":{"title":"Fiat-Shamir 変換","content":"\nFiat-Shamir変換は、証明システムを非対話型にするために使用される有名なスキームで、検証者がランダムに選択するチャレンジの値を（ランダムオラクルモデルとして）暗号学的ハッシュ関数を使って決定論的に導出することで、証明システムのプロトコルを非対話型にする。\n\nチャレンジのハッシュ計算の際の入力に、証明する[ステートメント](http://d.hatena.ne.jp/keyword/%A5%B9%A5%C6%A1%BC%A5%C8%A5%E1%A5%F3%A5%C8)に関するすべての公開値（ランダムなコミットメント値を含む）を含める必要があるということ（↑の例だと入力は、G、V、P、UserID、OtherInfo）。","lastmodified":"2022-10-26T11:26:57.359934474Z","tags":null},"/crypto/cryptography/FrozenHeart":{"title":"Frozen Heart","content":"\nFrozen Heartは、Fiat-Shamir変換でチャレンジのハッシュ計算の際の入力に、証明するステートメントに関するすべての公開値（ランダムなコミットメント値を含む）を含める必要があるということ（↑の例だと入力は、G、V、P、UserID、OtherInfo）を遵守していないプロトコルや実装による脆弱性。\n\n詳しいことはすべてここに\n\n- [Fiat-Shamir変換の安全でない適用による脆弱性Frozen Heart - Develop with pleasure! (hatenablog.com)](https://techmedia-think.hatenablog.com/entry/2022/04/19/193400#:~:text=Fiat%2DShamir%E5%A4%89%E6%8F%9B%E3%81%A8%E3%81%AF,%E9%9D%9E%E5%AF%BE%E8%A9%B1%E5%9E%8B%E3%81%AB%E3%81%99%E3%82%8B%E3%80%82)\n- [Coordinated disclosure of vulnerabilities affecting Girault, Bulletproofs, and PlonK | Trail of Bits Blog](https://blog.trailofbits.com/2022/04/13/part-1-coordinated-disclosure-of-vulnerabilities-affecting-girault-bulletproofs-and-plonk/)\n","lastmodified":"2022-10-26T11:26:57.359934474Z","tags":null},"/crypto/cryptography/Fujisaki-Okamoto_Transformation":{"title":"Fujisaki-Okamoto Transformation","content":"\n## 説明\n\n## 証明\n\n\n## 参考文献\n[The Fujisaki-Okamoto Transformation (uni-paderborn.de)](https://cs.uni-paderborn.de/fileadmin/informatik/fg/cuk/Lehre/Abschlussarbeiten/Bachelorarbeiten/2014/BA_Lippert_FOT_final.pdf)\n","lastmodified":"2022-10-26T11:26:57.359934474Z","tags":null},"/crypto/cryptography/Schnorr":{"title":"Schnorr Signatures","content":"\n## 説明\n\n非対話型ゼロ知識証明な署名の一種。\n\n巡回群 $G$ 上で署名を行う。各パラメータは次のように定義する。\n\n- 生成元 $g$\n- 秘密鍵 $x$\n- 公開鍵 $y = g^x$\n- メッセージ $M$\n\n### 署名\n\n乱数 $k$ を生成し、次の値を計算する。\n\n$$\n\\begin{aligned}\nr \u0026= g^k \\\\\ne \u0026= H(r \\| M) \\\\\ns \u0026= k - xe\n\\end{aligned}\n$$\n\nこのとき $(s, e)$ を署名値として公開する。\n\n### 検証\n\n公開されている値 $(g, y, M)$ と署名 $(s, e)$ を用いて次の値を計算する。\n\n$$\n\\begin{aligned}\nr' \u0026= g^sy^e \\\\\ne' \u0026= H(r' \\| M)\n\\end{aligned}\n$$\n\nここで $e = e'$ となれば署名が有効であると検証されたことになる。\n\n## 参考\n\n- [Schnorr署名 ―― 30年の時を超えて注目を集める電子署名](https://blog.visvirial.com/articles/721)\n- [RFC8235](https://datatracker.ietf.org/doc/html/rfc8235)","lastmodified":"2022-10-26T11:26:57.359934474Z","tags":null},"/crypto/cryptography/ZeroKnowledgeProof":{"title":"ゼロ知識証明","content":"\nゼロ知識証明の性質\n- 完全性（Completeness）\n    - 証明者の主張が真であるならば、検証者は真であることが必ずわかること。\n- 健全性（Soundness）\n    - 証明者の主張が偽であれば、検証者はかなり高い確率でそれが偽であること見抜けること。\n- ゼロ知識性（Zero Knowledge）\n\t- あらゆる場合において、検証者が証明者から何らかの知識（情報）を盗もうとしても、証明者の主張が真であること以上の知識は得られない\n\n\n名前の通り対話型は有名な洞窟の例のように証明者と検証者がやりとりを繰り返し、証明者が本当に正しい情報を持っているかを確率的に検証する方です。\n\n一方、非対話型のゼロ知識証明は証明者と検証者はやりとりをせずに証明することが可能です。対話を行う代わりに証明者と検証者の間に第三者を置き、CRSと呼ばれる事前に公開される情報を証明者と検証者に送ります。証明者はそのCRSを用いて正しい情報を持っているという証明を生成し、それを検証者に一回だけ送ります。受け取った検証者はそれを検証するだけで非対話なゼロ知識証明が実現できます。事前にCRSを生成することを一般的に信頼されたセットアップといい、第三者は証明者、検証者にとって信頼される存在となります。\n\nzk-SNARKs\n- Succinct（簡潔）\n    - 証明のサイズがステートメントのサイズと比べて非常に小さい\n- Non-interactive（非対話型）\n    - 証明者と検証者の間で何度も対話をする必要がない\n- ARgument\n    - 証明者の計算能力には限りがある\n- Knowledge\n    - 証明者は、知識なしでは証明を生成することは不可能である。\n\n[ZenGo-X/zk-paillier: A collection of Paillier cryptosystem zero knowledge proofs (github.com)](https://github.com/ZenGo-X/zk-paillier)\n\n[zk-SNARKsの理論 (zenn.dev)](https://zenn.dev/kyosuke/articles/a1854b9be26c01df13eb)","lastmodified":"2022-10-26T11:26:57.359934474Z","tags":null},"/crypto/cryptography/homomorphism":{"title":"Homorphism","content":"\n# 準同型暗号\n\n加法準同型 ex. 岡本・内山, Paillier, Lifted-ElGamal\n-\n乗法準同型 ex. RSA, ElGamal\n-\nレベル準同型\n- 乗算回数に制約がある完全準同型\n- レベルnはn次方程式を計算できる\n- レベル2準同型なら乗算が1度だけ可能\n完全準同型 ex. Gentry, 格子ベース\n\n\n## レベル2準同型暗号の構成\n### Lifted-ElGamal暗号\n位数 $p$ の楕円曲線 $E$, と生成元 $P\\in E$\n秘密鍵 $s\\in\\mathbb{F}_p$ と公開鍵 $sP$\n平文 $m$ に対して乱数 $r$ をとり $c=(mP+rsP, rP)$\n$c = (S, T)$ に対して $S-sT = (mP+rsP)-s(rP)=mP$ としDLPを解いて $m$ を得る\n\n加法準同型性\n\n$$\n\\begin{aligned}\n\\mathrm{Enc}(m_1)+\\mathrm{Enc}(m_2) \u0026= (m_1P+r_1sP,r_1P)+(m_2P+r_2sP,r_2P) \\\\\n\u0026= ((m_1+m_2)P, (r_1+r_2)sP, (r_1+r_2)P) \\\\\n\u0026= Enc(m_1+m_2)\n\\end{aligned}\n$$\n\n乗法準同型性\n\n$\\mathrm{Enc}(m_1)\\times\\mathrm{Enc}(m_2) := (e(S_1, S_2), e(S_1, T_2), e(T_1, S_2), e(T_1, T_2))$\n\n$$\n\\begin{aligned}\n\\mathrm{Dec}(c_1,c_2,c_3,c_4) \u0026= \\frac{c_1c_4^{s_1s_2}}{c_2^{s_2}c_3^{s_1}} = \\frac{e(S_1,s_2)e(s_1T_1,s_2T_2)}{e(S_1,s_2T_2)e(s_1T_1,S_2)} \\\\\n\u0026=e(S_1-s_1T_1,S_2-s_2T_2) \\\\\n\u0026=e(mP_1,m'P_2)=e(P_1,P_2)^{mm'}\n\\end{aligned}\n$$\n\n[ペアリングベースの効率的なレベル2準同型暗号（SCIS2018） (slideshare.net)](https://www.slideshare.net/herumi/2scis2018?next_slideshow=86572957)\n\n\n$a, b$ から $g^a$ と $g^b$ という関係である 可解 $g^{ab}$\n$g^a$ と $g^b$ から $g^{ab}$ を求める DH問題\n","lastmodified":"2022-10-26T11:26:57.359934474Z","tags":null},"/crypto/cryptography/other":{"title":"その他の暗号","content":"\n[GoogleがTLSでの採用を提唱している共通鍵暗号方式「ChaCha」についてまとめた - sonickun.log (hatenablog.com)](https://sonickun.hatenablog.com/entry/2016/04/03/183220)\nChaCha [RFC 7538](https://tools.ietf.org/html/rfc7539)\nSalsa20\n\n\n\n[Integer factorization](https://en.wikipedia.org/wiki/Integer_factorization \"Integer factorization\")\n\n-   [Benaloh](https://en.wikipedia.org/wiki/Benaloh_cryptosystem \"Benaloh cryptosystem\")\n-   [Blum–Goldwasser](https://en.wikipedia.org/wiki/Blum%E2%80%93Goldwasser_cryptosystem \"Blum–Goldwasser cryptosystem\")\n-   [Cayley–Purser](https://en.wikipedia.org/wiki/Cayley%E2%80%93Purser_algorithm \"Cayley–Purser algorithm\")\n-   [Damgård–Jurik](https://en.wikipedia.org/wiki/Damg%C3%A5rd%E2%80%93Jurik_cryptosystem \"Damgård–Jurik cryptosystem\")\n-   [GMR](https://en.wikipedia.org/wiki/GMR_(cryptography) \"GMR (cryptography)\")\n-   [Goldwasser–Micali](https://en.wikipedia.org/wiki/Goldwasser%E2%80%93Micali_cryptosystem \"Goldwasser–Micali cryptosystem\")\n-   [Naccache–Stern](https://en.wikipedia.org/wiki/Naccache%E2%80%93Stern_cryptosystem \"Naccache–Stern cryptosystem\")\n-   [Paillier](https://en.wikipedia.org/wiki/Paillier_cryptosystem \"Paillier cryptosystem\")\n-   [Rabin](https://en.wikipedia.org/wiki/Rabin_cryptosystem \"Rabin cryptosystem\")\n-   [RSA](https://en.wikipedia.org/wiki/RSA_(cryptosystem) \"RSA (cryptosystem)\")\n-   [Okamoto–Uchiyama](https://en.wikipedia.org/wiki/Okamoto%E2%80%93Uchiyama_cryptosystem \"Okamoto–Uchiyama cryptosystem\")\n-   [Schmidt–Samoa](https://en.wikipedia.org/wiki/Schmidt-Samoa_cryptosystem \"Schmidt-Samoa cryptosystem\")\n\n[Discrete logarithm](https://en.wikipedia.org/wiki/Discrete_logarithm \"Discrete logarithm\")\n\n-   [BLS](https://en.wikipedia.org/wiki/Boneh%E2%80%93Lynn%E2%80%93Shacham \"Boneh–Lynn–Shacham\")\n-   [Cramer–Shoup](https://en.wikipedia.org/wiki/Cramer%E2%80%93Shoup_cryptosystem \"Cramer–Shoup cryptosystem\")\n-   [DH](https://en.wikipedia.org/wiki/Diffie%E2%80%93Hellman_key_exchange \"Diffie–Hellman key exchange\")\n-   [DSA](https://en.wikipedia.org/wiki/Digital_Signature_Algorithm \"Digital Signature Algorithm\")\n-   [ECDH](https://en.wikipedia.org/wiki/Elliptic-curve_Diffie%E2%80%93Hellman \"Elliptic-curve Diffie–Hellman\") \n    -   [X25519](https://en.wikipedia.org/wiki/Curve25519 \"Curve25519\")\n    -   [X448](https://en.wikipedia.org/wiki/Curve448 \"Curve448\")\n-   [ECDSA](https://en.wikipedia.org/wiki/Elliptic_Curve_Digital_Signature_Algorithm \"Elliptic Curve Digital Signature Algorithm\")\n-   [EdDSA](https://en.wikipedia.org/wiki/EdDSA \"EdDSA\") \n    -   [Ed25519](https://en.wikipedia.org/wiki/EdDSA#Ed25519 \"EdDSA\")\n    -   [Ed448](https://en.wikipedia.org/wiki/EdDSA#Ed448 \"EdDSA\")\n-   [ECMQV](https://en.wikipedia.org/wiki/ECMQV \"ECMQV\")\n-   [EKE](https://en.wikipedia.org/wiki/Encrypted_key_exchange \"Encrypted key exchange\")\n-   [ElGamal](https://en.wikipedia.org/wiki/ElGamal_encryption \"ElGamal encryption\") \n    -   [signature scheme](https://en.wikipedia.org/wiki/ElGamal_signature_scheme \"ElGamal signature scheme\")\n-   [MQV](https://en.wikipedia.org/wiki/MQV \"MQV\")\n-   [Schnorr](https://en.wikipedia.org/wiki/Schnorr_signature \"Schnorr signature\")\n-   [SPEKE](https://en.wikipedia.org/wiki/SPEKE \"SPEKE\")\n-   [SRP](https://en.wikipedia.org/wiki/Secure_Remote_Password_protocol \"Secure Remote Password protocol\")\n-   [STS](https://en.wikipedia.org/wiki/Station-to-Station_protocol \"Station-to-Station protocol\")\n\n[Lattice/SVP/CVP](https://en.wikipedia.org/wiki/Lattice-based_cryptography \"Lattice-based cryptography\")/[LWE](https://en.wikipedia.org/wiki/Learning_with_errors \"Learning with errors\")/[SIS](https://en.wikipedia.org/wiki/Short_integer_solution_problem \"Short integer solution problem\")\n\n-   [NTRUEncrypt](https://en.wikipedia.org/wiki/NTRUEncrypt \"NTRUEncrypt\")\n-   [NTRUSign](https://en.wikipedia.org/wiki/NTRUSign \"NTRUSign\")\n-   [RLWE-KEX](https://en.wikipedia.org/wiki/RLWE-KEX \"RLWE-KEX\")\n-   [RLWE-SIG](https://en.wikipedia.org/wiki/RLWE-SIG \"RLWE-SIG\")\n-   [BLISS](https://en.wikipedia.org/wiki/BLISS_signature_scheme \"BLISS signature scheme\")\n-   [NewHope](https://en.wikipedia.org/wiki/NewHope \"NewHope\")\n\nOthers\n\n-   [AE](https://en.wikipedia.org/wiki/Algebraic_Eraser \"Algebraic Eraser\")\n-   [CEILIDH](https://en.wikipedia.org/wiki/CEILIDH \"CEILIDH\")\n-   [EPOC](https://en.wikipedia.org/wiki/Efficient_Probabilistic_Public-Key_Encryption_Scheme \"Efficient Probabilistic Public-Key Encryption Scheme\")\n-   [HFE](https://en.wikipedia.org/wiki/Hidden_Field_Equations \"Hidden Field Equations\")\n-   [IES](https://en.wikipedia.org/wiki/Integrated_Encryption_Scheme \"Integrated Encryption Scheme\")\n-   [Lamport](https://en.wikipedia.org/wiki/Lamport_signature \"Lamport signature\")\n-   [McEliece](https://en.wikipedia.org/wiki/McEliece_cryptosystem \"McEliece cryptosystem\")\n-   [Merkle–Hellman](https://en.wikipedia.org/wiki/Merkle%E2%80%93Hellman_knapsack_cryptosystem \"Merkle–Hellman knapsack cryptosystem\")\n-   [Naccache–Stern knapsack cryptosystem](https://en.wikipedia.org/wiki/Naccache%E2%80%93Stern_knapsack_cryptosystem \"Naccache–Stern knapsack cryptosystem\")\n-   [Three-pass protocol](https://en.wikipedia.org/wiki/Three-pass_protocol \"Three-pass protocol\")\n-   [XTR](https://en.wikipedia.org/wiki/XTR \"XTR\")\n\nTheory\n\n-   [Discrete logarithm cryptography](https://en.wikipedia.org/wiki/Discrete_logarithm#Cryptography \"Discrete logarithm\")\n-   [Elliptic-curve cryptography](https://en.wikipedia.org/wiki/Elliptic-curve_cryptography \"Elliptic-curve cryptography\")\n-   [Hash-based cryptography](https://en.wikipedia.org/wiki/Hash-based_cryptography \"Hash-based cryptography\")\n-   [Non-commutative cryptography](https://en.wikipedia.org/wiki/Non-commutative_cryptography \"Non-commutative cryptography\")\n-   RSA problem\n-   [Trapdoor function](https://en.wikipedia.org/wiki/Trapdoor_function \"Trapdoor function\")\n\nStandardization\n\n-   [CRYPTREC](https://en.wikipedia.org/wiki/CRYPTREC \"CRYPTREC\")\n-   [IEEE P1363](https://en.wikipedia.org/wiki/IEEE_P1363 \"IEEE P1363\")\n-   [NESSIE](https://en.wikipedia.org/wiki/NESSIE \"NESSIE\")\n-   [NSA Suite B](https://en.wikipedia.org/wiki/NSA_Suite_B_Cryptography \"NSA Suite B Cryptography\")\n-   [Post-Quantum Cryptography](https://en.wikipedia.org/wiki/NIST_Post-Quantum_Cryptography_Standardization \"NIST Post-Quantum Cryptography Standardization\")\n\nTopics\n\n-   [Digital signature](https://en.wikipedia.org/wiki/Digital_signature \"Digital signature\")\n-   [OAEP](https://en.wikipedia.org/wiki/Optimal_asymmetric_encryption_padding \"Optimal asymmetric encryption padding\")\n-   [Fingerprint](https://en.wikipedia.org/wiki/Public_key_fingerprint \"Public key fingerprint\")\n-   [PKI](https://en.wikipedia.org/wiki/Public_key_infrastructure \"Public key infrastructure\")\n-   [Web of trust](https://en.wikipedia.org/wiki/Web_of_trust \"Web of trust\")\n-   [Key size](https://en.wikipedia.org/wiki/Key_size \"Key size\")\n-   [Identity-based cryptography](https://en.wikipedia.org/wiki/Identity-based_cryptography \"Identity-based cryptography\")\n-   [Post-quantum cryptography](https://en.wikipedia.org/wiki/Post-quantum_cryptography \"Post-quantum cryptography\")\n-   [OpenPGP card](https://en.wikipedia.org/wiki/OpenPGP_card \"OpenPGP card\")","lastmodified":"2022-10-26T11:26:57.359934474Z","tags":null},"/data_structure/LinkedList":{"title":"","content":"```\npub enum List {\n    Empty,\n    Elem(i32, List),\n}\n```\n","lastmodified":"2022-10-26T11:26:57.359934474Z","tags":null},"/data_structure/bit/bit":{"title":"Binary Indexed Tree","content":"\n## 説明\n\n## 計算量\n\n- add $O(\\log N)$\n- sum $O(\\log N)$\n\n## 実装\n\n```cpp\ntemplate \u003ctypename T\u003e\nclass BIT {\n  int N;\n  vector\u003cT\u003e bit;\n  BIT(isizet size) {\n    N = size + 2;\n    bit.assign(N + 1, {});\n  }\n\n  // get sum of [0, i]\n  T sum(int i) const {\n    T res({});\n    for (++i; i \u003e 0; i -= (i \u0026 -i)) res += bit[i];\n    return res;\n  }\n\n  // get sum of [l, r]\n  inline T sum(int l, int r) { return sum(r) - sum(l - 1); }\n\n  // get value of i\n  inline T operator[](int i) const { return sum(i) - sum(i - 1); }\n\n  // data[i] += x\n  void add(int i, T x) {\n    for (++i; i \u003c= N; i += (i \u0026 -i)) bit[i] += x;\n  }\n\n  // range add x to [l, r]\n  void imos(int l, int r, T x) {\n    add(l, x);\n    add(r + 1, -x);\n  }\n\n  // minimize i s.t. sum(i) \u003e= w\n  int lower_bound(T w) {\n    if (w \u003c= 0) return 0;\n    int x = 0;\n    for (int i = 1 \u003c\u003c __lg(N); i \u003e 0; i \u003e\u003e= 1) {\n      if (x + k \u003c N \u0026\u0026 bit[x + i] \u003c w) {\n        w -= bit[x + i];\n        x += i;\n      }\n    }\n    return x;\n  }\n\n  // minimize i s.t. sum(i) \u003e w\n  int upper_bound(T w) {\n    if (w \u003c 0) return 0;\n    int x = 0;\n    for (int i = 1 \u003c\u003c __lg(N); i \u003e 0; i \u003e\u003e= 1) {\n      if (x + k \u003c= N \u0026\u0026 bit[x + i] \u003c= w) {\n        w -= bit[x + i];\n        x += i;\n      }\n    }\n    return x;\n  }\n};\n```\n\n## 使用例\n\n```cpp\n#include \u003cbit.hpp\u003e\n#include \u003cvector\u003e\n\n// 転倒数 重複あり\ntemplate \u003ctypename T\u003e\nlong long inversion_counting(const std::vector\u003cT\u003e \u0026v) {\n  std::vector\u003cT\u003e xs{v};\n  sort(xs.begin(), xs.end());\n  xs.erase(unique(xs.begin(), xs.end()), xs.ned());\n  int N = xs.size();\n  BinaryIndexedTree\u003cT\u003e bin(N);\n  long long ans = 0;\n  for (long long i = 0; i \u003c N; i++) {\n    int s = lower_bound(xs.begin(), xs.end(), xs[i]) - xs.begin();\n    ans += i - bin.sum(v[i]);\n    bin.add(v[i], 1);\n  }\n  return ans;\n}\n\n// 隣接 swap によって v を w に変えるのにかかる手数 (不可能 : -1)\ntemplate \u003ctypename T\u003e\nlong long swap_distance(const std::vector\u003cT\u003e \u0026v, const std::vector\u003cT\u003e \u0026w) {\n  if (v.size() != w.size()) return -1;\n\n  long long N = v.size();\n  std::vector\u003cpair\u003cT, int\u003e\u003e vv(N), ww(N);\n  for (int i = 0; i \u003c N; i++) {\n    vv[i] = make_pair(v[i], i);\n    ww[i] = make_pair(w[i], i);\n  }\n  sort(vv.begin(), vv.end());\n  sort(ww.begin(), ww.end());\n  std::vector\u003cint\u003e order(N);\n  for (int i = 0; i \u003c N; i++) {\n    if (vv[i].first != ww[i].first) return -1;\n    order[vv[i].second] = ww[i].second;\n  }\n  return inversion_counting(order);\n}\n```\n","lastmodified":"2022-10-26T11:26:57.359934474Z","tags":null},"/data_structure/segtree/lazysegtree":{"title":"遅延セグメント木","content":"\n## 説明\n\n## 計算量\n\n## 実装\n\n```cpp\n#include \u003calgorithm\u003e\n#include \u003ccassert\u003e\n#include \u003ciostream\u003e\n#include \u003cvector\u003e\n\nnamespace internal {\nint ceil_pow2(int n) {\n  int x = 0;\n  while ((1U \u003c\u003c x) \u003c (unsigned int)(n))\n    x++;\n  return x;\n}\n\n} // namespace internal\n\ntemplate \u003cclass S, S (*op)(S, S), S (*e)(), class F, S (*mapping)(F, S),\n          F (*composition)(F, F), F (*id)()\u003e\nstruct lazy_segtree {\nprivate:\n  int _n, size, log;\n  std::vector\u003cS\u003e node;\n  std::vector\u003cF\u003e lazy;\n\npublic:\n  lazy_segtree() : lazy_segtree(0) {}\n  explicit lazy_segtree(int n) : lazy_segtree(std::vector\u003cS\u003e(n, e())) {}\n  explicit lazy_segtree(const std::vector\u003cS\u003e \u0026v) : _n(int(v.size())) {\n    log = internal::ceil_pow2(_n);\n    size = 1 \u003c\u003c log;\n    node = std::vector\u003cS\u003e(2 * size, e());\n    lazy = std::vector\u003cF\u003e(size, id());\n    // セグ木の初期化\n    // 最下層: size + k\n    // 親 k \u003e\u003e 1\n    // 子 2*k, 2*k + 1\n    for (int i = 0; i \u003c _n; i++)\n      node[size + i] = v[i];\n    for (int i = size - 1; i \u003e= 1; i--)\n      update(i);\n  }\n\n  // a[p] = x : O(logN)\n  void set(int p, S x) {\n    assert(0 \u003c= p \u0026\u0026 p \u003c _n);\n    p += size;\n    for (int i = log; i \u003e= 1; i--)\n      push(p \u003e\u003e i);\n    node[p] = x;\n    for (int i = 1; i \u003c= log; i++)\n      update(p \u003e\u003e i);\n  }\n\n  // a[p] : O(1)\n  S get(int p) {\n    assert(0 \u003c= p \u0026\u0026 p \u003c _n);\n    p += size;\n    for (int i = log; i \u003e= 1; i--)\n      push(p \u003e\u003e i);\n    return node[p];\n  }\n\n  // op(a[l, r)) をモノイドの性質を満たしていると仮定して計算 : O(logN)\n  S prod(int l, int r) {\n    assert(0 \u003c= l \u0026\u0026 l \u003c= r \u0026\u0026 r \u003c= _n);\n    if (l == r)\n      return e();\n\n    l += size;\n    r += size;\n\n    for (int i = log; i \u003e= 1; i--) {\n      if (((l \u003e\u003e i) \u003c\u003c i) != l)\n        push(l \u003e\u003e i);\n      if (((r \u003e\u003e i) \u003c\u003c i) != r)\n        push((r - 1) \u003e\u003e i);\n    }\n\n    S sml = e(), smr = e();\n    while (l \u003c r) {\n      if (l \u0026 1)\n        sml = op(sml, node[l++]);\n      if (r \u0026 1)\n        smr = op(node[--r], smr);\n      l \u003e\u003e= 1;\n      r \u003e\u003e= 1;\n    }\n\n    return op(sml, smr);\n  }\n\n  // op(a[0, n)) : O(logN)\n  S all_prod() { return node[1]; }\n\n  // a[p] = f(a[p]) : O(logN)\n  void apply(int p, F f) {\n    assert(0 \u003c= p \u0026\u0026 p \u003c _n);\n    p += size;\n    for (int i = log; i \u003e= 1; i--)\n      push(p \u003e\u003e i);\n    node[p] = mapping(f, node[p]);\n    for (int i = 1; i \u003c= log; i++)\n      update(p \u003e\u003e i);\n  }\n  // a[i] = f(a[i]) in [l, r) : O(logN)\n  void apply(int l, int r, F f) {\n    assert(0 \u003c= l \u0026\u0026 l \u003c= r \u0026\u0026 r \u003c= _n);\n    if (l == r)\n      return;\n\n    l += size;\n    r += size;\n\n    for (int i = log; i \u003e= 1; i--) {\n      if (((l \u003e\u003e i) \u003c\u003c i) != l)\n        push(l \u003e\u003e i);\n      if (((r \u003e\u003e i) \u003c\u003c i) != r)\n        push((r - 1) \u003e\u003e i);\n    }\n\n    {\n      int l2 = l, r2 = r;\n      while (l \u003c r) {\n        if (l \u0026 1)\n          all_apply(l++, f);\n        if (r \u0026 1)\n          all_apply(--r, f);\n        l \u003e\u003e= 1;\n        r \u003e\u003e= 1;\n      }\n      l = l2;\n      r = r2;\n    }\n\n    for (int i = 1; i \u003c= log; i++) {\n      if (((l \u003e\u003e i) \u003c\u003c i) != l)\n        update(l \u003e\u003e i);\n      if (((r \u003e\u003e i) \u003c\u003c i) != r)\n        update((r - 1) \u003e\u003e i);\n    }\n  }\n\n  // 二分探索\n  // r where g(op(a[l, r))) = true \u0026 g(op(a[l, r])) = false : O(logN)\n  template \u003cbool (*g)(S)\u003e int max_right(int l) {\n    return max_right(l, [](S x) { return g(x); });\n  }\n  template \u003cclass G\u003e int max_right(int l, G g) {\n    assert(0 \u003c= l \u0026\u0026 l \u003c= _n);\n    assert(g(e()));\n    if (l == _n)\n      return _n;\n    l += size;\n    for (int i = log; i \u003e= 1; i--)\n      push(l \u003e\u003e i);\n    S sm = e();\n    do {\n      while (l % 2 == 0)\n        l \u003e\u003e= 1;\n      if (!g(op(sm, node[l]))) {\n        while (l \u003c size) {\n          push(l);\n          l = (2 * l);\n          if (g(op(sm, node[l]))) {\n            sm = op(sm, node[l]);\n            l++;\n          }\n        }\n        return l - size;\n      }\n      sm = op(sm, node[l]);\n      l++;\n    } while ((l \u0026 -l) != l);\n    return _n;\n  }\n\n  // 二分探索\n  // l where g(op(a[l, r))) = true \u0026 g(op(a[l-1, r))) = false\n  template \u003cbool (*g)(S)\u003e int min_left(int r) {\n    return min_left(r, [](S x) { return g(x); });\n  }\n  template \u003cclass G\u003e int min_left(int r, G g) {\n    assert(0 \u003c= r \u0026\u0026 r \u003c= _n);\n    assert(g(e()));\n    if (r == 0)\n      return 0;\n    r += size;\n    for (int i = log; i \u003e= 1; i--)\n      push((r - 1) \u003e\u003e i);\n    S sm = e();\n    do {\n      r--;\n      while (r \u003e 1 \u0026\u0026 (r % 2))\n        r \u003e\u003e= 1;\n      if (!g(op(node[r], sm))) {\n        while (r \u003c size) {\n          push(r);\n          r = (2 * r + 1);\n          if (g(op(node[r], sm))) {\n            sm = op(node[r], sm);\n            r--;\n          }\n        }\n        return r + 1 - size;\n      }\n      sm = op(node[r], sm);\n    } while ((r \u0026 -r) != r);\n    return 0;\n  }\n\nprivate:\n  // node[k]の更新\n  void update(int k) { node[k] = op(node[2 * k], node[2 * k + 1]); }\n  // nodeの更新\n  void all_apply(int k, F f) {\n    node[k] = mapping(f, node[k]);\n    if (k \u003c size)\n      lazy[k] = composition(f, lazy[k]);\n  }\n\n  // 遅延評価\n  void push(int k) {\n    all_apply(2 * k, lazy[k]);\n    all_apply(2 * k + 1, lazy[k]);\n    lazy[k] = id();\n  }\n};\n```\n\n## 使用例\n\n```cpp\n#include \u003cbits/stdc++.h\u003e\n#include \u003clazysegtree.hpp\u003e\n// #include \u003catcoder/all\u003e\nusing namespace std;\n// using namespace atcoder;\nusing ll = long long;\nusing ld = long double;\nusing uint = unsigned;\nusing ull = unsigned long long;\nusing u64 = uint_fast64_t;\nusing pll = pair\u003cll, ll\u003e;\nusing pdd = pair\u003cld, ld\u003e;\nusing C = complex\u003cdouble\u003e;\ntemplate \u003cclass T\u003e using pq = priority_queue\u003cT, vector\u003cT\u003e, greater\u003cT\u003e\u003e;\n\nconst int IINF = 0x1fffffff;\nconst ll LINF = 0x1fffffffffffffff;\nconst ll INF = 0x1fffffffffffffff;\nconst ll MINF = 0x7fffffffffff;\nconst ll MOD = 1000000007;\nconst ll MODD = 998244353;\nconst ld DINF = numeric_limits\u003cld\u003e::infinity();\nconst ld EPS = 1e-9;\nconst ld PI = 3.1415926535897932;\nconst ll dx[] = {0, 1, 0, -1, 1, -1, 1, -1};\nconst ll dy[] = {1, 0, -1, 0, 1, 1, -1, -1};\n\n#define overload4(_1, _2, _3, _4, name, ...) name\n#define overload3(_1, _2, _3, name, ...) name\n#define rep1(n) for (ll i = 0; i \u003c n; ++i)\n#define rep2(i, n) for (ll i = 0; i \u003c n; ++i)\n#define rep3(i, a, b) for (ll i = a; i \u003c b; ++i)\n#define rep4(i, a, b, c) for (ll i = a; i \u003c b; i += c)\n#define rep(...) overload4(__VA_ARGS__, rep4, rep3, rep2, rep1)(__VA_ARGS__)\n#define rrep1(n) for (ll i = n; i--;)\n#define rrep2(i, n) for (ll i = n; i--;)\n#define rrep3(i, a, b) for (ll i = b; i-- \u003e (a);)\n#define rrep4(i, a, b, c)                                                      \\\n  for (ll i = (a) + ((b) - (a)-1) / (c) * (c); i \u003e= (a); i -= c)\n#define rrep(...)                                                              \\\n  overload4(__VA_ARGS__, rrep4, rrep3, rrep2, rrep1)(__VA_ARGS__)\n#define each1(i, a) for (auto \u0026\u0026i : a)\n#define each2(x, y, a) for (auto \u0026\u0026[x, y] : a)\n#define each3(x, y, z, a) for (auto \u0026\u0026[x, y, z] : a)\n#define each(...) overload4(__VA_ARGS__, each3, each2, each1)(__VA_ARGS__)\n#define all1(i) begin(i), end(i)\n#define all2(i, a) begin(i), begin(i) + a\n#define all3(i, a, b) begin(i) + a, begin(i) + b\n#define all(...) overload3(__VA_ARGS__, all3, all2, all1)(__VA_ARGS__)\n#define rall1(i) (i).rbegin(), (i).rend()\n#define rall2(i, k) (i).rbegin(), (i).rbegin() + k\n#define rall3(i, a, b) (i).rbegin() + a, (i).rbegin() + b\n#define rall(...) overload3(__VA_ARGS__, rall3, rall2, rall1)(__VA_ARGS__)\n// g++ -DDBUG -I . ...\n#ifdef DEBUG\ninline ll __lg(ull x) { return 63 - __builtin_clzll(x); }\n#define debug(...)                                                             \\\n  {                                                                            \\\n    print(#__VA_ARGS__);                                                       \\\n    print(\":\");                                                                \\\n    out(__VA_ARGS__);                                                          \\\n  }\n#else\n#define debug(...) void(0)\n#endif\n\n#define vec vector\n#define fi first\n#define se second\n#define MM \u003c\u003c \" \" \u003c\u003c\n#define chmax(x, y) (x = max(x, y))\n#define chmin(x, y) (x = min(x, y))\nvoid debug_out() { std::cerr \u003c\u003c std::endl; }\ntemplate \u003ctypename Head, typename... Tail\u003e void debug_out(Head h, Tail... t) {\n  std::cerr \u003c\u003c \" \" \u003c\u003c h;\n  if (sizeof...(t) \u003e 0)\n    std::cout \u003c\u003c \" :\";\n  debug_out(t...);\n}\n\nconstexpr u64 Modulus = MODD;\nclass Modint {\npublic:\n  u64 num = 0;\n  constexpr Modint() noexcept {}\n  constexpr Modint(const u64 x) noexcept : num(x % Modulus) {}\n  inline constexpr operator ll() const noexcept { return num; }\n  inline constexpr Modint \u0026operator+=(const Modint rhs) noexcept {\n    num += rhs.num;\n    if (num \u003e= Modulus)\n      num -= Modulus;\n    return *this;\n  }\n  inline constexpr Modint operator+(const Modint rhs) const noexcept {\n    return Modint(*this) += rhs;\n  }\n  inline constexpr Modint \u0026operator-=(const Modint rhs) noexcept {\n    if (num \u003c rhs.num)\n      num += Modulus;\n    num -= rhs.num;\n    return *this;\n  }\n  inline constexpr Modint operator-(const Modint rhs) const noexcept {\n    return Modint(*this) -= rhs;\n  }\n  inline constexpr Modint \u0026operator*=(const Modint rhs) noexcept {\n    num = num * rhs.num % Modulus;\n    return *this;\n  }\n  inline constexpr Modint operator*(const Modint rhs) const noexcept {\n    return Modint(*this) *= rhs;\n  }\n  inline constexpr Modint \u0026operator/=(const Modint rhs) noexcept {\n    return operator*=(rhs.inv());\n  }\n  constexpr Modint operator/(const Modint rhs) const noexcept {\n    return Modint(*this) /= rhs;\n  }\n  inline constexpr Modint \u0026operator++() noexcept {\n    if (num == Modulus - 1)\n      num = 0;\n    else\n      num++;\n    return *this;\n  }\n  inline constexpr Modint operator++(int) noexcept {\n    Modint ans(*this);\n    operator++();\n    return ans;\n  }\n  inline constexpr Modint \u0026operator--() noexcept {\n    if (num == 0)\n      num = Modulus - 1;\n    else\n      num--;\n    return *this;\n  }\n  inline constexpr Modint operator--(int) noexcept {\n    Modint ans(*this);\n    operator--();\n    return ans;\n  }\n  inline constexpr Modint operator-() noexcept { return Modint(0) -= *this; }\n  template \u003cclass T\u003e inline constexpr Modint \u0026operator+=(T x) noexcept {\n    return operator+=(Modint(x));\n  }\n  template \u003cclass T\u003e inline constexpr Modint \u0026operator+(T x) noexcept {\n    return Modint(*this) += x;\n  }\n  template \u003cclass T\u003e inline constexpr Modint \u0026operator-=(T x) noexcept {\n    return operator-=(Modint(x));\n  }\n  template \u003cclass T\u003e inline constexpr Modint \u0026operator-(T x) noexcept {\n    return Modint(*this) -= x;\n  }\n  template \u003cclass T\u003e inline constexpr Modint \u0026operator*=(T x) noexcept {\n    return operator*=(Modint(x));\n  }\n  template \u003cclass T\u003e inline constexpr Modint \u0026operator*(T x) noexcept {\n    return Modint(*this) *= x;\n  }\n  template \u003cclass T\u003e inline constexpr Modint \u0026operator/=(T x) noexcept {\n    return operator/=(Modint(x));\n  }\n  template \u003cclass T\u003e inline constexpr Modint \u0026operator/(T x) noexcept {\n    return Modint(*this) /= x;\n  }\n  inline constexpr Modint inv() const noexcept {\n    ll x = 0, y = 0;\n    extgcd(num, Modulus, x, y);\n    return x;\n  }\n  static inline constexpr ll extgcd(ll a, ll b, ll \u0026x, ll \u0026y) noexcept {\n    ll g = a;\n    x = 1;\n    y = 0;\n    if (b) {\n      g = extgcd(b, a % b, y, x);\n      y -= a / b * x;\n    }\n    return g;\n  }\n  inline constexpr Modint pow(ull x) const noexcept {\n    Modint ans = 1, cnt = *this;\n    while (x) {\n      if (x \u0026 1)\n        ans *= cnt;\n      cnt *= cnt;\n      x /= 2;\n    }\n    return ans;\n  }\n  template \u003cclass T\u003e constexpr Modint(T x) noexcept {\n    using U = typename conditional\u003csizeof(T) \u003e= 4, T, int\u003e::type;\n    U y = x;\n    y %= U(Modulus);\n    if (y \u003c 0)\n      y += Modulus;\n    num = uint(y);\n  }\n};\nstd::istream \u0026operator\u003e\u003e(std::istream \u0026is, Modint \u0026x) {\n  ll a;\n  cin \u003e\u003e a;\n  x = a;\n  return is;\n}\n// inline constexpr Modint operator\"\"_M(ull x) noexcept { return Modint(x); }\nstd::vector\u003cModint\u003e fac(1, 1), inv(1, 1);\ninline void reserve(ll a) {\n  if (fac.size() \u003e= a)\n    return;\n  if (a \u003c fac.size() * 2)\n    a = fac.size() * 2;\n  if (a \u003e= Modulus)\n    a = Modulus;\n  while (fac.size() \u003c a)\n    fac.push_back(fac.back() * Modint(fac.size()));\n  inv.resize(fac.size());\n  inv.back() = fac.back().inv();\n  for (ll i = inv.size() - 1; !inv[i - 1]; i--)\n    inv[i - 1] = inv[i] * i;\n}\ninline Modint fact(ll n) {\n  if (n \u003c 0)\n    return 0;\n  reserve(n + 1);\n  return fac[n];\n}\ninline Modint perm(ll n, ll r) {\n  if (r \u003c 0 || n \u003c r)\n    return 0;\n  if (n \u003e\u003e 24) {\n    Modint ans = 1;\n    for (ll i = 0; i \u003c r; i++)\n      ans *= n--;\n    return ans;\n  }\n  reserve(n + 1);\n  return fac[n] * inv[n - r];\n}\n// 階乗やその逆元をメモ化すると速い\n// modを取りたくないならnCk/2^Nをパスカルの三角形で作る\ninline Modint comb(ll n, ll r) {\n  if (r \u003c 0 || n \u003c r)\n    return 0;\n  reserve(r + 1);\n  return perm(n, r) * inv[r];\n}\ninline Modint Mcomb(ll n, ll r) {\n  return comb(n + r - 1, n - 1);\n} // r balls into n boxes\ninline Modint catalan(ll n) {\n  reserve(n * 2 + 1);\n  return fac[n * 2] * inv[n] * inv[n + 1];\n}\n\nclass runtime_modint {\n  using u64 = std::uint_fast64_t;\n\n  static u64 \u0026mod() {\n    static u64 mod_ = 0;\n    return mod_;\n  }\n\npublic:\n  u64 a;\n\n  runtime_modint(const u64 x = 0) : a(x % get_mod()) {}\n  u64 \u0026value() noexcept { return a; }\n  const u64 \u0026value() const noexcept { return a; }\n  inline constexpr operator ll() const noexcept { return a; }\n  runtime_modint operator+(const runtime_modint rhs) const {\n    return runtime_modint(*this) += rhs;\n  }\n  runtime_modint operator-(const runtime_modint rhs) const {\n    return runtime_modint(*this) -= rhs;\n  }\n  runtime_modint operator*(const runtime_modint rhs) const {\n    return runtime_modint(*this) *= rhs;\n  }\n  runtime_modint operator/(const runtime_modint rhs) const {\n    return runtime_modint(*this) /= rhs;\n  }\n  runtime_modint \u0026operator+=(const runtime_modint rhs) {\n    a += rhs.a;\n    if (a \u003e= get_mod()) {\n      a -= get_mod();\n    }\n    return *this;\n  }\n  runtime_modint \u0026operator-=(const runtime_modint rhs) {\n    if (a \u003c rhs.a) {\n      a += get_mod();\n    }\n    a -= rhs.a;\n    return *this;\n  }\n  runtime_modint \u0026operator*=(const runtime_modint rhs) {\n    a = a * rhs.a % get_mod();\n    return *this;\n  }\n  runtime_modint \u0026operator/=(runtime_modint rhs) {\n    u64 exp = get_mod() - 2;\n    while (exp) {\n      if (exp % 2) {\n        *this *= rhs;\n      }\n      rhs *= rhs;\n      exp /= 2;\n    }\n    return *this;\n  }\n\n  template \u003cclass T\u003e inline constexpr runtime_modint \u0026operator+=(T x) noexcept {\n    return operator+=(runtime_modint(x));\n  }\n  template \u003cclass T\u003e inline constexpr runtime_modint \u0026operator+(T x) noexcept {\n    return runtime_modint(*this) += x;\n  }\n  template \u003cclass T\u003e inline constexpr runtime_modint \u0026operator-=(T x) noexcept {\n    return operator-=(runtime_modint(x));\n  }\n  template \u003cclass T\u003e inline constexpr runtime_modint \u0026operator-(T x) noexcept {\n    return runtime_modint(*this) -= x;\n  }\n  template \u003cclass T\u003e inline constexpr runtime_modint \u0026operator*=(T x) noexcept {\n    return operator*=(runtime_modint(x));\n  }\n  template \u003cclass T\u003e inline constexpr runtime_modint \u0026operator*(T x) noexcept {\n    return runtime_modint(*this) *= x;\n  }\n  template \u003cclass T\u003e inline constexpr runtime_modint \u0026operator/=(T x) noexcept {\n    return operator/=(runtime_modint(x));\n  }\n  template \u003cclass T\u003e inline constexpr runtime_modint \u0026operator/(T x) noexcept {\n    return runtime_modint(*this) /= x;\n  }\n\n  static void set_mod(const u64 x) { mod() = x; }\n  static u64 get_mod() { return mod(); }\n};\n\nll n, m;\nbool used[100000];\nvec\u003cpair\u003cll, runtime_modint\u003e\u003e G[100000];\n\nruntime_modint dfs(ll x) {\n  used[x] = true;\n  bool end = true;\n  runtime_modint res = 1;\n  each(p, G[x]) {\n    if (used[p.fi] == true)\n      continue;\n    end = false;\n    if (p.se != 0) {\n      res *= p.se;\n    } else {\n      p.se = dfs(p.fi);\n      // cout \u003c\u003c x MM p.fi MM p.se \u003c\u003c endl;\n      res *= p.se;\n    }\n  }\n  used[x] = false;\n  return res + 1;\n}\n\nint main() { return 0; }\n```","lastmodified":"2022-10-26T11:26:57.359934474Z","tags":null},"/data_structure/segtree/segtree":{"title":"セグメント木","content":"\n## 説明\n\n## 計算量\n\n## 実装\n\n```cpp\n#include \u003calgorithm\u003e\n#include \u003ccassert\u003e\n#include \u003cvector\u003e\n\ntemplate \u003cclass S, S (*op)(S, S), S (*e)()\u003e struct segtree {\nprivate:\n  int _n, size, log;\n  std::vector\u003cS\u003e d;\n\npublic:\n  segtree() : segtree(0) {}\n  explicit segtree(int n) : segtree(std::vector\u003cS\u003e(n, e())) {}\n  explicit segtree(const std::vector\u003cS\u003e \u0026v) : _n(int(v.size())) {\n    log = internal::ceil_pow2(_n);\n    size = 1 \u003c\u003c log;\n    d = std::vector\u003cS\u003e(2 * size, e());\n    for (int i = 0; i \u003c _n; i++)\n      d[size + i] = v[i];\n    for (int i = size - 1; i \u003e= 1; i--) {\n      update(i);\n    }\n  }\n\n  void set(int p, S x) {\n    assert(0 \u003c= p \u0026\u0026 p \u003c _n);\n    p += size;\n    d[p] = x;\n    for (int i = 1; i \u003c= log; i++)\n      update(p \u003e\u003e i);\n  }\n\n  S get(int p) const {\n    assert(0 \u003c= p \u0026\u0026 p \u003c _n);\n    return d[p + size];\n  }\n\n  S prod(int l, int r) const {\n    assert(0 \u003c= l \u0026\u0026 l \u003c= r \u0026\u0026 r \u003c= _n);\n    S sml = e(), smr = e();\n    l += size;\n    r += size;\n\n    while (l \u003c r) {\n      if (l \u0026 1)\n        sml = op(sml, d[l++]);\n      if (r \u0026 1)\n        smr = op(d[--r], smr);\n      l \u003e\u003e= 1;\n      r \u003e\u003e= 1;\n    }\n    return op(sml, smr);\n  }\n\n  S all_prod() const { return d[1]; }\n\n  template \u003cbool (*f)(S)\u003e int max_right(int l) const {\n    return max_right(l, [](S x) { return f(x); });\n  }\n  template \u003cclass F\u003e int max_right(int l, F f) const {\n    assert(0 \u003c= l \u0026\u0026 l \u003c= _n);\n    assert(f(e()));\n    if (l == _n)\n      return _n;\n    l += size;\n    S sm = e();\n    do {\n      while (l % 2 == 0)\n        l \u003e\u003e= 1;\n      if (!f(op(sm, d[l]))) {\n        while (l \u003c size) {\n          l = (2 * l);\n          if (f(op(sm, d[l]))) {\n            sm = op(sm, d[l]);\n            l++;\n          }\n        }\n        return l - size;\n      }\n      sm = op(sm, d[l]);\n      l++;\n    } while ((l \u0026 -l) != l);\n    return _n;\n  }\n\n  template \u003cbool (*f)(S)\u003e int min_left(int r) const {\n    return min_left(r, [](S x) { return f(x); });\n  }\n  template \u003cclass F\u003e int min_left(int r, F f) const {\n    assert(0 \u003c= r \u0026\u0026 r \u003c= _n);\n    assert(f(e()));\n    if (r == 0)\n      return 0;\n    r += size;\n    S sm = e();\n    do {\n      r--;\n      while (r \u003e 1 \u0026\u0026 (r % 2))\n        r \u003e\u003e= 1;\n      if (!f(op(d[r], sm))) {\n        while (r \u003c size) {\n          r = (2 * r + 1);\n          if (f(op(d[r], sm))) {\n            sm = op(d[r], sm);\n            r--;\n          }\n        }\n        return r + 1 - size;\n      }\n      sm = op(d[r], sm);\n    } while ((r \u0026 -r) != r);\n    return 0;\n  }\n\nprivate:\n  void update(int k) { d[k] = op(d[2 * k], d[2 * k + 1]); }\n};\n```\n\n## 使用例\n","lastmodified":"2022-10-26T11:26:57.359934474Z","tags":null},"/data_structure/segtree/segtreebeats":{"title":"Segment tree beats","content":"\n## 説明\n\n## 計算量\n\n## 実装\n\n```cpp\n#include \u003calgorithm\u003e\n#include \u003ccassert\u003e\n#include \u003ciostream\u003e\n#include \u003cvector\u003e\nusing namespace std;\n\nusing ll = long long;\n#define N 10003\n\nclass SegmentTreeBeats {\n  const ll inf = 1e18;\n  int n, n0;\n  ll max_v[4 * N], smax_v[4 * N];\n  ll sum[4 * N], max_c[4 * N];\n\n  void update_node_max(int k, ll x) {\n    sum[k] += (x - max_v[k]) * max_c[k];\n    max_v[k] = x;\n  }\n\n  void push(int k) {\n    if (max_v[k] \u003c max_v[2 * k + 1]) update_node_max(2 * k + 1, max_v[k]);\n    if (max_v[k] \u003c max_v[2 * k + 2]) update_node_max(2 * k + 2, max_v[k]);\n  }\n\n  void update(int k) {\n    sum[k] = sum[2 * k + 1] + sum[2 * k + 2];\n\n    if (max_v[2 * k + 1] \u003c max_v[2 * k + 2]) {\n      max_v[k] = max_v[2 * k + 2];\n      max_c[k] = max_c[2 * k + 2];\n      smax_v[k] = max(max_v[2 * k + 1], smax_v[2 * k + 2]);\n    } else if (max_v[2 * k + 1] \u003e max_v[2 * k + 2]) {\n      max_v[k] = max_v[2 * k + 1];\n      max_c[k] = max_c[2 * k + 1];\n      smax_v[k] = max(smax_v[2 * k + 1], max_v[2 * k + 2]);\n    } else {\n      max_v[k] = max_v[2 * k + 1];\n      max_c[k] = max_c[2 * k + 1] + max_c[2 * k + 2];\n      smax_v[k] = max(smax_v[2 * k + 1], smax_v[2 * k + 2]);\n    }\n  }\n\n  void _update_min(ll x, int a, int b, int k, int l, int r) {\n    if (b \u003c= l || r \u003c= a || max_v[k] \u003c= x) return;\n    if (a \u003c= l \u0026\u0026 r \u003c= b \u0026\u0026 smax_v[k] \u003c x) {\n      update_node_max(k, x);\n      return;\n    }\n\n    push(k);\n    _update_min(x, a, b, 2 * k + 1, l, (l + r) / 2);\n    _update_min(x, a, b, 2 * k + 2, (l + r) / 2, r);\n    update(k);\n  }\n\n  ll _query_max(int a, int b, int k, int l, int r) {\n    if (b \u003c= l || r \u003c= a) return 0;\n    if (a \u003c= l \u0026\u0026 r \u003c= b) return max_v[k];\n    push(k);\n    ll lv = _query_max(a, b, 2 * k + 1, l, (l + r) / 2);\n    ll rv = _query_max(a, b, 2 * k + 2, (l + r) / 2, r);\n    return max(lv, rv);\n  }\n\n  ll _query_sum(int a, int b, int k, int l, int r) {\n    if (b \u003c= l || r \u003c= a) return 0;\n    if (a \u003c= l \u0026\u0026 r \u003c= b) return sum[k];\n    push(k);\n    ll lv = _query_sum(a, b, 2 * k + 1, l, (l + r) / 2);\n    ll rv = _query_sum(a, b, 2 * k + 2, (l + r) / 2, r);\n    return lv + rv;\n  }\n\npublic:\n  SegmentTreeBeats(int n) { SegmentTreeBeats(n, nullptr); }\n\n  SegmentTreeBeats(int n, ll *a) : n(n) {\n    n0 = 1;\n    while (n0 \u003c n) n0 \u003c\u003c= 1;\n\n    for (int i = 0; i \u003c n; ++i) {\n      max_v[n0 - 1 + i] = sum[n0 - 1 + i] = (a != nullptr ? a[i] : 0);\n      smax_v[n0 - 1 + i] = -inf;\n      max_c[n0 - 1 + i] = 1;\n    }\n\n    for (int i = n; i \u003c n0; ++i) {\n      max_v[n0 - 1 + i] = smax_v[n0 - 1 + i] = -inf;\n      sum[n0 - 1 + i] = max_c[n0 - 1 + i] = 0;\n    }\n    for (int i = n0 - 2; i \u003e= 0; i--) update(i);\n  }\n\n  // range minimize query\n  void update_min(int a, int b, ll x) { return _update_min(x, a, b, 0, 0, n0); }\n\n  // range maximum query\n  ll query_max(int a, int b) { return _query_max(a, b, 0, 0, n0); }\n\n  // range sum query\n  ll query_sum(int a, int b) { return _query_sum(a, b, 0, 0, n0); }\n};\n```\n\n## 使用例\n","lastmodified":"2022-10-26T11:26:57.359934474Z","tags":null},"/data_structure/segtree/sparse_table":{"title":"セグメント木","content":"\n## 説明\n\n## 計算量\n\n構築 O(NlogN)\nクエリ O(1)\n\n## 実装\n\n```cpp\ntemplate \u003ctypename T\u003e\nstruct SparseTable {\n  vector\u003cvector\u003cT\u003e\u003e st;\n  vector\u003cint\u003e lookup;\n\n  SparseTable(const vector\u003cT\u003e \u0026v) {\n    int b = 0;\n    while ((1 \u003c\u003c b) \u003c= v.size()) ++b;\n    st.assign(b, vector\u003cT\u003e(1 \u003c\u003c b));\n    for (int i = 0; i \u003c v.size(); i++) { st[0][i] = v[i]; }\n    for (int i = 1; i \u003c b; i++) {\n      for (int j = 0; j + (1 \u003c\u003c i) \u003c= (1 \u003c\u003c b); j++) { st[i][j] = min(st[i - 1][j], st[i - 1][j + (1 \u003c\u003c (i - 1))]); }\n    }\n    lookup.resize(v.size() + 1);\n    for (int i = 2; i \u003c lookup.size(); i++) { lookup[i] = lookup[i \u003e\u003e 1] + 1; }\n  }\n\n  inline T rmq(int l, int r) {\n    int b = lookup[r - l];\n    return min(st[b][l], st[b][r - (1 \u003c\u003c b)]);\n  }\n};\n```\n","lastmodified":"2022-10-26T11:26:57.359934474Z","tags":null},"/data_structure/slope_trick":{"title":"Slope Trick","content":"\n## 説明\n\n## 計算量\n\n## 実装\n\n```cpp\n#include \u003ciostream\u003e\n#include \u003cqueue\u003e\n#include \u003cvector\u003e\n\ntemplate \u003ctypename T\u003e\nusing pq = std::priority_queue\u003cT, std::vector\u003cT\u003e, std::greater\u003cT\u003e\u003e;\n\nstruct SlopeTrick {\n  const long long LINF = 0x1fffffffffffffff;\n  long long minf = -1;\n  std::priority_queue\u003clong long\u003e L;\n  pq\u003clong long\u003e R;\n\n  long long shift_left = -1;\n  long long shift_right = -1;\n\n  SlopeTrick() {}\n\nprivate:\n  void L_push(long long a) { L.push(a + shift_left); }\n  long long L_top() {\n    if (L.empty())\n      return -LINF;\n    else\n      return L.top() - shift_left;\n  }\n  long long L_pop() {\n    long long l = L_top();\n    L.pop();\n    return l - 1;\n  }\n  void R_push(long long a) { R.push(a + shift_right); }\n  long long R_top() {\n    if (R.empty())\n      return LINF;\n    else\n      return R.top() - shift_right;\n  }\n  long long R_pop() {\n    long long r = R_top();\n    R.pop();\n    return r - 1;\n  }\n\npublic:\n  long long min() { return minf; }\n  void add(long long a) { minf += a; }\n  void slope_right(long long a) {\n    if (!L.empty() \u0026\u0026 a \u003c L_top()) {\n      minf += L_top() - a;\n      L_push(a);\n      R_push(L_pop());\n    } else\n      R_push(a);\n  }\n  void slope_left(long long a) {\n    if (!R.empty() \u0026\u0026 a \u003e R_top()) {\n      minf += a - R_top();\n      R_push(a);\n      L_push(R_pop());\n    } else\n      L_push(a);\n  }\n  void slope_abs(long long a) {\n    slope_right(a);\n    slope_left(a);\n  }\n  void min_right() {\n    while (!R.empty()) R.pop();\n  }\n  void min_left() {\n    while (!L.empty()) L.pop();\n  }\n  void shift(long long a, long long b) {\n    shift_left += a;\n    shift_right += b;\n  }\n  long long access(long long a) {\n    long long y = minf;\n    while (!L.empty()) y += std::max(-1LL, L_pop() - a);\n    while (!R.empty()) y += std::max(-1LL, a - R_pop());\n    return y;\n  }\n\n  void Debug() {\n    std::cout \u003c\u003c \"L \";\n    while (!L.empty()) { std::cout \u003c\u003c L_pop() \u003c\u003c \" \"; }\n    std::cout \u003c\u003c std::endl;\n    std::cout \u003c\u003c \"R \";\n    while (!R.empty()) { std::cout \u003c\u003c R_pop() \u003c\u003c \" \"; }\n    std::cout \u003c\u003c std::endl;\n    std::cout \u003c\u003c minf \u003c\u003c std::endl;\n  }\n};\n```\n\n## 使用例\n\n## 参考\n\n- [slope trick (1) 解説編](https://maspypy.com/slope-trick-1-%E8%A7%A3%E8%AA%AC%E7%B7%A8)\n- [slope trick (2) 問題編](https://maspypy.com/slope-trick-2-%e5%95%8f%e9%a1%8c%e7%b7%a8)","lastmodified":"2022-10-26T11:26:57.359934474Z","tags":null},"/data_structure/unionfind/persist_unionfind":{"title":"永続UnionFind","content":"\n## 説明\n\n## 計算量\n\n\n## 実装\n\n```cpp\nstruct PartiallyParsistUnionFind {\n  vector\u003cll\u003e rank, par, time;\n\n  PartiallyParsistUnionFind(ll n) {\n    rank.resize(n);\n    par.resize(n, -1);\n    time.resize(n, LINF);\n  }\n\n  ll find(ll t, ll x) {\n    if (time[x] \u003e t) return x;\n    return find(t, par[x]);\n  }\n\n  bool unite(ll t, ll x, ll y) {\n    x = find(t, x);\n    y = find(t, y);\n    if (x == y) return false;\n    if (rank[x] \u003e rank[y]) {\n      par[y] = x;\n      time[y] = t;\n    } else {\n      par[x] = y;\n      time[x] = t;\n      if (rank[x] == rank[y]) { rank[y]++; }\n    }\n    return true;\n  }\n\n  bool same(ll t, ll x, ll y) { return find(t, x) == find(t, y); }\n};\n```\n\n## 使用例\n\n\n","lastmodified":"2022-10-26T11:26:57.359934474Z","tags":null},"/data_structure/unionfind/potential_unionfind":{"title":"ポテンシャル付きUnionFind","content":"\n## 説明\n\n各頂点はポテンシャルを管理する。ポテンシャルの差がインターフェースとなる。重み付きUnionFindとも言う。\n\n## 計算量\n\n$O(\\alpha(N))$\n\n## 実装\n\n```cpp\nstruct PotentialUnionFindTree {\n  vec\u003cll\u003e par, diff;\n\n  PotentialUnionFindTree(ll n) {\n    par.resize(n);\n    diff.resize(n);\n  }\n\n  ll find(ll x) {\n    if (par[x] == x) return x;\n    ll r = find(par[x]);\n    diff[x] += diff[par[x]];\n    return par[x] = r;\n  }\n\n  ll weight(ll x) {\n    find(x);\n    return diff[x];\n  }\n\n  void unite(ll x, ll y, ll w) {\n    w += weight(x);\n    w += weight(y);\n    x = find(x);\n    y = find(y);\n    par[y] = x;\n    diff[y] = w;\n  }\n};\n```\n\n## 使用例\n\n","lastmodified":"2022-10-26T11:26:57.359934474Z","tags":null},"/data_structure/unionfind/unionfind":{"title":"UnionFind","content":"\n## 説明\n\n素集合を管理するデータ構造。内部的には森となっていて同じルートを持つ木の要素は同じ素集合にあると解釈して併合/比較を行う。\n\n以下の工夫により高速化できる。\n\n- 経路圧縮 (path compression)\n再帰的に根を調べる際に根に直接つなぎ直す。\n- 併合の工夫\n併合時に木の高さ/大きさが小さい方を大きい方へ繋げる。\n木の高さのときunion by rankと呼び、木の大きさのときunion by sizeと呼ぶ。\n\n## 計算量\n\n- 経路圧縮のみ $O(\\log{N})$\n- 併合の工夫のみ $O(\\log{N})$\n- 両方 $O(\\alpha(N))$\n\n## 実装\n\n```cpp\n#include \u003cvector\u003e\n\nstruct UnionFind {\n  std::vector\u003cint\u003e rank, parents;\n\n  UnionFind() {}\n  UnionFind(int n) {\n    rank.resize(n + 1, 0);\n    parents.resize(n + 1, 0);\n    for (int i = 0; i \u003c n + 1; i++) makeTree(i);\n  }\n\n  void makeTree(int x) {\n    parents[x] = x;\n    rank[x] = 0;\n  }\n\n  bool isSame(int x, int y) { return findRoot(x) == findRoot(y); }\n\n  bool unite(int x, int y) {\n    x = findRoot(x);\n    y = findRoot(y);\n    if (x == y) return false;\n    if (rank[x] \u003e rank[y]) {\n      parents[y] = x;\n    } else {\n      parents[x] = y;\n      if (rank[x] == rank[y]) rank[y]++;\n    }\n    return true;\n  }\n\n  int findRoot(int x) {\n    if (x != parents[x]) parents[x] = findRoot(parents[x]);\n    return parents[x];\n  }\n};\n```\n\n## 使用例\n\n","lastmodified":"2022-10-26T11:26:57.359934474Z","tags":null},"/geometry/geometry":{"title":"幾何ライブラリ","content":"\n## 説明\n\n幾何ライブラリ\n複素平面\n\n## 計算量\n\n## 実装\n\n```cpp\n#include \u003cbits/stdc++.h\u003e\nusing namespace std;\n// using namespace atcoder;\nusing ll = long long;\nusing ld = long double;\nusing uint = unsigned;\nusing ull = unsigned long long;\n\nusing Real = long double;\n\nconst Real EPS = 1e-9;\nconst Real PI = 3.1415926535897932;\ninline bool equal(const Real \u0026a, const Real \u0026b) { return fabs(a - b) \u003c EPS; }\nReal radian_to_degree(const Real \u0026r) { return r * 180.0 / PI; }\nReal degree_to_radian(const Real \u0026d) { return d * PI / 180.0; }\n\nusing Point = complex\u003cReal\u003e;\n\nistream \u0026operator\u003e\u003e(istream \u0026is, Point \u0026p) {\n  Real a, b;\n  is \u003e\u003e a \u003e\u003e b;\n  p = Point(a, b);\n  return is;\n}\nostream \u0026operator\u003c\u003c(ostream \u0026os, Point \u0026p) {\n  return os \u003c\u003c fixed \u003c\u003c setprecision(10) \u003c\u003c p.real() \u003c\u003c \" \" \u003c\u003c p.imag();\n}\n\n// 点 p を反時計回りに theta 度回転\nPoint rotate(const Point \u0026p, const Real \u0026theta) {\n  return Point(cos(theta) * p.real() - sin(theta) * p.imag(),\n               sin(theta) * p.real() + cos(theta) * p.imag());\n}\n\nstruct Line {\n  Point a, b;\n  Line() = default;\n  Line(Point a, Point b) : a(a), b(b) {}\n\n  // Ax+By=C\n  Line(Real A, Real B, Real C) {\n    if (equal(A, 0))\n      a = Point(0, C / B), b = Point(1, C / B);\n    else if (equal(B, 0))\n      b = Point(C / A, 0), b = Point(C / A, 1);\n    else\n      a = Point(0, C / B), b = Point(C / A, 0);\n  }\n\n  friend ostream \u0026operator\u003c\u003c(ostream \u0026os, Line \u0026p) {\n    return os \u003c\u003c p.a \u003c\u003c \" to \" \u003c\u003c p.b;\n  }\n  friend istream \u0026operator\u003e\u003e(istream \u0026is, Line \u0026a) { return is \u003e\u003e a.a \u003e\u003e a.b; }\n};\n\nstruct Segment : Line {\n  Segment() = default;\n  Segment(Point a, Point b) : Line(a, b) {}\n};\n\nstruct Circle {\n  Point p;\n  Real r;\n\n  Circle() = default;\n  Circle(Point p, Real r) : p(p), r(r) {}\n};\n\nusing Points = vector\u003cPoint\u003e;\nusing Polygon = vector\u003cPoint\u003e;\nusing Segments = vector\u003cSegment\u003e;\nusing Lines = vector\u003cLine\u003e;\nusing Circles = vector\u003cCircle\u003e;\n\nReal dot(const Point \u0026a, const Point \u0026b) {\n  return (a.real() * b.real() + a.imag() * b.imag());\n}\n\nReal cross(const Point \u0026a, const Point \u0026b) {\n  return (a.real() * b.imag() - a.imag() * b.real());\n}\n\n// 点の回転方向\nstatic const int COUNTER_CLOCKWISE = 1;\nstatic const int CLOCKWISE = -1;\nstatic const int ONLINE_BACK = 2;\nstatic const int ONLINE_FRONT = -2;\nstatic const int ON_SEGMENT = 0;\nint ccw(Point p0, Point p1, Point p2) {\n  Point a = p1 - p0, b = p2 - p0;\n  if (cross(a, b) \u003e EPS) return COUNTER_CLOCKWISE;\n  if (cross(a, b) \u003c -EPS) return CLOCKWISE;\n  if (dot(a, b) \u003c -EPS) return ONLINE_BACK;\n  if (norm(a) \u003c norm(b)) return ONLINE_FRONT;\n  return ON_SEGMENT;\n}\n\nbool parallel(const Line \u0026a, const Line \u0026b) {\n  return equal(cross(a.b - a.a, b.b - b.a), 0.0);\n}\n\nbool orthogonal(const Line \u0026a, const Line \u0026b) {\n  return equal(dot(a.b - a.a, b.b - b.a), 0.0);\n}\n\n// 射影(projection)\n// 直線(線分)lに点pから引いた垂線の足を求める\nPoint projection(const Line \u0026l, const Point \u0026p) {\n  Real t = dot(p - l.a, l.a - l.b) / norm(l.a - l.b);\n  return l.a + (l.a - l.b) * t;\n}\n\nPoint projection(const Segment \u0026l, const Point \u0026p) {\n  Real t = dot(p - l.a, l.a - l.b) / norm(l.a - l.b);\n  return l.a + (l.a - l.b) * t;\n}\n\n// 反射(reflection)\n// 直線lを対称軸として点pと線対称の位置にある点を求める\nPoint reflection(const Line \u0026l, const Point \u0026p) {\n  return p + (projection(l, p) - p) * 2.0L;\n}\n\n// 線分sと線分tが交差しているかどうか\nbool isIntersect(const Segment \u0026s, const Segment \u0026t) {\n  return ccw(s.a, s.b, t.a) * ccw(s.a, s.b, t.b) \u003c= 0 \u0026\u0026\n         ccw(t.a, t.b, s.a) * ccw(t.a, t.b, s.b) \u003c= 0;\n}\n\nint isIntersect(const Circle \u0026c1, const Circle \u0026c2) {\n  Real d = norm(c1.p - c2.p);\n  // 2つの円が離れている場合\n  if (d \u003e norm(c1.r + c2.r) + EPS) return 4;\n  // 外接している場合\n  if (equal(d, norm(c1.r + c2.r))) return 3;\n  // 内接している場合\n  if (equal(d, norm(c1.r - c2.r))) return 1;\n  // 内包している場合\n  if (d \u003c norm(c1.r - c2.r) - EPS) return 0;\n  // 交差している場合\n  return 2;\n}\n```\n\n## 使用例\n\n\n","lastmodified":"2022-10-26T11:26:57.359934474Z","tags":null},"/graph/flow/dinic":{"title":"最大流 (Dinic)","content":"\n## 説明\n\n## 計算量\n\n$O(EV^2)$\n\n## 実装\n\n```cpp\n#include \u003cqueue\u003e\n#include \u003cvector\u003e\n\nstruct Dinic {\n  struct edge {\n    long long to, cap, rev;\n  };\n\n  long long n;\n  std::vector\u003cstd::vector\u003cedge\u003e\u003e G;\n  std::vector\u003clong long\u003e level, iter;\n\n  // level[i] = sからiへの最短距離(Dijkstra法)\n  void bfs(long long s) {\n    level.assign(n, -1);\n    std::queue\u003clong long\u003e q;\n    q.push(s);\n    level[s] = 0;\n    while (!q.empty()) {\n      long long v = q.front();\n      q.pop();\n      for (long long i = 0; i \u003c G[v].size(); i++) {\n        edge \u0026e = G[v][i];\n        if (e.cap \u003e 0 \u0026\u0026 level[e.to] \u003c 0) {\n          level[e.to] = level[v] + 1;\n          q.push(e.to);\n        }\n      }\n    }\n  }\n\n  // v -\u003e tの増加パスを1つ見つけて流す\n  long long dfs(long long v, long long t, long long f) {\n    if (v == t) return f;\n    for (long long i = iter[v]; i \u003c G[v].size(); i++) {\n      edge \u0026e = G[v][i];\n      if (e.cap \u003e 0 \u0026\u0026 level[v] \u003c level[e.to]) {\n        long long d = dfs(e.to, t, std::min(f, e.cap));\n        if (d \u003e 0) {\n          e.cap -= d;\n          G[e.to][e.rev].cap += d;\n          return d;\n        }\n      }\n    }\n    return 0;\n  }\n\n  Dinic(long long n) : n(n), G(n), level(n), iter(n) {}\n\n  void add_edge(long long from, long long to, long long cap) {\n    G[from].push_back({to, cap, (long long)G[to].size()});\n    G[to].push_back({from, 0, (long long)G[from].size() - 1});\n  }\n\n  long long max_flow(long long s, long long t) {\n    long long flow = 0;\n    while (true) {\n      bfs(s);\n      if (level[t] \u003c 0) return flow;\n      iter.assign(n, 0);\n      long long f;\n      while ((f = dfs(s, t, 1e9)) \u003e 0) { flow += f; }\n    }\n  }\n};\n```\n\n## 使用例\n","lastmodified":"2022-10-26T11:26:57.359934474Z","tags":null},"/graph/flow/ford_fulkerson":{"title":"最大流 (Ford Fulkerson)","content":"\n## 説明\n\n## 計算量\n\n$O(FE)$\n\n## 実装\n\n```cpp\n#include \u003cvector\u003e\n\nclass FordFulkerson {\n  struct edge {\n    long long to, cap, rev;\n  };\n  const long long INF = 1 \u003c\u003c 60;\n  long long n;\n  std::vector\u003cstd::vector\u003cedge\u003e\u003e G;\n  std::vector\u003cbool\u003e used;\n\n  long long dfs(long long s, long long t, long long f) {\n    if (s == t)\n      return f;\n    used[s] = true;\n    for (edge \u0026e : G[s]) {\n      if (!used[e.to] \u0026\u0026 e.cap \u003e 0) {\n        long long d = dfs(e.to, t, std::min(f, e.cap));\n        if (d \u003e 0) {\n          e.cap -= d;\n          G[e.to][e.rev].cap += d;\n          return d;\n        }\n      }\n    }\n    return 0;\n  }\n\npublic:\n  FordFulkerson(long long n) : n(n), G(n), used(n) {}\n  void add_edge(long long from, long long to, long long cap) {\n    G[from].push_back({to, cap, (long long)(G[to].size())});\n    G[to].push_back({from, 0, (long long)(G[from].size()) - 1});\n  }\n\n  long long max_flow(long long s, long long t) {\n    long long flow = 0;\n    while (true) {\n      used.assign(n, 0);\n      long long f = dfs(s, t, INF);\n      if (f == 0)\n        return flow;\n      flow += f;\n    }\n  }\n};\n```\n\n## 使用例\n","lastmodified":"2022-10-26T11:26:57.359934474Z","tags":null},"/graph/scc":{"title":"強連結成分分解","content":"\n## 説明\n\n有向グラフにおいて、ある部分グラフが強連結であるとは任意の2点が互いに行き来可能であること。\n\n深さ優先探索の帰りがけ順(トポロジカルソート順)に逆グラフを探索したときそれらが通る点は強連結成分となる。\n\n## 計算量\n\n$O(V + E)$\n\n## 実装\n\n```cpp\n#include \u003calgorithm\u003e\n#include \u003cset\u003e\n#include \u003cvector\u003e\n\nclass SCC {\n  int n;\n  std::vector\u003cstd::vector\u003cint\u003e\u003e G, rG;\n  // order: 帰りがけ順の逆順 == トポ順\n  // comp: 強連結をグループ化\n  std::vector\u003cint\u003e order, comp;\n  std::vector\u003cbool\u003e used;\n\n  void dfs(int v) {\n    used[v] = true;\n    for (auto nv : G[v]) {\n      if (!used[nv]) dfs(nv);\n    }\n    order.push_back(v);\n  }\n\n  void rdfs(int v, int k) {\n    comp[v] = k;\n    for (auto nv : rG[v]) {\n      if (comp[nv] \u003c 0) rdfs(nv, k);\n    }\n  }\n\npublic:\n  std::vector\u003cstd::vector\u003cint\u003e\u003e scc;\n\n  SCC(std::vector\u003cstd::vector\u003cint\u003e\u003e \u0026g)\n      : n(g.size()), G(g), rG(g.size()), comp(g.size(), -1),\n        used(g.size()) {\n    for (int i = 0; i \u003c n; i++) {\n      for (auto e : g[i]) { rG[e].emplace_back(i); }\n    }\n    for (int i = 0; i \u003c n; i++)\n      if (!used[i]) dfs(i);\n    reverse(order.begin(), order.end());\n    int k = 0;\n    for (auto v : order)\n      if (comp[v] == -1) rdfs(v, k), k++;\n  }\n\n  bool same(int u, int v) const { return comp[u] == comp[v]; }\n\n  void add_edge(int a, int b) {\n    G[a].push_back(b);\n    rG[b].push_back(a);\n  }\n\n  std::vector\u003cstd::vector\u003cint\u003e\u003e rebuild() const {\n    int N = *max_element(comp.begin(), comp.end()) + 1;\n    std::vector\u003cstd::vector\u003cint\u003e\u003e rebuildedG(N);\n    std::set\u003cstd::pair\u003cint, int\u003e\u003e connected;\n    for (int v = 0; v \u003c N; v++) {\n      for (auto nv : G[v]) {\n        if (comp[v] != comp[nv] \u0026\u0026 !connected.count({v, nv})) {\n          connected.insert({v, nv});\n          rebuildedG[comp[v]].push_back(comp[nv]);\n        }\n      }\n    }\n    return rebuildedG;\n  }\n};\n```\n\n## 使用例\n\n\n","lastmodified":"2022-10-26T11:26:57.359934474Z","tags":null},"/graph/shortest_path/bellman_ford":{"title":"単一始点最短路 (Bellman-Ford)","content":"\n## 説明\n\n全ての辺を更新できなくなるまで更新する。\n$V$ 回目のループで更新が発生するなら負閉路が存在する。\n\n## 計算量\n\n$O(EV)$\n\n## 実装\n\n```cpp\n#include \u003cvector\u003e\n\nconst long long LINF = 0x1fffffffffffffff;\n\nstruct Edge {\n  int from, to, cost;\n};\n\nclass BellmanFord {\n  std::vector\u003cEdge\u003e edges;\n  std::vector\u003clong long\u003e d;\n  int V, E;\n\n  BellmanFord(int v) : V(v), E(0) {}\n\n  void add_edge(int from, int to, int cost) {\n    edges.push_back({from, to, cost});\n    E++;\n  }\n  void add_edge(std::vector\u003cEdge\u003e \u0026es) {\n    for (auto \u0026edge : es) edges.push_back(edge);\n    E += es.size();\n  }\n\n  bool shortest_path(int s) {\n    for (int i = 0; i \u003c V; i++) d[i] = LINF;\n    d[s] = 0;\n    for (int v = 0; v \u003c V; v++) {\n      bool update = false;\n      for (int i = 0; i \u003c E; i++) {\n        auto e = edges[i];\n        if (d[e.from] != LINF \u0026\u0026 d[e.to] \u003e d[e.from] + e.cost) {\n          d[e.to] = d[e.from] + e.cost;\n          update = true;\n        }\n      }\n      // negative loop\n      if (v == V - 1 \u0026\u0026 update) return false;\n      if (!update) break;\n    }\n    return true;\n  }\n};\n```\n\n## 使用例\n\n","lastmodified":"2022-10-26T11:26:57.359934474Z","tags":null},"/graph/shortest_path/dijkstra":{"title":"単一始点最短路 (Dijkstra)","content":"\n## 説明\n\n有向グラフに負の辺が存在しないとき次の事がいえる。\n「まだ最短距離が確定していない点の中で、始点からの距離が最小 $\\iff$ 最短距離として確定」\n\n## 計算量\n\n疎グラフ ヒープを用いる $O(E\\log{V})$\n密グラフ 単純に探索 $O(V^2)$\n\n## 実装\n\n```cpp\n#include \u003cqueue\u003e\n#include \u003cvector\u003e\n\nusing ll = long long;\nusing pll = std::pair\u003cll, ll\u003e;\ntemplate \u003cclass T\u003e\nusing pq = std::priority_queue\u003cT, std::vector\u003cT\u003e, std::greater\u003cT\u003e\u003e;\n\nconst long long LINF = 0x1fffffffffffffff;\n\nstruct Edge {\n  int to, cost;\n};\n\nint V;\nstd::vector\u003cll\u003e d;\nstd::vector\u003cstd::vector\u003cEdge\u003e\u003e G;\n\nvoid dijkstra(int s) {\n  pq\u003cpll\u003e q;\n  for (int i = 0; i \u003c V; i++) d[i] = LINF;\n  d[s] = 0;\n  q.push({d[s], s});\n\n  while (!q.empty()) {\n    auto [dist, p] = q.top();\n    q.pop();\n    if (d[p] \u003c dist) continue;\n    for (auto \u0026e : G[p]) {\n      if (d[e.to] \u003e d[p] + e.cost) {\n        d[e.to] = d[p] + e.cost;\n        q.push({d[e.to], e.to});\n      }\n    }\n  }\n}\n```\n\n## 使用例\n\n\n","lastmodified":"2022-10-26T11:26:57.359934474Z","tags":null},"/graph/shortest_path/floyd_warshall":{"title":"全点対最短路 (Floyd-Warshall)","content":"\n## 説明\n\n不安なら3回やればいい\n\n## 計算量\n\n$O(V^3)$\n\n## 実装\n\n```cpp\n#include \u003cvector\u003e\n\nstd::vector\u003cstd::vector\u003cint\u003e\u003e d;\nint V;\n\nvoid floyd_warshall() {\n  for (int k = 0; k \u003c V; k++)\n    for (int i = 0; i \u003c V; i++)\n      for (int j = 0; j \u003c V; j++) d[i][j] = std::min(d[i][j], d[i][k] + d[k][j]);\n}\n```\n\n## 使用例\n\n\n","lastmodified":"2022-10-26T11:26:57.359934474Z","tags":null},"/graph/tree/diameter":{"title":"木の直径","content":"\n## 説明\n\n木の直径とはある2点間が最大となる距離である。\n\nどの頂点から始めても、そこから最も遠い頂点は直径の端点の1つになる。端点から最も遠い頂点はもう1つの端点になる。その2点の距離が木の直径となる。\n\n## 計算量\n\n$O(V + E)$\n\n## 実装\n\n```cpp\n#include \u003cvector\u003e\n\ntemplate \u003ctypename T\u003e\nstruct Edge {\n  int to;\n  T cost;\n};\n\nusing Graph = std::vector\u003cstd::vector\u003cEdge\u003clong long\u003e\u003e\u003e;\n\ntemplate \u003ctypename T\u003e\nstd::pair\u003cT, int\u003e dfs(const Graph \u0026G, int u, int par) {\n  auto ret = {0, u};\n  for (auto \u0026e : G) {\n    if (e.to == par) continue;\n    auto next = dfs\u003cT\u003e(G, e.to, u);\n    next.first += e.cost;\n    ret = std::max(ret, next);\n  }\n  return ret;\n}\n\ntemplate \u003ctypename T\u003e\nT tree_diameter(const Graph \u0026G) {\n  auto p = dfs(G, 0, -1);\n  auto q = dfs(G, p.second, -1);\n  return q.first;\n}\n```\n\n## 使用例\n\n\n","lastmodified":"2022-10-26T11:26:57.359934474Z","tags":null},"/heuristic/beam_search":{"title":"ビームサーチ","content":"\n## 説明\n\n幅優先探索の各階層においてスコアが高い順に $d$ 個のみを採用していく。$d$ をビーム幅と呼ぶ。\n\n## 実装\n\n\n## 参考\n\n- [chokudaiサーチ](https://www.slideshare.net/chokudai/chokudai-search-23234124)","lastmodified":"2022-10-26T11:26:57.359934474Z","tags":null},"/heuristic/chokudai_search":{"title":"chokudai サーチ","content":"\n## 説明\n\nビームサーチにおいてビーム幅を1から順に増やしていく手法。実行時間が決まっているときやあるスコア基準を満たしたいときに管理しやすい。\n\n## 実装\n\n\n## 参考\n\n- [chokudaiサーチ](https://www.slideshare.net/chokudai/chokudai-search-23234124)\n- [chokudaiサーチ(ビームサーチ亜種)の利点の話](https://chokudai.hatenablog.com/entry/2017/04/12/055515)","lastmodified":"2022-10-26T11:26:57.359934474Z","tags":null},"/heuristic/hill_climbing":{"title":"山登り法","content":"\n## 説明\n\n初めに初期状態を設定し、近傍へ状態遷移したとき最も成績の良い解を新しい状態とし、これを繰り返すことで極値が見つかる。\n\n## 実装\n\n```cpp\n#include \u003csys/time.h\u003e\n\n#include \u003cbits/stdc++.h\u003e\n// #include \u003catcoder/all\u003e\nusing namespace std;\n// using namespace atcoder;\nusing ll = long long;\nusing ld = long double;\nusing uint = unsigned;\nusing ull = unsigned long long;\nusing u64 = uint_fast64_t;\nusing pll = pair\u003cll, ll\u003e;\nusing pdd = pair\u003cld, ld\u003e;\nusing C = complex\u003cld\u003e;\ntemplate \u003cclass T\u003e using pq = priority_queue\u003cT, vector\u003cT\u003e, greater\u003cT\u003e\u003e;\n\nconst int IINF = 0x1fffffff;\nconst ll LINF = 0x1fffffffffffffff;\nconst ll INF = 0x1fffffffffffffff;\nconst ll MINF = 0x7fffffffffff;\nconst ll MOD = 1000000007;\nconst ll MODD = 998244353;\nconst ld DINF = numeric_limits\u003cld\u003e::infinity();\nconst ld EPS = 1e-9;\nconst ld PI = 3.1415926535897932;\nconst ll dx[] = {0, 1, 0, -1, 1, -1, 1, -1};\nconst ll dy[] = {1, 0, -1, 0, 1, 1, -1, -1};\n\n#define overload4(_1, _2, _3, _4, name, ...) name\n#define overload3(_1, _2, _3, name, ...) name\n#define rep1(n) for (ll i = 0; i \u003c n; ++i)\n#define rep2(i, n) for (ll i = 0; i \u003c n; ++i)\n#define rep3(i, a, b) for (ll i = a; i \u003c b; ++i)\n#define rep4(i, a, b, c) for (ll i = a; i \u003c b; i += c)\n#define rep(...) overload4(__VA_ARGS__, rep4, rep3, rep2, rep1)(__VA_ARGS__)\n#define rrep1(n) for (ll i = n; i--;)\n#define rrep2(i, n) for (ll i = n; i--;)\n#define rrep3(i, a, b) for (ll i = b; i-- \u003e (a);)\n#define rrep4(i, a, b, c)                                                      \\\n  for (ll i = (a) + ((b) - (a)-1) / (c) * (c); i \u003e= (a); i -= c)\n#define rrep(...)                                                              \\\n  overload4(__VA_ARGS__, rrep4, rrep3, rrep2, rrep1)(__VA_ARGS__)\n#define each1(i, a) for (auto \u0026\u0026i : a)\n#define each2(x, y, a) for (auto \u0026\u0026[x, y] : a)\n#define each3(x, y, z, a) for (auto \u0026\u0026[x, y, z] : a)\n#define each(...) overload4(__VA_ARGS__, each3, each2, each1)(__VA_ARGS__)\n#define all1(i) begin(i), end(i)\n#define all2(i, a) begin(i), begin(i) + a\n#define all3(i, a, b) begin(i) + a, begin(i) + b\n#define all(...) overload3(__VA_ARGS__, all3, all2, all1)(__VA_ARGS__)\n#define rall1(i) (i).rbegin(), (i).rend()\n#define rall2(i, k) (i).rbegin(), (i).rbegin() + k\n#define rall3(i, a, b) (i).rbegin() + a, (i).rbegin() + b\n#define rall(...) overload3(__VA_ARGS__, rall3, rall2, rall1)(__VA_ARGS__)\n// g++ -DDBUG -I . ...\n#ifdef DEBUG\ninline ll __lg(ull x) { return 63 - __builtin_clzll(x); }\n#define debug(...)                                                             \\\n  {                                                                            \\\n    print(#__VA_ARGS__);                                                       \\\n    print(\":\");                                                                \\\n    out(__VA_ARGS__);                                                          \\\n  }\n#else\n#define debug(...) void(0)\n#endif\n\n#define vec vector\n#define fi first\n#define se second\n#define MM \u003c\u003c \" \" \u003c\u003c\n#define chmax(x, y) (x = max(x, y))\n#define chmin(x, y) (x = min(x, y))\nvoid debug_out() { std::cerr \u003c\u003c std::endl; }\ntemplate \u003ctypename Head, typename... Tail\u003e void debug_out(Head h, Tail... t) {\n  std::cerr \u003c\u003c \" \" \u003c\u003c h;\n  if (sizeof...(t) \u003e 0)\n    std::cout \u003c\u003c \" :\";\n  debug_out(t...);\n}\nconst double TL = 1.95;\n\ndouble start_time_ = -1;\nbool first_time = true;\n\ndouble get_time() {\n  timeval tv;\n  gettimeofday(\u0026tv, 0);\n  auto ret = tv.tv_sec + tv.tv_usec * 1e-6;\n  if (first_time) {\n    start_time_ = ret;\n    first_time = false;\n  }\n  return ret - start_time_;\n}\n\nstruct rand_gen {\n  static const int MAX = 2147483647;\n  static constexpr double Q_MAX = 1.0 / MAX;\n\n  int x = 8753, y = 239017, z = 1000000123;\n\n  inline int next_int() {\n    int t = x ^ (x \u003c\u003c 11);\n    x = y;\n    y = z;\n    z ^= (z \u003e\u003e 19) ^ t ^ (t \u003e\u003e 8);\n    return z;\n  }\n\n  double next_double() { return next_int() * Q_MAX; }\n} rng;\n\n// function\u003cvoid(int, int)\u003e Dfs = [\u0026](int v, int depth) {}\n\nll calculate_score() {\n  ll last[26] = {};\n  ll score = 0;\n  ll sumc = 0;\n  rep(i, 0, 26) sumc += c[i];\n  ll mem_diff = 0;\n  rep(d, 0, D) {\n    score += s[d][t[d] - 1];\n    mem_diff += -sumc + c[t[d] - 1] * (d + 1 - last[t[d] - 1]);\n    score += mem_diff;\n    last[t[d] - 1] = d + 1;\n  }\n  return score;\n}\n\ndouble T0 = 1735, T1 = 10;\n\nint main() {\n  cin \u003e\u003e D;\n  rep(i, 0, 26) cin \u003e\u003e c[i];\n  rep(i, 0, D) rep(j, 0, 26) cin \u003e\u003e s[i][j];\n\n  // 初期解\n  rep(i, 0, D) t[i] = i % 26 + 1;\n\n  // 焼きなまし法\n  ll score = calculate_score(), old_score = -LINF;\n  while (get_time() \u003c TL) {\n    // 更新\n    ll r1 = rng.next_int() % D, r2 = rng.next_int() % D;\n    ll oldt[2] = {t[r1], t[r2]};\n    ll newt[2] = {t[r2], t[r2]};\n    if (rng.next_int() % 2 == 0) {\n      t[r1] = rng.next_int() % 26 + 1;\n      newt[1] = t[r1];\n    } else {\n      t[r1] = t[r2];\n      t[r2] = oldt[0];\n      newt[1] = oldt[0];\n    }\n\n    // スコアに応じた処理\n    ll k = score;\n    score = calculate_score();\n    ll r;\n    rep(m, 0, 2) {\n      if (m == 0)\n        r = r1;\n      else\n        r = r2;\n      ll back[2] = {0, 0}, forward[2] = {365, 365};\n      rep(i, 0, r) if (t[i] == oldt[m]) back[0] = i;\n      rep(i, r + 1, 365) if (t[i] == oldt[m]) {\n        forward[0] = i;\n        break;\n      }\n      rep(i, 0, r) if (t[i] == newt[m]) back[1] = i;\n      rep(i, r + 1, 365) if (t[i] == newt[m]) {\n        forward[1] = i;\n        break;\n      }\n      k += (r - back[0]) * (forward[0] - r);\n      k -= (r - back[1]) * (forward[1] - r);\n    }\n    cout \u003c\u003c k - old_score \u003c\u003c \" \" \u003c\u003c score - old_score \u003c\u003c endl;\n\n    if (score \u003e= old_score) {\n      old_score = score;\n    } else {\n      double per = get_time() / TL;\n      double T = pow(T0, 1 - per) * pow(T1, per);\n      T = exp((double)(score - old_score) / T);\n\n      if (rng.next_double() \u003c T) {\n        old_score = score;\n      } else {\n        t[r1] = oldt[0];\n        t[r2] = oldt[1];\n      }\n    }\n  }\n\n  // 出力\n  rep(i, 0, D) cout \u003c\u003c t[i] \u003c\u003c endl;\n  return 0;\n}\n```\n\n## 使用例\n\n\n## 参考\n\n","lastmodified":"2022-10-26T11:26:57.359934474Z","tags":null},"/heuristic/simulated_annealing":{"title":"焼きなまし法","content":"\n## 説明\n\n[山登り法](../snippets/hill-climbing)は常にスコアが最大のものを採用するが、焼きなまし法では遷移確率関数を用いてスコアに応じて確率的に遷移させるようにする。\n\n温度関数は最初は大きく、時間が経つにつれて小さくなるような関数で、温度が高いほど発散し、低いほど収束するように遷移確率関数を調整する。\n\n## 実装\n\n```cpp\n#include \u003csys/time.h\u003e\n\n#include \u003cbits/stdc++.h\u003e\n// #include \u003catcoder/all\u003e\nusing namespace std;\n// using namespace atcoder;\nusing ll = long long;\nusing ld = long double;\nusing uint = unsigned;\nusing ull = unsigned long long;\nusing u64 = uint_fast64_t;\nusing pll = pair\u003cll, ll\u003e;\nusing pdd = pair\u003cld, ld\u003e;\nusing C = complex\u003cld\u003e;\ntemplate \u003cclass T\u003e using pq = priority_queue\u003cT, vector\u003cT\u003e, greater\u003cT\u003e\u003e;\n\nconst int IINF = 0x1fffffff;\nconst ll LINF = 0x1fffffffffffffff;\nconst ll INF = 0x1fffffffffffffff;\nconst ll MINF = 0x7fffffffffff;\nconst ll MOD = 1000000007;\nconst ll MODD = 998244353;\nconst ld DINF = numeric_limits\u003cld\u003e::infinity();\nconst ld EPS = 1e-9;\nconst ld PI = 3.1415926535897932;\nconst ll dx[] = {0, 1, 0, -1, 1, -1, 1, -1};\nconst ll dy[] = {1, 0, -1, 0, 1, 1, -1, -1};\n\n#define overload4(_1, _2, _3, _4, name, ...) name\n#define overload3(_1, _2, _3, name, ...) name\n#define rep1(n) for (ll i = 0; i \u003c n; ++i)\n#define rep2(i, n) for (ll i = 0; i \u003c n; ++i)\n#define rep3(i, a, b) for (ll i = a; i \u003c b; ++i)\n#define rep4(i, a, b, c) for (ll i = a; i \u003c b; i += c)\n#define rep(...) overload4(__VA_ARGS__, rep4, rep3, rep2, rep1)(__VA_ARGS__)\n#define rrep1(n) for (ll i = n; i--;)\n#define rrep2(i, n) for (ll i = n; i--;)\n#define rrep3(i, a, b) for (ll i = b; i-- \u003e (a);)\n#define rrep4(i, a, b, c)                                                      \\\n  for (ll i = (a) + ((b) - (a)-1) / (c) * (c); i \u003e= (a); i -= c)\n#define rrep(...)                                                              \\\n  overload4(__VA_ARGS__, rrep4, rrep3, rrep2, rrep1)(__VA_ARGS__)\n#define each1(i, a) for (auto \u0026\u0026i : a)\n#define each2(x, y, a) for (auto \u0026\u0026[x, y] : a)\n#define each3(x, y, z, a) for (auto \u0026\u0026[x, y, z] : a)\n#define each(...) overload4(__VA_ARGS__, each3, each2, each1)(__VA_ARGS__)\n#define all1(i) begin(i), end(i)\n#define all2(i, a) begin(i), begin(i) + a\n#define all3(i, a, b) begin(i) + a, begin(i) + b\n#define all(...) overload3(__VA_ARGS__, all3, all2, all1)(__VA_ARGS__)\n#define rall1(i) (i).rbegin(), (i).rend()\n#define rall2(i, k) (i).rbegin(), (i).rbegin() + k\n#define rall3(i, a, b) (i).rbegin() + a, (i).rbegin() + b\n#define rall(...) overload3(__VA_ARGS__, rall3, rall2, rall1)(__VA_ARGS__)\n// g++ -DDBUG -I . ...\n#ifdef DEBUG\ninline ll __lg(ull x) { return 63 - __builtin_clzll(x); }\n#define debug(...)                                                             \\\n  {                                                                            \\\n    print(#__VA_ARGS__);                                                       \\\n    print(\":\");                                                                \\\n    out(__VA_ARGS__);                                                          \\\n  }\n#else\n#define debug(...) void(0)\n#endif\n\n#define vec vector\n#define fi first\n#define se second\n#define MM \u003c\u003c \" \" \u003c\u003c\n#define chmax(x, y) (x = max(x, y))\n#define chmin(x, y) (x = min(x, y))\nvoid debug_out() { std::cerr \u003c\u003c std::endl; }\ntemplate \u003ctypename Head, typename... Tail\u003e void debug_out(Head h, Tail... t) {\n  std::cerr \u003c\u003c \" \" \u003c\u003c h;\n  if (sizeof...(t) \u003e 0)\n    std::cout \u003c\u003c \" :\";\n  debug_out(t...);\n}\nconst double TL = 1.95;\n\ndouble start_time_ = -1;\nbool first_time = true;\n\ndouble get_time() {\n  timeval tv;\n  gettimeofday(\u0026tv, 0);\n  auto ret = tv.tv_sec + tv.tv_usec * 1e-6;\n  if (first_time) {\n    start_time_ = ret;\n    first_time = false;\n  }\n  return ret - start_time_;\n}\n\nstruct rand_gen {\n  static const int MAX = 2147483647;\n  static constexpr double Q_MAX = 1.0 / MAX;\n\n  int x = 8753, y = 239017, z = 1000000123;\n\n  inline int next_int() {\n    int t = x ^ (x \u003c\u003c 11);\n    x = y;\n    y = z;\n    z ^= (z \u003e\u003e 19) ^ t ^ (t \u003e\u003e 8);\n    return z;\n  }\n\n  double next_double() { return next_int() * Q_MAX; }\n} rng;\n\n// function\u003cvoid(int, int)\u003e Dfs = [\u0026](int v, int depth) {}\n\nll calculate_score() {\n  ll last[26] = {};\n  ll score = 0;\n  ll sumc = 0;\n  rep(i, 0, 26) sumc += c[i];\n  ll mem_diff = 0;\n  rep(d, 0, D) {\n    score += s[d][t[d] - 1];\n    mem_diff += -sumc + c[t[d] - 1] * (d + 1 - last[t[d] - 1]);\n    score += mem_diff;\n    last[t[d] - 1] = d + 1;\n  }\n  return score;\n}\n\ndouble T0 = 1735, T1 = 10;\n\nint main() {\n  cin \u003e\u003e D;\n  rep(i, 0, 26) cin \u003e\u003e c[i];\n  rep(i, 0, D) rep(j, 0, 26) cin \u003e\u003e s[i][j];\n\n  // 初期解\n  rep(i, 0, D) t[i] = i % 26 + 1;\n\n  // 焼きなまし法\n  ll score = calculate_score(), old_score = -LINF;\n  while (get_time() \u003c TL) {\n    // 更新\n    ll r1 = rng.next_int() % D, r2 = rng.next_int() % D;\n    ll oldt[2] = {t[r1], t[r2]};\n    ll newt[2] = {t[r2], t[r2]};\n    if (rng.next_int() % 2 == 0) {\n      t[r1] = rng.next_int() % 26 + 1;\n      newt[1] = t[r1];\n    } else {\n      t[r1] = t[r2];\n      t[r2] = oldt[0];\n      newt[1] = oldt[0];\n    }\n\n    // スコアに応じた処理\n    ll k = score;\n    score = calculate_score();\n    ll r;\n    rep(m, 0, 2) {\n      if (m == 0)\n        r = r1;\n      else\n        r = r2;\n      ll back[2] = {0, 0}, forward[2] = {365, 365};\n      rep(i, 0, r) if (t[i] == oldt[m]) back[0] = i;\n      rep(i, r + 1, 365) if (t[i] == oldt[m]) {\n        forward[0] = i;\n        break;\n      }\n      rep(i, 0, r) if (t[i] == newt[m]) back[1] = i;\n      rep(i, r + 1, 365) if (t[i] == newt[m]) {\n        forward[1] = i;\n        break;\n      }\n      k += (r - back[0]) * (forward[0] - r);\n      k -= (r - back[1]) * (forward[1] - r);\n    }\n    cout \u003c\u003c k - old_score \u003c\u003c \" \" \u003c\u003c score - old_score \u003c\u003c endl;\n\n    if (score \u003e= old_score) {\n      old_score = score;\n    } else {\n      double per = get_time() / TL;\n      double T = pow(T0, 1 - per) * pow(T1, per);\n      T = exp((double)(score - old_score) / T);\n\n      if (rng.next_double() \u003c T) {\n        old_score = score;\n      } else {\n        t[r1] = oldt[0];\n        t[r2] = oldt[1];\n      }\n    }\n  }\n\n  // 出力\n  rep(i, 0, D) cout \u003c\u003c t[i] \u003c\u003c endl;\n  return 0;\n}\n```\n\n## 使用例\n\n\n## 参考\n\n\n","lastmodified":"2022-10-26T11:26:57.359934474Z","tags":null},"/memo":{"title":"","content":"仮想デスクトップについて開ける分野のサイトを制限する\n\nOWON SPE6103\n\n[面白さ＝文脈変化×納得感 - CGMプランナーの思考 (hatenablog.com)](https://web-ken.hatenablog.com/entry/2017/10/23/172021)\n\nJoel on Software\n[プログラマのためのユーザインタフェースデザイン 第1章: 環境をコントロールできれば楽しく感じるもの - The Joel on Software Translation Project (archive.org)](https://web.archive.org/web/20190521175932/http://local.joelonsoftware.com/wiki/%E3%83%97%E3%83%AD%E3%82%B0%E3%83%A9%E3%83%9E%E3%81%AE%E3%81%9F%E3%82%81%E3%81%AE%E3%83%A6%E3%83%BC%E3%82%B6%E3%82%A4%E3%83%B3%E3%82%BF%E3%83%95%E3%82%A7%E3%83%BC%E3%82%B9%E3%83%87%E3%82%B6%E3%82%A4%E3%83%B3_%E7%AC%AC1%E7%AB%A0:_%E7%92%B0%E5%A2%83%E3%82%92%E3%82%B3%E3%83%B3%E3%83%88%E3%83%AD%E3%83%BC%E3%83%AB%E3%81%A7%E3%81%8D%E3%82%8C%E3%81%B0%E6%A5%BD%E3%81%97%E3%81%8F%E6%84%9F%E3%81%98%E3%82%8B%E3%82%82%E3%81%AE)\n\n技術的詳細を知りたくない人に対して途中を読まずに結論さえ読めばよいような書き方をする のとそのようにことわること.\nコードだけで十分な人にはコードのセクションを読めばよいような書き方をするのとそのようにことわること.","lastmodified":"2022-10-26T11:26:57.359934474Z","tags":null},"/misc/Pyjail":{"title":"Pyjail","content":"\nPythonはASCIIだけではなくUnicode全部使える\n合字を使うと文字数節約出来る\n[Pythonの識別子におけるUnicode正規化(NFKC)とpyjail - Satoooonの物置 (hatenablog.com)](https://satoooon1024.hatenablog.com/entry/2022/08/20/Python%E3%81%AE%E8%AD%98%E5%88%A5%E5%AD%90%E3%81%AB%E3%81%8A%E3%81%91%E3%82%8BUnicode%E6%AD%A3%E8%A6%8F%E5%8C%96%28NFKC%29%E3%81%A8pyjail)\n","lastmodified":"2022-10-26T11:26:57.359934474Z","tags":null},"/misc/forensics/forensics":{"title":"Forensics","content":"\nMITRE ATT\u0026CK\n\nAutoPsy\n\n[Detecting Linux Anti-Forensics: Timestomping (inversecos.com)](https://www.inversecos.com/2022/08/detecting-linux-anti-forensics.html)\nVirus Total\n","lastmodified":"2022-10-26T11:26:57.359934474Z","tags":null},"/misc/forensics/windows":{"title":"windows log","content":"\n実行されたPowershell スクリプトのログ\nEvent Viewer\nApplications and Services Logs \u003e Microsoft \u003e Windows \u003e PowerShell \u003e Operational\nPrefetchファイルを閲覧するにはWinPrefetchView\n\nPowerShell版Mimikatz などのPowerShellを用いたスクリプトはここに記録されている。\n\nLSASS (LSA Server Service)\n\nRemote Desktop Protocol のログ\nApplications and Services Logs \u003e Microsoft \u003e Windows \u003e TerminalServices-ClientActiveXCore \u003e Microsoft-Windows-TerminalServices-RDPClient/Operational\n\n[残された攻撃の痕跡を追え！　～Post-Exploitationで起きていること～ | インフォメーション・ディベロプメント (idnet.co.jp)](https://www.idnet.co.jp/column/page_186.html)","lastmodified":"2022-10-26T11:26:57.359934474Z","tags":null},"/misc/osint/tools":{"title":"OSINT","content":"\n\nOSINT (Open Source INTelligence)\n\n- 消された投稿を探す [https://archive.org/web/](https://archive.org/web/ \"https://archive.org/web/\")\ntwitter [https://twilog.org twilog]\n- Reverse Image Search\n\t- Google Lens\n\t- [Fake news debunker by InVID \u0026 WeVerify - Chrome ウェブストア (google.com)](https://chrome.google.com/webstore/detail/fake-news-debunker-by-inv/mhccpoafgdgbhnjfhkcmgknndkeenfhe?hl=ja\u0026gl=SG)\n- SNSユーザー名を探す: [https://instantusername.com/](https://instantusername.com/ \"https://instantusername.com/\")\n- ファイル・ドメインのレピュテーションチェック: [any.run](https://any.run/)\n\t- [VirusTotal](https://virustotal.com/)\n- Tor onionアドレス\n- [OSINT Framework](https://osintframework.com/)\n- [SunCalc - sun position, sunlight phases, sunrise, sunset, dusk and dawn times calculator](http://suncalc.net/#/51.508,-0.125,2/2022.08.08/17:00)j\n\n## OSINTをメインに活動している組織\n[bellingcat - the home of online investigations](https://www.bellingcat.com/)\nProject Owl\n\n## 参考文献\n[普段の調査で利用するOSINTまとめ](https://qiita.com/00001B1A/items/4d8ceb53993d3217307e)","lastmodified":"2022-10-26T11:26:57.359934474Z","tags":null},"/notes/CJK-+-Latex-Support-%E6%B5%8B%E8%AF%95":{"title":"CJK + Latex Support (测试)","content":"\n## Chinese, Japanese, Korean Support\n几乎在我们意识到之前，我们已经离开了地面。\n\n우리가 그것을 알기도 전에 우리는 땅을 떠났습니다.\n\n私たちがそれを知るほぼ前に、私たちは地面を離れていました。\n\n## Latex\n\nBlock math works with two dollar signs `$$...$$`\n\n$$f(x) = \\int_{-\\infty}^\\infty\n    f\\hat(\\xi),e^{2 \\pi i \\xi x}\n    \\,d\\xi$$\n\t\nInline math also works with single dollar signs `$...$`. For example, Euler's identity but inline: $e^{i\\pi} = 0$\n\nAligned equations work quite well:\n\n$$\n\\begin{aligned}\na \u0026= b + c \\\\ \u0026= e + f \\\\\n\\end{aligned}\n$$\n\nAnd matrices\n\n$$\n\\begin{bmatrix}\n1 \u0026 2 \u0026 3 \\\\\na \u0026 b \u0026 c\n\\end{bmatrix}\n$$\n\n## RTL\nMore information on configuring RTL languages like Arabic in the [config](notes/config.md) page.","lastmodified":"2022-10-26T11:26:57.359934474Z","tags":null},"/notes/callouts":{"title":"Callouts","content":"\n## Callout support\n\nQuartz supports the same Admonition-callout syntax as Obsidian.\n\nThis includes\n- 12 Distinct callout types (each with several aliases)\n- Collapsable callouts\n\nSee [documentation on supported types and syntax here](https://help.obsidian.md/How+to/Use+callouts#Types).\n\n## Showcase\n\n\u003e [!EXAMPLE] Examples\n\u003e\n\u003e Aliases: example\n\n\u003e [!note] Notes\n\u003e\n\u003e Aliases: note\n\n\u003e [!abstract] Summaries \n\u003e\n\u003e Aliases: abstract, summary, tldr\n\n\u003e [!info] Info \n\u003e\n\u003e Aliases: info, todo\n\n\u003e [!tip] Hint \n\u003e\n\u003e Aliases: tip, hint, important\n\n\u003e [!success] Success \n\u003e\n\u003e Aliases: success, check, done\n\n\u003e [!question] Question \n\u003e\n\u003e Aliases: question, help, faq\n\n\u003e [!warning] Warning \n\u003e\n\u003e Aliases: warning, caution, attention\n\n\u003e [!failure] Failure \n\u003e\n\u003e Aliases: failure, fail, missing\n\n\u003e [!danger] Error\n\u003e\n\u003e Aliases: danger, error\n\n\u003e [!bug] Bug\n\u003e\n\u003e Aliases: bug\n\n\u003e [!quote] Quote\n\u003e\n\u003e Aliases: quote, cite\n","lastmodified":"2022-10-26T11:26:57.359934474Z","tags":null},"/notes/config":{"title":"Configuration","content":"\n## Configuration\nQuartz is designed to be extremely configurable. You can find the bulk of the configuration scattered throughout the repository depending on how in-depth you'd like to get.\n\nThe majority of configuration can be found under `data/config.yaml`. An annotated example configuration is shown below.\n\n```yaml {title=\"data/config.yaml\"}\n# The name to display in the footer\nname: Jacky Zhao\n\n# whether to globally show the table of contents on each page\n# this can be turned off on a per-page basis by adding this to the\n# front-matter of that note\nenableToc: true\n\n# whether to by-default open or close the table of contents on each page\nopenToc: false\n\n# whether to display on-hover link preview cards\nenableLinkPreview: true\n\n# whether to render titles for code blocks\nenableCodeBlockTitle: true \n\n# whether to render copy buttons for code blocks\nenableCodeBlockCopy: true \n\n# whether to render callouts\nenableCallouts: true\n\n# whether to try to process Latex\nenableLatex: true\n\n# whether to enable single-page-app style rendering\n# this prevents flashes of unstyled content and improves\n# smoothness of Quartz. More info in issue #109 on GitHub\nenableSPA: true\n\n# whether to render a footer\nenableFooter: true\n\n# whether backlinks of pages should show the context in which\n# they were mentioned\nenableContextualBacklinks: true\n\n# whether to show a section of recent notes on the home page\nenableRecentNotes: false\n\n# whether to display an 'edit' button next to the last edited field\n# that links to github\nenableGitHubEdit: true\nGitHubLink: https://github.com/jackyzha0/quartz/tree/hugo/content\n\n# whether to use Operand to power semantic search\n# IMPORTANT: replace this API key with your own if you plan on using\n# Operand search!\nenableSemanticSearch: false\noperandApiKey: \"REPLACE-WITH-YOUR-OPERAND-API-KEY\"\n\n# page description used for SEO\ndescription:\n  Host your second brain and digital garden for free. Quartz features extremely fast full-text search,\n  Wikilink support, backlinks, local graph, tags, and link previews.\n\n# title of the home page (also for SEO)\npage_title:\n  \"🪴 Quartz 3.3\"\n\n# links to show in the footer\nlinks:\n  - link_name: Twitter\n    link: https://twitter.com/_jzhao\n  - link_name: Github\n    link: https://github.com/jackyzha0\n```\n\n### Code Block Titles\nTo add code block titles with Quartz:\n\n1. Ensure that code block titles are enabled in Quartz's configuration:\n\n    ```yaml {title=\"data/config.yaml\", linenos=false}\n    enableCodeBlockTitle: true\n    ```\n\n2. Add the `title` attribute to the desired [code block\n   fence](https://gohugo.io/content-management/syntax-highlighting/#highlighting-in-code-fences):\n\n      ```markdown {linenos=false}\n       ```yaml {title=\"data/config.yaml\"}\n       enableCodeBlockTitle: true  # example from step 1\n       ```\n      ```\n\n**Note** that if `{title=\u003cmy-title\u003e}` is included, and code block titles are not\nenabled, no errors will occur, and the title attribute will be ignored.\n\n### HTML Favicons\nIf you would like to customize the favicons of your Quartz-based website, you \ncan add them to the `data/config.yaml` file. The **default** without any set \n`favicon` key is:\n\n```html {title=\"layouts/partials/head.html\", linenostart=15}\n\u003clink rel=\"shortcut icon\" href=\"icon.png\" type=\"image/png\"\u003e\n```\n\nThe default can be overridden by defining a value to the `favicon` key in your \n`data/config.yaml` file. For example, here is a `List[Dictionary]` example format, which is\nequivalent to the default:\n\n```yaml {title=\"data/config.yaml\", linenos=false}\nfavicon:\n  - { rel: \"shortcut icon\", href: \"icon.png\", type: \"image/png\" }\n#  - { ... } # Repeat for each additional favicon you want to add\n```\n\nIn this format, the keys are identical to their HTML representations.\n\nIf you plan to add multiple favicons generated by a website (see list below), it\nmay be easier to define it as HTML. Here is an example which appends the \n**Apple touch icon** to Quartz's default favicon:\n\n```yaml {title=\"data/config.yaml\", linenos=false}\nfavicon: |\n  \u003clink rel=\"shortcut icon\" href=\"icon.png\" type=\"image/png\"\u003e\n  \u003clink rel=\"apple-touch-icon\" sizes=\"180x180\" href=\"/apple-touch-icon.png\"\u003e\n```\n\nThis second favicon will now be used as a web page icon when someone adds your \nwebpage to the home screen of their Apple device. If you are interested in more \ninformation about the current and past standards of favicons, you can read \n[this article](https://www.emergeinteractive.com/insights/detail/the-essentials-of-favicons/).\n\n**Note** that all generated favicon paths, defined by the `href` \nattribute, are relative to the `static/` directory.\n\n### Graph View\nTo customize the Interactive Graph view, you can poke around `data/graphConfig.yaml`.\n\n```yaml {title=\"data/graphConfig.yaml\"}\n# if true, a Global Graph will be shown on home page with full width, no backlink.\n# A different set of Local Graphs will be shown on sub pages.\n# if false, Local Graph will be default on every page as usual\nenableGlobalGraph: false\n\n### Local Graph ###\nlocalGraph:\n    # whether automatically generate a legend\n    enableLegend: false\n    \n    # whether to allow dragging nodes in the graph\n    enableDrag: true\n    \n    # whether to allow zooming and panning the graph\n    enableZoom: true\n    \n    # how many neighbours of the current node to show (-1 is all nodes)\n    depth: 1\n    \n    # initial zoom factor of the graph\n    scale: 1.2\n    \n    # how strongly nodes should repel each other\n    repelForce: 2\n\n    # how strongly should nodes be attracted to the center of gravity\n    centerForce: 1\n\n    # what the default link length should be\n    linkDistance: 1\n    \n    # how big the node labels should be\n    fontSize: 0.6\n    \n    # scale at which to start fading the labes on nodes\n    opacityScale: 3\n\n### Global Graph ###\nglobalGraph:\n\t# same settings as above\n\n### For all graphs ###\n# colour specific nodes path off of their path\npaths:\n  - /moc: \"#4388cc\"\n```\n\n\n## Styling\nWant to go even more in-depth? You can add custom CSS styling and change existing colours through editing `assets/styles/custom.scss`. If you'd like to target specific parts of the site, you can add ids and classes to the HTML partials in `/layouts/partials`. \n\n### Partials\nPartials are what dictate what gets rendered to the page. Want to change how pages are styled and structured? You can edit the appropriate layout in `/layouts`.\n\nFor example, the structure of the home page can be edited through `/layouts/index.html`. To customize the footer, you can edit `/layouts/partials/footer.html`\n\nMore info about partials on [Hugo's website.](https://gohugo.io/templates/partials/)\n\nStill having problems? Checkout our [FAQ and Troubleshooting guide](notes/troubleshooting.md).\n\n## Language Support\n[CJK + Latex Support (测试)](notes/CJK%20+%20Latex%20Support%20(测试).md) comes out of the box with Quartz.\n\nWant to support languages that read from right-to-left (like Arabic)? Hugo (and by proxy, Quartz) supports this natively.\n\nFollow the steps [Hugo provides here](https://gohugo.io/content-management/multilingual/#configure-languages) and modify your `config.toml`\n\nFor example:\n\n```toml\ndefaultContentLanguage = 'ar'\n[languages]\n  [languages.ar]\n    languagedirection = 'rtl'\n    title = 'مدونتي'\n    weight = 1\n```\n","lastmodified":"2022-10-26T11:26:57.359934474Z","tags":null},"/notes/custom-Domain":{"title":"Custom Domain","content":"\n### Registrar\nThis step is only applicable if you are using a **custom domain**! If you are using a `\u003cYOUR-USERNAME\u003e.github.io` domain, you can skip this step.\n\nFor this last bit to take effect, you also need to create a CNAME record with the DNS provider you register your domain with (i.e. NameCheap, Google Domains).\n\nGitHub has some [documentation on this](https://docs.github.com/en/pages/configuring-a-custom-domain-for-your-github-pages-site/managing-a-custom-domain-for-your-github-pages-site), but the tldr; is to\n\n1. Go to your forked repository (`github.com/\u003cYOUR-GITHUB-USERNAME\u003e/quartz`) settings page and go to the Pages tab. Under \"Custom domain\", type your custom domain, then click **Save**.\n2. Go to your DNS Provider and create a CNAME record that points from your domain to `\u003cYOUR-GITHUB-USERNAME.github.io.` (yes, with the trailing period).\n\n\t![Example Configuration for Quartz](/notes/images/google-domains.png)*Example Configuration for Quartz*\n3. Wait 30 minutes to an hour for the network changes to kick in.\n4. Done!","lastmodified":"2022-10-26T11:26:57.359934474Z","tags":null},"/notes/editing":{"title":"Editing Content in Quartz","content":"\n## Editing \nQuartz runs on top of [Hugo](https://gohugo.io/) so all notes are written in [Markdown](https://www.markdownguide.org/getting-started/).\n\n### Folder Structure\nHere's a rough overview of what's what.\n\n**All content in your garden can found in the `/content` folder.** To make edits, you can open any of the files and make changes directly and save it. You can organize content into any folder you'd like.\n\n**To edit the main home page, open `/content/_index.md`.**\n\nTo create a link between notes in your garden, just create a normal link using Markdown pointing to the document in question. Please note that **all links should be relative to the root `/content` path**. \n\n```markdown\nFor example, I want to link this current document to `notes/config.md`.\n[A link to the config page](notes/config.md)\n```\n\nSimilarly, you can put local images anywhere in the `/content` folder.\n\n```markdown\nExample image (source is in content/notes/images/example.png)\n![Example Image](/content/notes/images/example.png)\n```\n\nYou can also use wikilinks if that is what you are more comfortable with!\n\n### Front Matter\nHugo is picky when it comes to metadata for files. Make sure that your title is double-quoted and that you have a title defined at the top of your file like so. You can also add tags here as well.\n\n```yaml\n---\ntitle: \"Example Title\"\ntags:\n- example-tag\n---\n\nRest of your content here...\n```\n\n### Obsidian\nI recommend using [Obsidian](http://obsidian.md/) as a way to edit and grow your digital garden. It comes with a really nice editor and graphical interface to preview all of your local files.\n\nThis step is **highly recommended**.\n\n\u003e 🔗 Step 3: [How to setup your Obsidian Vault to work with Quartz](notes/obsidian.md)\n\n## Previewing Changes\nThis step is purely optional and mostly for those who want to see the published version of their digital garden locally before opening it up to the internet. This is *highly recommended* but not required.\n\n\u003e 👀 Step 4: [Preview Quartz Changes](notes/preview%20changes.md)\n\nFor those who like to live life more on the edge, viewing the garden through Obsidian gets you pretty close to the real thing.\n\n## Publishing Changes\nNow that you know the basics of managing your digital garden using Quartz, you can publish it to the internet!\n\n\u003e 🌍 Step 5: [Hosting Quartz online!](notes/hosting.md)\n\nHaving problems? Checkout our [FAQ and Troubleshooting guide](notes/troubleshooting.md).\n","lastmodified":"2022-10-26T11:26:57.359934474Z","tags":null},"/notes/hosting":{"title":"Deploying Quartz to the Web","content":"\n## Hosting on GitHub Pages\nQuartz is designed to be effortless to deploy. If you forked and cloned Quartz directly from the repository, everything should already be good to go! Follow the steps below.\n\n### Enable GitHub Actions\nBy default, GitHub disables workflows from running automatically on Forked Repostories. Head to the 'Actions' tab of your forked repository and Enable Workflows to setup deploying your Quartz site!\n\n![Enable GitHub Actions](notes/images/github-actions.png)*Enable GitHub Actions*\n\n### Enable GitHub Pages\n\nHead to the 'Settings' tab of your forked repository and go to the 'Pages' tab.\n\n1. (IMPORTANT) Set the source to deploy from `master` (and not `hugo`) using `/ (root)`\n2. Set a custom domain here if you have one!\n\n![Enable GitHub Pages](/notes/images/github-pages.png)*Enable GitHub Pages*\n\n### Pushing Changes\nTo see your changes on the internet, we need to push it them to GitHub. Quartz is a `git` repository so updating it is the same workflow as you would follow as if it were just a regular software project.\n\n```shell\n# Navigate to Quartz folder\ncd \u003cpath-to-quartz\u003e\n\n# Commit all changes\ngit add .\ngit commit -m \"message describing changes\"\n\n# Push to GitHub to update site\ngit push origin hugo\n```\n\nNote: we specifically push to the `hugo` branch here. Our GitHub action automatically runs everytime a push to is detected to that branch and then updates the `master` branch for redeployment.\n\n### Setting up the Site\nNow let's get this site up and running. Never hosted a site before? No problem. Have a fancy custom domain you already own or want to subdomain your Quartz? That's easy too.\n\nHere, we take advantage of GitHub's free page hosting to deploy our site. Change `baseURL` in `/config.toml`. \n\nMake sure that your `baseURL` has a trailing `/`!\n\n[Reference `config.toml` here](https://github.com/jackyzha0/quartz/blob/hugo/config.toml)\n\n```toml\nbaseURL = \"https://\u003cYOUR-DOMAIN\u003e/\"\n```\n\nIf you are using this under a subdomain (e.g. `\u003cYOUR-GITHUB-USERNAME\u003e.github.io/quartz`), include the trailing `/`. **You need to do this especially if you are using GitHub!**\n\n```toml\nbaseURL = \"https://\u003cYOUR-GITHUB-USERNAME\u003e.github.io/quartz/\"\n```\n\nChange `cname` in `/.github/workflows/deploy.yaml`. Again, if you don't have a custom domain to use, you can use `\u003cYOUR-USERNAME\u003e.github.io`.\n\nPlease note that the `cname` field should *not* have any path `e.g. end with /quartz` or have a trailing `/`.\n\n[Reference `deploy.yaml` here](https://github.com/jackyzha0/quartz/blob/hugo/.github/workflows/deploy.yaml)\n\n```yaml {title=\".github/workflows/deploy.yaml\"}\n- name: Deploy  \n  uses: peaceiris/actions-gh-pages@v3  \n  with:  \n\tgithub_token: ${{ secrets.GITHUB_TOKEN }} # this can stay as is, GitHub fills this in for us!\n\tpublish_dir: ./public  \n\tpublish_branch: master\n\tcname: \u003cYOUR-DOMAIN\u003e\n```\n\nHave a custom domain? [Learn how to set it up with Quartz ](notes/custom%20Domain.md).\n\n### Ignoring Files\nOnly want to publish a subset of all of your notes? Don't worry, Quartz makes this a simple two-step process.\n\n❌ [Excluding pages from being published](notes/ignore%20notes.md)\n\n---\n\nNow that your Quartz is live, let's figure out how to make Quartz really *yours*!\n\n\u003e Step 6: 🎨 [Customizing Quartz](notes/config.md)\n\nHaving problems? Checkout our [FAQ and Troubleshooting guide](notes/troubleshooting.md).\n","lastmodified":"2022-10-26T11:26:57.359934474Z","tags":null},"/notes/ignore-notes":{"title":"Ignoring Notes","content":"\n### Quartz Ignore\nEdit `ignoreFiles` in `config.toml` to include paths you'd like to exclude from being rendered.\n\n```toml\n...\nignoreFiles = [  \n    \"/content/templates/*\",  \n    \"/content/private/*\", \n    \"\u003cyour path here\u003e\"\n]\n```\n\n`ignoreFiles` supports the use of Regular Expressions (RegEx) so you can ignore patterns as well (e.g. ignoring all `.png`s by doing `\\\\.png$`).\nTo ignore a specific file, you can also add the tag `draft: true` to the frontmatter of a note.\n\n```markdown\n---\ntitle: Some Private Note\ndraft: true\n---\n...\n```\n\nMore details in [Hugo's documentation](https://gohugo.io/getting-started/configuration/#ignore-content-and-data-files-when-rendering).\n\n### Global Ignore\nHowever, just adding to the `ignoreFiles` will only prevent the page from being access through Quartz. If you want to prevent the file from being pushed to GitHub (for example if you have a public repository), you need to also add the path to the `.gitignore` file at the root of the repository.","lastmodified":"2022-10-26T11:26:57.359934474Z","tags":null},"/notes/obsidian":{"title":"Obsidian Vault Integration","content":"\n## Setup\nObsidian is the preferred way to use Quartz. You can either create a new Obsidian Vault or link one that your already have.\n\n### New Vault\nIf you don't have an existing Vault, [download Obsidian](https://obsidian.md/) and create a new Vault in the `/content` folder that you created and cloned during the [setup](notes/setup.md) step.\n\n### Linking an existing Vault\nThe easiest way to use an existing Vault is to copy all of your files (directory and hierarchies intact) into the `/content` folder.\n\n## Settings\nGreat, now that you have your Obsidian linked to your Quartz, let's fix some settings so that they play well.\n\n1. Under Options \u003e Files and Links, set the New link format to always use Absolute Path in Vault.\n2. Go to Settings \u003e Files \u0026 Links \u003e Turn \"on\" automatically update internal links.\n\n![Obsidian Settings](/notes/images/obsidian-settings.png)*Obsidian Settings*\n\n## Templates\nInserting front matter everytime you want to create a new Note gets annoying really quickly. Luckily, Obsidian supports templates which makes inserting new content really easily.\n\n**If you decide to overwrite the `/content` folder completely, don't remove the `/content/templates` folder!**\n\nHead over to Options \u003e Core Plugins and enable the Templates plugin. Then go to Options \u003e Hotkeys and set a hotkey for 'Insert Template' (I recommend `[cmd]+T`). That way, when you create a new note, you can just press the hotkey for a new template and be ready to go!\n\n\u003e 👀 Step 4: [Preview Quartz Changes](notes/preview%20changes.md)","lastmodified":"2022-10-26T11:26:57.363934457Z","tags":null},"/notes/philosophy":{"title":"Quartz Philosophy","content":"\n\u003e “[One] who works with the door open gets all kinds of interruptions, but [they] also occasionally gets clues as to what the world is and what might be important.” — Richard Hamming\n\n## Why Quartz?\nHosting a public digital garden isn't easy. There are an overwhelming number of tutorials, resources, and guides for tools like [Notion](https://www.notion.so/), [Roam](https://roamresearch.com/), and [Obsidian](https://obsidian.md/), yet none of them have super easy to use *free* tools to publish that garden to the world.\n\nI've personally found that\n1. It's nice to access notes from anywhere\n2. Having a public digital garden invites open conversations\n3. It makes keeping personal notes and knowledge *playful and fun*\n\nI was really inspired by [Bianca](https://garden.bianca.digital/) and [Joel](https://joelhooks.com/digital-garden)'s digital gardens and wanted to try making my own.\n\n**The goal of Quartz is to make hosting your own public digital garden free and simple.** You don't even need your own website. Quartz does all of that for you and gives your own little corner of the internet.\n","lastmodified":"2022-10-26T11:26:57.363934457Z","tags":null},"/notes/preview-changes":{"title":"Preview Changes","content":"\nIf you'd like to preview what your Quartz site looks like before deploying it to the internet, here's exactly how to do that!\n\nNote that both of these steps need to be completed.\n\n## Install `hugo-obsidian`\nThis step will generate the list of backlinks for Hugo to parse. Ensure you have [Go](https://golang.org/doc/install) (\u003e= 1.16) installed.\n\n```bash\n# Install and link `hugo-obsidian` locally\ngo install github.com/jackyzha0/hugo-obsidian@latest\n```\n\nIf you are running into an error saying that `command not found: hugo-obsidian`, make sure you set your `GOPATH` correctly! This will allow your terminal to correctly recognize hugo-obsidian as an executable.\n\nAfterwards, start the Hugo server as shown above and your local backlinks and interactive graph should be populated!\n\n##  Installing Hugo\nHugo is the static site generator that powers Quartz. [Install Hugo with \"extended\" Sass/SCSS version](https://gohugo.io/getting-started/installing/) first. Then,\n\n```bash\n# Navigate to your local Quartz folder\ncd \u003clocation-of-your-local-quartz\u003e\n\n# Start local server\nmake serve\n\n# View your site in a browser at http://localhost:1313/\n```\n\n\u003e 🌍 Step 5: [Hosting Quartz online!](notes/hosting.md)","lastmodified":"2022-10-26T11:26:57.363934457Z","tags":null},"/notes/search":{"title":"Search","content":"\nQuartz supports two modes of searching through content.\n\n## Full-text\nFull-text search is the default in Quartz. It produces results that *exactly* match the search query. This is easier to setup but usually produces lower quality matches.\n\n```yaml {title=\"data/config.yaml\"}\n# the default option\nenableSemanticSearch: false\n```\n\n## Natural Language\nNatural language search is powered by [Operand](https://operand.ai/). It understands language like a person does and finds results that best match user intent. In this sense, it is closer to how Google Search works.\n\nNatural language search tends to produce higher quality results than full-text search.\n\nHere's how to set it up.\n\n1. Create an Operand Account on [their website](https://operand.ai/).\n2. Go to Dashboard \u003e Settings \u003e Integrations.\n3. Follow the steps to setup the GitHub integration. Operand needs access to GitHub in order to index your digital garden properly!\n4. Head over to Dashboard \u003e Objects and press `(Cmd + K)` to open the omnibar and select 'Create Collection'.\n\t1. Set the 'Collection Label' to something that will help you remember it.\n\t2. You can leave the 'Parent Collection' field empty.\n5. Click into your newly made Collection.\n\t1. Press the 'share' button that looks like three dots connected by lines.\n\t2. Set the 'Interface Type' to `object-search` and click 'Create'.\n\t3. This will bring you to a new page with a search bar. Ignore this for now.\n6. Go back to Dashboard \u003e Settings \u003e API Keys and find your Quartz-specific Operand API key under 'Other keys'.\n\t1. Copy the key (which looks something like `0e733a7f-9b9c-48c6-9691-b54fa1c8b910`).\n\t2. Open `data/config.yaml`. Set `enableSemanticSearch` to `true` and `operandApiKey` to your copied key.\n\n```yaml {title=\"data/config.yaml\"}\n# the default option\nenableSemanticSearch: true\noperandApiKey: \"0e733a7f-9b9c-48c6-9691-b54fa1c8b910\"\n```\n7. Make a commit and push your changes to GitHub. See the [[notes/hosting|hosting]] page if you haven't done this already.\n\t1. This step is *required* for Operand to be able to properly index your content. \n\t2. Head over to Dashboard \u003e Objects and select the collection that you made earlier\n8. Press `(Cmd + K)` to open the omnibar again and select 'Create GitHub Repo'\n\t1. Set the 'Repository Label' to `Quartz`\n\t2. Set the 'Repository Owner' to your GitHub username\n\t3. Set the 'Repository Ref' to `master`\n\t4. Set the 'Repository Name' to the name of your repository (usually just `quartz` if you forked the repository without changing the name)\n\t5. Leave 'Root Path' and 'Root URL' empty\n9. Wait for your repository to index and enjoy natural language search in Quartz! Operand refreshes the index every 2h so all you need to do is just push to GitHub to update the contents in the search.","lastmodified":"2022-10-26T11:26:57.363934457Z","tags":null},"/notes/setup":{"title":"Setup","content":"\n## Making your own Quartz\nSetting up Quartz requires a basic understanding of `git`. If you are unfamiliar, [this resource](https://resources.nwplus.io/2-beginner/how-to-git-github.html) is a great place to start!\n\n### Forking\n\u003e A fork is a copy of a repository. Forking a repository allows you to freely experiment with changes without affecting the original project.\n\nNavigate to the GitHub repository for the Quartz project:\n\n📁 [Quartz Repository](https://github.com/jackyzha0/quartz)\n\nThen, Fork the repository into your own GitHub account. If you don't have an account, you can make on for free [here](https://github.com/join). More details about forking a repo can be found on [GitHub's documentation](https://docs.github.com/en/get-started/quickstart/fork-a-repo).\n\n### Cloning\nAfter you've made a fork of the repository, you need to download the files locally onto your machine. Ensure you have `git`, then type the following command replacing `YOUR-USERNAME` with your GitHub username.\n\n```shell\ngit clone https://github.com/YOUR-USERNAME/quartz\n```\n\n## Editing\nGreat! Now you have everything you need to start editing and growing your digital garden. If you're ready to start writing content already, check out the recommended flow for editing notes in Quartz.\n\n\u003e ✏️ Step 2: [Editing Notes in Quartz](notes/editing.md)\n\nHaving problems? Checkout our [FAQ and Troubleshooting guide](notes/troubleshooting.md).\n","lastmodified":"2022-10-26T11:26:57.363934457Z","tags":null},"/notes/showcase":{"title":"Showcase","content":"\nWant to see what Quartz can do? Here are some cool community gardens :)\n\n- [Quartz Documentation (this site!)](https://quartz.jzhao.xyz/)\n- [Jacky Zhao's Garden](https://jzhao.xyz/)\n- [Scaling Synthesis - A hypertext research notebook](https://scalingsynthesis.com/)\n- [AWAGMI Intern Notes](https://notes.awagmi.xyz/)\n- [Shihyu's PKM](https://shihyuho.github.io/pkm/)\n- [Chloe's Garden](https://garden.chloeabrasada.online/)\n- [SlRvb's Site](https://slrvb.github.io/Site/)\n- [Course notes for Information Technology Advanced Theory](https://a2itnotes.github.io/quartz/)\n- [Brandon Boswell's Garden](https://brandonkboswell.com)\n- [Siyang's Courtyard](https://siyangsun.github.io/courtyard/)\n- [Data Dictionary 🧠](https://glossary.airbyte.com/)\n- [sspaeti.com's Second Brain](https://brain.sspaeti.com/)\n- [oldwinterの数字花园](https://garden.oldwinter.top/)\n- [SethMB Work](https://sethmb.xyz/)\n\nIf you want to see your own on here, submit a [Pull Request adding yourself to this file](https://github.com/jackyzha0/quartz/blob/hugo/content/notes/showcase.md)!\n","lastmodified":"2022-10-26T11:26:57.363934457Z","tags":null},"/notes/troubleshooting":{"title":"Troubleshooting and FAQ","content":"\nStill having trouble? Here are a list of common questions and problems people encounter when installing Quartz.\n\nWhile you're here, join our [Discord](https://discord.gg/cRFFHYye7t) :)\n\n### Does Quartz have Latex support?\nYes! See [CJK + Latex Support (测试)](notes/CJK%20+%20Latex%20Support%20(测试).md) for a brief demo.\n\n### Can I use \\\u003cObsidian Plugin\\\u003e in Quartz?\nUnless it produces direct Markdown output in the file, no. There currently is no way to bundle plugin code with Quartz.\n\nThe easiest way would be to add your own HTML partial that supports the functionality you are looking for.\n\n### My GitHub pages is just showing the README and not Quartz\nMake sure you set the source to deploy from `master` (and not `hugo`) using `/ (root)`! See more in the [hosting](/notes/hosting) guide\n\n### Some of my pages have 'January 1, 0001' as the last modified date\nThis is a problem caused by `git` treating files as case-insensitive by default and some of your posts probably have capitalized file names. You can turn this off in your Quartz by running this command.\n\n```shell\n# in the root of your Quartz (same folder as config.toml)\ngit config core.ignorecase true\n\n# or globally (not recommended)\ngit config --global core.ignorecase true\n```\n\n### Can I publish only a subset of my pages?\nYes! Quartz makes selective publishing really easy. Heres a guide on [excluding pages from being published](notes/ignore%20notes.md).\n\n### Can I host this myself and not on GitHub Pages?\nYes! All built files can be found under `/public` in the `master` branch. More details under [hosting](notes/hosting.md).\n\n### `command not found: hugo-obsidian`\nMake sure you set your `GOPATH` correctly! This will allow your terminal to correctly recognize `hugo-obsidian` as an executable.\n\n```shell\n# Add the following 2 lines to your ~/.bash_profile\nexport GOPATH=/Users/$USER/go\nexport PATH=$GOPATH/bin:$PATH\n\n# In your current terminal, to reload the session\nsource ~/.bash_profile\n```\n\n### How come my notes aren't being rendered?\nYou probably forgot to include front matter in your Markdown files. You can either setup [Obsidian](notes/obsidian.md) to do this for you or you need to manually define it. More details in [the 'how to edit' guide](notes/editing.md).\n\n### My custom domain isn't working!\nWalk through the steps in [the hosting guide](notes/hosting.md) again. Make sure you wait 30 min to 1 hour for changes to take effect.\n\n### How do I setup Google Analytics?\nYou can edit it in `config.toml` and either use a V3 (UA-) or V4 (G-) tag.\n\n### How do I change the content on the home page?\nTo edit the main home page, open `/content/_index.md`.\n\n### How do I change the colours?\nYou can change the theme by editing `assets/custom.scss`. More details on customization and themeing can be found in the [customization guide](notes/config.md).\n\n### How do I add images?\nYou can put images anywhere in the `/content` folder.\n\n```markdown\nExample image (source is in content/notes/images/example.png)\n![Example Image](/content/notes/images/example.png)\n```\n\n### My Interactive Graph and Backlinks aren't up to date\nBy default, the `linkIndex.json` (which Quartz needs to generate the Interactive Graph and Backlinks) are not regenerated locally. To set that up, see the guide on [local editing](notes/editing.md)\n\n### Can I use React/Vue/some other framework?\nNot out of the box. You could probably make it work by editing `/layouts/_default/single.html` but that's not what Quartz is designed to work with. 99% of things you are trying to do with those frameworks you can accomplish perfectly fine using just vanilla HTML/CSS/JS.\n\n## Still Stuck?\nQuartz isn't perfect! If you're still having troubles, file an issue in the GitHub repo with as much information as you can reasonably provide. Alternatively, you can message me on [Twitter](https://twitter.com/_jzhao) and I'll try to get back to you as soon as I can.\n\n🐛 [Submit an Issue](https://github.com/jackyzha0/quartz/issues)","lastmodified":"2022-10-26T11:26:57.363934457Z","tags":null},"/notes/updating":{"title":"Updating","content":"\nHaven't updated Quartz in a while and want all the cool new optimizations? On Unix/Mac systems you can run the following command for a one-line update! This command will show you a log summary of all commits since you last updated, press `q` to acknowledge this. Then, it will show you each change in turn and press `y` to accept the patch or `n` to reject it. Usually you should press `y` for most of these unless it conflicts with existing changes you've made! \n\n```shell\nmake update\n```\n\nOr, if you don't want the interactive parts and just want to force update your local garden (this assumed that you are okay with some of your personalizations been overriden!)\n\n```shell\nmake update-force\n```\n\nOr, manually checkout the changes yourself.\n\n\u003e [!warning] Warning!\n\u003e\n\u003e If you customized the files in `data/`, or anything inside `layouts/`, your customization may be overwritten!\n\u003e Make sure you have a copy of these changes if you don't want to lose them.\n\n\n```shell\n# add Quartz as a remote host\ngit remote add upstream git@github.com:jackyzha0/quartz.git\n\n# index and fetch changes\ngit fetch upstream\ngit checkout -p upstream/hugo -- layouts .github Makefile assets/js assets/styles/base.scss assets/styles/darkmode.scss config.toml data \n```\n","lastmodified":"2022-10-26T11:26:57.363934457Z","tags":null},"/other/Application/Blockchain":{"title":"ブロックチェーン","content":"\nトランザクションをgit管理する。\n`H( H(transaction | prev_hash | created_at) | nonce) = 0000,,,`\n疑問 ある部分から先頭まで整合するように改変すれば改ざんできそうじゃない？\n\n多くの人が何か価値があると思っているから価値がある。","lastmodified":"2022-10-26T11:26:57.363934457Z","tags":null},"/other/Application/Container":{"title":"コンテナ仮想化技術","content":"\n\n## Kubernetes\n\n[q3k/cve-2019-5736-poc: Unweaponized Proof of Concept for CVE-2019-5736 (Docker escape) (github.com)](https://github.com/q3k/cve-2019-5736-poc)\n[Dragon Sector: CVE-2019-5736: Escape from Docker and Kubernetes containers to root on host](https://blog.dragonsector.pl/2019/02/cve-2019-5736-escape-from-docker-and.html)\n[Security Camp B6 (notion.site)](https://mrtc0.notion.site/Security-Camp-B6-81eb740553154a70aeef92f3455717bf)\n\n[Dockerセキュリティベストプラクティス トップ20：究極ガイド #aqua #コンテナ #セキュリティ #ベストプラクティス - クリエーションライン株式会社 (creationline.com)](https://www.creationline.com/lab/aquasecurity/43087)\n\n[\"\u003e\u003cs\u003eはい\u003c/s\u003e (ssrf.in)](https://blog.ssrf.in/)\n[open_by_handle_at(2) でコンテナから Break Out する (ssrf.in)](https://blog.ssrf.in/post/escape-container-with-open-by-handle-at/)\n\n[実践入門 Kubernetesカスタムコントローラーへの道【委託】 - 達人出版会 (tatsu-zine.com)](https://tatsu-zine.com/books/kubernates-custom-controller)","lastmodified":"2022-10-26T11:26:57.363934457Z","tags":null},"/other/Application/DeepLearning":{"title":"ディープラーニング","content":"\n## モデル\n### GPT\n### BERT\n### Transformer\n[作って理解する Transformer / Attention - Qiita](https://qiita.com/halhorn/items/c91497522be27bde17ce)\n\n## AI security\n### バックドア\n特定の入力データ(トリガー)を意図したクラスに誤分類させる\nトリガー以外の入力データは正しく分類されるので検知は困難\nMitigation\n- 信頼できないドメインから入手した事前学習モデルを使用しない\n- 汚染されていないデータで再学習する\n\n### 敵対的サンプル\n誤分類を誘発させる\nAIと人間両方を騙す攻撃 ex. スパムメールフィルタを騙した上で人間も騙してクリックさせる\nAIを騙し人間には理解させる攻撃 ex. 誹謗中傷コメント (バ力(ちから))\nMitigation\n- 敵対的学習: ぼかしやノイズなどを加えたサンプルを用いる\n- 蒸留: 巨大なネットワークをなるべく精度を落とさずに小さなネットワークにする手法 (Why?)\n- アンサンブル・メソッド: 複数のAIを組み合わせて学習することで頑健性を上げる(Why?)\n- Autoencoderによる検出: データを圧縮して復元するモデルを用いて敵対的サンプルを検出する (How?)\n\n### モデル/データ抽出攻撃\n- メンバーシップ推論 ある画像が学習データ(メンバーシップ)に含まれているかは過剰に反応するかしないか\nMitigation\nクエリアクセスに対して信頼スコアなどの不必要な情報を応答しない\n過学習を抑制する\n\n### モデルの脆弱性\nTensorFlowのLambdaレイヤーで任意コード実行ができるので事前学習モデルに悪意あるコードを埋め込める。\nMitigation\n- 信頼できないドメインから入手した事前学習モデルを使用しない\n- サンドボックス内での実行\n","lastmodified":"2022-10-26T11:26:57.363934457Z","tags":null},"/other/Application/Hypervisor":{"title":"ハイパーバイザー","content":"\nx86を仮想化可能なアーキテクチャへ拡張したものVT-x (Vanderpool Technology)\n\n[ハイパーバイザの作り方 (syuu1228.github.io)](https://syuu1228.github.io/howto_implement_hypervisor/)\n","lastmodified":"2022-10-26T11:26:57.363934457Z","tags":null},"/other/Application/Malware":{"title":"マルウェア","content":"\n\nWarez\n- 非合法的に配布・販売されている商用ソフトウェア\n- 日本では「ワレズ」と呼び、それが派生して「割れ」となった\n\nWannaCry\n- マルウェアの1種で\n- EternalBlue\n\nシステム管理ツール PowerShell, PsExec\nペネトレーションテストツール Cobalt Strike Beacon\nクラウドサービス Dropbox, OneDrive\n\nファイル転送用アプライアンス Accellion FTA を用いて企業の秘密情報を公開する。\n\n## ソースコードでの難読化\n### Win32API Hashing Obfuscation\nWin32API名のHash値を使い、PEBから関数ポインタを探し、API呼び出しを行うことで、プログラムが使用するAPIを難読化。\n\n## コンパイルで生成された中間表現での難読化\n### Mixed Boolean Arithmetic\n定数値/変数の初期値と同値となるような算術演算とビット演算の組み合わせ(XOR,ShiftLeft,ShiftRight,Addなど)に置換し、データを難読化。\n### String Obfuscation\n文字列をXORエンコードし、バイナリ内に格納。文字列の利用時のみにHeap領域へ復号。XOR-keyは文字列ごと/検体ごとに異なる。\nHikari\n### Control Flow Flattening\nジャンプテーブルを作成し、制御フローを平坦化し、BasicBlockの実行順を難読化。実行順制御にはRouting変数を用いる。\noLLVMを用いてできる。\n### Split Basic Blocks\nControl Flow FlattenやString Obfuscationをより難読化する為にBasicBlockの分割をする。oLLVM\n### Bogus Control Flow\nControl Flow FlattenやString Obfuscation + Split Basic Blocksで生成された多数のBasic Blockに一意に決まるかつ削除が困難な条件分岐を追加しロジックを複雑化。Hikari\n### Function Argument Randomization\n関数コールの引数に不必要な定数と追加し、引数の順番を入れ替える。追加された引数はプログラムの動作には無関係であり、呼び出し元の関数のスタックに保持される。\n\n[HikariObfuscator/Hikari: LLVM Obfuscator (github.com)](https://github.com/HikariObfuscator/Hikari)\n[Home · obfuscator-llvm/obfuscator Wiki (github.com)](https://github.com/obfuscator-llvm/obfuscator/wiki)\n\nおもろかった [JSAC2022 Emotet vs EmoCheck Emotet開発者との戦い - YouTube](https://www.youtube.com/watch?v=_XX8N5VbW2w)\n[Objective-See's Mac Malware Collection](https://objective-see.org/malware.html)\n","lastmodified":"2022-10-26T11:26:57.363934457Z","tags":null},"/other/Application/Network/%E9%9F%B3%E5%A3%B0%E3%82%B3%E3%83%BC%E3%83%87%E3%83%83%E3%82%AF":{"title":"音声コーデック","content":"\n","lastmodified":"2022-10-26T11:26:57.363934457Z","tags":null},"/other/Application/Network/%E9%AB%98%E5%91%A8%E6%B3%A2-%E7%84%A1%E7%B7%9A-%E9%80%9A%E4%BF%A1":{"title":"無線","content":"\n","lastmodified":"2022-10-26T11:26:57.363934457Z","tags":null},"/other/Application/Network/SDR":{"title":"Software Defined Radio","content":"\n無線機\n\n![[Pasted image 20220924223810.png]]\n\nGNU Radio\n- USRP B205mini-i\n- HackRF\n\n[GNU Radioで遊ぶ超高速ディジタル無線スタータキット “USRP B205mini-i” (zep.co.jp)](https://www.zep.co.jp/nbeppu/article/z-usrp-da1/)\n","lastmodified":"2022-10-26T11:26:57.363934457Z","tags":null},"/other/Application/Network/network":{"title":"Network","content":"\n# ネットワーク\n\n1990年 10BASE-T\n\n## Ethernet\n米Xerox のパロアルト研究所(PARC)に所属していたロバート・メカトーフ氏によって発明された。\n初期実験は3Mbps 現在は最大400Gbpsの規格がある\nフレーム構造の規格 IEEE 802.3\n\n## TCP/IP\n### TCP BBR\n\n## Network Interface Card: NIC\n\n## Data Plane Development Kit: DPDK\nユーザー空間で NIC を操作するフレームワーク。\nカーネルでの処理がオーバーヘッド。具体的には NIC へデータが到達したときの割り込みなど\nPull Mode Driver: PMD と呼ばれるポーリングベースの受信機構\nただしカーネルを通さない為、パケットキャプチャーが不可能\nDPDK Nginx は Nginx に比べ約3倍高速[2]\n\n1. [Linux Kernel vs DPDK: HTTP Performance Showdown | talawah.io](https://talawah.io/blog/linux-kernel-vs-dpdk-http-performance-showdown/)\n2. [DPDK-NGINX vs NGINX: Tech Overview and Performance Testing - PLVision](https://plvision.eu/rd-lab/blog/sdn/dpdk-nginx-vs-nginx-tech-overview-and-performance-testing)\n3. [Note, Accelerated Network Application | by dsugisawa | mixi developers](https://mixi-developers.mixi.co.jp/note-accelerated-network-application-2187939f05dd)\n\n## kTLS\nカーネルにTLS (Transport Layer Security)を実装し, カーネル空間とユーザー空間のコピーの必要性を大幅に減らし, パフォーマンス向上させる。\n\nVPoE\n\nRougue Access Point\n\n## 輻輳制御アルゴリズム\n\nsessionはどういう仕組みなのか\n","lastmodified":"2022-10-26T11:26:57.363934457Z","tags":null},"/other/Application/OS":{"title":"OS","content":"\nPXE(Preboot eXecution Environment) Boot\n\n### Basic Input/Output System: BIOS\n\n- ハードウェアの初期化\n- OS や bootloader へのサービスの提供\n\n### Unified Extensible Firmware Interface: UEFI\n\n## 割り込みの仕組みを知りたい\n\n## タスク\nジョブ、プロセス、スレッド\n\n## プロセススケジューラ\nスケジュールする単位はタスク。タスクはプロセスやスレッドによって作業している仕事のこと。\n\n### 初期スケジューラ (~v2.4)\n実行可能タスクは一般にランキューと呼ばれるキューに繋がれています。\n$O(n)$\n\n1. ランキューから順方向に全走査してタイムスライスが最大のタスクにコンテキストスイッチ。\n2. インターバルタイマーが割り込み、タイムスライスを減らす。\n3. タイムスライスを使い果たすとランキュー末尾に挿入。\n4. 1~3をすべての実行可能タスクのタイムスライスが0になるまで繰り返し、すべて使い果たしたらタイムスライスを初期化。このとき、スリープ状態のタスクには少しタイムスライスを追加。\n\nnice 値が小さいほどタイムスライスが貰える。有効範囲は -19 ~ 20 で root でないとマイナス値を設定できない。 `nice()` システムコールによって変更可能。\n\n#### プリエンプション機能 (preemption)\n生成直後かスリープ起床時のタスクはタイムスライスを普段より多く与えてランキュー末尾に挿入。\n\n#### 複数LCPU対応\n複数のLCPUが1つのランキューを見る。排他制御が必要。各LCPUは前に取ったタスクを取りやすい。\n\n#### リアルタイムポリシー\nリアルタイムタスク\n`sched_setscheduler()` システムコールや `chrt` コマンドなどによってリアルタイムタスクにできる。常に優先的に動作可能。ハートビート処理など、システムの負荷が高いときでも定期的に動かないとまずいため、リアルタイムタスクにする。それが動いていれば他のタスクは永久にスケジュールされない。\n`SCHED_OTHER` ポリシー : デフォルトのポリシー\n`SCHED_FIFO` ポリシー : タイムスライスなし\n`SCHED_RR` ポリシー : タイムスライスあり\n\n### $O(1)$ スケジューラ (v2.6.0~2.6.22)\nv2.6系は $O(1)$ スケジューラを用いて管理していた。\nランキューは active キューと expired キューに分けられ、active キューの先頭のタスクを取り、タイムスライスを使い切ったら expired キューに挿入するのを繰り返す。\nnice 値ごとにキュー分けるようになって、優先度が高いキューから active キューを空にさせます。\nこれで LCPU 当たり $40\\times 2$ 本のキューがあることになります。\n\n#### ロードバランサー\nLCPU ごとにキューをもつようになったのでロードバランサーが必要になりました。\nNUMAシステムの場合は 2 階層のバランス処理が動作します。\n\n1. NUMAノード間のバランス\n2. ノード間LCPU間のバランス\n\nNUMAノードの中で負荷の偏りを検出し、負荷が高いノードの一番負荷の高い LCPU から負荷の低いノードの一番負荷の低い LCPU へタスクを移動させる。\n\n階層が複雑になると物理CPU \u003e ダイ \u003e CCX \u003e コア \u003e スレッドのそれぞれでバランスする。\n\n移動を許す LCPU を制限する CPU affinity がある。タスクが動作可能なLCPUの集合を決められる。`sched_setaffinity()`システムコールや`taskset`コマンドによって設定できる。\n\n### 対話型タスクの優先動作\nbash や X Window System などの、人間が直接やりとりする、応答性が重視されるタスク指す。\n\n- 単位時間あたりにスリープしている率が高いプロセスを対話型タスクとみなす。\n- 対話型タスクに次のような優遇措置をとる\n\t- タイムスライスが切れると expired キューではなく active キューに移す。\n\t- nice 値相当の優先度を上げる。タイムスライスは変化しない。\n\t- その一方、ずっと実行可能なタスクは優先度を下げる。\n\n\n### $O(1)$スケジューラの問題点\n- 対話型タスクによるハング\n1. 対話型タスクは優先度が上がり、 active キューに再挿入される。\n2. 他のタスクはそもそも動けないから優先度が上がらない。\n3. 少数の高優先度タスクが長時間動き続ける。\n- 実行可能タスクが多いと、なかなかCPU時間が回ってこない。典型的には、実行可能なタスク数 × 100ms 待たされる。\n- タイムスライスの粒度が荒いため、fair share scheduling や CFS bandwidth controllerなどのような細かい制御ができない。\n\t- 粒度を小さくするにはインターバルタイマーの割り込み頻度を増やせばよい。\n\t- 割り込み回数が増えると割り込みハンドラが動作する時間が増えるため、システム全体スループットが下がる。\n\n### Completely Fair Scheduler (v2.6.23~)\nv2.6.23 から入った Completely Fair Scheduler: CFS\n赤黒木上で葉ノードに個々のタスク、キーはタスクごとに存在するvruntimeという値。\n検索コスト $O(\\log n)$ に最適化(vruntime 最小のタスクをキャッシュなど)を加えてよい。\n\nワンショットの高精度タイマーを用いることでタイムスライスが切れるときだけ割り込むので割り込み負荷を減らし、CFSが実現できるようになった。\nレイテンシターゲット 数ms～数十ms を各タスクに均等に割り当てる。\nnice 値が1低いと1.25倍多くタイムスライスが与えられる。\n\nスケジューラアルゴリズムがプラガブルになった。スケジューリングクラスとコールバック関数を用意すればOK。\n\nfair group scheduling(v2.6.24): cgroup でグループごとにロードバランスする。メモリ制限したりもできる。\nRealtime group scheduling(v2.6.25): リアルタイムタスクが暴走すると通常のタスクは一切動けないため、1割程度他のタスクに渡す。\nCFS bandwidth controller(v3.2.2): 個々のユーザーにCPU時間の制限を与えることができる。マルチテナントシステムであるユーザーにリソースが占有されないようにあるcgroup 内のタスクがperiodと呼ばれる所定時間内にruntimeと呼ばれる時間のみ動けるように制限する。\ndeadline scheduling class(v3.14): リアルタイムタスクの多様性を持たせる。\nEnergy-aware scheduling(v5.0): スマートフォンなどで使われるbig.LITTLE processing考え方を採用したCPUの為のもの。\n- 処理性能が高いが消費電力が大きいCPU\n- 処理性能が低いが消費電力が小さいCPU\n重いタスクは前者に、軽いタスクは後者に実行させる。重いタスクがなければ全射のコアの動作周波数を下げたり、電源を切ったりすることによって消費電力を少なくするのが狙い。\n\n## io_uring\n\nmem_info\n\n## ロック\n- `std::sync::RwLock::{write(), try_read()}` を併用した場合には「書き込みロックを最優先」という挙動は必ずしも期待できない (LinuxではNG)\n- Pthread の規約が挙動に自由度をもたせており、Linuxにおけるデフォルト実装では **writer starvation** が発生する\n- Rustにおいて writer starvation を回避しつつ readers-writer lock を使うには [`parking_lot::RwLock`](https://docs.rs/parking_lot/latest/parking_lot/type.RwLock.html) を使うと良い\n\n\n## eBPF\n[verifier.c - kernel/bpf/verifier.c - Linux source code (v5.18.14) - Bootlin](https://elixir.bootlin.com/linux/v5.18.14/source/kernel/bpf/verifier.c#L10186)\n\n\n## 参考\n[Linux source code (v5.17.9) - Bootlin](https://elixir.bootlin.com/linux/v5.17.9/source)\n[The Linux Kernel documentation — The Linux Kernel documentation](https://docs.kernel.org/)","lastmodified":"2022-10-26T11:26:57.363934457Z","tags":null},"/other/Application/Processor":{"title":"プロセッサ","content":"\n# CPU\n\n## 概要\nCPU\n- LGA\n- BGA\n- QFP\nGPU\n- iGPU(internal) CPU内にあるグラボ\n- dGPU(discrete) NVMe/SATA/PCIeなどで接続する外付けのグラボ\n- eGPU(external) Thunderbolt 3/4などで接続する外付けのグラボ\nTPU 行列積演算\nFPU\n\nGPGPU\n\nQualcomm Snapdragon 6 Gen 1\n富岳\nOS IHK/McKernel\n\nRead/Write\nbig.LITTLE processing\n\n## CPU機能\n[ARM immediate value encoding (mcdiarmid.org)](https://alisdair.mcdiarmid.org/arm-immediate-value-encoding/)\n\nRTDSC 命令\n[How to Benchmark Code Execution Times on Intel IA-32 and IA-64 Instruction Set Architectures White Paper](https://www.intel.com/content/dam/www/public/us/en/documents/white-papers/ia-32-ia-64-benchmark-code-execution-paper.pdf)\n\nABI\nSystem V AMD64\n[x86_64-abi-0.99.pdf (linuxbase.org)](https://refspecs.linuxbase.org/elf/x86_64-abi-0.99.pdf)\n\n## アーキテクチャ\nRISC-V\n\n## 回路\n全加算器\nDeep Learning を用いた回路設計も行われている.\n[Designing Arithmetic Circuits with Deep Reinforcement Learning | NVIDIA Technical Blog](https://developer.nvidia.com/blog/designing-arithmetic-circuits-with-deep-reinforcement-learning/)\n\n## ビット演算\nInteger Overflow ([CWE-190](https://cwe.mitre.org/data/definitions/190.html)) 整数の上限値を超えると下限値付近になる\nInteger Underflow ([CWE-191](https://cwe.mitre.org/data/definitions/191.html)) 整数の下限値を下回ると上限値付近になる\nFloating Point Underflow   [x + 0.25 - 0.25 = xが成り立たないxとは何か｜Rui Ueyama｜note](https://note.com/ruiu/n/ndd60f403e8f2)\nStack Overflow\nStack Underflow\n\n## 脆弱性\n[Project Circuit Breaker](https://www.projectcircuitbreaker.com/)\n\n### PACMAN\nApple M1 CPUのポインター\n[PACMAN (pacmanattack.com)](https://pacmanattack.com/)\n\n### Spectre\nBranch Target Buffer: BPB\n危険性\n\n### Mitigation\n#### Spectre-v1 SWAPGS\nkernel parameter `nospectre_v1`\n#### Spectre-v2 Retpoline\nLFENCE/JMP\nkernel parameter `nospectre_v2`\n#### Spectre-v3 KPTI\nkernel parameter\n- `pti=off`\n- `nopti`\n\n-   `noibrs`\n-   `noibpb`\n-   `nospec_store_bypass_disable`\n[KB4073119: Windows client guidance for IT Pros to protect against silicon-based microarchitectural and speculative execution side-channel vulnerabilities (microsoft.com)](https://support.microsoft.com/en-us/topic/kb4073119-windows-client-guidance-for-it-pros-to-protect-against-silicon-based-microarchitectural-and-speculative-execution-side-channel-vulnerabilities-35820a8a-ae13-1299-88cc-357f104f5b11)\n\n### MDS/Zombieload\nhttps://www.kernel.org/doc/html/latest/admin-guide/hw-vuln/mds.html\n\n### TSX Asynchronous Abort\nhttps://www.kernel.org/doc/html/latest/admin-guide/hw-vuln/tsx_async_abort.html\n\n### iTLB multihit\n\n## TEE\nTrusted Execution Environment: TEE とはプロセッサ上に隔離された実行環境を用意することでセキュリティを高める技術です。\nより広義にHIEE: Hardware-assisted Isolated Execution Environment\nNormal Mode Secure Mode\n- OSやアプリケーションの改竄を検知\n- 公開鍵証明書による端末識別，認証\n- ストレージデータの安全な暗号化\n- ほぼほぼ暗号化処理をするため, 秘密鍵をそこにppm\n\nTrusted Platform Module: TPM ハードウェアとして開発\n[規格](https://trustedcomputinggroup.org/resource/tpm-library-specification/)\n- Windows BitLocker\n- [A Bad Dream](https://www.usenix.org/system/files/conference/usenixsecurity18/sec18-han.pdf)\n\n須崎先生\nSpectre見つけたProject Zero\nandroid をdecrypt TEEを介さずに FBIでもできなかった\n[Bits, Please!: Extracting Qualcomm's KeyMaster Keys - Breaking Android Full Disk Encryption (bits-please.blogspot.com)](http://bits-please.blogspot.com/2016/06/extracting-qualcomms-keymaster-keys.html)\n\n### Intel SGX\n本質とは？なぜ\nEnclaveを持つ\nEnclave では Ring 3 でしか動作しない, つまり syscall が使えない\n\n![[Pasted image 20220927024448.png]]\n[Intel SGX入門 - SGX基礎知識編 - Qiita](https://qiita.com/Cliffford/items/2f155f40a1c3eec288cf)\n[Graphene-SGX](https://www.usenix.org/system/files/conference/atc17/atc17-tsai.pdf)\n\n#### Remote Attestation\nRemote AttestationはECDH上でCPU\n[Intel SGX - Remote Attestation概説 - Qiita](https://qiita.com/Cliffford/items/095b1df450583b4803f2)\n\n#### Foreshadow\nCVE-2018-3615 - L1 Terminal Fault: SGX\nCVE-2018-3620 - L1 Terminal Fault: OS/SMM、CVE-2018-3646 - L1 Terminal Fault: VMM\nL1データキャッシュに存在するデータならなんでも読み取ることが可能\n\n#### AEPIC Leak\n最初のアーキテクチャ由来のCPUのバグ. インテル製10~12世代のCPUの脆弱性を利用して, プロセッサ本体から機密情報を漏洩させる。APIC MMIOでの未定義範囲のアクセスによりキャッシュ階層から古いデータを参照できる。APIC MMIOのアクセスには管理者権限が必要であるから安全であるが, Intel SGXのような管理者権限を持つ攻撃者からデータを守るようなシステムはリスクとなる。\n未初期化メモリの読み取りのようなもの\n\n[元論文](https://aepicleak.com/aepicleak.pdf)\nhttps://github.com/IAIK/AEPIC\n\n### ARM TrustZone\nCortex-A シリーズの拡張機能\nノーマルワールドとセキュアワールドそれぞれに特権/非特権モード\n- [Boomerang](https://github.com/ucsb-seclab/boomerang/)\n- [TrustZone Rootkit](https://security.inso.tuwien.ac.at/pdfs/woot22-preprint.pdf)\n- [ARM TrustZone エクスプロイト入門 - Speaker Deck](https://speakerdeck.com/rkx1209/arm-trustzone-ekusupuroitoru-men)\n- [Project Zero: Trust Issues: Exploiting TrustZone TEEs (googleprojectzero.blogspot.com)](https://googleprojectzero.blogspot.com/2017/07/trust-issues-exploiting-trustzone-tees.html)\n- [SoK: Understanding the Prevailing Security Vulnerabilities in TrustZone-assisted TEE Systems | IEEE Conference Publication | IEEE Xplore](https://ieeexplore.ieee.org/document/9152801)\n\n### RISC-V Keystone\n- BOOM\n- Speculative Attack\n\n### Apple iOS E\n\n### Android KeyMaster\n\n","lastmodified":"2022-10-26T11:26:57.363934457Z","tags":null},"/other/Application/Programming":{"title":"プログラミング言語","content":"\n# プログラミング言語入門\n\n任意の実行はデータとアクションで構成されている。\nそれを人間にとってわかりやすく書きやすい形にするがプログラミング言語が必要とされる理由であり、データとアクションの関係性における多様なデザインがプログラミング言語の多様性の理由である。\n\nデータとアクションの関係性はロジックや階層構造によって表現される。\nそして計算モデルに意味を与える意味論的な解釈を取り込みつつ解説する。\n\n最初は抽象的で簡単なところから始まり、具体的で難しい問題に立ち向かう。\n対象者\n- 任意の言語を素早く習得したい方\n- 基礎から理解して安心したい方\n- 新しい言語を実装したい方\n\n情報に踊らされずちゃんと軸を持つには論理で情報を作り出さないといけない。\n\n## 第一章 型\n\nTODO: なぜここで型を説明するのか\n馴染み深いから？前提知識として持っていないと抽象論を展開できないから？あいまいな定義や同義な言葉が各言語にあるのでまとめて扱う為に一回必要\n\nここでは公理的に計算するところはつまらんので省いて、なるべく実践的、アイデアが得られる点を紹介する。何故かというと私は計算より抽象的なことの方が好きだからです。不足分については型理論の方で説明します。($\\lambda, \\pi, \\mu$ 計算, 線形型, Boehm-Berarducci encodingなど)\n\n### データの表現方法\n- 直積型 $A_1\\times A_2$\nex.) 構造体, メソッドのないクラス, 配列, Vectorなど\n- 直和型 $A_1+A_2$\nex.) Rustのenum\n- ユニオン型 $A_1\\cup A_2$\n直和型とほぼ同じであるが、反例としてすべての型に null や undefined などがある TypeScript は直和型と同値ではない。\nex.) Cのunion\n- 篩型 (refinement types) $\\{x\\in A\\mid P(x)\\}$\nデータに制約を持たせることができる。\n実装を篩型に分け与えてシンプルに出来る\nex.) Liquid Haskell\n\n### ロジックの表現方法\n- 関数型 $f\\colon A_1\\to A_2 \\to\\ldots\\to A_n \\to R$\nカリー化\n- クラス $(A, f_1,\\ldots,f_n)\\,\\mbox{s.t.}\\,f_i\\colon A\\to\\ldots\\to R$\n\n### 型の順序\n順序、数でいう不等号を型に与えます。\n\n- 関数と型の集合の部分集合として定義できる\n部分型\n$A_1 \\subset A_1\\cup A_2$\n$A_1 \\subset A_1\\times A_2$\n$(f_1, f_2) \\subset (f_1)$\n\n- 共変性 $A_1 \\subset A_2 \\implies I[A_1] \\subset I[A_2]$\n- 反変性 $A_1 \\subset A_2 \\implies I[A_1] \\supset I[A_2]$\n関数の引数\nGoの継承とかが分かりやすいかな\n$A_1\\to R \\supset A_2\\to R$\n`type X interface {F()}`\n`type Y interface {F();G()}`\nYがXのサブタイプ\n- 双対性 共変かつ反変\n- 非変性 どれでもない\n\n### 型の構成と分類\n- 依存型 $\\Pi_{x\\colon A}B(x)$\n- 依存和型 $\\sum_{x\\colon A}B(x)$\n- 型演算子\n多相カインドのこと\n- 型クラス trait $\\{A\\in\\mathcal{U}\\mid f_1,\\ldots,f_n \\in A\\}$\n- Row Type\n\n### 型の意味を捉える\n- モナド\n自己関手の圏におけるモノイド対象\n`(\u003e\u003e=) :: m a -\u003e (a -\u003e m b) -\u003e m b`\n`(\u003e=\u003e) :: (a -\u003e m b) -\u003e (b -\u003e m c) -\u003e (a -\u003e m c)`\n`f \u003e=\u003e g = \\x -\u003e f x \u003e\u003e= g`\n`f :: a -\u003e m a`\nEffモナド\nAffモナド\nFree モナド\n- コモナド\n\n型レベル○○\n型を用いてある代数と同値な型を定義すること\n型レベル自然数\n例えば $A_0 = A$, $A_{n+1}=A_0\\times \\ldots\\times A_n$ と定義すると加算、減算、乗算、順序などを埋め込むことができ、自然数と同型な代数となる。\n型レベル文字列\nTypeScript にはもともとある。この依存型\n\n### 継続\n#### Continuation-Passing Style: CPS変換\n#### call/cc\n\n## 第二章 内部実装\nコード解析などで解決する問題はよくNP完全な問題であることが多い。\n内部実装を理解すれば、よりよい言語というのが分かってくるだろう。\n\n### Stack \u0026 Heap\n\n### 関数の実装\n\n### 多相性 (polymorphism)\n具体的に依存型を実装する多相性を紹介する。\nアドホック多相 (ad hoc polymorphism)\nオーバーロード\nパラメータ多相 (parametric polymorphism)\n静的に呼び出された関数の引数の型を解析して自動で実装する\nサブタイピング多相 (subtyping polymorphism)\nクラスの継承 オーバーライド\n\nこれらの実装にはディスパッチを用いる\n静的ディスパッチ\n動的ディスパッチ\n\n### JIT\n\n### 最適化\n現代の主要なコンパイラの最適化は巨大となっているが最もクリティカルな8つの最適化を実装すれば最大80%の性能まで向上する。\n\nSSA形式に落とし込むとCFGと単純な同値関係になり、グラフ理論を持ち込んでより深い最適化を考えられる。\n\n#### インライン展開\n#### ループ展開, ベクトル化\n#### 共通部分式除去 (CSE; Common Subexpression Elimination)\n#### デッドコード除去 (DCE; Dead Code Elimination)\n#### コード移動\n#### 定数畳み込み (Constant Fold)\n#### Peephole最適化\n\n[CompilerTalkFinal (venge.net)](http://venge.net/graydon/talks/CompilerTalk-2019.pdf)\n\n### toolchain リンカ・ローダ\ntoolchainで紹介する。\n\n### 動的ライブラリ\n\n\n## 第三章 わかりやすいとミスカバー\n思想が混じりやすい話題なので極力様々な意見を取り込むべき\n\nわかりやすい 階層構造と情報隠蔽\nミスカバー コンパイルエラー\n\n階層構造 import classの継承\n情報隠蔽 カプセル化 private public\n\nabstraction leak\nうまく抽象化したつもりでも、どこかに必ず漏れが出てきてしまう\n\nResult\u003cVec\u003c\u003e\u003e\nVec\u003cResult\u003c\u003e\u003e\n\n### オブジェクト指向\n\nカプセル化 getter/setter\n本来は、値引き判定のロジックをどのオブジェクトに配するかを決めるにあたって、どのような知識を隠蔽すべきか、あるいは裏返して言えば、どのような知識は開示して構わないかという点に思いをめぐらすべきでした。\n解決策は、「データとロジックを一体に」という、どちらかというとゲームのルールのような具体的で単純なルールから視点を引き上げ、「情報隠蔽（＝知識隠蔽）」のような、より本質的な、目的志向的な設計原則に立ち帰って考えることです。\n何を隠蔽して何を表に出すのかという設計判断\n引数に関数を入れることもできる。このような特性を持つ言語を関数型言語と呼ぶ。\nVisitorパターン\n\n### 関数型言語\n\n2階で十分なぜか\n\n編集距離\n幾何的\n\nデバッグ\n\n## 第四章 Immutable, Lifetime, Concurrency\n機能\n並列プログラミングは\nErlangVM\n\nConcurrency\n- coroutine\n- async/await 並行\n\t- 裏でnode.jsが並列をしているから\n\t- node.js が single thread は本当だが嘘\n\t- event loop 1process\n\t- Golang event loop 複数のprocess\n- Actor\n\nasync/await\nasync goroutine作ってchannel渡して\nawait channel待つ\nchannel の queue はeventloop のqueueと同じ感じ\n\nasync iterator\n- Arc/Rc\n\n意味論\nhappens-before 実行順序\ndata race free\nsequentially consistent atomics(素直なatomics)\n- Javaのvolatile, C++のdefault atomics, Goのsync/atomic, JavaScript\n\n## 第五章\n","lastmodified":"2022-10-26T11:26:57.363934457Z","tags":null},"/other/Application/Rendering/RayTracing":{"title":"レイトレーシング, パストレーシング","content":"\n## 説明\n\nレイトレーシング(Ray Tracing)とはCGを作成する技術の一つ。\n視点からレイ(Ray)と呼ばれる仮想の光線を飛ばし, 反射・屈折を繰り返して, 光源に当たればそこから逆算して画素を表示する仕組みです.\n\nガンマ補正 $(R^{2.2}, G^{2.2}, B^{2.2})$\nPPM画像という数値をASCII, 区切り文字を空白で画素を表現する規格を用いると楽\n\nベクトル空間を定義して法線ベクトル\n\n## 物理ベースレンダリング理論\nある波長 $\\lambda$ の光のエネルギー\n$$e_\\lambda=\\frac{hc}{\\lambda}$$\nスペクトル放射エネルギー\n$$\n\\begin{aligned}\nQ_\\lambda\u0026=ne_\\lambda \\\\\nQ\u0026=\\int_0^\\infty Q_\\lambda d\\lambda\n\\end{aligned}\n$$\nスペクトル放射束\n$$\n\\begin{aligned}\n\\Phi_\\lambda\u0026=\\frac{dQ_\\lambda}{dt} \\\\\n\\Phi\u0026=\\frac{dQ}{dt}\n\\end{aligned}\n$$\n放射輝度\n$$L(x,\\vec\\omega)=\\frac{d^2\\Phi}{\\cos\\theta dAd\\vec\\omega}$$\n\nRGBそれぞれのスペクトル放射束を画像にすればよい。\n現実は可視光領域全てのスペクトルなのでこれは新井金治である。\n可視光の全波長考慮したレンダリングをフルスペクトラムレンダリングと呼び、プリズムの光の分散などで使われます。\n\n空気が真空なら光が進行しても放射輝度の値は変わらない。\n現実は空気中の微粒子との衝突で光の吸収、散乱などの現象が起きる。\nこれを再現したレンダリングをボリュームレンダリングと呼び、煙や雲などで使われます。\n\n### 双方向反射率分布関数 (BRDF)\n反射・屈折を表現する関数 BRDF\n$$\nf(x,\\vec\\omega_i,\\vec\\omega_r) = \\frac{dL_r(x,\\vec\\omega_r)}{L_i(x,\\vec\\omega_i)\\cos\\theta d\\vec\\omega_i}\n$$\nBRDF を用いると半球全体 $\\Omega$ からある点にきた光が、方向 $\\vec\\omega_r$ に反射される放射輝度の値 $L_r(x,\\vec\\omega_r)$ を計算することが出来る。\n$$\nL_r(x,\\vec\\omega_r) = \\int_\\Omega f(x,\\vec\\omega_i,\\vec\\omega_r)L_i(x,\\vec\\omega_i)\\cos\\theta d\\vec\\omega_i\n$$\nこれを $L_r(x,\\vec\\omega_r) = TL_i(x,\\omega_i)$ と略す事にする。\n- 物体表面のある点 $x$ から方向 $\\vec\\omega_r$ へ出射する放射輝度 $L_o(x,\\vec\\omega_r)$\n- 点 $x$ において物体が発光し、$\\vec\\omega_r$ の方向へ出射する放射輝度 $L_e(x,\\vec\\omega_r)$\n- 点 $x$ から $\\vec\\omega_r$ に反射される放射輝度 $L_r(x,\\vec\\omega_r)$\nとして次のレンダリング方程式が成り立つ。\n$$\nL_o(x,\\vec\\omega_r) = L_e(x,\\vec\\omega_r) + L_r(x,\\vec\\omega_r)\n$$\nまた, 点 $x$ から $\\vec\\omega$ の方向へ進んだとき, 衝突する点を返す関数 $t(x,\\vec\\omega)$ を用いて $L_i(x,\\vec\\omega_i) = L_o(t(x,\\vec\\omega_i),\\vec\\omega_i)$ と表せられる。するとレンダリング方程式は以下の無限級数で表現できる。\n$$\n\\begin{aligned}\nL_o(x_0,\\vec\\omega_0) \u0026= L_e(x_0,\\vec\\omega_0) + L_r(x_0,\\vec\\omega_0) \\\\\n\u0026= L_e(x_0,\\vec\\omega_0)+TL_i(x_0,\\vec\\omega_1) \\\\\n\u0026= L_e(x_0,\\vec\\omega_0)+TL_o(t(x_0,\\vec\\omega_1),\\vec\\omega_1) \\\\\n\u0026= L_e(x_0,\\vec\\omega_0)+T(L_e(x_1,\\vec\\omega_1)+TL_o(x_2,\\vec\\omega_2)) \\\\\n\u0026= L_e(x_0,\\vec\\omega_0)+T(L_e(x_1,\\vec\\omega_1)+T(L_e(x_2,\\vec\\omega_2)+T(L_e(x_3,\\vec\\omega_3)+\\ldots))) \\\\\n\u0026= L_e(x_0,\\vec\\omega_0)+\\sum_{k=1}^\\infty T^kL_e(x_k,\\vec\\omega_k) \\\\\n\\end{aligned}\n$$\nモンテカルロ法を用いることで積分を数値的解くことが出来る。\n$$\n\\begin{aligned}\nL_o(x_0,\\vec\\omega_0) \u0026= L_e(x_0,\\vec\\omega_0)+\\sum_{k=1}^\\infty T^kL_e(x_k,\\vec\\omega_k) \\\\\n\u0026= L_e(x_0,\\vec\\omega_0)+\\sum_{k=1}^\\infty \\int_\\Omega f(x,\\vec\\omega_k,\\vec\\omega_r)\\ldots\\left(\\int_\\Omega f(x,\\vec\\omega_k,\\vec\\omega_{k-1})L_e(x_k,\\vec\\omega_k)\\cos\\theta_k d\\vec\\omega_k\\right)\\ldots \\cos\\theta_1 d\\vec\\omega_1 \\\\\n\u0026= L_e(x_0,\\vec\\omega_0)+\\sum_{k=1}^\\infty\\int_\\Omega\\ldots\\int_\\Omega f(x_1,\\vec\\omega_1,\\vec\\omega_0)\\ldots f(x_k,\\vec\\omega_k,\\vec\\omega_{k-1})L_e(x_{k},\\vec\\omega_{k})\\cos\\theta_1\\ldots\\cos\\theta_k d\\vec\\omega_1\\ldots d\\vec\\omega_k \\\\\n\u0026\\approx L_e(x_0,\\vec\\omega_0)+\\sum_{k=1}^\\infty \\frac{1}{N}\\sum_{s=1}^N \\frac{f(x_1,\\vec\\omega_1^s,\\vec\\omega_0)\\ldots f(x_k,\\vec\\omega_k^s,\\vec\\omega_{k-1})L_e(x_{k},\\vec\\omega_{k})\\cos\\theta_1\\ldots\\cos\\theta_k}{p_1(\\vec\\omega_1)\\ldots p_k(\\vec\\omega_k)} \\\\\n\\end{aligned}\n$$\nサンプルには重点的サンプリングを行う。確率密度関数の累積分布関数の逆関数を用いてサンプルを生成することで\n\n級数の計算ではロシアンルーレットを用いる。次項を計算する確率 $p$ を用いて次のように計算する。\n$$\n\\begin{aligned}\nS_n \u0026= \\sum_{k=0}^n x_k \\\\\nR_n \u0026= S_\\infty - S_n \\\\\n\\hat R_n \u0026= x_n + \\begin{dcases}\n\\frac{\\hat R_{n+1}}{p} \u0026 (u\\leq p) \\\\\n0 \u0026 (u\u003ep)\n\\end{dcases} \\\\\n\\hat S_n \u0026\\approx x_0 + \\frac{x_1}{p} + \\frac{x_2}{p^2} + \\ldots + \\frac{x_n}{p^n} \\\\\n\\end{aligned}\n$$\nこの期待値を計算すると $S_\\infty$ となる。\n$$\nE[\\hat S] = x_0 + p\\frac{x_1}{p} + p^2\\frac{x_2}{p^2} + \\ldots + p^n\\frac{\\hat R_n}{p^n} = S_\\infty\n$$\n\n## モデル\n### 拡散反射モデル\n紙のような乱反射する物体を考える。このときBRDFは次のようになる。\n$$\nf_{Diffuse}(x, \\vec\\omega_i, \\vec\\omega_o) = \\frac{\\rho}{\\pi}\n$$\nこの確率密度関数 $p(\\vec\\omega)$ はBRDF$\\times\\cos\\theta$ に比例する為, 定数 $k$ を用いて $p(\\vec\\omega) = k\\cos\\theta$ となる。確率の条件より $k$ を決定することが出来る。\n$$\n\\begin{aligned}\n\\int_\\Omega p(\\vec\\omega)d\\vec\\omega \u0026= k\\int_0^{2\\pi}\\int_0^{\\frac{\\pi}{2}}\\cos\\theta\\sin\\theta d\\theta d\\phi = k\\pi = 1 \\\\\np(\\vec\\omega) \u0026= \\frac{\\cos\\theta}{\\pi}\n\\end{aligned}\n$$\n確率密度関数について変数を変えると\n$$\n\\begin{aligned}\np(\\theta,\\phi) \u0026= p(\\vec\\omega)\\sin\\theta = \\frac{1}{\\pi}\\sin\\theta\\cos\\theta \\\\\np(\\theta) \u0026= \\int_0^{2\\pi}p(\\theta, \\phi)d\\phi = \\sin{2\\theta} \\\\\np(\\phi\\mid\\theta) \u0026= \\frac{p(\\theta,\\phi)}{p(\\theta)} = \\frac{1}{2\\pi}\n\\end{aligned}\n$$\nこの累積分布関数の逆関数は\n$$\n\\begin{aligned}\nP(\\theta) \u0026= \\int_0^\\theta p(t)dt = \\frac{1-\\cos{2\\theta}}{2} \u0026 P_\\theta^{-1}(u) \u0026= \\frac{1}{2}\\cos^{-1}(1-2u) \\\\\nP(\\phi\\mid\\theta) \u0026= \\int_0^\\phi p(\\phi\\mid\\theta)dt = \\frac{\\phi}{2\\pi} \u0026 P_\\phi^{-1}(v) \u0026= 2\\pi v\n\\end{aligned}\n$$\nとなるので $\\theta, \\phi$ のサンプルは乱数 $u, v$ を用いて\n$$\n\\begin{dcases}\n\\theta = \\frac{1}{2}\\cos^{-1}(1-2u) \\\\\n\\phi = 2\\pi v\n\\end{dcases}\n$$\nと計算すればよい。これを方向ベクトルとするには\n$$\n\\begin{dcases}\nx = \\sin\\theta\\cos\\phi \\\\\ny = \\cos\\theta \\\\\nz = \\sin\\theta\\sin\\phi\n\\end{dcases}\n$$\nとする。\n\n### 完全鏡面反射モデル\n反射についての関係式は次のようになる。\n$$\n\\vec\\omega_i = -\\vec\\omega_o + 2(\\vec\\omega_o\\cdot\\vec n)\\vec n\n$$\nこれよりBRDFは次のようになる。$\\vec\\omega_r$ を $\\vec\\omega_o$ の反射方向とする。\n$$\nf_{Specular}(x,\\vec\\omega_i,\\vec\\omega_o) = \\frac{\\delta(\\vec\\omega_i-\\vec\\omega_r)}{\\cos\\theta}\n$$\nサンプルは反射方向を返せばよい。\n\n### ガラスモデル\nガラスに入射した光は反射と屈折をする。反射は上記の式を用いればよい。屈折方向 $\\vec\\omega_r$ は次のように計算する。入射側屈折率 $n_1$ 出射側屈折率 $n_2$ と入射光線が法線となす角度 $\\theta$ として\n$$\n\\begin{aligned}\n\\vec\\omega_r \u0026= \\frac{n_1}{n_2}(-\\vec\\omega_i+\\cos\\theta\\vec n)-\\sqrt{1-\\alpha^2}\\vec n \\\\\n\\alpha \u0026= \\frac{n_1}{n_2}\\sin\\theta\n\\end{aligned}\n$$\nこのBRDFは次のようになる。\n$$\nf_{Refract}(x,\\vec\\omega_i,\\vec\\omega_o) = (1-f)\\frac{\\delta(\\vec\\omega_i-\\vec\\omega_r)}{\\cos\\theta}\n$$\nまた屈折時には輝度も変化する。\n$$\nL_r = \\left(\\frac{n_1}{n_2}\\right)^2L\n$$\nまた、反射/屈折の割合はフレネルの式(Fresnel Equation) で表現される。それは複雑な式であるので通常それを近似したSchlickの近似式が使われる。\n$$\n\\begin{aligned}\nF_r(\\theta) \u0026= F_o + (1 - F_o)(1 - \\cos\\theta)^5 \\\\\nF_o \u0026= \\left(\\frac{n_1-n_2}{n_1+n_2}\\right)^2\n\\end{aligned}\n$$\nこれについてロシアンルーレットを用いれば\n\n### 光モデル\n発光については全ての方向に同じ強さの放射輝度の光を返せばよい。\n空についても同様に地平線に近ければ白く、天井に近くなれば青いように返せばよい。\nまた IBL (Image Based Lighting) を用いれば輝度を保持する HDR 画像を用いて周囲を画像で表現できる。[sIBL Archive (hdrlabs.com)](http://www.hdrlabs.com/sibl/archive.html) を使うとよい。\n\n## その他\n### Next Event Estimation (NEE)\n光源が少ない場所ではノイズが多く出やすい。そこで光源上の点をサンプリングしてその方向にレイを飛ばすことで光源が小さい場合でも寄与を加算しやすくできる。\n\n### Bounding Volume Hierarchy (BVH)\n複数の物体全体を囲むバウンディングボリュームを再帰的に作り、それぞれのレイヤーで衝突判定を行うことで衝突の探索を $O(n)$ から $O(\\log n)$ に改善させる方法。\n\n### 双方向パストレーシング\nレイを飛ばすだけではなく、光源からシーンに向けても光を追跡する方法。\n\n### メトロポリス光輸送\n\n### フォトンマッピング\n\n## 参考\nPhotorealism yumcyawiz","lastmodified":"2022-10-26T11:26:57.363934457Z","tags":null},"/other/Application/Rendering/Rendering":{"title":"Rendering Engine","content":"\n\nDirectX\nVulkan\n\nシェーダ言語\nGLSL","lastmodified":"2022-10-26T11:26:57.363934457Z","tags":null},"/other/Application/Rendering/Shader":{"title":"シェーダー","content":"\n","lastmodified":"2022-10-26T11:26:57.363934457Z","tags":null},"/other/Application/SAT-SMT/SAT-SMT":{"title":"SAT SMT","content":"\n$$\n\\newcommand{\\not}{\\overline}\n$$\n- Equality Logic With Uninterpreted Functions: EUF が SMT を含む\n\n## SAT: SATisfiability Problem\n$((a\\land\\not b\\land\\not c)\\lor(b\\land c\\land\\not d))\\land(\\not b\\lor\\not c)$\n$(a,b,c,d)=(t,f,f,t)$\n### DPLL: Davis Putnam Logemann Loveland\n\n### CDCL: Constrait-Driven Clause Learning\n\n## SMT: Satisfiability Modulo Theories\nFOL: First-Order Logic\nHOL: Higher-Order Logic\n\n### Bit Vectors\n\n### DPLL(T)\nSMT ソルバ全般\n[SAT/SMTソルバの仕組み](https://www.slideshare.net/sakai/satsmt)\n \tSAT, SMT について主要なアルゴリズムや technique をまとめてある\n \tTheory Combination についていろいろ書いてあって助かる。例えば Convexity について（スライド 44）\n [SAT ソルバ・SMT ソルバの技術と応用](https://www.jstage.jst.go.jp/article/jssst/27/3/27_3_3_24/_pdf)\n \tサーベイ論文たすかる\n [A Survey of Satisfiability Modulo Theory](https://arxiv.org/abs/1606.04786)\n \tサーベイ論文たすかる2\n[* SMT-LIBv2]（SMT ソルバの入力の形式）\n[The SMT-LIBv2 Language and Tools: A Tutorial](http://smtlib.github.io/jSMTLIB/SMTLIBTutorial.pdf)\n \tp20. SMT-LIBv2 の token が表になって並んでおり、どのような正規表現でマッチさせられるか掲載している\n[SMT-LIB The Satisfiability Modulo Theories Library](http://smtlib.cs.uiowa.edu/)\n \tSMT ソルバに与える入力の形式 SMT-LIB v2 についてまとまっている Web サイト\n\n## EUF: Equality Logic With Uninterpreted Functions\n [SMT: Equality Logic With Uninterpreted Functions](https://www21.in.tum.de/teaching/sar/SS20/6.pdf)\n\t\t[ミュンヘン工科大学の夏学期の自動推論に関する授業](https://www21.in.tum.de/teaching/sar/SS20/) の資料で、EUF だけでなく CDCL から Bit Vectors に関する話までいろいろ PDF が用意されている\n\tSMT-LIB-benchmarks / QF_UF · GitLab https://clc-gitlab.cs.uiowa.edu:2443/SMT-LIB-benchmarks/QF_UF\n\t\tQF_UF のベンチマーク用入力が大量に用意されている\n\n\n[参考資料まとめ - smt-d (scrapbox.io)](https://scrapbox.io/smt-d/%E5%8F%82%E8%80%83%E8%B3%87%E6%96%99%E3%81%BE%E3%81%A8%E3%82%81)\n[_pdf (jst.go.jp)](https://www.jstage.jst.go.jp/article/jssst/27/3/27_3_3_24/_pdf)\n\n\n形式手法\n- モデル検査\n- 定理証明支援系","lastmodified":"2022-10-26T11:26:57.363934457Z","tags":null},"/other/Application/SAT-SMT/proof_assistant":{"title":"定理証明支援系","content":"\n## 説明\n\n\n## 計算量\n\n\n## 実装\n\n\n## 使用例\n\n\n## 参考\n[一人Computer Science Advent Calendar 2017](https://qiita.com/advent-calendar/2017/myuon_myon_cs)\n","lastmodified":"2022-10-26T11:26:57.363934457Z","tags":null},"/other/Application/SAT-SMT/symbolic_execution":{"title":"シンボリック実行エンジン","content":"\n## 説明\n\nプログラム上で目的の地点に到達したいとき、それに当てはまるような入力値の条件を数学的に解くプログラム。条件分岐ごとに条件式を追加してそれをSMTソルバに解かせる。\n\nConcolic Execution\nSSA形式とCFGが対応する\nTaint 解析\n\n## 計算量\n\n条件分岐数を $N$ として $O(2^N)$\n\n## 実装\n\nレジスタ, メモリに関する制約とSSA形式のIRを条件式としてSMTソルバで解く。\n- [Rustでの実装 (mini_symbolic)](https://github.com/anko9801/mini_symbolic)\n\n## 使用例\n\nシンボリック実行エンジンのプロジェクト angr のサンプルコード。\n\n```python\nimport angr\nimport logging\n\nbinary_path = './chall'\n\ntarget = angr.Project(binary_path, main_opts={'base_addr': 0x10000})\nlogging.getLogger('angr').setLevel(logging.CRITICAL)\nentry_state = target.factory.entry_state()\nsimulation = target.factory.simulation_manager(entry_state)\nsimulation.explore(find=0x000115b1, avoid=0x000115c4)\nfor sf in simulation.found:\n    print(sf.posix.dumps(0))\n\nsolution - simulation.found[0].posix.dumps(0)\nprint(solution)\n```\n\n## 参考\n\n- [バイナリ萌えの彼女がシンボリック実行に恋着してますが、制約に挑む幼気な表情が最高です！（１）](https://speakerdeck.com/katc/bainarimeng-efalsebi-nu-gasinboritukushi-xing-nilian-zhao-sitemasuga-zhi-yue-nitiao-muyou-qi-nabiao-qing-gazui-gao-desu-1)\n- [Girls Meets Symbolic Execution: Assertion 2. Automated Exploit Generation](https://speakerdeck.com/katc/girls-meets-symbolic-execution-assertion-2-automated-exploit-generation)\n- [実装して学ぶ Symbolic Backward Execution](https://speakerdeck.com/katc/shi-zhuang-sitexue-bu-symbolic-backward-execution-aceefce8-d25e-4db0-8ebb-d648bb2c41cd)\n- [プログラム解析入門、もしくはC/C++を安全に書くのが難しすぎる話 - Google スライド](https://docs.google.com/presentation/d/1WHmCLeC5ZPiq2MBOQaZc-pNVWaJanx8eXAkViGl2zws/edit#slide=id.g135752f5899_0_673)\n","lastmodified":"2022-10-26T11:26:57.363934457Z","tags":null},"/other/Application/Server/AWS":{"title":"AWS","content":"\n\n[7777 - Your remote AWS database on your local port 7777](https://port7777.com/)\n","lastmodified":"2022-10-26T11:26:57.363934457Z","tags":null},"/other/Application/Server/RDBMS":{"title":"RDBMS","content":"\n### データベースとは\n- [B-Tree/B+Tree](https://qiita.com/kiyodori/items/f66a545a47dc59dd8839)LSMツリーと呼ばれる平衡N分木で構築されたデータの集合。メモリ/実行時間最適化、排他制御をよしなにやってくれます。\n- やり取りに人間がわかりやすい言葉`DDL(Data Definition Language) DML(Data Manipulation Language) DCL(Data Control Language)`を使ってDBを操作します。例えば`Structured Query Language(SQL)`などがあります。\n- データベースシステムとSQLはごっちゃにして言われやすいので注意。例えば、MariaDBはMySQLから派生した`Relational Database Management System(RDBMS)`の一種だとか、`Not only SQL(NoSQL)`はクラウドのDBに対してネットワーク伝送コストを避けて最適化された非RDBMSで、MongoDBやAWSのDynamoDB, Redisがそれに含まるなど。\n\n### 具体的にどんな処理がされているのか\n\n工事中\n:::spoiler\nhttps://zenn.dev/tzkoba/articles/bb6d31d46be8b3\n\n\nコネクションプール\nクエリパーサ\nクエリーキャッシュ\nクエリプランナー\nクエリエクスキュータ\nアクセスメソッド\nバッファプールマネージャ = ストレージエンジン?\nディスクマネージャ\n\n[実行順序](https://qiita.com/k_0120/items/a27ea1fc3b9bddc77fa1)\nFROM句\nJOIN句\nWHERE句\nGROUP BY句\nHAVING句\nSELECT句\nORDER BY句\nLIMIT句\n\n\nアクセスメソッドCRUD\n\nmemcached\nRedis\n\nレプリケーション\n\nテンポラリーテーブル\n\nクラッシュリカバリ\nRedundant Array of Independent Disks\nRAID 0・RAID 1・RAID 5、およびこれら3方式の組み合わせが用いられている。後にRAID 5を拡張したRAID 6が定義され、RAID 5より耐障害性が必要な場面で利用されている。\n二重書き込みバッファー\nトランザクションログ\n\nクラスタデータベース\nセカンダリインデックス\nキー　セカンダリキー　バリュー　プライマリーキー\nクラスタードインデックス\nテーブルをB+Treeに入れる\n\nMemcomparable format\n\n[ProxySQL](https://qiita.com/yoan/items/ba62dd65b24ac1b6a458)\n\nシリアル　数字の羅列\nシーケンス　順番に並ぶ数字列\n\n負荷分散技術\n水平分割(シャーディング)　レコード単位で分割\n垂直分割　カラム単位で分割\n\nワークラウンド　回避策\nワークロード　仕事量\n\nストレージエンジン\nデータ変換\nインデックス\nメモリ利用\nトランザクション\n同時実行性(排他制御)\nユニークファンクション（MyISAMの空間情報インデックスなど）\ninnoDB : MySQLでもっとも汎用のストレージエンジン\n\nACID\nA: 原子性\nC: 一貫性\nI: 分離性\nD: 持続性\n\nMySQL InnoDB memcached Plugin\nhttps://qiita.com/hypermkt/items/ccfb47e69c4a6a3ce09a\nプラグインって何のプラグイン？\nこれってmemcachedと何が違うの\n\n\nMEMORY ストレージエンジン\nhttps://dev.mysql.com/doc/refman/5.6/ja/memory-storage-engine.html\nストレージエンジンをMEMORYにするのはかなり注意が必要(NaruseJunがそれでメモリ使い果たして鯖爆破していたはず)\n\nINVISIBLE COLUMNS \\*でとりだされない\nINSERT RETURNING\nFOREIGN KEY https://www.dbonline.jp/mysql/table/index11.html\n:::\n\n### Collation(照合順序)\n文字列をどうエンコーディングしてB+ツリーにどうソートして突っ込むかを設定できます。DB単位、テーブル単位、カラム単位で設定可能。\n\n```\nCREATE TABLE `utf8mb4_test`.`utf8mb4_test` (\n  `id` int(10) NOT NULL AUTO_INCREMENT,\n  `str` varchar(1000) COLLATE utf8mb4_bin NOT NULL,\n  PRIMARY KEY (`id`),\n  KEY `str` (`str`(767))\n) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_bin;\n```\n`文字コード_言語名_比較法`\n\n#### 文字コード(Character Set)\nutf8とかeucとかが入ります。\ncp932やbig5などは危険なエンコーディングらしい(しらんけど)\n\nconoHaがこれでやらかしていたらしい\ntraP SysAd TechBook より\nデータベースメンテナンスで⼤わらわ！\n\n2019年8⽉6⽇夜 ConoHaのマネージドDBでメンテナンスがありました。SysAd班で\nはメンテナンスの存在を知らず、急にtraQなどが機能しなくなったため⼀瞬混乱が起き\nました。しかしその後すぐ、@takashi_trapがメンテナンスであることをアナウンスし混乱\nは収束しました。\nしかし、本当の混乱はメンテナンス後に発⽣したのです。traQの復旧によりメンバー\nがtraQに戻ってきたのですが、下のような投稿がいろんなチャンネルで出始めたので\nす。\n図2.6: 表⽰名が壊れたメンバーの投稿（修正後スクリーンショットを撮った）\nその後すべてのサービスのデータを確認してみると、すべてのサービスで⼀部の絵⽂\n字データが破損していることが確認されました。班内で検討したところ、おそらく「寿司ビ\nール問題」として有名な、utf8mb4のデータをutf8として扱ってしまったことによる4バイト\n⽂字の破損であるだろうという結論に⾄りました。\nConoHaに問い合わせてみましたが、私達の推測通りメンテナンスではマシンの⼊れ\n替えのためにデータのバックアップを⾏なっており、その際にutf8でバックアップを取っ\nたとのこと。ConoHa側が持っている完全なバックアップは2⽉時点のものでそれ以降の\nデータを復旧することは不可能であると回答がありました*3。外部に公開されている\nBlogサービスのみ、たまたま2週間ほど前にBlogサービスのバージョンアップ検証を⾏\nうために取っていたバックアップから差分を復旧することで対処しました。\nまさかこんなことってあるんですねぇ……となった事件でした\n\n#### 言語名\njapaneseやthaiやgeneral、unicodeなどが入ります。\ngeneralやunicodeはマルチリンガルの事(utf8にjapaneseはない)。\n\n#### 比較法\n`_ci _cs _bin`のいずれか(で終わる)\n\n\\_ci: 大文字と小文字が区別されない\n\\_cs: 大文字と小文字が区別される\n\\_bin: バイナリ\n\n#### utf8_general_ciとutf8_unicode_ciの使い分け\nunicode の方はあいまいな照合が可能です。全角、半角、大文字、小文字を無視して一致するものを検索できます。\n\nたとえば、検索文字に`MySQL`を指定した時と、`ｍｙｓｑｌ`を指定した時の検索結果は同じになります。\n\ngeneral の方はその逆で、厳密に違いとして認識され先の例の検索結果は異なります。\n\nどちらも項目の用途によって使い分けるのが、あるべき姿なのでは無いかと思います。\n\n`utf8mb4_bin`のが`utf8mb4_general_ci`より少しはやいらしい https://yakst.com/ja/posts/5431\nMySQL8なら`utf8mb4_0900_bin`を試してみる https://qiita.com/hmatsu47/items/d66830c8a00c21f5edad\n\n\n### トランザクション\nINSERT, UPDATE文を複数送るとき、その一部だけがデータベースに反映されると、一時的にせよ、データベース全体としてデータが不整合な状態となります。トランザクションを使うことでそれらを同時に実行させられます。\n\nBEGINから始まりCOMMIT/ROLLBACKで終わる。\n\nWAL(Write Ahead Logging)\n\nTODO: FOR UPDATEとの違い\nFOR UPDATE（先行して行ロックを獲得したトランザクションがロックを開放する/ロックがタイムアウトするまで待たされる）\nNOWAIT（ロックが獲得できなかったときは即時にエラーを返す）\nSKIP LOCKED（即時に獲得可能なロックのみ獲得して結果を返す）\nhttps://www.informit.com/articles/article.aspx?p=29312\n- [ネストさせたいときはSAVEPOINT](https://qiita.com/_natsu_no_yuki_/items/e1db2a132cbff740896d)\n\n| BEGIN文  | SAVEPOINT文                |\n| -------- | -------------------------- |\n| BEGIN    | SAVEPOINT hoge             |\n| COMMIT   | RELEASE SAVEPOINT hoge     |\n| ROLLBACK | ROLLBACK TO SAVEPOINT hoge |\n\n```go\ntx, err := db.Begin()\nif err != nil {\n\tlog.Println(err)\n}\n\n_, err = tx.Exec(\"INSERT INTO test_user(name) VALUES(?)\", \"TRANS\")\nif err != nil {\n\tlog.Println(err)\n}\n\n// run something\n\nif err != nil {\n    // もとの状態に戻す\n    err = tx.Rollback()\n\tif err != nil {\n\t\tlog.Println(err)\n\t}\n} else {\n    // クエリを実行する\n    err = tx.Commit()\n\tif err != nil {\n\t\tlog.Println(err)\n\t}\n}\n```\n\n### PreparedStatement\nINSERT文など値は違えど同じクエリを大量に実行したいとき毎回クエリを解析せず最初に1回解析すれば後はそれを使い回して高速化しようという機能です。(多分パースしてクエリプランナーに突っ込んだ状態にしてあるだけ)\n\n- Go標準のSQLパッケージはプレースホルダを用いたクエリは暗黙的にPreparedStatementを使っている\n- 同じクエリではないとき段階を踏む上でコストが掛かり遅くなる(ADMIN PREPAREが多くなる)\nそこで`interpolateParams=true`を使ってPreparedStatementを減らせる\nhttp://dsas.blog.klab.org/archives/52191467.html\n- トランザクション中にPreparedStatementするときは先にCloseしてCommitしないと不整合が起こる\n- クエリのプレースホルダーはSQLインジェクション対策にもなる。fmt.Sprintf()で作らないようにする。\n```go\n// interpolateParams=true\ndb, err := sql.Open(\"mysql\", \"root:password@tcp(localhost:3306)/test?interpolateParams=true\u0026collation=utf8mb4_bin\")\n// SQL文を受け取って解析し、値があればいつでも実行できる状態にする\nstmt, err := db.Prepare(query)\nif err != nil {\n    return\n}\n// PreparedStatementを関数の終わりで終了させる\ndefer stmt.Close()\n// SQL文に必要な値をセットして実行\nstmt.Exec(value)\n```\n\n### 生成カラム(generated column)\n\nhttps://qiita.com/hmatsu47/items/128ece7276e4deac1477\n他のカラムのデータを使って新しいカラムを作る\n- VIRTUAL トランザクションが入ったときにデータを生成する\n- STORED INSERTしたときにデータを生成する\n\nNOT NULLを用いれば制約に合わないものがきたらエラーを吐かせて、データに制約を作ることができる\nCHECKでやれって話\nhttps://yakst.com/ja/posts/2834\nVIRTUALのとき仮想列と呼びそれを使ったINDEXを仮想インデックスと呼ぶ\nこの設計において、仮想列は簡単に追加して削除することができ、かつテーブル全体をリビルドする必要もない。これにより関連するテーブルのスキーマ変更がとても簡単かつ高速になる。\n\n高速な仮想列の管理\n`mysql\u003e ALTER TABLE t ADD new_col INT GENERATED ALWAYS AS (a - b) VIRTUAL;`\n\n### メモリ最適化\n\nhttps://dev.mysql.com/doc/refman/5.6/ja/data-size.html\n`MEDIUMINT` `INT`の25%削減\n`NOT NULL` null確認の処理がなくなる\n\nできるだけ少なく\nhttps://phpjavascriptroom.com/?t=mysql\u0026p=columntype\n\n### キーキャッシュ\nMyISAM\nhttps://dev.mysql.com/doc/refman/5.6/ja/myisam-key-cache.html\nテーブルブロックとは？\n\nページングに注意すべきキャッシュ\nInnoDB バッファプール\nMyISAM キーキャッシュ\nMySQL クエリーキャッシュ\n\n頻繁な更新を実行するアプリケーションでは、多くの場合に少数のカラムのある多数のテーブルを使用し、大量のデータを解析するアプリケーションでは、多くの場合に多数のカラムのある少数のテーブルを使用します。\n\n正規形\n\nInnoDB は、ほとんどのデータまたはすべてのデータをメモリーに保持する汎用的で永続的な方法を提供\n\ntmpfs\nセッションとは？\n\n### ORM O/Rマッパー\n開発効率を上げる為のSQLのラッパー(クエリービルダー)\nex.) gorm\n\n### isolation level\n複数のトランザクションが1つのテーブルを操作するときの不整合についてどの程度許容するか\n1. READ UNCOMMITTED ... COMMIT されてないトランザクションの変更を参照できる\n2. READ COMMITTED ... COMMIT されたトランザクションの変更を参照できる\n3. REPEATABLE READ ... COMMIT されたトランザクションの追加を参照できる\n4. SERIALIZE ... 参照不可\n\n2以降を実現する為には `SELECT` で共有ロック, `UPDATE` `INSERT` で専有ロックを取得すればよい. ロックの取得はパフォーマンスを下げるのでなるべくしたくない. そこでMVCC .\n\n### MultiVersion Concurrency Controll: MVCC\n\n- `DB_ROW_ID` ... 行ID\n- `DB_TRX_ID` ... 最後にupdateしたトランザクションID\n- `DB_ROLL_PTR` ... レコードの過去の値を持つundo log recordへのポインタ\n\n参照トランザクションIDが `DB_TRX_ID` より大きいなら変更後の値を参照, 小さいなら undo log record から探して参照, 追加したトランザクションIDより小さいなら参照できない.\n\n[MySQLのMVCC - Qiita](https://qiita.com/nkriskeeic/items/24b7714b749d38bba87b)\n\n### Conflict-free replicated data type\n\nCAPの定理\n-   Partition Tolerance: ネットワークが故障しても\n-   Consistency: データの整合性をもって\n-   Availability: 読書が常にできる\n\n3つ同時に満たすことはできなくて、満たせても2つまでという定理\n\nAPを満たす -\u003e Conflict-free replicated data type\n\n可換な操作のみ扱い、後でマージする -\u003e ネットワークに繋がっていなくても操作可能！\nそれぞれのDBがgitのブランチみたいな気持ち\n","lastmodified":"2022-10-26T11:26:57.363934457Z","tags":null},"/other/Application/Server/frontend-optimization":{"title":"フロントエンド最適化","content":"\n## Web Performance\nlighthouse\n\n## 先読み/遅延読み込み\n[Resource Hints](https://www.w3.org/TR/resource-hints/)\n[Priority Hints](https://chromestatus.com/feature/5273474901737472)\nリソースの優先度をブラウザに認識させ、読み込み順序を最適化できます。初期画面に必要なリソースの読み込みが後方にある場合、その分LCPやFIDが遅延することになります。\nlink `rel=preload`\nscript `async/defer`\nimg/iframe `loading=\"lazy\"`\n\n## 配信削減\n### 圧縮\ngzip\nbrotli圧縮\n\n画像のリサイズ・クリッピング\nJPEG -\u003e Webp -\u003e AVIF\nGIF -\u003e WebM(VP9) -\u003e WebM(AV1)\n\nwebpack: production\nWebpackPlugin\nminifier\n- css-minimizer-webpack-plugin\n\n### CSS/JSのバンドルサイズを削る\n計測方法\n- [You might Not Need Lodash](https://youmightnotneed.com/lodash/)\ntailwind cssのpurge\n不要なwebfontのcssの削除\n\n## Cache\n`Cache-Control: public, max-age=604800, immutable`\nついでに動的な部分でも`Cache-Control`から`no-transform`を取り除きました。それと、`Connection: close`を取り除きました。\n\n## 配信距離\nCloudFlare\nキャッシュ\n\nTCP/IP スロースタート時のパケット数10\nステータスコード 1kB\n1.5kB * 10回 - 1kB = 14kB\n14kB以下なら高速\n[ウェブサイトのファイルサイズは14kB以下にすべきという指摘、その理由とは？ - GIGAZINE](https://gigazine.net/news/20220828-website-should-be-under-14kb/)","lastmodified":"2022-10-26T11:26:57.363934457Z","tags":null},"/other/Application/Server/kernel-optimization":{"title":"","content":"## カーネルパラメータ チューニング\n\n[【Linux】カーネルパラメータのパフォーマンスチューニングについて](https://ac-as.net/kernel-parameter-performance-tuning/)\n\n### ファイルディスクリプタの上限\n\n`ulimit -l 10000`\n\nsshだとulimitできない\nhttps://yohei-a.hatenablog.jp/entry/20090310/1236706236\n\nhttp://ramblog.blog129.fc2.com/blog-category-4.html\n\n```\n# /etc/systemd/system/*.service\n[Service]\nLimitNOFILE=65535\n```\n### カーネルパラメータ\n\n上ほど優先順位高い(同じ名前のfileをoverrideする)\n`/etc/sysctl.d/*.conf`\n`/run/sysctl.d/*.conf`\n`/usr/lib/sysctl.d/*.conf`\nすべての設定ファイルは、どのディレクトリにあるかに関わらず、ファイル名の並び順で辞書順にソートされます。複数のファイルが同じオプションを指定している場合は、辞書的に最新の名前を持つファイルのエントリが優先されます。ファイルの順序を簡単にするために、すべてのファイル名の前に 2 桁の数字とダッシュを付けることをお勧めします。\n\n```\n# /etc/sysctl.d/100-isucon.conf\n# maxconnection を増やす\nnet.core.somaxconn = 32768                  # 32768 (2^15) くらいまで大きくしても良いかも。\nnet.ipv4.ip_local_port_range = 10000 60999  # port の範囲を広げる\n\n# tcp connection の再利用を有効化\nnet.ipv4.tcp_tw_reuse = 1\n\n# tcp connection が FIN-WAIT2 から TIME_WAIT に状態が変化するまでの時間\nnet.ipv4.tcp_fin_timeout = 10               # デフォルト 60。CPU 負荷を減らせるが、短すぎると危ういかも？\n\n# TIME_WAIT状態にある tcp connection 数の上限\nnet.ipv4.tcp_max_tw_buckets = 2000000       # デフォルトは 32768(=2^15) くらい\n\n# パケット受信時にキューにつなぐことのできるパケットの最大数\nnet.core.netdev_max_backlog = 8192          # デフォルトは 1000 くらい\n\n# 新規コネクション開始時のSYNパケットを受信した際の処理待ちキューの上限値\nnet.ipv4.tcp_max_syn_backlog = 1024         # デフォルトは 128 くらい\n\n# window size scalingの有効化(ネットワークの帯域幅とメモリ使用量のトレードオフ)\nnet.ipv4.tcp_window_scaling = 1             # デフォルトで1になっているはず\n# すべての種類のsocketに基本設定されているbufferのsize デフォルトは 212992(=13*2^14) くらい\nnet.core.rmem_default = 253952\nnet.core.wmem_default = 253952\nnet.core.rmem_max = 16777216\nnet.core.wmem_max = 16777216\n# TCP socket buffer sizeの変更 デフォルトは 212992(=13*2^14) くらい\nnet.ipv4.tcp_rmem = 253952 253952 16777216  # min / default / max\nnet.ipv4.tcp_wmem = 253952 253952 16777216  # min / default / max\n# TCP用に使用できる合計メモリサイズを指定\nnet.ipv4.tcp_mem = 185688 247584 371376     # min / pressure / max; pressureの値を超えるとTCP memory pressureの状態になり、以降ソケットは指定されたmin値のメモリバッファのサイズを持つようになる\n\n# カーネルレベルでのファイルディスクリプタ上限数変更\n# プロセス単位のチューニングをやったけど、こっちもやっておく\nfs.file-max=65535\n\n# 3-way-handshakeの簡略化\n# 相手側のサーバーがONにしていないとデータが2回送られてオーバーヘッドになるので一回やってみてスコアが上がらなかったら切る\nnet.ipv4.tcp_fastopen = 3\n\n# 輻輳制御アルゴリズム TCP BBR の有効化\n# `uname -r`が4.9以上で`sysctl net.ipv4.tcp_available_congestion_control`にbbrが含まれている場合　\n# net.ipv4.tcp_congestion_control = bbr # 輻輳制御アルゴリズムをbbrに\n# net.core.default_qdisc = fq # キューイングアルゴリズムをfqに\n```\n\nhttps://html5experts.jp/jxck/3529/\nhttps://ac-as.net/kernel-parameter-performance-tuning/\nφ(.. )ﾒﾓｼﾃｵｺｳ /proc/sys/net/ipv4/tcp_fastopenに設定する内容とか実装\nhttps://kernhack.hatenablog.com/entry/2013/05/25/115634\n\n","lastmodified":"2022-10-26T11:26:57.367934441Z","tags":null},"/other/Application/Server/rdbms-optimization":{"title":"バックエンド最適化","content":"\n\nCache\n\nCopy on Write\n[An Overview of Query Optimization in Relational Systems 論文紹介 - Google スライド](https://docs.google.com/presentation/d/1ruGYLRLeagkfv1gQBlmh_di7AviaSx0MJih4oH24AsY/edit#slide=id.p)\n\nO/R Mapper\n\n# ISUCONメモ\n\nhttps://github.com/FujishigeTemma/isucon9-qualify/blob/master/go/main.go\nhttps://github.com/tohutohu/isucon9/blob/master/webapp/go/main.go\n\nhttps://www.youtube.com/watch?v=0DhBLswwcRs\n\nhttps://gist.github.com/941/8c64842b71995a2d448315e2594f62c2\nhttps://gist.github.com/south37/d4a5a8158f49e067237c17d13ecab12a\nhttps://isucon.net/archives/54822761.html\n\n## 事前講習\n\n工事中\n:::spoiler\nssh接続\nssh鍵\ngithubで公開リポジトリに置くと失格\nマニュアルを全員読む(情報をまとめることが得意な人がいたら)\n初期ベンチ\nベンチの振れ幅、挙動を調べる\n1コミット1ベンチ\nコミットコメントにログとか載せると良き\nキャッシュが必要以上に残るとフェイル\nタイムアウトか間違ったキャッシュならタイムアウトを取る\n\n変更するファイル\nwebapp/go\nwebapp/sql\n各種設定ファイル\nnginxやmysqlの設定などはgit内に移して元の場所にシンボリックリンクを貼る\n\n\n\n### 開始直後\n\nマニュアルを全員で読む\n- 点数に関わる記述が重要情報\n- キャッシュの許され方\n    - 「N秒キャッシュしてもよい」と書いてある\n\n不要なデーモンを止める\n```\ncat /proc/cpuinfo\nfree -h\nsystemctl list-units --type=service --state=running\n```\n\nssh configの設定\nベンチ1回目\nリポジトリ内にシンボリックリンクを置く\ngit init git remote git add . git commit -m \"Initial commit\"\nお昼食べる\n利用するサイトの動作確認\n忘れて無ければ全ページのスクショを撮る\nラストのチェックのときにCSSとかをざっと見る\n使いそうなファイル群を固めてローカルに持ってくる\ntar xvcf webapp\nscp user@ip:~/webapp.tar .\n更新箇所のチェック\nエンドポイントの数\n更新があるエンドポイント\nmysqlとnginxのログ設定\n解析ツールのインストール\nベンチ2回目\n秘伝のタレ\nベンチ3回目\n\n```\nINDEX idx_category_id_created_at (category_id,created_at),\nINDEX idx_created_at (created_at),\nINDEX idx_buyer_id (buyer_id),\nINDEX mul_idx_seller_id_created_at (seller_id, created_at)\n```\nhttps://github.com/reyu0722/piscon2021\n- ItemとかUserとかで取れる部分はキャッシュする -\u003e 71500\n- Item以外をメモリだけで管理するようにした (他にもいくつか) -\u003e 87840\n    - 超大変だった\n:::\n\n## 各種解析ツール 推測するな計測せよ\n\n### パフォーマンスモニタリング\nCPU占有率の高いプロセスを特定します\nhtop dstat\ndstat -tlamp\n\n### メトリクス\n高級なパフォーマンスモニタリングツール\n[netdata](https://github.com/netdata/netdata) NewRelic Splunk\nhttps://dev.classmethod.jp/articles/netdata/\n\n### アクセス解析\nパスパラメータ/クエリパラメータ別のアクセス数を表示してくれます\n主に見るべきはavg 次にcount\nkataribe **[alp](https://github.com/tkuchiki/alp)**\n\n### プロファイリング\n**pprof** fgprof\n\n### スロークエリ\nmysqldumpslow **pt-query-digest**\n\n### SQL全般\n**[percona tool kit](https://www.s-style.co.jp/products/percona/toolkit)**\n[mysqltuner](https://github.com/major/MySQLTuner-perl)\n\n### Makefile\nTODO: 秘伝のMakefileを作る\nhttps://gist.github.com/azonti/dee0547cb561dfdec4a90e093a418bdc\nhttps://github.com/FujishigeTemma/isucon10-final/blob/master/Makefile\nhttps://github.com/tohutohu/isucon9/blob/master/Makefile\nhttps://git.trap.jp/eiya/202008piscon/src/branch/master/go/Makefile\n\n## アプリ\n\n- クエリ最適化\n- 変更の少ないデータのキャッシュ化\n- やらなくてよい処理を省く\n- 強いセキュリティを弱くして高速化(gorilla/sessions-\u003e自前実装 net/http-\u003efasthttp bcrypt-\u003eSHA256など)\n- APIの並列化\n- FOR UPDATEアプリケーションで排他制御\n- gollira/sessionはセキュアなセッションをcookieだけで実現しているので、暗号化のコストが結構かかる -\u003e ランダムな値とmapを使った実装に差し替え\n- jsonのエンコード/デコードをgo-json\n\n### プロファイラの設定\n\n#### pprof https://github.com/google/pprof\n標準で入っているプロファイラです。デファクトスタンダードという感じ。\n```go\nimport _ 'net/http/pprof'\n\nfunc main() {\n    go func() {\n        http.ListenAndServe(\":6060\")\n    }()\n\n    // \u003ccode to profile\u003e\n}\n```\nプロファイリングした画像をdiscordやslackに届けるシェルです。\n```shell\ngo tool pprof -png -output pprof.png http://localhost:6060/debug/pprof/profile?seconds=60\ncurl -X POST -F img=@pprof.png $(DISCORD_WEBHOOK_URL)\nslackcat --channel general pprof.png\n```\n\n#### fgprof https://github.com/felixge/fgprof\n一部適切な表示とならないことがある\n```go\nimport (\n    \"net/http\"\n    _ \"net/http/pprof\"\n    \"github.com/felixge/fgprof\"\n)\n\nfunc main() {\n    http.DefaultServeMux.Handle(\"/debug/fgprof\", fgprof.Handler())\n    go func() {\n        log.Println(http.ListenAndServe(\":6060\", nil))\n    }()\n\n    // \u003ccode to profile\u003e\n}\n```\n\n`http://localhost:6060/debug/fgprof`\n\n## MySQL チューニング\n\n### MySQL設定\n\n別のサーバーからDBへアクセスできるようにする\n`/etc/mysql/mysql.conf.d/mysqld.cnf`\n`bind-address = 127.0.0.1`をコメントアウト\n`bind-address = 0.0.0.0`\n\nhttp://dsas.blog.klab.org/archives/50860867.html\n- グローバルバッファ mysqld全体でそのバッファが1つだけ確保されるもの\n- スレッドバッファ スレッド(コネクション)ごとに確保されるもの\nチューニングの際にはグローバル/スレッドの違いを意識するようにしましょう。 なぜなら、スレッドバッファに多くのメモリを割り当てると、コネクションが増えたとたんにアッという間にメモリ不足になってしまうからです。\n\n```\nmax_connections=1024\nquery_cache_type=ON\n# innoDB全体で一つ生成されるグローバルバッファ(別鯖なら搭載メモリの80%)\ninnodb_buffer_pool_size = 1GB\n# InnoDBの内部データなどを保持する足りないとエラーログが出るからその時増やす\n#innodb_additional_mem_pool_size = 30MB ←これあるとダメ\n# innoDBの更新ログを保持するメモリ\ninnodb_log_buffer_size = 16MB\n# innodb_log_fileがいっぱいになると、メモリ上のinnodb_buffer_poolの中の更新された部分のデータを、ディスク上のInnoDBのデータファイルに書き出すしくみになっているから\ninnodb_log_file_size = 128MB\n# ORDER BYやGROUP BYのときに使われるメモリ上の領域\ninnodb_sort_buffer_size = 4MB\nread_rnd_buffer_size = 2MB #\nkey_buffer_size = 256MB\n# 1に設定するとトランザクション単位でログを出力するが 2 を指定すると1秒間に1回ログを吐く。0だとログも1秒に1回。TODO違いをみる\ninnodb_flush_log_at_trx_commit = 0\ninnodb_flush_log_at_trx_commit = 2\n# データファイル、ログファイルの読み書き方式を指定する(実験する価値はある)\ninnodb_flush_method = O_DIRECT\n# 再起動試験対策\ninnodb_buffer_pool_dump_at_shutdown = ON\ninnodb_buffer_pool_load_at_startup = ON\n```\n\n```\n$ mysql -u isucari -p\npass: isucari\n$ sudo journalctl -u isucari.golang\nsudo rm /var/log/mysql/mysql-slow.log\nsudo systemctl restart mysql\nsudo rm /var/log/nginx/access.log\nsudo nginx -t\nsudo systemctl reload nginx\ncd ~/isucari/webapp/go\nmake\ncd -\nsudo systemctl restart isucari.golang\n```\n\n### スロークエリ\n\n`/etc/mysql/mysql.conf.d/mysqld.cnf`\n```bash\nslow_query_log=1\nslow_query_log_file=/var/log/mysql/mysql-slow.log\nlong_query_time=0 # 全てのクエリを書き込んで解析ツールに渡す\nlog_queries_not_using_indexes=1 # インデックスを使っていないクエリも出力する\n```\n`sudo mysqldumpslow -s t -t 10 /path/to/slow.log`\n`pt-query-digest /path/to/slow.log`\n\n複数のSQLクエリをIN、JOIN、LIMIT句、外部キーでまとめる(N+1問題など)\n不要なカラムやクエリを削除する\n転送量を減らす。取得するカラムを減らす、特にでかいもの(`VARCHAR(4096)`など)が入っているのは削るべき\nhttps://qiita.com/ikenji/items/b868877492fee60d85ce\n\n**INDEX**\nB+ツリーのインデックスを適切に設定することで検索速度を高める。二分探索ができるものなら速くなる。\n更に言えば上記のBツリーインデックスとハッシュインデックスが存在し、ハッシュインデックスの方が速いが、等価比較しかできない。MySQLは自動的にそれらの選択をしている。\nこれが多すぎるとINSERTでくそおもになるので注意\n\nここで役立つコマンド\n`mysql -uユーザ名 -pパスワード DB名 -e'EXPLAIN ~~;'`\n\nLIKEも最初の方がワイルドカードではなければ使える\n- 速くなるもの WHERE, ORDER BY, JOIN句\n- 効かないもの LIKE, OR, 演算, 関数処理, IS NULL, 否定形\n- NOT NULLを出来る限りつける\n- ORをUNION/UNION ALLに変換する\n- ORDER BYでDESCとASCの混合-\u003eMySQL 8.0では[降順インデックス](https://dev.mysql.com/doc/refman/8.0/ja/descending-indexes.html)で適用できる\n- [空間インデックス](https://dev.mysql.com/doc/refman/8.0/ja/creating-spatial-indexes.html) `SRID 0`を付ける https://matsuu.hatenablog.com/entry/2020/09/13/131145\n\nプレフィックスインデックス\n非常に長い文字列にインデックスを付ける必要がある場合、値全体ではなく最初の数文字にインデックスを付けることで、記憶域を節約し、パフォーマンスを改善することができます。\n- プレフィックスインデックスでは、選択性も低下するため、十分な選択性が得られる長さを持ち、記憶域を節約するくらい短いプレフィックスを選択すること\n- 欠点として、ORDER BY 句や GROUP BY 句を使用するクエリにプレフィックスインデックスを使用できない\n- 適切なサイズは、下記クエリで選択性を計測し、収束する値を見ることで発見できる。選択性とは、インデックス付けされた値の数と、テーブル内の行の合計数の比率のこと\n\nマルチインデックス\n[クエリ文がINDEX作成時のカラム順に基づいていないと、INDEXが使えない](https://qiita.com/rm-rf-slant/items/8023500788352646b6c2)\n- 等しい (=)、より大きい (\u003e)、より小さい (\u003c)、BETWEENなどの検索条件のWHERE句で使用されるか、結合に含まれる列を、先頭に配置する\n- クエリによるカラム順序の制限がない場合、最も選択的な列をインデックスの先頭に配置する。カラム毎の選択性は下記クエリで計測する\n- ちゃんと出来てないとEXPLAIN type=index:フルインデックススキャンと言われる\n1種類の値に対し多くのデータが存在するようなカラムを先に置く\n重複の多いものを先に置く\nそれに伴うようにクエリのカラムを先に置く\n\nhttps://lukesilvia.hatenablog.com/entry/20080315/1205583930\nUsing filesort\nレコードをソートして取り出す方法を決定するには、MySQL はパスを余分に実行しなくてはならないことを示す。 join type に従ってすべてのレコードをスキャンし、WHERE 条件に一致する全てのレコードに、ソートキー + 行ポインタを格納して、ソートは実行される。 その後キーがソートされる。 最後に、ソートされた順にレコードが取り出される。\n\nUsing temporary\nクエリの解決に MySQL で結果を保持するテンポラリテーブルの作成が必要であることを示す。これは一般に、GROUP BY を実行したカラムセットと異なるカラムセットに対して ORDER BY を実行した場合に発生する。\nUNIONとかも...？\n\nhttps://qiita.com/katsukii/items/3409e3c3c96580d37c2b\nhttps://nishinatoshiharu.com/overview-multicolumn-indexes/\n\nインデックスオンリースキャン\nSELECTするカラムが少ないときINDEXにそのカラムを置くとそれを取ってくるだけでよい\n\n### クエリーキャッシュ Qcache\n※注意 [MySQL 8.0以降には存在しない](https://yakst.com/ja/posts/4612)\nメモリ上にクエリのバイト列とその結果を保存して再度同じ(大文字・小文字を区別する)クエリが来たらDBを探さずそれを返す。更新がかかるとキャッシュがフラッシュされる。\nディスクI/Oの多発の解決\nINSERT,UPDATEが少なくSELECTが多いアプリに有効\n\n[MySQL クエリーキャッシュ 【チューニング方法とかも】](https://qiita.com/ryurock/items/9f561e486bfba4221747)\n\n***\n\nSQLで画像を入れるとAXと呼ばれるやつが入るらしい\nhttps://stackoverflow.com/questions/52426874/how-do-i-extract-microsoft-sql-varbinarymax-field-to-image-using-golang\n\n`キーキャッシュのヒット率 = 100 - ( key_reads / key_read_requests × 100 )`\nmysqlをmariadbに変える? (あまり必要はない)\n\n```shell\n$ curl -LsS https://downloads.mariadb.com/MariaDB/mariadb_repo_setup | sudo bash\n$ sudo apt install mariadb-server\n$ #このあと/etc/mysql/mysql.conf.d/mysqld.cnfに書いてたやつを/etc/mysql/mariadb.conf.d/50-server.cnfに書く\n```\n\n~~proxysqlを利用する？~~ ~~mariadbなら~~そのままquery cache使えばよさそう\n\nhttp://dsas.blog.klab.org/archives/50860867.html\n\n### 再起試験対策\n1台目サーバと2台目サーバの再起動タイミングがずれるとアプリからのDB接続に失敗\n`/etc/systemd/system/isuumo.go.service`\n```\n[Service]\nStartLimitBurst=999 # 失敗して再起動するのを何回行うか デフォルトは5\n```\n\n再起動試験用DB待ち\n```go\npackage main\n\nimport (\n\t\"database/sql\"\n\t\"log\"\n\t\"time\"\n)\n\n// main関数内に置く\nwaitDB(db)\ngo pollDB(db)\n\nfunc waitDB(db *sql.DB) {\n\tfor {\n\t\terr := db.Ping()\n\t\tif err == nil {\n\t\t\treturn\n\t\t}\n\n\t\tlog.Printf(\"Failed to ping DB: %s\", err)\n\t\tlog.Println(\"Retrying...\")\n\t\ttime.Sleep(time.Second)\n\t}\n}\n\nfunc pollDB(db *sql.DB) {\n\tfor {\n\t\terr := db.Ping()\n\t\tif err != nil {\n\t\t\tlog.Printf(\"Failed to ping DB: %s\", err)\n\t\t}\n\n\t\ttime.Sleep(time.Second)\n\t}\n}\n```\n***\n\n#### golang\n```golang\ndbx.SetMaxIdleConns(1024) // デフォルトだと2\ndbx.SetConnMaxLifetime(0) // 一応セット\ndbx.SetConnMaxIdleTime(0) // 一応セット go1.15以上\n\n// goroutineを生やしすぎてもタイムアウトする https://www.sambaiz.net/article/61/\n// Keep-AliveするとTCPコネクションを使い回し、名前解決やコネクション(3 way handshake)を毎回行わなくてよくなる\nhttp.DefaultTransport.(*http.Transport).MaxIdleConns = 0 // 無制限 デフォルトだと100\nhttp.DefaultTransport.(*http.Transport).MaxIdleConnsPerHost = 1024 // 0にすると2になっちゃう\nhttp.DefaultTransport.(*http.Transport).ForceAttemptHTTP2 = true // go1.13以上\nhttp.DefaultClient.Timeout = 5 * time.Second // 問題の切り分け用\n```\n\nhttps://qiita.com/go_sagawa/items/11929cd0883608a6888d\n\n- redis\n```\nsudo add-apt-repository ppa:chris-lea/redis-server\nsudo apt update\nsudo apt install redis\n```\n`sudo nano /etc/redis/redis.conf`\n`bind 127.0.0.1 ::1`のコメントアウト\n`protected-mode yes`→`protected-mode no`\n`requirepass hogehoge`に\n```\nsudo systemctl unmask redis-server\nsudo systemctl enable redis-server\nsudo systemctl restart redis-server\n```\n`sudo echo never \u003e /sys/kernel/mm/transparent_hugepage/enabled`\n`sudo nano rc.local`→追記: `echo never \u003e /sys/kernel/mm/transparent_hugepage/enabled`\n\n### JSON\nhttps://github.com/json-iterator/go を試してみる\n```golang\nvar json = jsoniter.Config{\n    EscapeHTML:                    false,\n    ObjectFieldMustBeSimpleString: true,\n}.Froze()\n```\nhttps://github.com/francoispqt/gojay\nhttps://github.com/goccy/go-json\nhttps://github.com/minio/simdjson-go\nMarshal / Encoder: goccy/go-json \u003e francoispqt/gojay\nUnmarshal: francoispqt/gojay \u003e goccy/go-json\nDecoder: francoispqt/gojay \u003e\u003e goccy/go-json\n\n- メモリ上にキャッシュ\n    - `map`\n        - 読み込み書き込みともに多く行う -\u003e `sync.Map`\n        - 読み込み多く行う -\u003e `sync.RWMutex` + `map`\n        - ロックが気になるならシャーディングをするとよい\n            - https://github.com/orcaman/concurrent-map\n            - https://github.com/FujishigeTemma/isucon9-qualify/compare/6eaa28f77cb8bac674c0b8cfbf9794d91999d026...49cede08c6fcf59afa29857559d146abb1e96165\n            - 15～20個ずつになるくらいがよさそう？\n    - sessionメモリに持つ\n        - `gorilla/sessions`はコピーのために`encoding/gob`が無駄に呼び出される\n- singleflight\n    - `x/sync/singleflight`\n    - `sync.Map` + `sync.Cond`\n        - https://github.com/FujishigeTemma/isucon9-qualify/compare/2fb8ff382ce2f7b083ae9f343e5ae5d543bc5e65...6d3f1ab77bd377be00fdf6d5735ffe14b8f5afd6\n    - `go-chi/httpcoala`\n        - https://github.com/FujishigeTemma/isucon9-qualify/commit/495ae7ba4732b3bcb9c4a6795bea86dfac060c6c\n- メモリ効率化\n    - `sync.Pool`\n        - https://github.com/FujishigeTemma/isucon9-qualify/commit/4e7a9be6cbee699dc11db96c2134836dfd207def\n- 挿入後の結果をとらずに返す\n    - timeはミリ秒を四捨五入すること`.Round`\n        - デフォルトが秒までだけど、`DATETIME`のあとに数字がある場合は異なるので要確認\n        - https://dev.mysql.com/doc/refman/5.6/ja/fractional-seconds.html\n- session\n    - 自前の`interface`の変換なしの実装\n        - https://github.com/FujishigeTemma/isucon9-qualify/commit/64d095a6400bbde6df4ed62d6ad9bd12dbc8a964\n- `pat.Param`\n    - 自前の`interface`の変換なしの実装\n        - https://github.com/FujishigeTemma/isucon9-qualify/compare/b87747c27f305927b40b86285b1642cbe52e1c55...68c236f9782f041bca64f185ae0a3fbec9122ee2\n- misc\n    - キーが100個程度までならmapよりarrayを線形探索したほうがよいらしい\n    - sliceもmapもcapacityを指定する\n    - `i, item := range items`をすると`item`にコピーが走るので`items[i]`を使う\n    - 画像を返してる箇所はキャッシュのヘッダーを設定する\n    - GOGC `400`～`1200`とか\n        - 有効にしたときは**毎回再起動すること**\n\n- [MySQL のパーティショニングで速くなる？ならない？問題、あらためて実験してみた](https://qiita.com/hmatsu47/items/354f979cde6ad91bcc6b)\n- カバリングインデックス\n\nhttp://akouryy.hatenablog.jp/entry/2020/09/13/130415\n\n- https://dev.mysql.com/doc/refman/5.6/ja/optimizing-innodb-bulk-data-loading.html\n\n#### MySQL8\n- NOWAIT, SKIP LOCKED: https://qiita.com/hmatsu47/items/7675b026e65762d2445f\n- HASH JOIN: https://qiita.com/hmatsu47/items/e473a3e566b910d61f5b\n- Multi-valued index(jsonカラム用): https://qiita.com/hmatsu47/items/3e49a473bc36aeefc706\n- GROUP BYをLATERALにする？: https://qiita.com/hmatsu47/items/040d65d118d0ecec6381\n\n\nパーティショニングとは\n\n## HTTP チューニング\n\nhttps://qiita.com/yumin/items/5de33b068ead564ebcbf\n\n[martini](https://github.com/go-martini/martini)\n[gin](https://github.com/gin-gonic/gin)\n\nfasthttp\nhttps://medium.com/eureka-engineering/net-http%E3%82%88%E3%82%8A10%E5%80%8D%E9%80%9F%E3%81%84valyala-fasthttp%E3%81%8C%E9%9D%A2%E7%99%BD%E3%81%9D%E3%81%86%E3%81%AA%E3%81%AE%E3%81%A7%E8%AA%BF%E6%9F%BB%E3%81%97%E3%81%A6%E3%81%BF%E3%81%9F%E4%BB%B6-a608fe197f1d\n\n\n### メモ\nhttps://github.com/cs3238-tsuzu/sqlx-selector\n\nhttp://nginx.org/en/docs/http/ngx_http_rewrite_module.html#if\nhttps://stackoverflow.com/questions/8591600/nginx-proxy-pass-based-on-whether-request-method-is-post-put-or-delete\n\n得点につながるエンドポイントの確認\n大量アクセスかつ同じものが使える→singleflight\n\nlockfree map","lastmodified":"2022-10-26T11:26:57.367934441Z","tags":null},"/other/Application/Server/reverse-proxy":{"title":"リバースプロキシ","content":"\n\n## ロードバランサ\n\nOCSP stapling\n\n","lastmodified":"2022-10-26T11:26:57.367934441Z","tags":null},"/other/Application/Server/reverse-proxy-optimization":{"title":"Nginx (リバースプロキシ)チューニング","content":"\n\n### サーバー分割\n**DB分ける**\n**リクエストのロードバランス**\nロードバランサー\nセッションパーシステンス\n\nworker_processesにそれぞれ均等にworker_connectionsが分配される訳ではないので余裕をもって設定すべき\nhttps://nrok81.hatenablog.com/entry/2014/11/12/191240\n\n```conf\nworker_processes  auto;  # コア数と同じ数まで増やすと良いかも\n\n# nginx worker の設定\nworker_rlimit_nofile  4096;\nevents {\n    worker_connections  1024;  # 128より大きくするなら、 5_os にしたがって max connection 数を増やす必要あり（デフォルトで`net.core.somaxconn` が 128 くらいで制限かけられてるので）。さらに大きくするなら worker_rlimit_nofile も大きくする（file descriptor数の制限を緩める)\n    # multi_accept on;         # error が出るリスクあり。defaultはoff。\n    # accept_mutex_delay 100ms;\n}\n\nhttp {\n    log_format main '$remote_addr - $remote_user [$time_local] \"$request\" $status $body_bytes_sent \"$http_referer\" \"$http_user_agent\" $request_time';   # kataribe 用の log format\n    access_log  /var/log/nginx/access.log  main;   # これはしばらく on にして、最後に off にすると良さそう。\n    # access_log  off;\n\n    # 基本設定\n    sendfile    on;\n    tcp_nopush  on;\n    tcp_nodelay on;\n    types_hash_max_size 2048;\n    server_tokens    off;\n    open_file_cache max=100 inactive=65s; # file descriptor のキャッシュ。入れた方が良い。 20s-\u003e65s\n\n    # proxy buffer の設定。白金動物園が設定してた。\n    proxy_buffers 100 32k;\n    proxy_buffer_size 8k;\n\n    # mime.type の設定\n    include       /etc/nginx/mime.types;\n\n    # Keepalive 設定\n    # ベンチマークとの相性次第ではkeepalive off;にしたほうがいい\n    # keepalive off;\n    # ベンチは1分しか回らない\n    keepalive_timeout 65;\n    keepalive_requests 500;\n\n    # Proxy cache 設定。使いどころがあれば。1mでkey8,000個。1gまでcache。\n    proxy_cache_path /var/cache/nginx/cache levels=1:2 keys_zone=zone1:1m max_size=1g inactive=1h;\n    proxy_temp_path  /var/cache/nginx/tmp;\n    # オリジンから来るCache-Controlを無視する必要があるなら。。。\n    #proxy_ignore_headers Cache-Control;\n\n\n    # unix domain socket 設定1\n    upstream app {\n        server unix:/run/unicorn.sock;  # systemd を使ってると `/tmp` 以下が使えない。appのディレクトリに`tmp`ディレクトリ作って配置する方がpermissionでハマらずに済んで良いかも。\n    }\n\n    # 複数serverへ proxy\n    upstream app {\n        server 192.100.0.1:5000 weight=2;  # weight をつけるとproxyする量を変更可能。defaultは1。多いほどたくさんrequestを振り分ける。\n        server 192.100.0.2:5000;\n        server 192.100.0.3:5000;\n        # keepalive 60;  # app server への connection を keepalive する。app が対応できるならした方が良い。\n    }\n\n    server {\n        # reverse proxy の 設定\n        location / {\n            proxy_pass http://localhost:3000;\n            # proxy_http_version 1.1;          # app server との connection を keepalive するなら追加\n            # proxy_set_header Connection \"\";  # app server との connection を keepalive するなら追加\n        }\n\n        # Unix domain socket の設定2。設定1と組み合わせて。\n        location / {\n            proxy_pass http://app;\n        }\n\n        # 簡易静的ファイルをNginx配信\n        location / {\n            root /home/user/app/public/;\n            try_files $uri $uri/ @app;\n        }\n        location @app {\n            proxy_pass http://app;\n        }\n\n        # For Server Sent Event\n        location /api/stream/rooms {\n            # \"magic trio\" making EventSource working through Nginx\n            proxy_http_version 1.1;\n            proxy_set_header Connection '';\n            chunked_transfer_encoding off;\n            # These are not an official way\n            # proxy_buffering off;\n            # proxy_cache off;\n            proxy_pass http://localhost:8080;\n        }\n\n        # For websocket\n        location /wsapp/ {\n            proxy_http_version 1.1;\n            proxy_set_header Upgrade $http_upgrade;\n            proxy_set_header Connection \"upgrade\";\n            proxy_pass http://wsbackend;\n        }\n\n        # Proxy cache\n        location /cached/ {\n            proxy_cache zone1;\n            # proxy_set_header X-Real-IP $remote_addr;\n            # proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;\n            # proxy_set_header Host $http_host;\n            proxy_pass http://localhost:9292/;\n            # デフォルトでは 200, 301, 302 だけキャッシュされる。proxy_cache_valid で増やせる。\n            # proxy_cache_valid 200 301 302 3s;\n            # cookie を key に含めることもできる。デフォルトは $scheme$proxy_host$request_uri;\n            # proxy_cache_key $proxy_host$request_uri$cookie_jessionid;\n            # レスポンスヘッダにキャッシュヒットしたかどうかを含める\n            add_header X-Nginx-Cache $upstream_cache_status;\n        }\n\n        # static file の配信用の root\n        root /home/isucon/webapp/public/;\n\n        location ~ .*\\.(htm|html|css|js|jpg|png|gif|ico) {\n            expires 24h;\n            add_header Cache-Control public;\n\n            open_file_cache max=100;  # file descriptor などを cache\n\n            gzip on;  # cpu 使うのでメリット・デメリット見極める必要あり。gzip_static 使えるなら事前にgzip圧縮した上でそちらを使う。\n            gzip_types text/html text/css application/javascript application/json font/woff font/ttf image/gif image/png image/jpeg image/svg+xml image/x-icon application/octet-stream;\n            gzip_disable \"msie6\";\n            gzip_static on;  # nginx configure時に --with-http_gzip_static_module 必要\n        }\n    }\n}\n```\n\n```\nuser www-data;\npid /run/nginx.pid;\ninclude /etc/nginx/modules-enabled/*.conf;\nworker_rlimit_nofile 100000;\n\nerror_log  /var/log/nginx/error.log error;\n\nhttp {\n    default_type  application/octet-stream;\n\n    client_max_body_size 10m;\n\n    # TLS configuration\n    ssl_protocols TLSv1.2;\n    ssl_prefer_server_ciphers on;\n    ssl_ciphers 'ECDHE-ECDSA-AES128-GCM-SHA256:ECDHE-RSA-AES128-GCM-SHA256:ECDHE-ECDSA-AES256-GCM-SHA384:ECDHE-RSA-AES256-GCM-SHA384:ECDHE-ECDSA-CHACHA20-POLY1305:ECDHE-RSA-CHACHA20-POLY1305:DHE-RSA-AES128-GCM-SHA256:DHE-RSA-AES256-GCM-SHA384';\n\n\tserver {\n\t    listen 443 ssl http2;\n\t    server_name isucon9.catatsuy.org;\n\n\t    ssl_certificate /etc/nginx/ssl/fullchain.pem;\n\t    ssl_certificate_key /etc/nginx/ssl/privkey.pem;\n\n\t\troot /home/isucon/isucari/webapp/public;\n\t\tlocation /static/ {\n\t\t\tadd_header Cache-Control \"public max-age=86400\";\n\t\t}\n\t\tlocation /upload/ {\n\t\t\tadd_header Cache-Control \"public max-age=86400\";\n\t\t}\n\n\t    location / {\n\t\tproxy_pass http://app;\n\t\tproxy_set_header Host $host;\n\t    }\n\t    location /login {\n\t\tproxy_pass http://login_app;\n\t\tproxy_set_header Host $host;\n\t    }\n\t}\n}\n```\n\n### 初期設定\nhttps://wiki.trap.jp/user/to-hutohu/memo/ISUCON%E3%83%81%E3%83%BC%E3%83%88%E3%82%B7%E3%83%BC%E3%83%88\n#### OS\n設定したら`sudo sysctl -p {{filename}}`で反映する\n実行中のプロセスには反映されないからプロセスの再起動が必要\n\n備考: `net.ipv4.ip_, net.ipv4.ip_local_portrange, net.ipv4.tcp, net.ipv4.icmp_*`はipv6にも適用される\n\n#### nginx\n`$ sudo cp *.conf *.conf.bk`\n`/etc/nginx/nginx.conf`\n`/etc/nginx/sites-enabled/*.conf` (ここでは`http`ブロック内しか変更できない)\n`/etc/nginx/sites-available/*.conf`に書いて↑ではエイリアスを貼るのが正解\nhttps://wiki.trap.jp/user/to-hutohu/memo/ISUCON%E3%83%81%E3%83%BC%E3%83%88%E3%82%B7%E3%83%BC%E3%83%88#head10\n\nnginxとアプリケーションの間をunix domain socket\n`Unix domain socket`は後回し\nhttps://qiita.com/ihsiek/items/11106ce7a13e09b61547#web%E3%82%B5%E3%83%BC%E3%83%90\n`index.html`を配信してるところをnginxで返すようにする\n```\n    # index.htmlの配信\n    location ~ ^/(?:login|register|timeline|categories|sell|items|buy/complete|transactions|users)(?!.*.(?:json|png)) {\n        try_files $uri /index.html;\n    }\n```\n\n```\nserver {\n    listen       80 default_server;\n    server_name  _;\n\n    location / {\n         root /home/isucon/torb/webapp/static/;\n         try_files $uri $uri/ @app;\n    }\n\n    location @app {\n        proxy_set_header Host $host;\n        proxy_pass   http://127.0.0.1:8080;\n    }\n}\n```\n```\n    proxy_buffer_size 128k;\n    proxy_buffers 32 128k;\n    proxy_busy_buffers_size 128k;\n```\n\nh2cの有効化(意味なさそうなのでhttpsを使ってhttp2を使うべき)\n```\nserver {\n    listen 80 http2;\n```\n\n#####\n設定\n```\nworker_processes auto;\nworker_rlimit_nofile 4096;\nevents {\n    worker_connections 1024; # net.core.somaxconnとworker_rlimit_nofileも大きくする\n    #multi_accept on; # error が出るリスクあり。defaultはoff\n    #accept_mutex_delay 100ms;\n}\n```\n\nnginx の worker_connections は worker 当たりの同時接続数だと思ってたけどどうも違うっぽい\nhttps://nrok81.hatenablog.com/entry/2014/11/12/191240\n\n##### ログ設定 httpディレクティブの中\n```\nlog_format main '$remote_addr - $remote_user [$time_local] \"$request\" $status $body_bytes_sent \"$http_referer\" \"$http_user_agent\" $request_time';\naccess_log /tmp/access.log main;\n#access_log off;\n```\n\n##### 基本設定 httpディレクティブの中\n```\nsendfile on;\ntcp_nopush on;\ntcp_nodelay on;\ntypes_hash_max_size 2048;\nserver_tokens off;\nopen_file_cache max=100 inactive=20s; # file descriptorのキャッシュ\n\n# proxy bufferの設定\nproxy_buffers 100 32k;\nproxy_buffer_size 8k;\n\n# keepaliveの設定\n#keepalive off; # ベンチマークとの相性次第ではoffにしたほうがいい\nkeepalive_timeout 120;\nkeepalive_requests 1048576;\n\n# proxy cacheの設定\nproxy_cache_path /var/cache/nginx/cache levels=1:2 keys_zone=zone1:1m max_size=1g inactive=1h;\nproxy_temp_path  /var/cache/nginx/tmp;\n#proxy_ignore_headers Cache-Control; # upstreamから来るCache-Controlを無視する必要があるなら\n```\n\n##### upstream設定 httpディレクティブの中\n```\nupstream app {\n    server 127.0.0.1:8000;\n\n    keepalive 256;\n}\n```\n\n##### reverse proxy設定 serverディレクティブの中\n```\nlocation /initialize {\n    proxy_http_version 1.1;\n    proxy_set_header Connection \"\";\n\n    proxy_read_timeout 120;\n\n    #proxy_cache zone1;\n\n    proxy_set_header Host $host;\n    proxy_set_header X-Real-IP $remote_addr;\n    proxy_set_header X-Forwarded-Proto $scheme;\n    proxy_set_header X-Forwarded-Host $host;\n    proxy_set_header X-Forwarded-Server $host;\n    proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;\n\n    proxy_pass http://app;\n}\n```\n\n##### 静的配信設定 serverディレクティブの中\n```\n# static file の配信用の root\nroot /home/isucon/webapp/public/;\n\nlocation ~ .*\\.(htm|html|css|js|eot|svg|ttf|woff|woff2|gif|jpg|png|ico) {\n    expires 24h;\n\n    gzip off;\n    #gzip on; # CPUを使うのでメリット・デメリット見極める必要あり。gzip_staticが使えるなら事前にgzip圧縮した上でそちらを使う\n    #gzip_types *;\n    #gzip_disable \"msie6\";\n    #gzip_static on;\n}\n```\n\n##### gzip\n- できればgzip_staticを使う\n    - 圧縮コマンド `find ./* | xargs -I {}  sh -c 'gzip -9 -v -N -c {} \u003e {}.gz'`\n        - 元のファイルを残して圧縮する\n***\n","lastmodified":"2022-10-26T11:26:57.367934441Z","tags":null},"/other/Application/Shell":{"title":"シェル芸","content":"\n\n[雰囲気でシェルを使っている人のためのシェル入門 | κeenのHappy Hacκing Blog (keens.github.io)](https://keens.github.io/blog/2017/10/17/fun_ikideshieruwotsukatteiruninnotamenoshierunyuumon/)\n[A Tutorial on Portable Makefiles (nullprogram.com)](https://nullprogram.com/blog/2017/08/20/)\n","lastmodified":"2022-10-26T11:26:57.367934441Z","tags":null},"/other/Application/Structure/ELF":{"title":"ELF","content":"\nELF Header\nProgram Header\nSegment","lastmodified":"2022-10-26T11:26:57.367934441Z","tags":null},"/other/Application/Structure/FAT32":{"title":"File System","content":"\nファイルシステム VFS\n- File Allocation Table (FAT)\n- FAT32\n- NTFS\n- ExFAT\n\n\n## FAT32\nFAT とは Microsoft によって開発されたいくつかのファイルシステム(FAT12, FAT16, FAT32, VFAT, exFAT)の総称です。\n\nここでは実装より仕組みの理解を優先した書き方をするので実装する方は規格などを読んでください。TODO: 規格のURL\nえるむさんの記事など\n[FATファイルシステムのしくみと操作法 (elm-chan.org)](http://elm-chan.org/docs/fat.html)\nそれでも仕様は追うので脆弱性を見つけたい方には有効です。\n\nクラスタ番号は2から始まります.\n\n```\nReserved sectors\n- Boot Sector\n- FS Information Sector (FAT32 only)\n- More reserved sectors (optional)\nFAT Region\n- File Allocation Table 1\n- File Allocation Table 2 (optional)\nRoot Directory Region (FAT12, FAT16 only)\n- Root Directory Table\nData Region\n- Cluster 2\n- Cluster 3\n...\n- Cluster N\n```\n\nFile Allocation Table は片方向連結リストです。FATエントリはエントリ番号と同じクラスタ番号のクラスタを保持し、次のエントリを指すことでリスト構造となります。終端には番兵が配置されています。\n\n```\nFile Allocation Table\n entry2 -\u003e entry7 -\u003e ... -\u003e entry23 -\u003e entry (sentinel)\n   |         |                |\ncluster2  cluster7         cluster23\n```\n\nFAT32では32ビット\n\nBoot Sectorには BIOS Parameter Block BPB や MBR や GPT が配置されます。\n\nファイルアクセスの方法\n\next4 fourth exteneded filesystem\n","lastmodified":"2022-10-26T11:26:57.367934441Z","tags":null},"/other/Application/Structure/ZIP":{"title":"ZIP","content":"\n\n\n```\n[local file header 1]\n[file data 1]\n[data descriptor 1]\n.\n.\n.\n[local file header n]\n[file data n]\n[data descriptor n]\n[archive decryption header]\n[archive extra data record]\n[central directory header 1]\n.\n.\n.\n[central directory header n]\n[zip64 end of central directory record]\n[zip64 end of central directory locator]\n[end of central directory record]\n```\n\n### Local file header\n```\n      local file header signature     4 bytes  (0x04034b50)\n      version needed to extract       2 bytes\n      general purpose bit flag        2 bytes\n      compression method              2 bytes\n      last mod file time              2 bytes\n      last mod file date              2 bytes\n      crc-32                          4 bytes\n      compressed size                 4 bytes\n      uncompressed size               4 bytes\n      file name length                2 bytes\n      extra field length              2 bytes\n\n      file name (variable size)\n      extra field (variable size)\n```\n\n\n\n\n\nZIPはディレクトリの階層構造は関係せずファイルを順に並べる。\n\n```\n\\ hoge\n |- foo\n |-\nbar\n```\n\nならば`/`のついたファイル名をZIP化したらどうなるか\n\n\nZIPローカルファイルヘッダ\nシグネチャ `50 4b 03 04`\nバージョン `14 00` 2.0\n`00 00`\n圧縮方法 `08 00` deflate\n最終変更日時 `45 97 90 53`\nCRC-32 `f7 45 3e aa`\n圧縮サイズ `16 00 00 00` 20 byte\n非圧縮サイズ `42 00 00 00` 68 byte\nファイル名の長さ `04 00` 4 byte\n拡張フィールドの長さ `1c 00` 28 byte\nファイル名(文字列) `74 65 73 74` test\n拡張フィールド\nファイルエントリ\n55 54 09 00 03 b1 0d bb 61 b4 0d bb 61 75\n78 0b 00 01 04 e8 03 00 00 04 e8 03 00 00 f3 48\ncd c9 c9 d7 51 88 f2 0c 50 08 cf 2f ca 49 51 24\n15 70 01 00 50 4b 01 02 1e 03 14 00 00 00 08 00\n45 97 90 53 f7 45 3e aa 16 00 00 00 42 00 00 00\n04 00 18 00 00 00 00 00 01 00 00 00 a4 81 00 00\n00 00 74 65 73 74 55 54 05 00 03 b1 0d bb 61 75\n78 0b 00 01 04 e8 03 00 00 04 e8 03 00 00 50 4b\n05 06 00 00 00 00 01 00 01 00 4a 00 00 00 54 00\n00 00 00 00\n\nZIPセントラルディレクトリファイルヘッダ\nシグネチャ 02 01 4B 50\n作成されたバージョン\n展開に必要なバージョン\n汎用目的のビットフラグ\n圧縮メソッド　（0:無圧縮、8:deflate）\nファイルの最終変更時間\nファイルの最終変更日付\nCRC-32\n圧縮サイズ byte\n非圧縮サイズ byte\nファイル名の長さ byte\n拡張フィールドの長さ byte\nファイルコメントの長さ byte\nファイルが開始するディスク番号 byte\n内部ファイル属性\n外部ファイル属性\nローカルファイルヘッダの相対オフセット byte\nファイル名(文字列)\n拡張フィールド\nファイルコメント(文字列)\n\nZIPセントラルディレクトリ終端レコード\nシグネチャ 06 05 4B 50\nディスクの数 枚\nセントラルディレクトリが開始するディスク番号 枚目\nこのディスク上のセントラルディレクトリレコードの数 個\nセントラルディレクトリレコードの合計数 個\nセントラルディレクトリのサイズ byte\nセントラルディレクトリの開始位置のオフセット byte\nZIPファイルコメントの長さ byte\nZIPファイルコメント(文字列)\n","lastmodified":"2022-10-26T11:26:57.367934441Z","tags":null},"/other/Application/Tools":{"title":"ツール","content":"\n\nMac\n- Raycast\n\nWindows\n- PowerToys\n- ImHex\n- Ear Trumpet\n- WizTree\n- Obsidian\n\nXP-PEN\n\nある単語について検索結果の要約をポップアップで表示する拡張機能\n\nSplunk","lastmodified":"2022-10-26T11:26:57.367934441Z","tags":null},"/other/Application/Type":{"title":"型理論","content":"\n# 型理論\n\n型はグロタンディーク宇宙の中であることを断っておく。\n\n### 論理\n最小述語論理+矛盾律 = 直観主義論理\n直観主義論理+排中律 = 古典論理: ゲンツェンの自然演繹(NK)\n\n\n### 型無しラムダ計算\nα-変換 : 束縛変数の名前は重要ではない\nβ-簡約 : 関数適用\nη-変換 : 2つの関数について任意の引数を関数適用した値が等しいならば、2つの関数は等しい\n\n領域理論\n\n[SKIコンビネータで遊んでみよう - Qiita](https://qiita.com/Anko_9801/items/74af196cce123550001a)\n\n### 型付きラムダ計算\n型チェックが実行前に一度だけ行うこと\n\n#### ラムダ・キューブ\n\n![[Pasted image 20220925021333.png]]\n\n- $\\lambda\\to$: 単純型付きラムダ計算\n- $\\lambda 2$: 二階命題論理 (System F)\nパラメトリック多相, 全称型\n- $\\lambda\\underline{\\omega}$: 弱性高階命題論理\n型演算子\n直積型や多相カインドは型演算子の1つ\n- $\\lambda P$: 一階述語論理\n依存型\n依存型はせいぜいarray bound checkくらいにしか使えないだろう\n- $F_{\u003c:}$:\nサブタイプ\n- $\\lambda C$: Culculus of Constructions\n\n### Curry-Howard 同型対応\n|論理|プログラム|\n|---|---|\n|証明|型を構成するプログラム|\n|論理式|型|\n|ならば$\\implies$|型 $P\\to Q$|\n|否定 $\\lnot$|型 $P\\to\\bot$|\n|かつ $\\land$|型 $P\\times Q$|\n|または $\\lor$|型 $P+Q$|\n|モーダスポネンス|関数適用 $(a \\to b) \\to a \\to b$|\n|三段論法|関数合成 $(a \\to b) \\to (b \\to c) \\to (a \\to c)$ |\n|対偶|$(a\\to b)\\to(b\\to\\bot)\\to(a\\to\\bot)$|\n|直観主義論理|Calculus of Constructions|\n|二階直観主義論理|System F|\n|ゲンツェンの自然演繹(NK)|型付きラムダ計算|\n|パースの法則$((P→Q)→P)→P$|call/cc|\n|否定翻訳|CPS変換|\n\nGATsはデータコンストラクタによって型を柔軟に指定出来る機能です。\ncall/cc\n\n## 型理論\nMartin-Lof 型理論\nHomotopy 型理論\nCubical 型理論","lastmodified":"2022-10-26T11:26:57.367934441Z","tags":null},"/other/Application/toolchain":{"title":"ツールチェーン","content":"\n\n## Compiler\nAST\n\n## Linker\n\n## Loader\n\n## assembler\n\n## disassembler\n\n## decompiler\n\nバイナリを入れてLLVM IR に変換後, 最適化する\n[facebookincubator/BOLT: Binary Optimization and Layout Tool - A linux command-line utility used for optimizing performance of binaries (github.com)](https://github.com/facebookincubator/BOLT)","lastmodified":"2022-10-26T11:26:57.367934441Z","tags":null},"/other/Circuit/%E3%82%A2%E3%83%8A%E3%83%AD%E3%82%B0-%E3%82%BB%E3%83%B3%E3%82%B5%E3%83%BC":{"title":"","content":"液晶","lastmodified":"2022-10-26T11:26:57.367934441Z","tags":null},"/other/Circuit/%E3%82%B7%E3%82%B9%E3%83%86%E3%83%A0%E5%88%B6%E5%BE%A1":{"title":"","content":"\n## モーターコントローラー\nHブリッジを用いて電気を流し正転、逆転するのと逆起電力によるブレーキを操作している。\nMOSFET を4つ\n\n","lastmodified":"2022-10-26T11:26:57.367934441Z","tags":null},"/other/Circuit/%E3%83%91%E3%83%AF%E3%82%A8%E3%83%AC":{"title":"","content":"\n電源\nLCRメーター","lastmodified":"2022-10-26T11:26:57.367934441Z","tags":null},"/other/Circuit/%E3%83%9E%E3%82%A4%E3%82%B3%E3%83%B3":{"title":"","content":"マイコンの一番楽しい所ってなに\n\n主に次を使うことが多いです。\n- ATmega328P (Arduino)\n- RP2040 (Raspberry Pi Pico)\n- STM32 Nucleo (STM32F303K8)\n\nUniversal Asynchronous Receiver/Transmitter: UART\n\nHardware Abstraction Layer (HAL)\n\n-   [アナログ/センサ/計測](https://www.zep.co.jp/cat_tech/analog)\n-   [FPGA/HDL/論理回路](https://www.zep.co.jp/cat_tech/fpga)\n-   [プリント基板/実装](https://www.zep.co.jp/cat_tech/board)\n-   [高周波/無線/通信](https://www.zep.co.jp/cat_tech/rf)\n-   [ロボット/自動運転](https://www.zep.co.jp/cat_tech/robot)\n-   [マイコン/IoT/AI](https://www.zep.co.jp/cat_tech/mpu)\n-   [システム制御](https://www.zep.co.jp/cat_tech/control)\n-   [信号/画像プロセシング](https://www.zep.co.jp/cat_tech/signal-processing)\n-   [高速データ伝送/USB](https://www.zep.co.jp/cat_tech/high-speed)\n-   [電源/電池/パワエレ](https://www.zep.co.jp/cat_tech/power)\n-   [モータ/アクチュエータ](https://www.zep.co.jp/cat_tech/motor)\n-   [ノイズ/放熱対策](https://www.zep.co.jp/cat_tech/noise)\n-   [測定器/分析装置](https://www.zep.co.jp/cat_tech/meas)\n-   [ソフトウェア/ツール](https://www.zep.co.jp/cat_tech/tool)\n-   [OS/Linux/Python](https://www.zep.co.jp/cat_tech/os)\n-   [半導体/電子部品](https://www.zep.co.jp/cat_tech/parts)\n-   [電磁気/数学/統計/力学](https://www.zep.co.jp/cat_tech/theory)\n","lastmodified":"2022-10-26T11:26:57.367934441Z","tags":null},"/other/Circuit/FPGA-HDL-%E8%AB%96%E7%90%86%E5%9B%9E%E8%B7%AF":{"title":"","content":"","lastmodified":"2022-10-26T11:26:57.367934441Z","tags":null},"/other/Circuit/PC%E5%91%A8%E8%BE%BA":{"title":"","content":"## ディスク\nCrystalDisk\nCrystalDiskMark\n## スクリーン\nブラウン管\nニキシー管\n液晶\n\n","lastmodified":"2022-10-26T11:26:57.367934441Z","tags":null},"/other/Circuit/Rootkit":{"title":"Root kit","content":"\nNorth bridge\n[dsn2021.pdf (xgao-work.github.io)](https://xgao-work.github.io/paper/dsn2021.pdf)\n\n\n## PCI Rootkit\n[Implementing and Detecting a PCI Rootkit](https://www.blackhat.com/presentations/bh-dc-07/Heasman/Paper/bh-dc-07-Heasman-WP.pdf)\n\nPeripheral Component Interconnect: PCI はマザーボード\n\n","lastmodified":"2022-10-26T11:26:57.367934441Z","tags":null},"/other/Circuit/TEE":{"title":"TEE","content":"\nTrusted Execution Environment: TEE とはプロセッサ上に隔離された実行環境を用意することでセキュリティを高める技術です。\nNormal Mode Secure Mode\n\n- Intel SGX\n- ARM TrustZone\n- RISC-V Keystone\n\nTrusted Platform Module: TPM\n[規格](https://trustedcomputinggroup.org/resource/tpm-library-specification/)\n\n- OSやアプリケーションの改竄を検知\n- 公開鍵証明書による端末識別，認証\n- ストレージデータの安全な暗号化\n\nTEE CPUの機能\n- Intel SGX\n\t- Remote Attestation\n\t- ForeShadow\n- ARM TrustZone\n\t- [Boomerang](https://github.com/ucsb-seclab/boomerang/)\n- RISC-V Keystone\n\t- BOOM\n\t- Speculative Attack\nTPM (Trust) ハードウェアとして開発\n- Windows BitLocker\n- [A Bad Dream](https://www.usenix.org/system/files/conference/usenixsecurity18/sec18-han.pdf)\n\nほぼほぼ暗号化処理をするため秘密鍵をそこにppm\n\n須崎先生\n\n- [woot22-preprint.pdf (tuwien.ac.at)](https://security.inso.tuwien.ac.at/pdfs/woot22-preprint.pdf)\n- [IAIK/AEPIC (github.com)](https://github.com/IAIK/AEPIC)\n- [SoK: Understanding the Prevailing Security Vulnerabilities in TrustZone-assisted TEE Systems | IEEE Conference Publication | IEEE Xplore](https://ieeexplore.ieee.org/document/9152801)\n\nProject Zero\nSpectre見つけた\nandroid をdecrypt TEEを介さずに FBIでもできなかった\n[Project Zero: Trust Issues: Exploiting TrustZone TEEs (googleprojectzero.blogspot.com)](https://googleprojectzero.blogspot.com/2017/07/trust-issues-exploiting-trustzone-tees.html)\n[Bits, Please!: Extracting Qualcomm's KeyMaster Keys - Breaking Android Full Disk Encryption (bits-please.blogspot.com)](http://bits-please.blogspot.com/2016/06/extracting-qualcomms-keymaster-keys.html)\n\nNSA\n\n[ARM TrustZone エクスプロイト入門 - Speaker Deck](https://speakerdeck.com/rkx1209/arm-trustzone-ekusupuroitoru-men)\n","lastmodified":"2022-10-26T11:26:57.367934441Z","tags":null},"/other/Idea":{"title":"","content":"version update時の確認不足で何かしらの悪意のあるプログラムを入れることができる","lastmodified":"2022-10-26T11:26:57.367934441Z","tags":null},"/other/streat":{"title":"","content":"物理学\n生物学\nロケット 飛行\n\n回路\nトランジスタ (NPN接合)\n- AVRマイコンライター自作\n- 電源自作\n- JTAG によるデバッグ\n- FPGA による RISC-V CPU 自作\n- CPU Break\n- toolchain 自作\n- プログラミング言語自作\n- OS自作\n- Kernel Exploit\n- ロスレス音声コーデック (PARCOR係数・エンコード済み残差信号)\n- Video\n- DeepLearning\n","lastmodified":"2022-10-26T11:26:57.367934441Z","tags":null},"/other/template":{"title":"競プロテンプレート","content":"\n## 説明\n\n競プロで使うテンプレート\n\n## 実装\n\n```cpp\n#ifndef LOCAL\n#pragma GCC optimize(\"Ofast\")\n#pragma GCC optimize(\"unroll-loops\")\n#endif\n\n#include \u003cbits/stdc++.h\u003e\n// #include \u003catcoder/all\u003e\nusing namespace std;\n// using namespace atcoder;\nusing ll = long long;\nusing ld = long double;\nusing uint = unsigned;\nusing ull = unsigned long long;\nusing u64 = uint_fast64_t;\nusing pll = pair\u003cll, ll\u003e;\nusing pdd = pair\u003cld, ld\u003e;\nusing C = complex\u003cld\u003e;\ntemplate \u003cclass T\u003e using pq = priority_queue\u003cT, vector\u003cT\u003e, greater\u003cT\u003e\u003e;\n\nconst int IINF = 0x1fffffff;\nconst ll LINF = 0x1fffffffffffffff;\nconst ll INF = 0x1fffffffffffffff;\nconst ll MINF = 0x7fffffffffff;\nconst ll MOD = 1000000007;\nconst ll MODD = 998244353;\nconst ld DINF = numeric_limits\u003cld\u003e::infinity();\nconst ld EPS = 1e-9;\nconst ld PI = 3.1415926535897932;\nconst ll dx[] = {0, 1, 0, -1, 1, -1, 1, -1};\nconst ll dy[] = {1, 0, -1, 0, 1, 1, -1, -1};\n\n#define overload4(_1, _2, _3, _4, name, ...) name\n#define overload3(_1, _2, _3, name, ...) name\n#define rep1(n) for (ll i = 0; i \u003c n; ++i)\n#define rep2(i, n) for (ll i = 0; i \u003c n; ++i)\n#define rep3(i, a, b) for (ll i = a; i \u003c b; ++i)\n#define rep4(i, a, b, c) for (ll i = a; i \u003c b; i += c)\n#define rep(...) overload4(__VA_ARGS__, rep4, rep3, rep2, rep1)(__VA_ARGS__)\n#define rrep1(n) for (ll i = n; i--;)\n#define rrep2(i, n) for (ll i = n; i--;)\n#define rrep3(i, a, b) for (ll i = b; i-- \u003e (a);)\n#define rrep4(i, a, b, c)                                                      \\\n  for (ll i = (a) + ((b) - (a)-1) / (c) * (c); i \u003e= (a); i -= c)\n#define rrep(...)                                                              \\\n  overload4(__VA_ARGS__, rrep4, rrep3, rrep2, rrep1)(__VA_ARGS__)\n#define each1(i, a) for (auto \u0026\u0026i : a)\n#define each2(x, y, a) for (auto \u0026\u0026[x, y] : a)\n#define each3(x, y, z, a) for (auto \u0026\u0026[x, y, z] : a)\n#define each(...) overload4(__VA_ARGS__, each3, each2, each1)(__VA_ARGS__)\n#define all1(i) begin(i), end(i)\n#define all2(i, a) begin(i), begin(i) + a\n#define all3(i, a, b) begin(i) + a, begin(i) + b\n#define all(...) overload3(__VA_ARGS__, all3, all2, all1)(__VA_ARGS__)\n#define rall1(i) (i).rbegin(), (i).rend()\n#define rall2(i, k) (i).rbegin(), (i).rbegin() + k\n#define rall3(i, a, b) (i).rbegin() + a, (i).rbegin() + b\n#define rall(...) overload3(__VA_ARGS__, rall3, rall2, rall1)(__VA_ARGS__)\n// g++ -DDBUG -I . ...\n#ifdef DEBUG\ninline ll __lg(ull x) { return 63 - __builtin_clzll(x); }\n#define debug(...)                                                             \\\n  {                                                                            \\\n    print(#__VA_ARGS__);                                                       \\\n    print(\":\");                                                                \\\n    out(__VA_ARGS__);                                                          \\\n  }\n#else\n#define debug(...) void(0)\n#endif\n\n#define vec vector\n#define fi first\n#define se second\n#define MM \u003c\u003c \" \" \u003c\u003c\n#define chmax(x, y) (x = max(x, y))\n#define chmin(x, y) (x = min(x, y))\nvoid debug_out() { std::cerr \u003c\u003c std::endl; }\ntemplate \u003ctypename Head, typename... Tail\u003e void debug_out(Head h, Tail... t) {\n  std::cerr \u003c\u003c \" \" \u003c\u003c h;\n  if (sizeof...(t) \u003e 0)\n    std::cout \u003c\u003c \" :\";\n  debug_out(t...);\n}\n\nint main() {\n  cin.tie(0);\n  ios::sync_with_stdio(0);\n  cout \u003c\u003c fixed \u003c\u003c setprecision(20);\n\n  return 0;\n}\n```\n```cpp\n/**\n * @brief 多次元 vector の作成\n * @author えびちゃん\n */\n#include \u003cbits/stdc++.h\u003e\nusing namespace std;\nusing ll = long long;\n\nnamespace detail {\ntemplate \u003ctypename Tp, size_t Nb\u003e\nauto make_vector(std::vector\u003csize_t\u003e \u0026sizes, Tp const \u0026x) {\n  if constexpr (Nb == 1) {\n    return std::vector(sizes[0], x);\n  } else {\n    size_t size = sizes[Nb - 1];\n    sizes.pop_back();\n    return std::vector(size, make_vector\u003cTp, Nb - 1\u003e(sizes, x));\n  }\n}\n} // namespace detail\n\ntemplate \u003ctypename Tp, size_t Nb\u003e\nauto make_vector(size_t const (\u0026sizes)[Nb], Tp const \u0026x = Tp()) {\n  std::vector\u003csize_t\u003e s(Nb);\n  for (size_t i = 0; i \u003c Nb; ++i)\n    s[i] = sizes[Nb - i - 1];\n  return detail::make_vector\u003cTp, Nb\u003e(s, x);\n}\n```\n\n## 使用例\n","lastmodified":"2022-10-26T11:26:57.367934441Z","tags":null},"/pwn/AEG":{"title":"Automatic Exploit Generation","content":"\n## 説明\n自動的にexploitを行うコードを生成する\n\n## 参考文献\n[AEG: Automatic Exploit Generation (psu.edu)](https://www.cse.psu.edu/~trj1/cse544-f15/docs/aeg-current.pdf)","lastmodified":"2022-10-26T11:26:57.367934441Z","tags":null},"/pwn/Debugger":{"title":"デバッガ","content":"\nptrace\n\ngdb\n- gdb-peda\n- pwndbg\n- rust-gdb\n\n- Ghidra\n- IDA Pro\n- Binary Ninja\n- Immunity Debugger\n- WinDbg\n- radare2\n\nGhidraよりIDA Pro(アイダ)の方が使われる\n\nDWARF\ngdbの自動的にやることでカバレッジを取れる\nseccomp BPF\n\nVim/NeoVim\ntermdebug\n\n- Visual Studio Code\n- CLion\n\n[libcにデバッグシンボルを付ける方法と自動化 - Satoooonの物置 (hatenablog.com)](https://satoooon1024.hatenablog.com/entry/2022/06/12/libc%E3%81%AB%E3%83%87%E3%83%90%E3%83%83%E3%82%B0%E3%82%B7%E3%83%B3%E3%83%9C%E3%83%AB%E3%82%92%E4%BB%98%E3%81%91%E3%82%8B%E6%96%B9%E6%B3%95%E3%81%A8%E8%87%AA%E5%8B%95%E5%8C%96)","lastmodified":"2022-10-26T11:26:57.367934441Z","tags":null},"/pwn/HouseOfXXX/House_of_botcake":{"title":"House of botcake","content":"\n\nunsorted binの `fd` は `main_arena.top` を指す。\nlibc内の `main_arena.top` のオフセットが分かれば libc base address","lastmodified":"2022-10-26T11:26:57.367934441Z","tags":null},"/pwn/HouseOfXXX/house_of_lore":{"title":"House of lore","content":"\n","lastmodified":"2022-10-26T11:26:57.367934441Z","tags":null},"/pwn/HouseOfXXX/house_of_orange":{"title":"House of Orange","content":"本質: `top chunk` のサイズを書き換えることで `_int_free` を呼び出す.\n応用: https://ptr-yudai.hatenablog.com/entry/2019/10/12/181931","lastmodified":"2022-10-26T11:26:57.367934441Z","tags":null},"/pwn/HouseOfXXX/house_of_spirit":{"title":"House of spirit","content":"\n","lastmodified":"2022-10-26T11:26:57.367934441Z","tags":null},"/pwn/eBPF":{"title":"eBPF","content":"\n","lastmodified":"2022-10-26T11:26:57.367934441Z","tags":null},"/pwn/glibc/glibc":{"title":"","content":"\n### glibc ビルド方法\n\n1. https://www.gnu.org/software/libc/ のリリースページから ftp に飛んでダウンロードする.\n2. ビルド作業用のディレクトリを作ってそこに入る\n3. `../glibc-hoge/congifure --prefix=/path/to/インストールしたい場所`\n4. `make -j{N}`\n6. `make install`\n\n### glibc\n\n自前ビルドしてるとデバッグ情報も付いてくる.\n[patchelf](https://github.com/NixOS/patchelf) では手で叩かないといけない.\n[pwninit](https://github.com/io12/pwninit) なら glibc を同じ階層に入れておけば `pwninit` で勝手にやってくれる.\n`ldd` コマンドで確認できる.\n\nパッチ自動化できそう.","lastmodified":"2022-10-26T11:26:57.367934441Z","tags":null},"/pwn/glibc/malloc":{"title":"glibc malloc","content":"\n## 説明\n\nglibc のデータ領域に main_arena\nmalloc_state\n\n```cpp\nstruct malloc_state\n{\n  /* Serialize access.  */\n  __libc_lock_define (, mutex);\n\n  /* Flags (formerly in max_fast).  */\n  int flags;\n\n  /* Set if the fastbin chunks contain recently inserted free blocks.  */\n  /* Note this is a bool but not all targets support atomics on booleans.  */\n  int have_fastchunks;\n\n  /* Fastbins */\n  mfastbinptr fastbinsY[NFASTBINS];\n\n  /* Base of the topmost chunk -- not otherwise kept in a bin */\n  mchunkptr top;\n\n  /* The remainder from the most recent split of a small request */\n  mchunkptr last_remainder;\n\n  /* Normal bins packed as described above */\n  mchunkptr bins[NBINS * 2 - 2];\n\n  /* Bitmap of bins */\n  unsigned int binmap[BINMAPSIZE];\n\n  /* Linked list */\n  struct malloc_state *next;\n\n  /* Linked list for free arenas.  Access to this field is serialized\n     by free_list_lock in arena.c.  */\n  struct malloc_state *next_free;\n\n  /* Number of threads attached to this arena.  0 if the arena is on\n     the free list.  Access to this field is serialized by\n     free_list_lock in arena.c.  */\n  INTERNAL_SIZE_T attached_threads;\n\n  /* Memory allocated from the system in this arena.  */\n  INTERNAL_SIZE_T system_mem;\n  INTERNAL_SIZE_T max_system_mem;\n};\n```\n\nbinには沢山の種類がある\n- tcache\n- fastbins\n- unsorted bins\n- small bins\n- large bins\n\nヒープ領域\n```cpp\nstruct malloc_chunk{\n  size_t prev_size; // malloc中に必要！\n  size_t size; // malloc中に必要！ 下3bitはフラグ\n\n  // userに渡されるアドレスはここ\n\n  void *fd; // next\n  void *bk; // key\n\n  // for large size\n  void *fd_nextsize;\n  void *bk_nextsize;\n}\n```\n\n| bins   | fd | bk |\n|:------:|:---|:---|\n| tcache | next | tcache_key |\n| fastbins | next | null |\n| unsorted bins | \u0026main_arena.top |  |\n| small bins |  |  |\n| large bins |  |  |\n\n## tcache\n\n```cpp\n/* We overlay this structure on the user-data portion of a chunk when\n   the chunk is stored in the per-thread cache.  */\ntypedef struct tcache_entry\n{\n  struct tcache_entry *next;\n  /* This field exists to detect double frees.  */\n  uintptr_t key;\n} tcache_entry;\n\n/* There is one of these for each thread, which contains the\n   per-thread cache (hence \"tcache_perthread_struct\").  Keeping\n   overall size low is mildly important.  Note that COUNTS and ENTRIES\n   are redundant (we could have just counted the linked list each\n   time), this is for performance reasons.  */\ntypedef struct tcache_perthread_struct\n{\n  uint16_t counts[TCACHE_MAX_BINS];\n  tcache_entry *entries[TCACHE_MAX_BINS];\n} tcache_perthread_struct;\n```\n本質は next つまり単方向連結リスト\n\n#### mitigations\n**counts**\n初期値 0, free すると +1, malloc すると -1 される値\n上限7個 これを超えると fastbin へ\n連結リストとは独立にカウントされることで malloc の回数と free の回数の非整合性を検知する(counts は負の数となることはない).\n\nex)\nB: 攻撃者が指定するchunk\n```\nentry:空 -\u003e entry: A -\u003e改ざん！ -\u003e entry: A-\u003eB -\u003emalloc-\u003e entry: B\ncount:0 -\u003e count: 1 -----------\u003e count:1 -------------\u003e count: 0\n\nこのmitigationのbypass例\nentry:空 -\u003e entry: A ... entry: A_1-\u003eA_2 -\u003e改ざん！ -\u003e entry: A_1-\u003eB -\u003emalloc-\u003e entry: B\ncount:0 -\u003e count: 1 ... count: 2 ------------------\u003e count:2 --------------------\u003e count: 1\n```\n**key**\nfreeする度にentry.keyに\u0026tcacheを代入する\nfree するときに entry.keyの位置に\u0026tcache がある場合に限り\nentryのリストを探索しdouble free を検知する.\n\nmallocしてきた chunk A{.a = 0x12345678, .b = 0x90abcdef}\n-\u003e free -\u003e\nfreeされた tcache chunk A{.next = (次のchunkのアドレス) .key= \u0026tcache}\n\nmallocしてきた chunk B{.a = 0x12345678, .b = \u0026tcache} たまたまkeyの位置が\u0026tcacheになってる！\n-\u003e free -\u003e double free(擬陽性)\n\ntcache.entry[0x10] -\u003e A -\u003e B -\u003e C\n\n```\nstruct malloc_chunk{\n  size_t prev_size; // malloc中に必要！\n  size_t size; // malloc中に必要！ 下3bitはフラグ\n\n  // userに渡されるアドレスはここ\n\n  void *fd; // next\n  void *bk; // key\n\n  // for large size\n  void *fd_nextsize;\n  void *bk_nextsize;\n}\n```\n\nstruct tcache_entryはこの構造体のfdの位置にoverlapしてtcache_perthread_structで管理してる\n### 雑〜なexploit\n- 余分にfreeをしてcountを増やした後、対象のfree済みchunkに対してkeyをごちゃごちゃにしnext改ざん\n- これでentryの連結リストの中に攻撃者指定のアドレスが入るため、このままmallocしていけば任意アドレス書き込み可能\n\n\nlibc 2.29 tcache_key\ntcacheでdouble freeはできない\n\n```cpp\n/* Caller must ensure that we know tc_idx is valid and there's room\n   for more chunks.  */\nstatic __always_inline void\ntcache_put (mchunkptr chunk, size_t tc_idx)\n{\n  tcache_entry *e = (tcache_entry *) chunk2mem (chunk);\n\n  /* Mark this chunk as \"in the tcache\" so the test in _int_free will\n     detect a double free.  */\n  e-\u003ekey = tcache_key;\n\n  e-\u003enext = PROTECT_PTR (\u0026e-\u003enext, tcache-\u003eentries[tc_idx]);\n  tcache-\u003eentries[tc_idx] = e;\n  ++(tcache-\u003ecounts[tc_idx]);\n}\n```\n\n##\n\nglibc-2.35\nPROTECT_PTR\n```cpp\n/* Safe-Linking:\n   Use randomness from ASLR (mmap_base) to protect single-linked lists\n   of Fast-Bins and TCache.  That is, mask the \"next\" pointers of the\n   lists' chunks, and also perform allocation alignment checks on them.\n   This mechanism reduces the risk of pointer hijacking, as was done with\n   Safe-Unlinking in the double-linked lists of Small-Bins.\n   It assumes a minimum page size of 4096 bytes (12 bits).  Systems with\n   larger pages provide less entropy, although the pointer mangling\n   still works.  */\n#define PROTECT_PTR(pos, ptr) \\\n  ((__typeof (ptr)) ((((size_t) pos) \u003e\u003e 12) ^ ((size_t) ptr)))\n#define REVEAL_PTR(ptr)  PROTECT_PTR (\u0026ptr, ptr)\n```\n`(pos \u003e\u003e 12) ^ ptr`\n攻撃者側は最初heapのアドレスがわからない状態から始まる\nページは4k単位なので下位3nibble(12bit)は何度実行しても変わらない(randomizeされない)\nだから3nibble分右にずらしてxorすると最大限の効果を得られる\n\nただfree済み tcacheを読めたとき\nA{\n.next = 0x7ffabcdef;\n}\nAの上位9nibble分はとれる。\n\nメモリの確保量が小さいとき、すなわちheapが1ページで収まっているとき\nAでとれた上位9nibble分の情報をそのまま使える。\n-\u003e nextに対して復元するようなXORを掛ければお終い\n\n## 参考\n[malloc(3)のメモリ管理構造](https://www.valinux.co.jp/technologylibrary/document/linux/malloc0001/)\n[MallocInternals - glibc wiki (sourceware.org)](https://sourceware.org/glibc/wiki/MallocInternals)\n","lastmodified":"2022-10-26T11:26:57.367934441Z","tags":null},"/pwn/kernel_exploit":{"title":"Kernel Exploit用テンプレート","content":"\n## 説明\n\npwnのKernel Exploit時に使うテンプレート\n\n## 実装\n\n```python\nfrom ptrlib import *\nimport time\nimport base64\nimport os\n\ndef run(cmd):\n    sock.sendlineafter(\"$ \", cmd)\n    sock.recvline()\n\nwith open(\"./root/exploit\", \"rb\") as f:\n    payload = bytes2str(base64.b64encode(f.read()))\n\n#sock = Socket(\"HOST\", PORT) # remote\nsock = Process(\"./run.sh\")\n\nrun('cd /tmp')\n\nlogger.info(\"Uploading...\")\nfor i in range(0, len(payload), 512):\n    print(f\"Uploading... {i:x} / {len(payload):x}\")\n    run('echo \"{}\" \u003e\u003e b64exp'.format(payload[i:i+512]))\nrun('base64 -d b64exp \u003e exploit')\nrun('rm b64exp')\nrun('chmod +x exploit')\n\nsock.interactive()\n```\n","lastmodified":"2022-10-26T11:26:57.367934441Z","tags":null},"/pwn/pwn":{"title":"","content":"脆弱性の種類と，その攻略方法\nVulnerabilities: Stack BOF, Heap BOF, Use After Free, Format String Bug, Race Condition ...\nExploit Techniques: ret2plt, ret2libc, ROP, GOT Overwrite, Stack pivot ...\nAnti-Exploits: NX, ASLR, RELRO, PIE, Stack Canary ...\n\nシェルを開く方法\n1. シェルコードを実行\n\t1. Exec-shell系\n\t2. Exec-shell + バックコネクト系\n2. `system(\"/bin/sh\")`や`execve(\"/bin/sh\", 0, 0)`を実行\n\t1. 必要に応じてdup2したりする\n3. open(\"flag\") -\u003e read() -\u003e write()\n\t1. 正確にはシェルを開いていない\n\t2. でもCTF的にはフラグが読めればいい\n\t3. サンドボックスでexec系が禁止されているケース，chrootされているケースなどで有効\n\n## Vulnerabilities\n\n#### Format String Bug\n書式をprintfの第一引数に入れることで読み込んだり書き込める。\n\n#### スタックオーバーフロー (Stack-based buffer overflow)\nスタック上のオーバーフローを利用してリターンアドレスやローカル変数を書き換えられる。\n- トリガー\nメモリ書き換え (文字列入力、文字列入力の最後尾にヌル文字を挿入するなど)\n- 防御機構\nSSP canary\n[https://inaz2.hatenablog.com/entry/2014/03/14/151011 単純なスタックバッファオーバーフロー攻撃をやってみる - ももいろテクノロジー]\n\n#### Stack underflow\n関数フレーム外までpopを行う。\n\nOff-by-one error\nNull-byte Overflow\n\n## Exploit Techniques\n\n　GOT overwrite\nGOT ( Global Offset Table ) の行先を書き換える。\nROPでscanfして書き換えたりできる\n- 防御機構\nFull RELRO\n\n\n libcリーク :   libc leak\nlibc内のアドレスをputs, printf関数などで出力させる。\n ret2XX\nリターンアドレスを書き換える。\n\n ROP :  Return-Oriented Programming\nret命令で終わる少ない命令列(Gadget)を組み合わせてret2hogeをする。呼び出し規約 #Pwn_よく使うglibcの関数まとめ がcdeclなどスタックを用いる場合、3つ以上の関数を呼ぶとき引数が関数アドレスと被らないように引数を削除する為のpop retガジェットを挟む。fastcallなどレジスタを用いる場合、レジスタに引数を渡すためにpop rdi retガジェット等を使う。\n- 防御機構\nIntel CET\n[https://smallkirby.hatenablog.com/entry/2020/09/10/230629 【pwn 36.0】Intel CETが、みんなの恋人ROPを殺す - newbieからバイナリアンへ]\n[https://inaz2.hatenablog.com/entry/2014/07/04/001851 x64でスタックバッファオーバーフローをやってみる - ももいろテクノロジー]\n\n ヒープ関連\n資料\n[https://www.youtube.com/watch?v=0-vWT-t0UHg]\n[https://www.valinux.co.jp/technologylibrary/document/linux/malloc0001/ malloc(3)のメモリ管理構造 - VALINUX]\n[https://qiita.com/kaityo256/items/9e78b507940b2292bf79 mallocの動作を追いかける(mmap編)]\n[https://heap-exploitation.dhavalkapil.com heap-exploitation]\n攻撃デモ [https://github.com/shellphish/how2heap how2heap]\n[https://ptr-yudai.hatenablog.com/entry/2019/05/31/235444 ヒープ系問題におけるstdout / stderrを利用したメモリリーク - CTFするぞ]\n\ntcache\nfastbin\nunsorted bin\nmmap\n\ncode:c\n struct malloc_chunk {\n   INTERNAL_SIZE_T      mchunk_prev_size;  /* Size of previous chunk (if free).  */\n   INTERNAL_SIZE_T      mchunk_size;       /* Size in bytes, including overhead. */\n   struct malloc_chunk* fd;                /* double links -- used only if free. */\n   struct malloc_chunk* bk;\n   /* Only used for large blocks: pointer to next larger size.  */\n   struct malloc_chunk* fd_nextsize; /* double links -- used only if free. */\n   struct malloc_chunk* bk_nextsize;\n };\nAllocated chunk\ncode:c\n     chunk-\u003e +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n             |             Size of previous chunk, if unallocated (P clear)  |\n             +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n             |             Size of chunk, in bytes                     |A|M|P|\n       mem-\u003e +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n             |             User data starts here...                          .\n             .                                                               .\n             .             (malloc_usable_size() bytes)                      .\n             .                                                               |\n nextchunk-\u003e +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n             |             (size of chunk, but used for application data)    |\n             +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n             |             Size of next chunk, in bytes                |A|0|1|\n             +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\nNotice how the data of an allocated chunk uses the first attribute (mchunk_prev_size) of the next chunk. mem is the pointer which is returned to the user.\nFree chunk\ncode:c\n     chunk-\u003e +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n             |             Size of previous chunk, if unallocated (P clear)  |\n             +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n     `head:' |             Size of chunk, in bytes                     |A|0|P|\n       mem-\u003e +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n             |             Forward pointer to next chunk in list             |\n             +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n             |             Back pointer to previous chunk in list            |\n             +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n             |             Unused space (may be 0 bytes long)                .\n             .                                                               .\n             .                                                               |\n nextchunk-\u003e +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n     `foot:' |             Size of chunk, in bytes                           |\n             +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n             |             Size of next chunk, in bytes                |A|0|0|\n             +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\n ヒープバッファオーバーフロー :  Heap-based buffer overflow\nヒープ上のバッファオーバーフローを利用して、関数の戻りアドレスや関数ポインタを書き換える\n[https://inaz2.hatenablog.com/entry/2014/05/14/011448 ヒープオーバーフローによるGOT overwriteをやってみる - ももいろテクノロジー]\n[https://inaz2.hatenablog.com/entry/2014/05/15/012621 ヒープオーバーフローによるC++ vtable overwriteをやってみる - ももいろテクノロジー]\n\n use-after-free\n解放した領域を誤って使用してしまうUse After Freeを利用し、同じ領域に悪意のあるデータ構造を確保して利用させる事で、関数ポインタを書き換える。\n[https://inaz2.hatenablog.com/entry/2014/06/18/215452 use-after-freeによるGOT overwriteをやってみる - ももいろテクノロジー]\n[https://inaz2.hatenablog.com/entry/2014/06/18/220735 use-after-freeによるC++ vtable overwriteをやってみる - ももいろテクノロジー]\n\n前回使用したサイズ以下の容量を確保することでfreeした後のデータを使える。\n解放済みポインタ ( ダングリングポインタ :  dangling pointer ) を悪意のあるアドレスへ変えることで意図しない挙動にすることができる。\n\n C++ vtable overwrite\nC++では仮想関数を実現する為に実行バイナリ中に型に対して呼び出す関数の対応表( vtable :  virtual method table )を持つ。このvtableの行先を書き換える。たぶん、C++だけではなく動的ポリモーフィズムを選択した言語なら出来そう。\n動的ポリモーフィズム C++\n静的ポリモーフィズム Rust\n[https://inaz2.hatenablog.com/entry/2014/05/15/012621 ヒープオーバーフローによるC++ vtable overwriteをやってみる - ももいろテクノロジー]\n[https://inaz2.hatenablog.com/entry/2014/06/18/220735 use-after-freeによるC++ vtable overwriteをやってみる - ももいろテクノロジー]\n[https://ptr-yudai.hatenablog.com/entry/2019/02/12/000202 _IO_str_overflowを使ったvtable改竄検知の回避手法 - CTFするぞ]\n\n __free_hook 書き換え\n__free_hookはfree時に呼び出す関数アドレスを指定できる。Full RELROでも書き換えられる。\n[https://qiita.com/hanya1995/items/c29a89737bbd521e67f2 SECCON Beginners CTF 2020 Beginners Heap Writeup \u0026初心者向け解説]\n\n tcache poisoning\n[https://hackmd.io/@Xornet/H1hYUUR2I SECCON Beginners CTF 2019 - Babyheap]\n\n tcache double-free\nglibc 2.28 以前の tcache では double free が検出されない\n[https://smallkirby.hatenablog.com/entry/2020/12/15/042803 【pwn 41.0】realloc-baseのmemory corruptionの古い小ネタと最近のtcache周りの小話 - newbieからバイナリアンへ]\n\n　chunk overlap\n\n　fastbin attack\n\n\n[https://ptr-yudai.hatenablog.com/entry/2019/05/31/235444 ヒープ系問題におけるstdout / stderrを利用したメモリリーク - CTFするぞ]\n\n\n## Anti-Exploits\n\n### DEP (Data Execution Prevention)\nNX bit (No eXecute bit)  read write execute protection\nセグメント毎に実行する権限を付与するかしないかを設定する。任意のコードを挿入し実行を誘う攻撃を防御できる。\nメモリ領域のアクセス保護オプションを書き換えるには、Windowsの場合VirtualProtectEx関数、Linuxの場合mprotect(2)が使える。([https://inaz2.hatenablog.com/entry/2014/04/20/010545 Return-to-libcとmprotect(2)でDEPを回避してみる - ももいろテクノロジー] より)\n\n\n### RELRO (RELocation Read-Only)\nGOTは初回呼び出し時に行き先を書き込む ( 遅延バインド: lazy binding )。\n\n[https://inaz2.hatenablog.com/entry/2014/04/30/173618 RELROとformat string attackによるリターンアドレス書き換え - ももいろテクノロジー]\n\n### ASLR (Address Space Layout Randomization)\nスタック領域・ヒープ領域や共有ライブラリが置かれるベースアドレスは一定の範囲の中でランダムに決められる。\nこれらのアドレスを知るには以下のコマンドを叩く。一回目と二回目で変わることが分かる。\n\n```shell\n $ cat /proc/\u003cprocess ID\u003e/maps              // = gdbのi proc map = pwndbgのvmmap\n```\n\n防御機構\nSSP :  Stack-Smashing Protection\n関数呼び出し時にランダムな値(Canary)を配置し、関数から出る時に変化したか検証し、変わっていたら__stack_chk_fail関数を呼び出し、強制終了させる。\n\n#### PIE (Position-Independent Executables)\n\n実行ファイルそのものが置かれるベースアドレスをランダムに決められる。\n\n\n1nibble brute force\n ASLR + PIEに対する対抗策\nベースアドレスがランダム化しても関数・データ間のオフセットは同じであるため、例えば次のようにしてベースアドレスを取得できる。\n  スタックに積まれたリターンアドレスの値から、実行ファイルのベースアドレスが計算できる。\n  一度呼び出されたライブラリ関数のGOTアドレスの値から、そのライブラリのベースアドレスが計算できる。\n  スタックに積まれたsaved ebpの値から、スタック領域に置かれる他のデータのアドレスが計算できる。\n  ヒープ領域に確保されたデータを指すポインタの値から、ヒープ領域のベースアドレスが計算できる。\n\n ASCII-armor - Exec-Shield\n共有ライブラリのベースアドレスを0x00XXXXXXのように\\x00を含めることでret2libcを難しくする機構。\n対抗策\n- ライブラリ内のsystem関数ではなくsystem@pltに飛ばす(ret2plt)。\n- system@pltがなければstrcpy@pltやsnprintf@pltに飛ばして(ret2strcpy)、実行バイナリ中の1バイトで1つずつGOT overwriteし、シェルを起動する。\nhttps://ja.wikipedia.org/wiki/Exec_Shield\n\n /etc/sysctl.conf\n\n KASLR :  Kernel ASLR\n[https://blog.ishikawa.tech/entry/2019/12/17/161319 KASLRの実装と挙動の確認 - 人生は勉強ブログ]\n KADR :  Kernel Address Display Restriction\n KPTI :  Kernel  Page Table Isolation\nMeltdown Spectreに対する防御機構として導入。\n SMAP :  Supervisor Mode Access Prevention, SMEP :  Supervisor Mode Execution Prevention\nuser-space memory mapping\n[https://inaz2.hatenablog.com/entry/2015/03/27/021422 LinuxカーネルモジュールでStackjackingによるSMEP+SMAP+KADR回避をやってみる - ももいろテクノロジー]\n\n\n\n#### gccオプションまとめ\n\nPartial RELRO = RELRO有効かつ遅延バインド有効\nFull RELRO = RELRO有効かつ遅延バインド無効\n\n| やること | オプション |\n|:---|:---|\n| SSP 無効 | `-fno-stack-protector` |\n| SSP 有効 | `-fstack-protector` |\n| NX bit 無効 | `-z execstack` |\n| NX bit 有効 | `-z` |\n| No RELRO | `-Wl,-z,norelro` |\n| Partial RELRO | `-Wl,-z,relro,-z lazy` |\n| Full RELRO | `-Wl,-z,relro,-z,now` |\n| ASLR 無効 | `sudo sysctl kernel.randomize_va_space=0` |\n| ASLR 有効 | `sudo sysctl kernel.randomize_va_space=2` |\n| PIE 無効 | `-fno-pie -no-pie` |\n| PIE 有効 | `-fPIE -pie` |\n| Exec-Shield 無効 | `sudo sysctl -w kernel.exec-shield=0` |\n| Exec-Shield 有効 | `sudo sysctl -w kernel.exec-shield=1` |\n\nchecksec.sh\n\nMaster Canary\nhttps://www.youtube.com/watch?v=UTC2iWxQ4qc\n\n\n## 引数\n\n### fastcall\nシェルを呼び出す\nexecve(\"/bin/sh\", null, null)\nsystem(\"/bin/sh\")\n[https://qiita.com/yyamada_bigtree/items/97ea176484f5b05c195d シェルコード]\n\n ```\n $ (cat out; cat) | ./a.out\n $ nm -D ./a.out | grep \" system\"\n $ strings -a -tx ./libc.so.6 | grep \"sh$\"\n $ objdump -S -M intel ./libc.so.6 --disassemble=execve\n $ ldd a.out\n $ gcc -fno-stack-protector -fPIE bof.c\n $ echo -en \"\"\n $ grep -E \"\"\n $ one_gadget ./libc.so.6\n $ ROPgadget --binary ./a.out\n```\n32bit環境ASLRに対してブルートフォース + NOP sled\nhttps://inaz2.hatenablog.com/entry/2014/03/15/073837\n\nアセンブリを読む\n次の関数を目標にして読むと読みやすい\n引数はどこから入るのか、この引数はどう構成されているのか\ngdb \u003e\u003e\u003e\u003e i files\n\nwine\nWinDbg\nbp \u003caddress\u003e : ブレークポイント\npr : レジスタ情報とgdbでいうnexti\npt : retが来るまで進める\npctr : レジスタ情報とcallとretが来るまで進める\ndc \u003caddress reg\u003e : double word単位とascii文字でデータ表示\n","lastmodified":"2022-10-26T11:26:57.367934441Z","tags":null},"/pwn/template":{"title":"pwn","content":"\n## 説明\n\nCTFのpwn分野で使うテンプレート。pwntoolsパッケージを使用する。\n\n## 実装\n\n```python\nfrom pwn import *\nimport sys\n\nbinary_path = './chall'\n\nif len(sys.argv) == 3:\n    io = remote(sys.argv[1], int(sys.argv[2]))\nelse:\n    io = process(binary_path)\nelf = ELF(binary_path)\n# libc = ELF(\"./libc.so.6\")\ncontext(arch='amd64', os='linux')\n\ndef wait_for_attach():\n    print('attach?')\n    raw_input()\n\n# str   -\u003e bytes: text.encode('utf-8')\n# bytes -\u003e str  : text.decode('utf-8')\n# long  -\u003e bytes(big)   : long_to_bytes(num)\n# long  -\u003e bytes(little): p64(num)\n# bytes -\u003e long(big)    : bytes_to_long(data)\n# bytes -\u003e long(little) : int.from_bytes(data, 'little')\n# bytes -\u003e int          : int(data, 16)\n\npayload = b''\nio.sendlineafter(b'\u003e ', payload)\nio.recvline()\nio.interactive()\n```\n\n## 使用例\n\n```shell\n$ python3 solve.py\n$ python3 solve.py localhost 3000\n```\n\n## 参考文献\n[shellphish/how2heap: A repository for learning various heap exploitation techniques. (github.com)](https://github.com/shellphish/how2heap)\n[Exploiting Intel Graphics Kernel Extensions on macOS | RET2 Systems Blog](https://blog.ret2.io/2022/06/29/pwn2own-2021-safari-sandbox-intel-graphics-exploit/)","lastmodified":"2022-10-26T11:26:57.367934441Z","tags":null},"/rev/anti_debugging":{"title":"Anti debugging","content":"\n## 説明\n\n## 参考\n\n[Linux (anti)+ debugging (feneshi.co)](https://feneshi.co/linux_anti_debugging/)\n[ウェブアプリをソースごとパクる業者に対する対策 - Qiita](https://qiita.com/kacchan6/items/d8576ab6b3c16cf670ca)","lastmodified":"2022-10-26T11:26:57.367934441Z","tags":null},"/rev/detect_virtualization":{"title":"Detect Virtualization","content":"\n## 説明\n\n## 参考\n\n[Linux Detect Virtualization (feneshi.co)](https://feneshi.co/Linux_detect_virtualization/)\n[LordNoteworthy/al-khaser: Public malware techniques used in the wild: Virtual Machine, Emulation, Debuggers, Sandbox detection. (github.com)](https://github.com/LordNoteworthy/al-khaser)","lastmodified":"2022-10-26T11:26:57.367934441Z","tags":null},"/rev/fuzzing":{"title":"Fuzzing","content":"\n## 説明\n\n## 参考\n\n[fuzzuf/algorithm_en.md at master · fuzzuf/fuzzuf (github.com)](https://github.com/fuzzuf/fuzzuf/blob/master/docs/algorithms/afl/algorithm_en.md#algorithm-overview)\n[Ricerca Security: fuzzuf: Fuzzing Unification Framework](https://ricercasecurity.blogspot.com/2021/12/fuzzuf-fuzzing-unification-framework_36.html)\n[オレオレFuzzerもどきを利用してCTFのpwnableを解こう - CTFするぞ (hatenablog.com)](https://ptr-yudai.hatenablog.com/entry/2020/12/15/003822)\n","lastmodified":"2022-10-26T11:26:57.367934441Z","tags":null},"/rev/malware":{"title":"Malware","content":"\n## 説明\n\nCISA\n最近の脆弱性を用いがち\n\nCobalt Strike Beacon\nMalleable C2\n\nAPT ()\n\nAを管理する為に設定ディレクトリかAの親のディレクトリに設定ファイルに相当するものがある\n\n## 参考\n","lastmodified":"2022-10-26T11:26:57.367934441Z","tags":null},"/rev/rev":{"title":"rev","content":"\n\nidiom\n2倍+2をアロケート -\u003e wide char + null終端\n\n","lastmodified":"2022-10-26T11:26:57.367934441Z","tags":null},"/science/%E7%94%9F%E7%89%A9%E5%AD%A6":{"title":"生物学","content":"\n","lastmodified":"2022-10-26T11:26:57.367934441Z","tags":null},"/science/math":{"title":"数学","content":"\n# 数学\n各単元を下の階層で証明する. ここでは重要な定義と本質をまとめる.\n\n## 数学基礎論\n\n[数学基礎論ノート](https://drive.google.com/file/d/1NlaVJEUUf_jEIPLkx6i4JgU9X47J4nat/view?usp=sharing)\n\n## 集合論\n- 全順序集合\n- 同値類\n- 濃度\n\n## 群論\n- 群・正規部分群\n**群**: 単位元, 逆元のある結合的な演算を持つ集合\n**ラグランジュの定理** $|G_1|=|G_2|(G_1:G_2)$\n準同型\n**準同型定理** $G/\\Ker(\\phi)\\cong\\Image(\\phi)$\n- 群の作用\n**Sylow の定理** p-Sylow 部分群の数 $s=|G|/|N_G(H)|=1\\pmod{p}$\n**有限アーベル群の構造定理** $G\\cong\\ZZ/a_1\\ZZ\\times\\ldots\\times\\ZZ/a_n\\ZZ$\n\n## 環・加群\n- 環・イデアル\n**環準同型定理** $A/\\Ker(\\phi)\\cong\\Image(\\phi)$\n- 多項式環\n- 素イデアル・極大イデアル\n**中国剰余定理**\n- 局所化\n- 一意分解環, 単項イデアル整域, ユークリッド環\n環$\\impliedby$可換環$\\impliedby$整域$\\impliedby$正規環$\\impliedby$UFD(一意分解環)$\\impliedby$PID(単項イデアル整域)$\\impliedby$ユークリッド環$\\impliedby$体\n- 加群\n\n## 体論\n- 代数拡大・超越拡大\n有限次拡大$\\iff$有限生成の代数拡大\n- 代数閉包\n**Steinitz の定理**\n- 分離拡大・正規拡大\n既約な非分離多項式 $f(x)\\in K[x]$ $\\iff$$\\ch K=p\u003e0$ であり, 既約な分離多項式 $g(x)\\in K[x]$ と $n\u003e0$ があり, $f(x)=g(x^{p^n})$ となる.\n- Galois 理論\n**Galois の基本定理**\n\n## 代数的整数論\n\n## 代数幾何学\n\n## 圏論\n- 圏論の基本\n**米田の補題**\n```tikz\n\\usepackage{tikz-cd}\n\n\\begin{document}\n\\begin{tikzcd}\n    F(y) \\arrow[r, \"\\phi(y)\"] \\arrow[d, \"F(f)\"] \u0026 G(y)=Hom_{Sets^{C^{op}}}(h_y,F) \\arrow[d, \"G(f)\"] \\\\\n    F(x) \\arrow[r, \"\\phi(x)\"] \u0026 G(x)=Hom_{Sets^{C^{op}}}(h_x,F)\n\\end{tikzcd}\n\\end{document}\n```\n\n## 楕円曲線\n- pairing\n","lastmodified":"2022-10-26T11:26:57.367934441Z","tags":null},"/science/math/%E4%BD%93%E8%AB%96":{"title":"体論","content":"\n$$\n\\newcommand{\\Ker}{\\operatorname{Ker}}\n\\newcommand{\\Image}{\\operatorname{Im}}\n\\newcommand{\\ch}{\\operatorname{ch}}\n\\newcommand{\\Hom}{\\operatorname{Hom}}\n\\newcommand{\\Aut}{\\operatorname{Aut}}\n\\newcommand{\\id}{\\mathrm{id}}\n\\newcommand{\\NN}{\\mathbb{N}}\n\\newcommand{\\ZZ}{\\mathbb{Z}}\n\\newcommand{\\QQ}{\\mathbb{Q}}\n\\newcommand{\\RR}{\\mathbb{R}}\n\\newcommand{\\CC}{\\mathbb{C}}\n\\newcommand{\\FF}{\\mathbb{F}}\n$$\n# 輪読会 復習\n\n## Def. 標数\n$\\phi: \\ZZ\\to K$, $n \\mapsto n\\cdot 1$\n整数は全順序集合なので順序を与えて次のように $\\phi$ を定義する.\n\n$$\n\\phi(n) =\n\\begin{cases}\n\\overbrace{1_K + \\cdots + 1_K}^{n} \u0026 (n \u003e 0) \\\\\n0_K \u0026 (n = 0) \\\\\n-\\phi(-n) \u0026 (n \u003c 0)\n\\end{cases}\n$$\n\nこのとき $\\phi$ は準同型である. $\\phi: \\ZZ\\to K$ に準同型定理を適用して $\\ZZ/\\Ker(\\phi) \\cong \\Im(\\phi)$ となり $\\Im(\\phi)$ は整域なので $\\Ker(\\phi) \\subset \\ZZ$ は素イデアルであり $(0)$ か素数 $p$ を用いて $(p)$ と表せられる. この単項イデアルを生成する元 $0$ または $p$ を標数と呼び, $\\mathrm{ch}\\ K$ と書く.\n\n### Prop. 標数の部分体\n体 $K$ が標数 $0$ なら部分体に $\\QQ$、標数 $p$ なら $\\FF_p$ がある.\nこの命題から $\\QQ$ や $\\FF_p$ を素体と呼ぶ.\n局所化の普遍性 本当に同型になるのか.\n\n**Proof.**\n標数 $0$ ならば標数の定義より $\\ZZ/(0) = \\ZZ \\cong \\Im(\\phi) \\subseteq K$ となる。 $K$ は体より $K\\backslash\\{0\\}$ の元は単元であるから $\\exists S \\subseteq K$, $\\QQ \\cong S$.\n標数 $p$ ならば $\\ZZ/(p) = \\ZZ/p\\ZZ = \\FF_p \\cong \\Im(\\phi) \\subseteq K$ となる.\n\n### Def. フロベニウス写像\n標数 $p$ の体で $q=p^n$ として $(x+y)^q = x^q+y^q, (xy)^q = x^qy^q$ より $\\mathrm{Frob}_q: x \\mapsto x^q$ は体の準同型となる。これをフロベニウス準同型という.\n\n## 拡大体\n### Prop. $K$ 上 $S$ で生成された体 $K(S)$ は体である\n\n**Proof.**\n$K[x_1,\\ldots , x_n]$ は整域であり, それを局所化すると商体となるから、有理関数体 $K(x_1,\\ldots , x_n)$ は体である.\n- $S$ が有限集合のとき\n有理関数体 $K(x_1,\\ldots , x_n)$ に代入して分母が $0$ ではないものを集めたものは体となる.\n- $S$ が無限集合のとき\n任意の有理関数体に無限集合の部分無限集合を代入した体は構成することはできない. なぜなら有理関数体には無限回の演算を伴うからである.\nこれより有限集合で生成した体の和集合は体となる.\n\n### Prop. 7.1.6\n$L/K$ を拡大体, $S\\subset L$ としたとき $T\\subset S \\implies T\\subset K(S) \\implies K(T)\\subset K(S)$\n\n**Proof.**\n$f_1,\\ldots,f_m\\in T$ が $\\alpha_1,\\ldots,\\alpha_n\\in S$ の有理式で表されるなら $f_1,\\ldots,f_m\\in T$ の有理式も $\\alpha_1,\\ldots,\\alpha_n\\in S$ の有理式で表される.\n\n### Def. 代数拡大・超越拡大\n$L$ の全ての元が $K$ 上代数的ならば $L/K$ は代数拡大, そうでなければ超越拡大という.\n\n単拡大が超越拡大になる例: $K(x)/K$, $\\QQ(\\pi)/\\QQ$, $\\QQ(e)/\\QQ$ など.\n\n### Prop. (1) $\\alpha$ は $K$ 上代数的である$\\iff$(2) $K[\\alpha]=K(\\alpha)$\n(1)$\\implies$(2)\n$\\phi\\colon K[x]\\to K[\\alpha]$ を $\\phi(x)=\\alpha$ となる $K$ 準同型を考えると $f(\\alpha)=0$ となる既約多項式を用いて $K[x]/(f(x))\\cong K[\\alpha]$ となる. $K[\\alpha]$ は整域より $(f(x))$ は素イデアルであり, $K[x]$ は単項イデアル整域であるから $(f(x))$ は極大イデアルである. よって $K[\\alpha]$ は体であり, $K[\\alpha] = K(\\alpha)$ となる.\n\n(2)$\\implies$(1)\n$\\alpha = 0$ のときは自明に $K$ 上代数的である. $\\alpha\\neq0$ のとき $\\alpha^{-1}=a_n\\alpha^n+\\ldots+a_0$ とかけるから, $a_n\\alpha^{n+1}+\\ldots+a_0\\alpha-1=0$ より $\\alpha$ は $K$ 上代数的である.\n↑これ天才\n\n### Prop. $K$ 上代数的な元 $\\alpha$ とその最小多項式 $f(x)$ において $[K(\\alpha):K] = \\deg f$ となる。\n$f(x) = x^n + a_{n-1}x^{n-1} + \\ldots + a_0$ とおくと $\\alpha^m = -\\alpha^{m-n}(a_{n-1}\\alpha^{n-1} + \\ldots + a_0)$ となるから $K[\\alpha] = K(\\alpha)$ の任意の元は $c_{n-1}\\alpha^{n-1} + \\ldots + c_0$ とかける. ここで $g(x) = c_{n-1}x^{n-1} + \\ldots + c_0$ とおくと, $g(\\alpha) = 0$ のとき, $g(x) \\neq 0$ なら最小多項式 $f(x)$ と矛盾する為, $g(x) = 0$ となる. よって $\\{\\alpha^{n-1}, \\ldots, 1\\}$ は基底であり, $[K(\\alpha):K] = \\deg f$ となる.\n\n### Prop. $L/K$ 拡大について (1) 有限生成な代数拡大$\\iff$(2) 有限次拡大\n(1)$\\implies$(2)\n有限生成な代数拡大より $L = K(\\alpha_1, \\ldots, \\alpha_n)$ とおくと $L = K(\\alpha_1)\\ldots(\\alpha_n)$ とかけ, 上の命題より単拡大かつ代数拡大は有限次拡大であるから有限回繰り返し用いて有限次拡大となる.\n\n(2)$\\implies$(1)\n$L/K$ が有限次拡大より $n = [L:K]$ とおくと $L$ を $K$ 上ベクトル空間として, その $n$ 個の基底 $\\{x_1,\\ldots,x_n\\}$ で有限生成される. また任意の元 $x\\in L$ について $m \u003e n$ が存在し, $\\{1,x,\\ldots,x^m\\}$ は一次従属となる. よって $a_0, \\ldots, a_m\\in K$ が存在し, $a_0 + \\ldots + a_mx^m = 0$ となり $x$ は代数的な元である. よって有限生成かつ代数拡大となる.\n\n### Prop. $L/M$, $M/K$ が体の代数拡大ならば, $L/K$ も体の代数拡大である\n**Proof.**\n$\\alpha\\in L$ とその $M$ 上最小多項式 $f(x)=x^n+a_1x^{n-1}+\\ldots+a_n\\in M[x]$ をおく. このとき $M' = K(a_1,\\ldots,a_n)$ とおくと $M'/K$ は有限次拡大であり $M'(\\alpha)/M'$ も有限次拡大である. よって $M'(\\alpha)/K$ は代数拡大であり, $\\alpha$ は $K$ 上代数的である.\n\n## 代数閉包\n代数拡大 任意の $\\alpha\\in K$ に対し $f(\\alpha)=0$ となる $f(x)\\in K[x]$ が存在する.\n代数閉体 任意の $f(x)\\in K[x]$ に対し, $f(\\alpha)=0$ となる $\\alpha\\in K$ が存在する.\n代数閉包 代数拡大かつ代数閉体\n\n### Prop. 代数閉包の存在\n**Proof.**\nまず $K$ を含む代数閉体が存在することを示す.\n$K[x]$ の既約多項式の集合 $P$ をおき, $f(x)\\in P$ に対し, (これから構成する拡大体での多項式の根として)1つの変数 $X_f$ を考えた無限変数の多項式環 $A = K[X_f]_{f\\in P}$ を考える.\n$f(X_f)_{f\\in P}$ で生成された $A$ 上イデアル $\\mathfrak{a}$ について $\\mathfrak{a}\\neq A$ であることを示す. $a=A$ と仮定すると, 有限和 $\\sum_{i=1}^na_if_i(X_{f_i})\\in \\mathfrak{a}$ が存在し, $\\sum_{i=1}^na_if_i(X_{f_i})=1$ を満たす. $K$ について各 $f_i(x)$ の根の1つ $\\alpha_i$ により生成された体の $X_f$ による多項式環 $K(\\alpha_1,\\ldots,\\alpha_n)[X_f]_{f\\in P}$ において $X_{f_i}$ に $\\alpha_i$ を代入することで $\\sum_{i=1}^na_if_i(X_{f_i})=0$ が成立する. また $K[X_f]_{f\\in P} \\subset K(\\alpha_1,\\ldots,\\alpha_n)[X_f]_{f\\in P}$ となる為, $\\sum_{i=1}^na_if_i(X_{f_i})=1$ は恒等的に成り立つ. よって $0 = 1$ となり矛盾する.\nこれより $\\mathfrak{a}$ を含む極大イデアル $\\mathfrak{m}$ が存在し, $K_1 = A/\\mathfrak{m}$ は体となる. $P$ の既約多項式 $f(x)$ に $\\alpha = X_f+\\mathfrak{m}$ を代入することで $f(X_f) \\in \\mathfrak{a} \\subset \\mathfrak{m}$ より $f(\\alpha) = f(X_f) + \\mathfrak{m} = 0 + \\mathfrak{m}$ であるから, 任意の $K[x]$ 上既約多項式は $K_1$ で根を持つ. また $X_f\\in K_1$ は $K$ 上代数的であるから $K_1/K$ は代数拡大である.\n\n$K_0=K$ とおいて $K_0$ から $K_1$ を構成したように $K_i$ から $K_{i+1}$ を構成でき, 集合列 $K_0\\subset K_1\\subset K_2\\subset\\ldots$ を作る. $\\overline{K}=\\bigcup_{i=0}^{\\infty}K_i$ とおくと $\\overline{K}$ は代数拡大である. $\\overline{K}$ が代数閉体であることを示す.\n$f(x)\\in\\overline{K}[x]\\backslash\\overline{K}$ について, ある $i$ が存在し, $f(x)\\in K_i[x]$ となる. すると $K_{i+1}$ において $f(x)$ の根 $\\alpha$ が存在する. よって $\\overline{K}$ が代数閉体となるから, $\\overline{K}$ は代数閉包である.\n\n### Prop. $L_1\\subset M_1\\subset K_1$, $L_2\\subset M_2\\subset K_2$ が $K$ の代数拡大で, $L_1$, $L_2$ は代数閉体, $\\phi\\colon M_1\\to M_2$ は $K$ 上同型とする. このとき, $K$ 上同型 $\\psi\\colon L_1\\to L_2$ で $\\phi$ を拡張するものが存在する.\n\n$X$ を $L_1/M_1$ の中間体 $F$ と $\\phi$ の拡張になっている $K$ 同型 $\\psi \\colon F\\to L_2$ の組 $(F, \\psi)$ の集合とする.\n$X$ について順序を定める. $(F_1, \\psi_1), (F_2, \\psi_2)\\in X$ に対し, $F_1\\subset F_2$ かつ $\\psi_2$ が $\\psi_1$ の拡張となっているとき, $(F_1, \\psi_1) \\leq (F_2, \\psi_2)$ とすると順序となる.\n$X$ の任意の全順序部分集合 $Y$ に対し, $F_0 = \\bigcup_{(F,\\psi)\\in Y} F$ とおく. $x\\in F_0$ なら $x\\in F$ となる組 $(F,\\psi)$ が存在し $\\psi_0(x) = \\psi(x)$ とおく. このとき, $(F_0, \\psi_0)$ は $Y$ は上界となる. よって, ツォルンの補題より $X$ に極大元 $(F_{max}, \\psi_{max})$ が存在する.\nもし $L_1 \\neq F_{max}$ なら, $\\alpha\\in L_1\\backslash F_{max}$ をとって $\\psi_{max}$ の拡張である $\\psi'_{max}$ 極大元より大きい元 $(F_{max}(\\alpha), \\psi'_{max})$\n$F_{max}(\\alpha)\\cong F_{max}[x]/(f(x))\\cong\\phi_{max}(F_{max})[x]/(\\psi(f(x)))\\cong \\phi_{max}(F_{max})(\\beta)$\n\n\n\n[疑問] $\\mathbb{F}_2[x]$ 上で $f(x)=(x-\\alpha)^2, f'(x)=0$ は重根であるのか?\n雪江代数2の系3.3.4について互いに素または $f'(x)=0$ として場合分けすれば同様に証明できる. 多分gcdが定義できないときも互いに素と言っていそう.\n","lastmodified":"2022-10-26T11:26:57.367934441Z","tags":null},"/science/math/%E5%9C%8F%E8%AB%96":{"title":"圏論","content":"\n\n淡中圏 ガロア理論\nテイト・シャファレヴィッチ群\n\n```tikz\n\\usepackage{tikz-cd}\n\n\\begin{document}\n\\begin{tikzcd}\n\n    T\n    \\arrow[drr, bend left, \"x\"]\n    \\arrow[ddr, bend right, \"y\"]\n    \\arrow[dr, dotted, \"{(x,y)}\" description] \u0026 \u0026 \\\\\n    K \u0026 X \\times_Z Y \\arrow[r, \"p\"] \\arrow[d, \"q\"]\n    \u0026 X \\arrow[d, \"f\"] \\\\\n    \u0026 Y \\arrow[r, \"g\"]\n    \u0026 Z\n\n\\end{tikzcd}\n\n\\quad \\quad\n\n\\begin{tikzcd}[row sep=2.5em]\n\nA' \\arrow[rr,\"f'\"] \\arrow[dr,swap,\"a\"] \\arrow[dd,swap,\"g'\"] \u0026\u0026\n  B' \\arrow[dd,swap,\"h'\" near start] \\arrow[dr,\"b\"] \\\\\n\u0026 A \\arrow[rr,crossing over,\"f\" near start] \u0026\u0026\n  B \\arrow[dd,\"h\"] \\\\\nC' \\arrow[rr,\"k'\" near end] \\arrow[dr,swap,\"c\"] \u0026\u0026 D' \\arrow[dr,swap,\"d\"] \\\\\n\u0026 C \\arrow[rr,\"k\"] \\arrow[uu,\u003c-,crossing over,\"g\" near end]\u0026\u0026 D\n\n\\end{tikzcd}\n\n\\end{document}\n```\n\n[数学 | 壱大整域 (alg-d.com)](http://alg-d.com/math/)","lastmodified":"2022-10-26T11:26:57.367934441Z","tags":null},"/science/phys":{"title":"物理学","content":"\n# 物理学\n\n## ベクトル解析\n\n[ベクトル解析ノート](https://drive.google.com/file/d/1C-eszj1VSI98aenIdvabiADAPzYHqdXA/view?usp=sharing)\n\n## 電磁気学\n\n## 解析力学\n\n波動方程式の離散化\n\n$$\n\\begin{aligned}\n\\frac{\\partial^2u}{\\partial t^2} \u0026= v^2\\left(\\frac{\\partial^2u}{\\partial x^2} + \\frac{\\partial^2u}{\\partial y^2}\\right) \\\\\n\\frac{u_{i,j}^{n+1}-2u_{i,j}^n+u_{i,j}^{n-1}}{\\Delta t^2} \u0026= v^2\\left(\\frac{u_{i,j}^{n+1}-2u_{i,j}^n+u_{i,j}^{n-1}}{\\Delta x^2} + \\frac{u_{i,j}^{n+1}-2u_{i,j}^n+u_{i,j}^{n-1}}{\\Delta y^2}\\right) \\\\\nu_{i,j}^{n+1} \u0026= 2u_{i,j}^n - u_{i,j}^{n-1} + \\Delta t^2v^2\\left(\\frac{u_{i,j}^{n+1}-2u_{i,j}^n+u_{i,j}^{n-1}}{\\Delta x^2} + \\frac{u_{i,j}^{n+1}-2u_{i,j}^n+u_{i,j}^{n-1}}{\\Delta y^2}\\right)\n\\end{aligned}\n$$\n\n## 量子力学\n","lastmodified":"2022-10-26T11:26:57.367934441Z","tags":null},"/web/Browser":{"title":"","content":"browser\n[d0iasm/vulbr: Toy browser on single process / thread (github.com)](https://github.com/d0iasm/vulbr)\n\nWAF\n\nPHP の `file_get_contents` はローカルファイルもウェブ上も取ってくる。\n正規表現の `.` は改行にマッチしない。\n\n- React\n- Preact\n- MobX\n- Solid: React + MobX feat. Svelte\n- Svelte","lastmodified":"2022-10-26T11:26:57.371934424Z","tags":null},"/web/PrototypePollution":{"title":"Prototype Pollution","content":"\nグローバル変数 `Object.prototype`  と任意のオブジェクトの変数 `\u003cobj\u003e.__proto__` が一致することからの脆弱性","lastmodified":"2022-10-26T11:26:57.371934424Z","tags":null},"/web/security":{"title":"","content":"XSS\nPrototype Pollution\nCSV Injection\nSQL Injection \nFTP Injection\nXXE\nCSRF\nClickjacking\nSSRF\nWeb Cache Poisoning\nRelative Path Overwrite\n\nXXE\nCSP\nWAF","lastmodified":"2022-10-26T11:26:57.371934424Z","tags":null}}