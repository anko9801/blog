{"/":{"title":"🪴 あやめHex","content":"\n## これはなに？\n\nCTF のライブラリ/知識集らしいです。なぜか CTF より競プロや雑学の方が多い。 (現在は LYT に近い思想で書いてる。)\n\n競プロはライブラリ化されたものがよく出回ってるけど、CTF の方はほとんど閉じた場所でしか共有されてないよな～と思ったのであんこ(将来的に traP の CTF 班)が CTF に関するライブラリや CTF に必要な知識をまとめたものです。編集したい方は大歓迎です！気軽にプルリク投げてください～\n\n説明を読めば機能最小限の同じものを自作できること以上、研究的な部分は自分が面白いとか知識が整理されたなとか思えば載せます。\n\nこれらは CC0 ライセンスとします。自由にコピペして OK です！\nTODO: ライセンス\n\n## 競プロ\n- [テンプレート](./Template.md)\n- Python\n- Rust\n\n## データ構造\n- [UnionFind](./DataStructure/UnionFind/UnionFind.md)\n\t- [ポテンシャル付きUnionFind](./DataStructure/UnionFind/PotentialUnionFind.md)\n\t- [永続UnionFind](./DataStructure/UnionFind/PersistUnionFind.md)\n- [BIT (Binary-Indexed-Tree) / Fenwick Tree](./DataStructure/BIT/BIT.md)\n- Sparse Table\n- [セグメント木](./DataStructure/SegTree/SegTree.md)\n\t- [遅延セグメント木](./DataStructure/SegTree/LazySegTree.md)\n\t- [Segment Tree Beats](./DataStructure/SegTree/SegTreeBeats.md)\n- 平方分割, パケット法\n- 平衡二分探索木\n\t- 赤黒木 RBST\n\t- AVL木\n\t- Splay木\n\t- Treap\n- Wavelet Matrix\n- Wavelet Tree\n- [slope trick](./DataStructure/SlopeTrick.md)\n- コンテナ\n\t- List\n\t- Map\n\t- Set\n\t- Unorderd Map\n\t- Unordered Set\n\n## グラフ\n- [グラフ](./Graph/Graph.md)\n\t- [最短経路問題](./Graph/ShortestPath/ShortestPath.md)\n\t\t- [単一始点最短路 $O(E\\log V)$ (Dijkstra)](./Graph/ShortestPath/Dijkstra.md)\n\t\t\t- k-最短路 $O(kE\\log V)$ (Dijkstra)\n\t\t- [単一始点最短路 $O(EV)$ (Bellman-Ford)](./Graph/ShortestPath/BellmanFord.md)\n\t\t\t- 負閉路検出 $O(EV)$ (Bellman-Ford)\n\t\t- [全点対間最短路 $O(V^3)$ (Floyd Warshall)](./Graph/ShortestPath/FloydWarshall.md)\n\t\t- 全点対間最短路 $O((V + E)V\\log V)$ (Johnson)\n\t- 閉路検出\n\t- 全域木\n\t\t- 最小全域森 $O(E\\log V)$ (Prim)\n\t\t- 最小全域森 $O(E\\log V)$ (Kruskal)\n\t- [フロー](./Graph/Flow/Flow.md)\n\t\t- [最大流 $O(V^2E)$ (Dinic)](./Graph/Flow/Dinic.md)\n\t\t- [最大流 $O(E\\times\\mathrm{maxFlow})$ (Ford Fulkerson)](./Graph/Flow/FordFulkerson.md)\n\t\t- 最小費用流\n\t\t- 燃やす埋める\n\t- [強連結成分分解](./Graph/SCC.md)\n\t- Dilworth の定理\n\t- 最大クリーク\n\t- 最大独立集合\n\t- Functional Graph\n\t- トポロジカルソート\n\t- 2-SAT\n- ツリー\n\t- [木の直径](./graph/tree/diameter.md)\n\t- 木の重心\n\t- 重心分解\n\t- HL分解\n\t- オイラーツアー\n\t- 最小共通祖先\n\n## 算数\n- Bit Trick\n- 数論\n\t- [拡張 Euclid の互除法](./Arithmetic/gcd.md)\n\t- [数論的関数/進数変換](./Arithmetic/ArithmeticalFunction.md)\n\t- 素数\n\t\t- [素因数分解](./Arithmetic/Primes/Factorize.md)\n\t\t- [高速素因数分解 (Pollard-$\\rho$法/Millar-Rabin)](./Arithmetic/Primes/FastFactorize.md)\n\t\t- [素数列挙 (エラトステネスの篩)](./Arithmetic/Primes/Primes.md)\n\t\t- 素数判定\n\t\t- 素数テーブル\n\t- 剰余\n\t\t- [Modint](./Arithmetic/Modulo/Modint.md)\n\t\t- [任意Modint](./Arithmetic/Modulo/ArbitraryModint.md)\n\t- [中国剰余定理](./Arithmetic/CRT.md)\n\t- floor sum\n\t- 二分探索\n\t- 三分探索\n- 有理数\n- [行列](./Arithmetic/Matrix/Matrix.md)\n- [高速フーリエ変換 (FFT)](./Arithmetic/FFT.md)\n\t- 任意mod畳み込み\n\t- [高速ゼータ変換/高速メビウス変換](./Arithmetic/Zeta.md)\n\t- Karatsuba 法\n- 形式的冪級数 (FPS)\n\t- [数論変換 (NTT)](./Arithmetic/NTT.md)\n\t- 多項式GCD\n\t- 多項式補間\n- スライド最小値\n\n## 探索\n- 深さ優先探索\n- 幅優先探索\n- 座標圧縮\n- 枝刈り\n- A*\n- IDA*\n- α-β 探索\n\n## 幾何\n- [幾何ライブラリ](./Geometry/Geometry.md)\n- 凸包\n- 偏角ソート\n\n## 文字列\n- Z algorithm\n- Rabin-Karp 法\n- 最長増加部分列\n- ローリングハッシュ\n- 接尾辞配列\n- Boyer-Moore\n- LL(1) parser\n- Aho-Corasick\n\n## 典型\n- しゃくとり法\n- 動的計画法\n- 集合の整数表現\n- 最小値の最大化\n- 半分全列挙\n- 行列累乗\n- 数え上げ\n\t- 包除原理\n\t- 対称性\n- Grundy 数\n\n## ヒューリスティック\n- [山登り法](./Heuristic/HillClimbing.md)\n- [焼きなまし法](./Heuristic/SimulatedAnnealing.md)\n- [ビームサーチ](./Heuristic/BeamSearch.md)\n- [chokudai サーチ](./Heuristic/ChokudaiSearch.md)\n\n## Pwn\n使用言語はPythonまたはC言語です。\n\n- Linux Userland\n\t- [テンプレート](./pwn/LinuxUserland/template.md)\n\t- [pwn を解く為に必要なステップ](./pwn/LinuxUserland/method.md)\n\t- [脆弱性とセキュリティ機構](./pwn/LinuxUserland/vulns\u0026security.md)\n\t- Stack Exploit\n\t\t- [脆弱性とセキュリティ機構](./pwn/LinuxUserland/StackExploit/vulns\u0026security.md)\n\t\t- [ret2xxx](./pwn/LinuxUserland/StackExploit/ret2xxx.md)\n\t\t- [ROP: Return Oriented Programming](./pwn/LinuxUserland/StackExploit/ROP.md)\n\t- [Format String Attack](./pwn/LinuxUserland/FormatStringAttack.md)\n\t- [GOT overwrite](./pwn/LinuxUserland/GOToverwrite.md)\n\t- [glibc](./pwn/LinuxUserland/glibc/glibc.md)\n\t\t- [glibc heap](./pwn/LinuxUserland/glibc/glibc_heap/glibc_heap.md)\n\t\t\t- [malloc_chunk](./pwn/LinuxUserland/glibc/glibc_heap/malloc_chunk.md)\n\t\t\t- [malloc_state](./pwn/LinuxUserland/glibc/glibc_heap/malloc_state.md)\n\t\t\t- [Bins and Chunks](./pwn/LinuxUserland/glibc/glibc_heap/BinsChunks.md)\n\t\t\t- [Internal Functions](./pwn/LinuxUserland/glibc/glibc_heap/InternalFunctions.md)\n\t\t\t- [Core Functions](./pwn/LinuxUserland/glibc/glibc_heap/CoreFunctions.md)\n\t\t\t- [Security Checks](./pwn/LinuxUserland/glibc/glibc_heap/SecurityChecks.md)\n\t\t- [`_IO_FILE`](./pwn/LinuxUserland/glibc/_IO_FILE/_IO_FILE.md)\n\t- [Heap Exploit](./pwn/LinuxUserland/HeapExploit/HeapExploit.md)\n\t\t- [脆弱性とセキュリティ機構](./pwn/LinuxUserland/HeapExploit/vulns\u0026security.md)\n\t\t- First Fit\n\t\t- Double Free\n\t\t- Forging chunks\n\t\t- Unlink Exploit\n\t\t- Shrinking Free Chunks\n\t\t- [tcache poisoning](./pwn/LinuxUserland/HeapExploit/tcache_poisoning.md)\n\t\t- fastbin attack\n\t\t- overlapping chunks\n\t\t- mmap overlapping chunks\n\t\t- House of XXX\n\t\t\t- [House of Orange](./pwn/LinuxUserland/HeapExploit/HouseOfXXX/HouseOfOrange.md)\n\t\t\t- [House of Botcake](./pwn/LinuxUserland/HeapExploit/HouseOfXXX/HouseOfBotcake.md)\n\t\t\t- [House of Spirit](./pwn/LinuxUserland/HeapExploit/HouseOfXXX/HouseOfSpirit.md)\n\t\t\t- [House of Lore](./pwn/LinuxUserland/HeapExploit/HouseOfXXX/HouseOfLore.md)\n\t\t\t- House of Storm\n\t\t\t- House of Force\n- Linux Kernel\n\t- [テンプレート](./pwn/LinuxKernel/kernel_exploit.md)\n\t- Kernel Code Reading\n\t\t- セキュリティ機構\n\t\t- カーネルモジュール\n\t- Heap Spray\n\t- Dirty Pipe\n\t- Race Condition\n- Windows Userland\n- Windows Kernel\n- VM Escape\n\t- Container Escape\n- [Automatic Exploit Generation](./pwn/AEG.md)\n\n## Crypto\nそれぞれの暗号自体を取り扱うのではなく、Cryptoの背景にある理論を取り扱っていきます。使用言語はPythonまたはSageMathです。\n\n- [SageMathチートシート](./Crypto/sagemath.md)\n- 暗号構成基盤\n\t- 攻撃者から守る為に\n\t- [Diffie-Hellman 鍵交換](./Crypto/Cryptography/Diffie-Hellman.md)\n\t- [Fiat-Shamir 変換](./Crypto/Cryptography/Fiat-Shamir.md)\n\t\t- [Schnorr 署名](./Crypto/Cryptography/Schnorr.md)\n\t\t- [Frozen Heart](./Crypto/Cryptography/FrozenHeart.md)\n\t- Lamport 署名\n\t- [ゼロ知識証明](./Crypto/Cryptography/ZeroKnowledgeProof.md)\n\t- [Fujisaki-Okamoto Transformation](./Crypto/Cryptography/Fujisaki-Okamoto_Transformation.md)\n\t- [準同型暗号](./Crypto/Cryptography/homomorphism.md)\n- [格子](./Crypto/Lattice/tour_of_Lattice.md)\n\t- [Gram-Schmidt](./Crypto/Lattice/GSO.md)\n\t- SVP (Shortest Vector Problem)\n\t\t- [Lagrange 基底簡約 (Gauss 基底簡約)](./Crypto/Lattice/Lagrange.md)\n\t\t- [サイズ基底簡約](./Crypto/Lattice/size_reduction.md)\n\t\t- [LLL 基底簡約](./Crypto/Lattice/LLL.md)\n\t\t- BKZ 基底簡約 / HKZ 基底簡約\n\t\t- Kannan’s embedding method\n\t- CVP (Closest Vector Problem)\n\t\t- Babai’s Algorithm\n\t- Merkle-Hellmanナップサック暗号\n\t\t- LO法\n\t\t- CLOS法\n\t- LWE (Learning with Errors) 暗号\n\t\t- LWE\n\t\t\t- BDD (Bounded Distance Decoding) Attack\n\t\t\t- SIS (Short Integer Solution) Attack\n\t\t\t- BKW Attack\n\t\t\t- Arora-Ge Attack\n\t\t- Ring-LWE\n\t\t- Module-LWE\n\t\t\t- CRYSTALS\n\t\t- LWR\n\t- [TFHE (Torus Fully Homomorphic Encryption)](./Crypto/Lattice/TFHE.md)\n- 多項式\n\t- [Coppersmith Method](./Crypto/coppersmith.md)\n\t- グレブナー基底\n\t- 終結式\n\t- MQ 問題\n\t- Matsumoto-Imai 暗号 / HFE 暗号\n\t- NTRU 暗号\n\t- Rainbow 署名\n\t- UOV 署名 / QR-UOV 署名\n- 数論\n\t- ディオファントス方程式\n\t\t- 二平方和\n\t\t- ペル方程式\n\t- [離散対数問題 (DLP)](./Crypto/DLP/DLP.md)\n\t\t- [Baby-step Giant-step](./Crypto/DLP/BSGS.md)\n\t\t- [Pollard's rho 法](./Crypto/DLP/Pollard_rho.md)\n\t\t- 指数計算法 (Index Calculus Algorithm)\n\t\t- 数体ふるい法\n\t\t- [Pohlig-Hellman](./Crypto/DLP/Pohlig_Hellman.md)\n- [RSA暗号](./Crypto/RSA/RSA.md)\n\t- [Wiener's Attack](./Crypto/RSA/WienersAttack.md)\n\t- [Boneh-Durfee Attack](./Crypto/RSA/Boneh-DurfeeAttack.md)\n\t- [Common Modulus Attack](./Crypto/RSA/CommonModulusAttack.md)\n\t- [Håstad's Broadcast Attack](./Crypto/RSA/HåstadsBroadcastAttack.md)\n\t- [Small Common Private Exponent Attack](./Crypto/RSA/SmallCommonPrivateExponentAttack.md)\n\t- [適応的選択暗号文攻撃](./Crypto/RSA/RSA-CCA.md)\n\t- [LSB Decryption Oracle Attack](./Crypto/RSA/LSB-DecryptionOracleAttack.md)\n\t- [RSA-CRT Fault Attack](./Crypto/RSA/RSA-CRT-FaultAttack.md)\n\t- [Franklin-Reiter Related Message Attack](./Crypto/RSA/Franklin-ReiterRelatedMessageAttack.md)\n\t- [Partial Key Exposure Attack](./Crypto/RSA/PartialKeyExposureAttack.md)\n\t- [逆元が存在しないとき](./Crypto/RSA/NoInverse.md)\n\t- [ROCA Attack](./Crypto/RSA/ROCA.md)\n- [楕円曲線暗号](./Crypto/ECC/ECC.md)\n\t- 楕円曲線\n\t\t- Millar のアルゴリズム\n\t\t- [Schoof のアルゴリズム](./Crypto/ECC/Schoof.md)\n\t\t- Tate pairing / Weil pairing\n\t\t- [ECFFT](./Crypto/ECC/ECFFT.md)\n\t\t- 超楕円曲線\n\t- 攻撃\n\t\t- [Pohlig-Hellman Attack](./Crypto/ECC/Pohlig-Hellman.md)\n\t\t- [MOV/FR Reduction](./Crypto/ECC/MOV-FR-Reduction.md)\n\t\t- [SSSA Attack](./Crypto/ECC/SSSA-Attack.md)\n\t\t- [Invalid Curve Attack](./Crypto/ECC/Invalid-Curve-Attack.md)\n\t\t- [GHS Attack](./Crypto/ECC/GHS-Attack.md)\n\t\t- Dual EC DRBG\n\t\t- [Attacks on SIKE](./Crypto/ECC/SIKE.md)\n- [AES](./Crypto/AES/AES.md)\n\t- Padding Oracle Attack\n\t- BEAST Attack\n\t- Lucky Thirteen Attack\n\t- POODLE Attack\n\t- ghash\n\t- Integral Cryptanalysis\n- [その他の暗号](./Crypto/Cryptography/other.md)\n- [Hash](./Crypto/Hash/hash.md)\n\t- 誕生日攻撃\n\t- [Differencial cryptanalysis](./Crypto/Hash/DifferencialCryptoanalysis.md)\n- 疑似乱数生成器 (PRNG)\n\t- Xorshift\n\t- [Mersenne twister](./Crypto/PRNG/MersenneTwister.md)\n- ブロックチェーン\n\t- Flash Loan Attack\n- [参考文献](./Crypto/Books.md)\n\n## Web\nWebに関してはよわよわなので読み込むと良いかもしれない資料リストを集めています。(これ読むといいよみたいなのがあったら教えてくださると助かります！)\n\n- [Prototype Pollution](./Web/PrototypePollution.md)\n- [CTFにおけるWebセキュリティ入門とまとめ](https://blog.hamayanhamayan.com/entry/2021/12/01/194114)\n- 常設Web問\n\t- [Web Security Academy](https://portswigger.net/web-security/all-labs)\n\t- [KENRO](https://kenro.flatt.tech)\n\t- [wargame.kr](http://wargame.kr)\n\t- [XSS Game](https://xss-game.appspot.com)\n\t- [The Lord of the SQLI](https://los.rubiya.kr)\n- [SQL Injection list](https://github.com/payloadbox/sql-injection-payload-list)\n\n## Misc\nCTF の3大分野以外をまとめます.\n\n- [Forensics](./Misc/Forensics/Forensics.md)\n\t- [Windows](./Misc/Forensics/Windows.md)\n- [OSINT](./Misc/OSINT.md)\n- Reversing\n\t- [表層解析](./Reversing/SurfaceAnalysis.md)\n\t- 静的解析\n\t\t- Ghidra\n\t- 動的解析\n\t\t- Fuzzing\n\t\t- [シンボリック実行](./other/SAT-SMT/SymbolicExecution.md)\n\t- [マルウェア](./Reversing/Malware/Malware.md)\n\t\t- [デバッグ検知](./Reversing/Malware/AntiDebugging.md)\n\t\t- [仮想化検知](./Reversing/Malware/DetectVirtualization.md)\n\t\t- [Windowsの内部](./Reversing/Malware/WindowsInternal.md)\n- バイナリフォーマット探検隊\n\t- [ASCII](./Misc/BinaryFormat/ASCII.md)\n\t- [Unicode](./Misc/BinaryFormat/Unicode.md)\n\t- [ELF](./Misc/BinaryFormat/ELF.md)\n\t- [FAT32](./Misc/BinaryFormat/FAT32.md)\n\t- ext4\n\t- [ZIP](./Misc/BinaryFormat/ZIP.md)\n\t- JPEG\n- ピッキング\n- Tamper Evident\n- Social Engineering\n- Car Hacking\n- [Pyjail](./Misc/Misc/Pyjail.md)\n\n## コンピュータ・アーキテクチャ\n- [数学](./Science/Math/Math.md)\n\t- [命題論理](./Science/Math/PropositionalLogic.md)\n\t- [意味論](./Science/Math/Semantics.md)\n- [物理](./Science/Physics/Physics.md)\n\t- 航空技術\n- [回路](./other/Circuit/Circuit)\n\t- 回路素子\n\t- アナログ回路\n\t\t- 抵抗とコンデンサ\n\t\t- 昇圧チョッパ回路\n\t\t- マルチバイブレータ回路\n\t\t- 発振回路\n\t\t\t- コルピッツ発振回路\n\t\t- 電源\n\t\t- パワエレ\n\t\t- ノイズキャンセリング\n\t\t- センサー・アクチュエータ\n\t\t\t- モーター\n\t\t\t- Hブリッジ回路\n\t\t\t- PWM制御\n\t\t\t- ゲートドライバ\n\t\t\t\t- FETのオン抵抗, デッドタイム、昇圧回路\n\t\t\t- TA7291P, TB6643KQ, L298N\n\t- デジタル回路\n\t\t- 遅延回路 + シュミットトリガ\n\t\t- キーボード\n\t\t- AVLライタ\n\t\t- 論理回路\n\t\t\t- ラッチ\n\t\t\t- フリップフロップ\n\t\t- [マイコン](./other/Circuit/Digital/Microcomputer.md)\n\t\t- 通信\n- [プロセッサ](./other/Processor/Processor.md)\n\t- [LSI](./other/Processor/LSI)\n\t- Spectre / Meltdown\n\t- HIEE; Hardware-assisted Isolated Execution Environments\n\t\t- [TEE; Trusted Execution Environment](./other/Processor/HIEE/TEE.md)\n\t\t- [TPM; Trusted Platform Module](./other/Processor/HIEE/TPM.md)\n\t\t- [DRM; Digital Rights Management](./other/Processor/HIEE/DRM.md)\n\t\t- DAA; Direct Anonymous Attestation\n\t- [rootkit](./other/Processor/rootkit.md)\n- 論理\n- マイクロアーキテクチャ\n- アーキテクチャ\n- 仮想化技術\n\t- [エミュレータ](./other/Virtualization/Emulator.md)\n\t- [コンテナ仮想化技術](./other/Virtualization/Container.md)\n\t- [ハイパーバイザの作り方](https://syuu1228.github.io/howto_implement_hypervisor/)\n- [OS](./other/OS/OS.md)\n\t- [略語](./other/OS/abbreviation)\n\t- [スケジューラ](./other/OS/Scheduler)\n\t- BIOS/UEFI\n\t- ACPI\n\t- NIC\n- サーバー\n\t- [RDBMS](./other/Server/RDBMS.md)\n\t- [RDBMS 最適化](./other/Server/rdbms-optimization.md)\n\t- [リバースプロキシ](./other/Server/reverse-proxy.md)\n\t- [リバースプロキシ最適化](./other/Server/reverse-proxy-optimization.md)\n\t- [フロントエンド最適化](./other/Server/frontend-optimization.md)\n- [ネットワーク](./other/Network/Network.md)\n\t- [SDR](./other/Network/SDR.md)\n\n## 量子アルゴリズム\n\n- [各ゲートの紹介と量子計算の方法](./other/Quantum/Quantum.md)\n- Shor のアルゴリズム\n- 量子暗号通信\n- 量子中継ネットワーク\n\n## 雑学\n\n- 生物学\n- [プログラミング言語](./other/Programming/Programming.md)\n\t- [型推論](./other/Programming/Type.md)\n\t- [toolchain](./other/Programming/toolchain)\n\t- 未定義動作\n\t- シェル\n\t- 定理証明支援系\n- [SAT/SMT](./other/SAT-SMT/SAT-SMT.md)\n\t- [シンボリック実行エンジン](./other/SAT-SMT/SymbolicExecution.md)\n\t- 自動定理証明支援系\n- レンダリング\n\t- [レイトレーシング](./other/Rendering/RayTracing.md)\n- ブロックチェーン\n- [Deep Learning](./other/DeepLearning.md)\n- [【画像処理入門】アルゴリズム＆プログラミング](https://algorithm.joho.info/programming/image-processing/)\n- 超解像\n- [ツール](./other/Tools)\n\n## 脆弱性集\n\n- [CVEs for the Rust standard library](https://rustrepo.com/repo/Qwaz-rust-cve-rust-security-tools)\n\t- [Rustのunsound hole issue #25860を理解する](https://speakerdeck.com/moratorium08/rustfalseunsound-hole-issue-number-25860woli-jie-suru)\n\t- [str::repeat - stable wildcopy exploit](https://saaramar.github.io/str_repeat_exploit/)","lastmodified":"2022-12-30T07:57:21.463263852Z","tags":null},"/DataStructure/BIT/BIT":{"title":"Binary Indexed Tree","content":"\n## 説明\n\n## 計算量\n\n- add $O(\\log N)$\n- sum $O(\\log N)$\n\n## 実装\n\n```cpp\ntemplate \u003ctypename T\u003e\nclass BIT {\n  int N;\n  vector\u003cT\u003e bit;\n  BIT(isizet size) {\n    N = size + 2;\n    bit.assign(N + 1, {});\n  }\n\n  // get sum of [0, i]\n  T sum(int i) const {\n    T res({});\n    for (++i; i \u003e 0; i -= (i \u0026 -i)) res += bit[i];\n    return res;\n  }\n\n  // get sum of [l, r]\n  inline T sum(int l, int r) { return sum(r) - sum(l - 1); }\n\n  // get value of i\n  inline T operator[](int i) const { return sum(i) - sum(i - 1); }\n\n  // data[i] += x\n  void add(int i, T x) {\n    for (++i; i \u003c= N; i += (i \u0026 -i)) bit[i] += x;\n  }\n\n  // range add x to [l, r]\n  void imos(int l, int r, T x) {\n    add(l, x);\n    add(r + 1, -x);\n  }\n\n  // minimize i s.t. sum(i) \u003e= w\n  int lower_bound(T w) {\n    if (w \u003c= 0) return 0;\n    int x = 0;\n    for (int i = 1 \u003c\u003c __lg(N); i \u003e 0; i \u003e\u003e= 1) {\n      if (x + k \u003c N \u0026\u0026 bit[x + i] \u003c w) {\n        w -= bit[x + i];\n        x += i;\n      }\n    }\n    return x;\n  }\n\n  // minimize i s.t. sum(i) \u003e w\n  int upper_bound(T w) {\n    if (w \u003c 0) return 0;\n    int x = 0;\n    for (int i = 1 \u003c\u003c __lg(N); i \u003e 0; i \u003e\u003e= 1) {\n      if (x + k \u003c= N \u0026\u0026 bit[x + i] \u003c= w) {\n        w -= bit[x + i];\n        x += i;\n      }\n    }\n    return x;\n  }\n};\n```\n\n## 使用例\n\n```cpp\n#include \u003cbit.hpp\u003e\n#include \u003cvector\u003e\n\n// 転倒数 重複あり\ntemplate \u003ctypename T\u003e\nlong long inversion_counting(const std::vector\u003cT\u003e \u0026v) {\n  std::vector\u003cT\u003e xs{v};\n  sort(xs.begin(), xs.end());\n  xs.erase(unique(xs.begin(), xs.end()), xs.ned());\n  int N = xs.size();\n  BinaryIndexedTree\u003cT\u003e bin(N);\n  long long ans = 0;\n  for (long long i = 0; i \u003c N; i++) {\n    int s = lower_bound(xs.begin(), xs.end(), xs[i]) - xs.begin();\n    ans += i - bin.sum(v[i]);\n    bin.add(v[i], 1);\n  }\n  return ans;\n}\n\n// 隣接 swap によって v を w に変えるのにかかる手数 (不可能 : -1)\ntemplate \u003ctypename T\u003e\nlong long swap_distance(const std::vector\u003cT\u003e \u0026v, const std::vector\u003cT\u003e \u0026w) {\n  if (v.size() != w.size()) return -1;\n\n  long long N = v.size();\n  std::vector\u003cpair\u003cT, int\u003e\u003e vv(N), ww(N);\n  for (int i = 0; i \u003c N; i++) {\n    vv[i] = make_pair(v[i], i);\n    ww[i] = make_pair(w[i], i);\n  }\n  sort(vv.begin(), vv.end());\n  sort(ww.begin(), ww.end());\n  std::vector\u003cint\u003e order(N);\n  for (int i = 0; i \u003c N; i++) {\n    if (vv[i].first != ww[i].first) return -1;\n    order[vv[i].second] = ww[i].second;\n  }\n  return inversion_counting(order);\n}\n```\n","lastmodified":"2022-12-30T07:57:21.463263852Z","tags":null},"/DataStructure/BinarySearchTree/Treap":{"title":"Treap","content":"\n## 説明\n\n## 計算量\n$O(\\log n)$\n\n## 実装\n\n## 使用例\n\n## 参考\n- [Implicit Treap - 競プロ練習記録 (hatenablog.com)](https://xuzijian629.hatenablog.com/entry/2018/12/08/000452)\n- [プログラミングコンテストでのデータ構造 2　～平衡二分探索木編～ (slideshare.net)](https://www.slideshare.net/iwiwi/2-12188757)\n- [データ構造とアルゴリズム AVL木 (平衡探索木) (uec.ac.jp)](http://dopal.cs.uec.ac.jp/okamotoy/lect/2005/DSA/avl.pdf)\n\n\n","lastmodified":"2022-12-30T07:57:21.463263852Z","tags":null},"/DataStructure/LinkedList":{"title":"","content":"```\npub enum List {\n    Empty,\n    Elem(i32, List),\n}\n```\n\n単方向だと要素を追加するときに前のリストを変更する必要が無いから永続化可能","lastmodified":"2022-12-30T07:57:21.463263852Z","tags":null},"/DataStructure/SegTree/LazySegTree":{"title":"遅延セグメント木","content":"\n## 説明\n\n## 計算量\n\n## 実装\n\n```cpp\n#include \u003calgorithm\u003e\n#include \u003ccassert\u003e\n#include \u003ciostream\u003e\n#include \u003cvector\u003e\n\nnamespace internal {\nint ceil_pow2(int n) {\n  int x = 0;\n  while ((1U \u003c\u003c x) \u003c (unsigned int)(n))\n    x++;\n  return x;\n}\n\n} // namespace internal\n\ntemplate \u003cclass S, S (*op)(S, S), S (*e)(), class F, S (*mapping)(F, S),\n          F (*composition)(F, F), F (*id)()\u003e\nstruct lazy_segtree {\nprivate:\n  int _n, size, log;\n  std::vector\u003cS\u003e node;\n  std::vector\u003cF\u003e lazy;\n\npublic:\n  lazy_segtree() : lazy_segtree(0) {}\n  explicit lazy_segtree(int n) : lazy_segtree(std::vector\u003cS\u003e(n, e())) {}\n  explicit lazy_segtree(const std::vector\u003cS\u003e \u0026v) : _n(int(v.size())) {\n    log = internal::ceil_pow2(_n);\n    size = 1 \u003c\u003c log;\n    node = std::vector\u003cS\u003e(2 * size, e());\n    lazy = std::vector\u003cF\u003e(size, id());\n    // セグ木の初期化\n    // 最下層: size + k\n    // 親 k \u003e\u003e 1\n    // 子 2*k, 2*k + 1\n    for (int i = 0; i \u003c _n; i++)\n      node[size + i] = v[i];\n    for (int i = size - 1; i \u003e= 1; i--)\n      update(i);\n  }\n\n  // a[p] = x : O(logN)\n  void set(int p, S x) {\n    assert(0 \u003c= p \u0026\u0026 p \u003c _n);\n    p += size;\n    for (int i = log; i \u003e= 1; i--)\n      push(p \u003e\u003e i);\n    node[p] = x;\n    for (int i = 1; i \u003c= log; i++)\n      update(p \u003e\u003e i);\n  }\n\n  // a[p] : O(1)\n  S get(int p) {\n    assert(0 \u003c= p \u0026\u0026 p \u003c _n);\n    p += size;\n    for (int i = log; i \u003e= 1; i--)\n      push(p \u003e\u003e i);\n    return node[p];\n  }\n\n  // op(a[l, r)) をモノイドの性質を満たしていると仮定して計算 : O(logN)\n  S prod(int l, int r) {\n    assert(0 \u003c= l \u0026\u0026 l \u003c= r \u0026\u0026 r \u003c= _n);\n    if (l == r)\n      return e();\n\n    l += size;\n    r += size;\n\n    for (int i = log; i \u003e= 1; i--) {\n      if (((l \u003e\u003e i) \u003c\u003c i) != l)\n        push(l \u003e\u003e i);\n      if (((r \u003e\u003e i) \u003c\u003c i) != r)\n        push((r - 1) \u003e\u003e i);\n    }\n\n    S sml = e(), smr = e();\n    while (l \u003c r) {\n      if (l \u0026 1)\n        sml = op(sml, node[l++]);\n      if (r \u0026 1)\n        smr = op(node[--r], smr);\n      l \u003e\u003e= 1;\n      r \u003e\u003e= 1;\n    }\n\n    return op(sml, smr);\n  }\n\n  // op(a[0, n)) : O(logN)\n  S all_prod() { return node[1]; }\n\n  // a[p] = f(a[p]) : O(logN)\n  void apply(int p, F f) {\n    assert(0 \u003c= p \u0026\u0026 p \u003c _n);\n    p += size;\n    for (int i = log; i \u003e= 1; i--)\n      push(p \u003e\u003e i);\n    node[p] = mapping(f, node[p]);\n    for (int i = 1; i \u003c= log; i++)\n      update(p \u003e\u003e i);\n  }\n  // a[i] = f(a[i]) in [l, r) : O(logN)\n  void apply(int l, int r, F f) {\n    assert(0 \u003c= l \u0026\u0026 l \u003c= r \u0026\u0026 r \u003c= _n);\n    if (l == r)\n      return;\n\n    l += size;\n    r += size;\n\n    for (int i = log; i \u003e= 1; i--) {\n      if (((l \u003e\u003e i) \u003c\u003c i) != l)\n        push(l \u003e\u003e i);\n      if (((r \u003e\u003e i) \u003c\u003c i) != r)\n        push((r - 1) \u003e\u003e i);\n    }\n\n    {\n      int l2 = l, r2 = r;\n      while (l \u003c r) {\n        if (l \u0026 1)\n          all_apply(l++, f);\n        if (r \u0026 1)\n          all_apply(--r, f);\n        l \u003e\u003e= 1;\n        r \u003e\u003e= 1;\n      }\n      l = l2;\n      r = r2;\n    }\n\n    for (int i = 1; i \u003c= log; i++) {\n      if (((l \u003e\u003e i) \u003c\u003c i) != l)\n        update(l \u003e\u003e i);\n      if (((r \u003e\u003e i) \u003c\u003c i) != r)\n        update((r - 1) \u003e\u003e i);\n    }\n  }\n\n  // 二分探索\n  // r where g(op(a[l, r))) = true \u0026 g(op(a[l, r])) = false : O(logN)\n  template \u003cbool (*g)(S)\u003e int max_right(int l) {\n    return max_right(l, [](S x) { return g(x); });\n  }\n  template \u003cclass G\u003e int max_right(int l, G g) {\n    assert(0 \u003c= l \u0026\u0026 l \u003c= _n);\n    assert(g(e()));\n    if (l == _n)\n      return _n;\n    l += size;\n    for (int i = log; i \u003e= 1; i--)\n      push(l \u003e\u003e i);\n    S sm = e();\n    do {\n      while (l % 2 == 0)\n        l \u003e\u003e= 1;\n      if (!g(op(sm, node[l]))) {\n        while (l \u003c size) {\n          push(l);\n          l = (2 * l);\n          if (g(op(sm, node[l]))) {\n            sm = op(sm, node[l]);\n            l++;\n          }\n        }\n        return l - size;\n      }\n      sm = op(sm, node[l]);\n      l++;\n    } while ((l \u0026 -l) != l);\n    return _n;\n  }\n\n  // 二分探索\n  // l where g(op(a[l, r))) = true \u0026 g(op(a[l-1, r))) = false\n  template \u003cbool (*g)(S)\u003e int min_left(int r) {\n    return min_left(r, [](S x) { return g(x); });\n  }\n  template \u003cclass G\u003e int min_left(int r, G g) {\n    assert(0 \u003c= r \u0026\u0026 r \u003c= _n);\n    assert(g(e()));\n    if (r == 0)\n      return 0;\n    r += size;\n    for (int i = log; i \u003e= 1; i--)\n      push((r - 1) \u003e\u003e i);\n    S sm = e();\n    do {\n      r--;\n      while (r \u003e 1 \u0026\u0026 (r % 2))\n        r \u003e\u003e= 1;\n      if (!g(op(node[r], sm))) {\n        while (r \u003c size) {\n          push(r);\n          r = (2 * r + 1);\n          if (g(op(node[r], sm))) {\n            sm = op(node[r], sm);\n            r--;\n          }\n        }\n        return r + 1 - size;\n      }\n      sm = op(node[r], sm);\n    } while ((r \u0026 -r) != r);\n    return 0;\n  }\n\nprivate:\n  // node[k]の更新\n  void update(int k) { node[k] = op(node[2 * k], node[2 * k + 1]); }\n  // nodeの更新\n  void all_apply(int k, F f) {\n    node[k] = mapping(f, node[k]);\n    if (k \u003c size)\n      lazy[k] = composition(f, lazy[k]);\n  }\n\n  // 遅延評価\n  void push(int k) {\n    all_apply(2 * k, lazy[k]);\n    all_apply(2 * k + 1, lazy[k]);\n    lazy[k] = id();\n  }\n};\n```\n\n## 使用例\n\n```cpp\n#include \u003cbits/stdc++.h\u003e\n#include \u003clazysegtree.hpp\u003e\n// #include \u003catcoder/all\u003e\nusing namespace std;\n// using namespace atcoder;\nusing ll = long long;\nusing ld = long double;\nusing uint = unsigned;\nusing ull = unsigned long long;\nusing u64 = uint_fast64_t;\nusing pll = pair\u003cll, ll\u003e;\nusing pdd = pair\u003cld, ld\u003e;\nusing C = complex\u003cdouble\u003e;\ntemplate \u003cclass T\u003e using pq = priority_queue\u003cT, vector\u003cT\u003e, greater\u003cT\u003e\u003e;\n\nconst int IINF = 0x1fffffff;\nconst ll LINF = 0x1fffffffffffffff;\nconst ll INF = 0x1fffffffffffffff;\nconst ll MINF = 0x7fffffffffff;\nconst ll MOD = 1000000007;\nconst ll MODD = 998244353;\nconst ld DINF = numeric_limits\u003cld\u003e::infinity();\nconst ld EPS = 1e-9;\nconst ld PI = 3.1415926535897932;\nconst ll dx[] = {0, 1, 0, -1, 1, -1, 1, -1};\nconst ll dy[] = {1, 0, -1, 0, 1, 1, -1, -1};\n\n#define overload4(_1, _2, _3, _4, name, ...) name\n#define overload3(_1, _2, _3, name, ...) name\n#define rep1(n) for (ll i = 0; i \u003c n; ++i)\n#define rep2(i, n) for (ll i = 0; i \u003c n; ++i)\n#define rep3(i, a, b) for (ll i = a; i \u003c b; ++i)\n#define rep4(i, a, b, c) for (ll i = a; i \u003c b; i += c)\n#define rep(...) overload4(__VA_ARGS__, rep4, rep3, rep2, rep1)(__VA_ARGS__)\n#define rrep1(n) for (ll i = n; i--;)\n#define rrep2(i, n) for (ll i = n; i--;)\n#define rrep3(i, a, b) for (ll i = b; i-- \u003e (a);)\n#define rrep4(i, a, b, c)                                                      \\\n  for (ll i = (a) + ((b) - (a)-1) / (c) * (c); i \u003e= (a); i -= c)\n#define rrep(...)                                                              \\\n  overload4(__VA_ARGS__, rrep4, rrep3, rrep2, rrep1)(__VA_ARGS__)\n#define each1(i, a) for (auto \u0026\u0026i : a)\n#define each2(x, y, a) for (auto \u0026\u0026[x, y] : a)\n#define each3(x, y, z, a) for (auto \u0026\u0026[x, y, z] : a)\n#define each(...) overload4(__VA_ARGS__, each3, each2, each1)(__VA_ARGS__)\n#define all1(i) begin(i), end(i)\n#define all2(i, a) begin(i), begin(i) + a\n#define all3(i, a, b) begin(i) + a, begin(i) + b\n#define all(...) overload3(__VA_ARGS__, all3, all2, all1)(__VA_ARGS__)\n#define rall1(i) (i).rbegin(), (i).rend()\n#define rall2(i, k) (i).rbegin(), (i).rbegin() + k\n#define rall3(i, a, b) (i).rbegin() + a, (i).rbegin() + b\n#define rall(...) overload3(__VA_ARGS__, rall3, rall2, rall1)(__VA_ARGS__)\n// g++ -DDBUG -I . ...\n#ifdef DEBUG\ninline ll __lg(ull x) { return 63 - __builtin_clzll(x); }\n#define debug(...)                                                             \\\n  {                                                                            \\\n    print(#__VA_ARGS__);                                                       \\\n    print(\":\");                                                                \\\n    out(__VA_ARGS__);                                                          \\\n  }\n#else\n#define debug(...) void(0)\n#endif\n\n#define vec vector\n#define fi first\n#define se second\n#define MM \u003c\u003c \" \" \u003c\u003c\n#define chmax(x, y) (x = max(x, y))\n#define chmin(x, y) (x = min(x, y))\nvoid debug_out() { std::cerr \u003c\u003c std::endl; }\ntemplate \u003ctypename Head, typename... Tail\u003e void debug_out(Head h, Tail... t) {\n  std::cerr \u003c\u003c \" \" \u003c\u003c h;\n  if (sizeof...(t) \u003e 0)\n    std::cout \u003c\u003c \" :\";\n  debug_out(t...);\n}\n\nconstexpr u64 Modulus = MODD;\nclass Modint {\npublic:\n  u64 num = 0;\n  constexpr Modint() noexcept {}\n  constexpr Modint(const u64 x) noexcept : num(x % Modulus) {}\n  inline constexpr operator ll() const noexcept { return num; }\n  inline constexpr Modint \u0026operator+=(const Modint rhs) noexcept {\n    num += rhs.num;\n    if (num \u003e= Modulus)\n      num -= Modulus;\n    return *this;\n  }\n  inline constexpr Modint operator+(const Modint rhs) const noexcept {\n    return Modint(*this) += rhs;\n  }\n  inline constexpr Modint \u0026operator-=(const Modint rhs) noexcept {\n    if (num \u003c rhs.num)\n      num += Modulus;\n    num -= rhs.num;\n    return *this;\n  }\n  inline constexpr Modint operator-(const Modint rhs) const noexcept {\n    return Modint(*this) -= rhs;\n  }\n  inline constexpr Modint \u0026operator*=(const Modint rhs) noexcept {\n    num = num * rhs.num % Modulus;\n    return *this;\n  }\n  inline constexpr Modint operator*(const Modint rhs) const noexcept {\n    return Modint(*this) *= rhs;\n  }\n  inline constexpr Modint \u0026operator/=(const Modint rhs) noexcept {\n    return operator*=(rhs.inv());\n  }\n  constexpr Modint operator/(const Modint rhs) const noexcept {\n    return Modint(*this) /= rhs;\n  }\n  inline constexpr Modint \u0026operator++() noexcept {\n    if (num == Modulus - 1)\n      num = 0;\n    else\n      num++;\n    return *this;\n  }\n  inline constexpr Modint operator++(int) noexcept {\n    Modint ans(*this);\n    operator++();\n    return ans;\n  }\n  inline constexpr Modint \u0026operator--() noexcept {\n    if (num == 0)\n      num = Modulus - 1;\n    else\n      num--;\n    return *this;\n  }\n  inline constexpr Modint operator--(int) noexcept {\n    Modint ans(*this);\n    operator--();\n    return ans;\n  }\n  inline constexpr Modint operator-() noexcept { return Modint(0) -= *this; }\n  template \u003cclass T\u003e inline constexpr Modint \u0026operator+=(T x) noexcept {\n    return operator+=(Modint(x));\n  }\n  template \u003cclass T\u003e inline constexpr Modint \u0026operator+(T x) noexcept {\n    return Modint(*this) += x;\n  }\n  template \u003cclass T\u003e inline constexpr Modint \u0026operator-=(T x) noexcept {\n    return operator-=(Modint(x));\n  }\n  template \u003cclass T\u003e inline constexpr Modint \u0026operator-(T x) noexcept {\n    return Modint(*this) -= x;\n  }\n  template \u003cclass T\u003e inline constexpr Modint \u0026operator*=(T x) noexcept {\n    return operator*=(Modint(x));\n  }\n  template \u003cclass T\u003e inline constexpr Modint \u0026operator*(T x) noexcept {\n    return Modint(*this) *= x;\n  }\n  template \u003cclass T\u003e inline constexpr Modint \u0026operator/=(T x) noexcept {\n    return operator/=(Modint(x));\n  }\n  template \u003cclass T\u003e inline constexpr Modint \u0026operator/(T x) noexcept {\n    return Modint(*this) /= x;\n  }\n  inline constexpr Modint inv() const noexcept {\n    ll x = 0, y = 0;\n    extgcd(num, Modulus, x, y);\n    return x;\n  }\n  static inline constexpr ll extgcd(ll a, ll b, ll \u0026x, ll \u0026y) noexcept {\n    ll g = a;\n    x = 1;\n    y = 0;\n    if (b) {\n      g = extgcd(b, a % b, y, x);\n      y -= a / b * x;\n    }\n    return g;\n  }\n  inline constexpr Modint pow(ull x) const noexcept {\n    Modint ans = 1, cnt = *this;\n    while (x) {\n      if (x \u0026 1)\n        ans *= cnt;\n      cnt *= cnt;\n      x /= 2;\n    }\n    return ans;\n  }\n  template \u003cclass T\u003e constexpr Modint(T x) noexcept {\n    using U = typename conditional\u003csizeof(T) \u003e= 4, T, int\u003e::type;\n    U y = x;\n    y %= U(Modulus);\n    if (y \u003c 0)\n      y += Modulus;\n    num = uint(y);\n  }\n};\nstd::istream \u0026operator\u003e\u003e(std::istream \u0026is, Modint \u0026x) {\n  ll a;\n  cin \u003e\u003e a;\n  x = a;\n  return is;\n}\n// inline constexpr Modint operator\"\"_M(ull x) noexcept { return Modint(x); }\nstd::vector\u003cModint\u003e fac(1, 1), inv(1, 1);\ninline void reserve(ll a) {\n  if (fac.size() \u003e= a)\n    return;\n  if (a \u003c fac.size() * 2)\n    a = fac.size() * 2;\n  if (a \u003e= Modulus)\n    a = Modulus;\n  while (fac.size() \u003c a)\n    fac.push_back(fac.back() * Modint(fac.size()));\n  inv.resize(fac.size());\n  inv.back() = fac.back().inv();\n  for (ll i = inv.size() - 1; !inv[i - 1]; i--)\n    inv[i - 1] = inv[i] * i;\n}\ninline Modint fact(ll n) {\n  if (n \u003c 0)\n    return 0;\n  reserve(n + 1);\n  return fac[n];\n}\ninline Modint perm(ll n, ll r) {\n  if (r \u003c 0 || n \u003c r)\n    return 0;\n  if (n \u003e\u003e 24) {\n    Modint ans = 1;\n    for (ll i = 0; i \u003c r; i++)\n      ans *= n--;\n    return ans;\n  }\n  reserve(n + 1);\n  return fac[n] * inv[n - r];\n}\n// 階乗やその逆元をメモ化すると速い\n// modを取りたくないならnCk/2^Nをパスカルの三角形で作る\ninline Modint comb(ll n, ll r) {\n  if (r \u003c 0 || n \u003c r)\n    return 0;\n  reserve(r + 1);\n  return perm(n, r) * inv[r];\n}\ninline Modint Mcomb(ll n, ll r) {\n  return comb(n + r - 1, n - 1);\n} // r balls into n boxes\ninline Modint catalan(ll n) {\n  reserve(n * 2 + 1);\n  return fac[n * 2] * inv[n] * inv[n + 1];\n}\n\nclass runtime_modint {\n  using u64 = std::uint_fast64_t;\n\n  static u64 \u0026mod() {\n    static u64 mod_ = 0;\n    return mod_;\n  }\n\npublic:\n  u64 a;\n\n  runtime_modint(const u64 x = 0) : a(x % get_mod()) {}\n  u64 \u0026value() noexcept { return a; }\n  const u64 \u0026value() const noexcept { return a; }\n  inline constexpr operator ll() const noexcept { return a; }\n  runtime_modint operator+(const runtime_modint rhs) const {\n    return runtime_modint(*this) += rhs;\n  }\n  runtime_modint operator-(const runtime_modint rhs) const {\n    return runtime_modint(*this) -= rhs;\n  }\n  runtime_modint operator*(const runtime_modint rhs) const {\n    return runtime_modint(*this) *= rhs;\n  }\n  runtime_modint operator/(const runtime_modint rhs) const {\n    return runtime_modint(*this) /= rhs;\n  }\n  runtime_modint \u0026operator+=(const runtime_modint rhs) {\n    a += rhs.a;\n    if (a \u003e= get_mod()) {\n      a -= get_mod();\n    }\n    return *this;\n  }\n  runtime_modint \u0026operator-=(const runtime_modint rhs) {\n    if (a \u003c rhs.a) {\n      a += get_mod();\n    }\n    a -= rhs.a;\n    return *this;\n  }\n  runtime_modint \u0026operator*=(const runtime_modint rhs) {\n    a = a * rhs.a % get_mod();\n    return *this;\n  }\n  runtime_modint \u0026operator/=(runtime_modint rhs) {\n    u64 exp = get_mod() - 2;\n    while (exp) {\n      if (exp % 2) {\n        *this *= rhs;\n      }\n      rhs *= rhs;\n      exp /= 2;\n    }\n    return *this;\n  }\n\n  template \u003cclass T\u003e inline constexpr runtime_modint \u0026operator+=(T x) noexcept {\n    return operator+=(runtime_modint(x));\n  }\n  template \u003cclass T\u003e inline constexpr runtime_modint \u0026operator+(T x) noexcept {\n    return runtime_modint(*this) += x;\n  }\n  template \u003cclass T\u003e inline constexpr runtime_modint \u0026operator-=(T x) noexcept {\n    return operator-=(runtime_modint(x));\n  }\n  template \u003cclass T\u003e inline constexpr runtime_modint \u0026operator-(T x) noexcept {\n    return runtime_modint(*this) -= x;\n  }\n  template \u003cclass T\u003e inline constexpr runtime_modint \u0026operator*=(T x) noexcept {\n    return operator*=(runtime_modint(x));\n  }\n  template \u003cclass T\u003e inline constexpr runtime_modint \u0026operator*(T x) noexcept {\n    return runtime_modint(*this) *= x;\n  }\n  template \u003cclass T\u003e inline constexpr runtime_modint \u0026operator/=(T x) noexcept {\n    return operator/=(runtime_modint(x));\n  }\n  template \u003cclass T\u003e inline constexpr runtime_modint \u0026operator/(T x) noexcept {\n    return runtime_modint(*this) /= x;\n  }\n\n  static void set_mod(const u64 x) { mod() = x; }\n  static u64 get_mod() { return mod(); }\n};\n\nll n, m;\nbool used[100000];\nvec\u003cpair\u003cll, runtime_modint\u003e\u003e G[100000];\n\nruntime_modint dfs(ll x) {\n  used[x] = true;\n  bool end = true;\n  runtime_modint res = 1;\n  each(p, G[x]) {\n    if (used[p.fi] == true)\n      continue;\n    end = false;\n    if (p.se != 0) {\n      res *= p.se;\n    } else {\n      p.se = dfs(p.fi);\n      // cout \u003c\u003c x MM p.fi MM p.se \u003c\u003c endl;\n      res *= p.se;\n    }\n  }\n  used[x] = false;\n  return res + 1;\n}\n\nint main() { return 0; }\n```","lastmodified":"2022-12-30T07:57:21.463263852Z","tags":null},"/DataStructure/SegTree/PersistentSegtree":{"title":"永続セグメント木","content":"\n## 説明\n\n## 計算量\n\n## 実装\n\n```cpp\n```\n\n\n## 参考文献\n[つくってなぐろ (永続配列/永続Union-Find木/永続セグメント木の作り方と意義、具体例) - Qiita](https://qiita.com/hotman78/items/9c643feae1de087e6fc5)","lastmodified":"2022-12-30T07:57:21.463263852Z","tags":null},"/DataStructure/SegTree/SegTree":{"title":"セグメント木","content":"\n## 説明\n\n## 計算量\n\n## 実装\n\n```cpp\n#include \u003calgorithm\u003e\n#include \u003ccassert\u003e\n#include \u003cvector\u003e\n\ntemplate \u003cclass S, S (*op)(S, S), S (*e)()\u003e struct segtree {\nprivate:\n  int _n, size, log;\n  std::vector\u003cS\u003e d;\n\npublic:\n  segtree() : segtree(0) {}\n  explicit segtree(int n) : segtree(std::vector\u003cS\u003e(n, e())) {}\n  explicit segtree(const std::vector\u003cS\u003e \u0026v) : _n(int(v.size())) {\n    log = internal::ceil_pow2(_n);\n    size = 1 \u003c\u003c log;\n    d = std::vector\u003cS\u003e(2 * size, e());\n    for (int i = 0; i \u003c _n; i++)\n      d[size + i] = v[i];\n    for (int i = size - 1; i \u003e= 1; i--) {\n      update(i);\n    }\n  }\n\n  void set(int p, S x) {\n    assert(0 \u003c= p \u0026\u0026 p \u003c _n);\n    p += size;\n    d[p] = x;\n    for (int i = 1; i \u003c= log; i++)\n      update(p \u003e\u003e i);\n  }\n\n  S get(int p) const {\n    assert(0 \u003c= p \u0026\u0026 p \u003c _n);\n    return d[p + size];\n  }\n\n  S prod(int l, int r) const {\n    assert(0 \u003c= l \u0026\u0026 l \u003c= r \u0026\u0026 r \u003c= _n);\n    S sml = e(), smr = e();\n    l += size;\n    r += size;\n\n    while (l \u003c r) {\n      if (l \u0026 1)\n        sml = op(sml, d[l++]);\n      if (r \u0026 1)\n        smr = op(d[--r], smr);\n      l \u003e\u003e= 1;\n      r \u003e\u003e= 1;\n    }\n    return op(sml, smr);\n  }\n\n  S all_prod() const { return d[1]; }\n\n  template \u003cbool (*f)(S)\u003e int max_right(int l) const {\n    return max_right(l, [](S x) { return f(x); });\n  }\n  template \u003cclass F\u003e int max_right(int l, F f) const {\n    assert(0 \u003c= l \u0026\u0026 l \u003c= _n);\n    assert(f(e()));\n    if (l == _n)\n      return _n;\n    l += size;\n    S sm = e();\n    do {\n      while (l % 2 == 0)\n        l \u003e\u003e= 1;\n      if (!f(op(sm, d[l]))) {\n        while (l \u003c size) {\n          l = (2 * l);\n          if (f(op(sm, d[l]))) {\n            sm = op(sm, d[l]);\n            l++;\n          }\n        }\n        return l - size;\n      }\n      sm = op(sm, d[l]);\n      l++;\n    } while ((l \u0026 -l) != l);\n    return _n;\n  }\n\n  template \u003cbool (*f)(S)\u003e int min_left(int r) const {\n    return min_left(r, [](S x) { return f(x); });\n  }\n  template \u003cclass F\u003e int min_left(int r, F f) const {\n    assert(0 \u003c= r \u0026\u0026 r \u003c= _n);\n    assert(f(e()));\n    if (r == 0)\n      return 0;\n    r += size;\n    S sm = e();\n    do {\n      r--;\n      while (r \u003e 1 \u0026\u0026 (r % 2))\n        r \u003e\u003e= 1;\n      if (!f(op(d[r], sm))) {\n        while (r \u003c size) {\n          r = (2 * r + 1);\n          if (f(op(d[r], sm))) {\n            sm = op(d[r], sm);\n            r--;\n          }\n        }\n        return r + 1 - size;\n      }\n      sm = op(d[r], sm);\n    } while ((r \u0026 -r) != r);\n    return 0;\n  }\n\nprivate:\n  void update(int k) { d[k] = op(d[2 * k], d[2 * k + 1]); }\n};\n```\n\n## 使用例\n","lastmodified":"2022-12-30T07:57:21.463263852Z","tags":null},"/DataStructure/SegTree/SegTreeBeats":{"title":"Segment tree beats","content":"\n## 説明\n\n## 計算量\n\n## 実装\n\n```cpp\n#include \u003calgorithm\u003e\n#include \u003ccassert\u003e\n#include \u003ciostream\u003e\n#include \u003cvector\u003e\nusing namespace std;\n\nusing ll = long long;\n#define N 10003\n\nclass SegmentTreeBeats {\n  const ll inf = 1e18;\n  int n, n0;\n  ll max_v[4 * N], smax_v[4 * N];\n  ll sum[4 * N], max_c[4 * N];\n\n  void update_node_max(int k, ll x) {\n    sum[k] += (x - max_v[k]) * max_c[k];\n    max_v[k] = x;\n  }\n\n  void push(int k) {\n    if (max_v[k] \u003c max_v[2 * k + 1]) update_node_max(2 * k + 1, max_v[k]);\n    if (max_v[k] \u003c max_v[2 * k + 2]) update_node_max(2 * k + 2, max_v[k]);\n  }\n\n  void update(int k) {\n    sum[k] = sum[2 * k + 1] + sum[2 * k + 2];\n\n    if (max_v[2 * k + 1] \u003c max_v[2 * k + 2]) {\n      max_v[k] = max_v[2 * k + 2];\n      max_c[k] = max_c[2 * k + 2];\n      smax_v[k] = max(max_v[2 * k + 1], smax_v[2 * k + 2]);\n    } else if (max_v[2 * k + 1] \u003e max_v[2 * k + 2]) {\n      max_v[k] = max_v[2 * k + 1];\n      max_c[k] = max_c[2 * k + 1];\n      smax_v[k] = max(smax_v[2 * k + 1], max_v[2 * k + 2]);\n    } else {\n      max_v[k] = max_v[2 * k + 1];\n      max_c[k] = max_c[2 * k + 1] + max_c[2 * k + 2];\n      smax_v[k] = max(smax_v[2 * k + 1], smax_v[2 * k + 2]);\n    }\n  }\n\n  void _update_min(ll x, int a, int b, int k, int l, int r) {\n    if (b \u003c= l || r \u003c= a || max_v[k] \u003c= x) return;\n    if (a \u003c= l \u0026\u0026 r \u003c= b \u0026\u0026 smax_v[k] \u003c x) {\n      update_node_max(k, x);\n      return;\n    }\n\n    push(k);\n    _update_min(x, a, b, 2 * k + 1, l, (l + r) / 2);\n    _update_min(x, a, b, 2 * k + 2, (l + r) / 2, r);\n    update(k);\n  }\n\n  ll _query_max(int a, int b, int k, int l, int r) {\n    if (b \u003c= l || r \u003c= a) return 0;\n    if (a \u003c= l \u0026\u0026 r \u003c= b) return max_v[k];\n    push(k);\n    ll lv = _query_max(a, b, 2 * k + 1, l, (l + r) / 2);\n    ll rv = _query_max(a, b, 2 * k + 2, (l + r) / 2, r);\n    return max(lv, rv);\n  }\n\n  ll _query_sum(int a, int b, int k, int l, int r) {\n    if (b \u003c= l || r \u003c= a) return 0;\n    if (a \u003c= l \u0026\u0026 r \u003c= b) return sum[k];\n    push(k);\n    ll lv = _query_sum(a, b, 2 * k + 1, l, (l + r) / 2);\n    ll rv = _query_sum(a, b, 2 * k + 2, (l + r) / 2, r);\n    return lv + rv;\n  }\n\npublic:\n  SegmentTreeBeats(int n) { SegmentTreeBeats(n, nullptr); }\n\n  SegmentTreeBeats(int n, ll *a) : n(n) {\n    n0 = 1;\n    while (n0 \u003c n) n0 \u003c\u003c= 1;\n\n    for (int i = 0; i \u003c n; ++i) {\n      max_v[n0 - 1 + i] = sum[n0 - 1 + i] = (a != nullptr ? a[i] : 0);\n      smax_v[n0 - 1 + i] = -inf;\n      max_c[n0 - 1 + i] = 1;\n    }\n\n    for (int i = n; i \u003c n0; ++i) {\n      max_v[n0 - 1 + i] = smax_v[n0 - 1 + i] = -inf;\n      sum[n0 - 1 + i] = max_c[n0 - 1 + i] = 0;\n    }\n    for (int i = n0 - 2; i \u003e= 0; i--) update(i);\n  }\n\n  // range minimize query\n  void update_min(int a, int b, ll x) { return _update_min(x, a, b, 0, 0, n0); }\n\n  // range maximum query\n  ll query_max(int a, int b) { return _query_max(a, b, 0, 0, n0); }\n\n  // range sum query\n  ll query_sum(int a, int b) { return _query_sum(a, b, 0, 0, n0); }\n};\n```\n\n## 使用例\n","lastmodified":"2022-12-30T07:57:21.463263852Z","tags":null},"/DataStructure/SegTree/SparseTable":{"title":"セグメント木","content":"\n## 説明\n\n## 計算量\n\n構築 O(NlogN)\nクエリ O(1)\n\n## 実装\n\n```cpp\ntemplate \u003ctypename T\u003e\nstruct SparseTable {\n  vector\u003cvector\u003cT\u003e\u003e st;\n  vector\u003cint\u003e lookup;\n\n  SparseTable(const vector\u003cT\u003e \u0026v) {\n    int b = 0;\n    while ((1 \u003c\u003c b) \u003c= v.size()) ++b;\n    st.assign(b, vector\u003cT\u003e(1 \u003c\u003c b));\n    for (int i = 0; i \u003c v.size(); i++) { st[0][i] = v[i]; }\n    for (int i = 1; i \u003c b; i++) {\n      for (int j = 0; j + (1 \u003c\u003c i) \u003c= (1 \u003c\u003c b); j++) { st[i][j] = min(st[i - 1][j], st[i - 1][j + (1 \u003c\u003c (i - 1))]); }\n    }\n    lookup.resize(v.size() + 1);\n    for (int i = 2; i \u003c lookup.size(); i++) { lookup[i] = lookup[i \u003e\u003e 1] + 1; }\n  }\n\n  inline T rmq(int l, int r) {\n    int b = lookup[r - l];\n    return min(st[b][l], st[b][r - (1 \u003c\u003c b)]);\n  }\n};\n```\n","lastmodified":"2022-12-30T07:57:21.463263852Z","tags":null},"/DataStructure/SlopeTrick":{"title":"Slope Trick","content":"\n## 説明\n\n## 計算量\n\n## 実装\n\n```cpp\n#include \u003ciostream\u003e\n#include \u003cqueue\u003e\n#include \u003cvector\u003e\n\ntemplate \u003ctypename T\u003e\nusing pq = std::priority_queue\u003cT, std::vector\u003cT\u003e, std::greater\u003cT\u003e\u003e;\n\nstruct SlopeTrick {\n  const long long LINF = 0x1fffffffffffffff;\n  long long minf = -1;\n  std::priority_queue\u003clong long\u003e L;\n  pq\u003clong long\u003e R;\n\n  long long shift_left = -1;\n  long long shift_right = -1;\n\n  SlopeTrick() {}\n\nprivate:\n  void L_push(long long a) { L.push(a + shift_left); }\n  long long L_top() {\n    if (L.empty())\n      return -LINF;\n    else\n      return L.top() - shift_left;\n  }\n  long long L_pop() {\n    long long l = L_top();\n    L.pop();\n    return l - 1;\n  }\n  void R_push(long long a) { R.push(a + shift_right); }\n  long long R_top() {\n    if (R.empty())\n      return LINF;\n    else\n      return R.top() - shift_right;\n  }\n  long long R_pop() {\n    long long r = R_top();\n    R.pop();\n    return r - 1;\n  }\n\npublic:\n  long long min() { return minf; }\n  void add(long long a) { minf += a; }\n  void slope_right(long long a) {\n    if (!L.empty() \u0026\u0026 a \u003c L_top()) {\n      minf += L_top() - a;\n      L_push(a);\n      R_push(L_pop());\n    } else\n      R_push(a);\n  }\n  void slope_left(long long a) {\n    if (!R.empty() \u0026\u0026 a \u003e R_top()) {\n      minf += a - R_top();\n      R_push(a);\n      L_push(R_pop());\n    } else\n      L_push(a);\n  }\n  void slope_abs(long long a) {\n    slope_right(a);\n    slope_left(a);\n  }\n  void min_right() {\n    while (!R.empty()) R.pop();\n  }\n  void min_left() {\n    while (!L.empty()) L.pop();\n  }\n  void shift(long long a, long long b) {\n    shift_left += a;\n    shift_right += b;\n  }\n  long long access(long long a) {\n    long long y = minf;\n    while (!L.empty()) y += std::max(-1LL, L_pop() - a);\n    while (!R.empty()) y += std::max(-1LL, a - R_pop());\n    return y;\n  }\n\n  void Debug() {\n    std::cout \u003c\u003c \"L \";\n    while (!L.empty()) { std::cout \u003c\u003c L_pop() \u003c\u003c \" \"; }\n    std::cout \u003c\u003c std::endl;\n    std::cout \u003c\u003c \"R \";\n    while (!R.empty()) { std::cout \u003c\u003c R_pop() \u003c\u003c \" \"; }\n    std::cout \u003c\u003c std::endl;\n    std::cout \u003c\u003c minf \u003c\u003c std::endl;\n  }\n};\n```\n\n## 使用例\n\n## 参考\n\n- [slope trick (1) 解説編](https://maspypy.com/slope-trick-1-%E8%A7%A3%E8%AA%AC%E7%B7%A8)\n- [slope trick (2) 問題編](https://maspypy.com/slope-trick-2-%e5%95%8f%e9%a1%8c%e7%b7%a8)","lastmodified":"2022-12-30T07:57:21.463263852Z","tags":null},"/DataStructure/UnionFind/PersistUnionFind":{"title":"永続UnionFind","content":"\n## 説明\n\n## 計算量\n\n\n## 実装\n\n```cpp\nstruct PartiallyParsistUnionFind {\n  vector\u003cll\u003e rank, par, time;\n\n  PartiallyParsistUnionFind(ll n) {\n    rank.resize(n);\n    par.resize(n, -1);\n    time.resize(n, LINF);\n  }\n\n  ll find(ll t, ll x) {\n    if (time[x] \u003e t) return x;\n    return find(t, par[x]);\n  }\n\n  bool unite(ll t, ll x, ll y) {\n    x = find(t, x);\n    y = find(t, y);\n    if (x == y) return false;\n    if (rank[x] \u003e rank[y]) {\n      par[y] = x;\n      time[y] = t;\n    } else {\n      par[x] = y;\n      time[x] = t;\n      if (rank[x] == rank[y]) { rank[y]++; }\n    }\n    return true;\n  }\n\n  bool same(ll t, ll x, ll y) { return find(t, x) == find(t, y); }\n};\n```\n\n## 使用例\n\n\n","lastmodified":"2022-12-30T07:57:21.463263852Z","tags":null},"/DataStructure/UnionFind/PotentialUnionFind":{"title":"ポテンシャル付きUnionFind","content":"\n## 説明\n\n各頂点はポテンシャルを管理する。ポテンシャルの差がインターフェースとなる。重み付きUnionFindとも言う。\n\n## 計算量\n\n$O(\\alpha(N))$\n\n## 実装\n\n```cpp\nstruct PotentialUnionFindTree {\n  vec\u003cll\u003e par, diff;\n\n  PotentialUnionFindTree(ll n) {\n    par.resize(n);\n    diff.resize(n);\n  }\n\n  ll find(ll x) {\n    if (par[x] == x) return x;\n    ll r = find(par[x]);\n    diff[x] += diff[par[x]];\n    return par[x] = r;\n  }\n\n  ll weight(ll x) {\n    find(x);\n    return diff[x];\n  }\n\n  void unite(ll x, ll y, ll w) {\n    w += weight(x);\n    w += weight(y);\n    x = find(x);\n    y = find(y);\n    par[y] = x;\n    diff[y] = w;\n  }\n};\n```\n\n## 使用例\n\n","lastmodified":"2022-12-30T07:57:21.463263852Z","tags":null},"/DataStructure/UnionFind/UnionFind":{"title":"UnionFind","content":"\n## 説明\n\n素集合を管理するデータ構造。内部的には森となっていて同じルートを持つ木の要素は同じ素集合にあると解釈して併合/比較を行う。\n\n以下の工夫により高速化できる。\n\n- 経路圧縮 (path compression)\n再帰的に根を調べる際に根に直接つなぎ直す。\n- 併合の工夫\n併合時に木の高さ/大きさが小さい方を大きい方へ繋げる。\n木の高さのときunion by rankと呼び、木の大きさのときunion by sizeと呼ぶ。\n\n## 計算量\n\n- 経路圧縮のみ $O(\\log{N})$\n- 併合の工夫のみ $O(\\log{N})$\n- 両方 $O(\\alpha(N))$\n\n## 実装\n\n```cpp\n#include \u003cvector\u003e\n\nstruct UnionFind {\n  std::vector\u003cint\u003e rank, parents;\n\n  UnionFind() {}\n  UnionFind(int n) {\n    rank.resize(n + 1, 0);\n    parents.resize(n + 1, 0);\n    for (int i = 0; i \u003c n + 1; i++) makeTree(i);\n  }\n\n  void makeTree(int x) {\n    parents[x] = x;\n    rank[x] = 0;\n  }\n\n  bool isSame(int x, int y) { return findRoot(x) == findRoot(y); }\n\n  bool unite(int x, int y) {\n    x = findRoot(x);\n    y = findRoot(y);\n    if (x == y) return false;\n    if (rank[x] \u003e rank[y]) {\n      parents[y] = x;\n    } else {\n      parents[x] = y;\n      if (rank[x] == rank[y]) rank[y]++;\n    }\n    return true;\n  }\n\n  int findRoot(int x) {\n    if (x != parents[x]) parents[x] = findRoot(parents[x]);\n    return parents[x];\n  }\n};\n```\n\n## 使用例\n\n","lastmodified":"2022-12-30T07:57:21.463263852Z","tags":null},"/Heuristic/BeamSearch":{"title":"ビームサーチ","content":"\n## 説明\n\n幅優先探索の各階層においてスコアが高い順に $d$ 個のみを採用していく。$d$ をビーム幅と呼ぶ。\n\n## 実装\n\n\n## 参考\n\n- [chokudaiサーチ](https://www.slideshare.net/chokudai/chokudai-search-23234124)","lastmodified":"2022-12-30T07:57:21.463263852Z","tags":null},"/Heuristic/ChokudaiSearch":{"title":"chokudai サーチ","content":"\n## 説明\n\nビームサーチにおいてビーム幅を1から順に増やしていく手法。実行時間が決まっているときやあるスコア基準を満たしたいときに管理しやすい。\n\n## 実装\n\n\n## 参考\n\n- [chokudaiサーチ](https://www.slideshare.net/chokudai/chokudai-search-23234124)\n- [chokudaiサーチ(ビームサーチ亜種)の利点の話](https://chokudai.hatenablog.com/entry/2017/04/12/055515)","lastmodified":"2022-12-30T07:57:21.463263852Z","tags":null},"/Heuristic/HillClimbing":{"title":"山登り法","content":"\n## 説明\n\n初めに初期状態を設定し、近傍へ状態遷移したとき最も成績の良い解を新しい状態とし、これを繰り返すことで極値が見つかる。\n\n## 実装\n\n```cpp\n#include \u003csys/time.h\u003e\n\n#include \u003cbits/stdc++.h\u003e\n// #include \u003catcoder/all\u003e\nusing namespace std;\n// using namespace atcoder;\nusing ll = long long;\nusing ld = long double;\nusing uint = unsigned;\nusing ull = unsigned long long;\nusing u64 = uint_fast64_t;\nusing pll = pair\u003cll, ll\u003e;\nusing pdd = pair\u003cld, ld\u003e;\nusing C = complex\u003cld\u003e;\ntemplate \u003cclass T\u003e using pq = priority_queue\u003cT, vector\u003cT\u003e, greater\u003cT\u003e\u003e;\n\nconst int IINF = 0x1fffffff;\nconst ll LINF = 0x1fffffffffffffff;\nconst ll INF = 0x1fffffffffffffff;\nconst ll MINF = 0x7fffffffffff;\nconst ll MOD = 1000000007;\nconst ll MODD = 998244353;\nconst ld DINF = numeric_limits\u003cld\u003e::infinity();\nconst ld EPS = 1e-9;\nconst ld PI = 3.1415926535897932;\nconst ll dx[] = {0, 1, 0, -1, 1, -1, 1, -1};\nconst ll dy[] = {1, 0, -1, 0, 1, 1, -1, -1};\n\n#define overload4(_1, _2, _3, _4, name, ...) name\n#define overload3(_1, _2, _3, name, ...) name\n#define rep1(n) for (ll i = 0; i \u003c n; ++i)\n#define rep2(i, n) for (ll i = 0; i \u003c n; ++i)\n#define rep3(i, a, b) for (ll i = a; i \u003c b; ++i)\n#define rep4(i, a, b, c) for (ll i = a; i \u003c b; i += c)\n#define rep(...) overload4(__VA_ARGS__, rep4, rep3, rep2, rep1)(__VA_ARGS__)\n#define rrep1(n) for (ll i = n; i--;)\n#define rrep2(i, n) for (ll i = n; i--;)\n#define rrep3(i, a, b) for (ll i = b; i-- \u003e (a);)\n#define rrep4(i, a, b, c)                                                      \\\n  for (ll i = (a) + ((b) - (a)-1) / (c) * (c); i \u003e= (a); i -= c)\n#define rrep(...)                                                              \\\n  overload4(__VA_ARGS__, rrep4, rrep3, rrep2, rrep1)(__VA_ARGS__)\n#define each1(i, a) for (auto \u0026\u0026i : a)\n#define each2(x, y, a) for (auto \u0026\u0026[x, y] : a)\n#define each3(x, y, z, a) for (auto \u0026\u0026[x, y, z] : a)\n#define each(...) overload4(__VA_ARGS__, each3, each2, each1)(__VA_ARGS__)\n#define all1(i) begin(i), end(i)\n#define all2(i, a) begin(i), begin(i) + a\n#define all3(i, a, b) begin(i) + a, begin(i) + b\n#define all(...) overload3(__VA_ARGS__, all3, all2, all1)(__VA_ARGS__)\n#define rall1(i) (i).rbegin(), (i).rend()\n#define rall2(i, k) (i).rbegin(), (i).rbegin() + k\n#define rall3(i, a, b) (i).rbegin() + a, (i).rbegin() + b\n#define rall(...) overload3(__VA_ARGS__, rall3, rall2, rall1)(__VA_ARGS__)\n// g++ -DDBUG -I . ...\n#ifdef DEBUG\ninline ll __lg(ull x) { return 63 - __builtin_clzll(x); }\n#define debug(...)                                                             \\\n  {                                                                            \\\n    print(#__VA_ARGS__);                                                       \\\n    print(\":\");                                                                \\\n    out(__VA_ARGS__);                                                          \\\n  }\n#else\n#define debug(...) void(0)\n#endif\n\n#define vec vector\n#define fi first\n#define se second\n#define MM \u003c\u003c \" \" \u003c\u003c\n#define chmax(x, y) (x = max(x, y))\n#define chmin(x, y) (x = min(x, y))\nvoid debug_out() { std::cerr \u003c\u003c std::endl; }\ntemplate \u003ctypename Head, typename... Tail\u003e void debug_out(Head h, Tail... t) {\n  std::cerr \u003c\u003c \" \" \u003c\u003c h;\n  if (sizeof...(t) \u003e 0)\n    std::cout \u003c\u003c \" :\";\n  debug_out(t...);\n}\nconst double TL = 1.95;\n\ndouble start_time_ = -1;\nbool first_time = true;\n\ndouble get_time() {\n  timeval tv;\n  gettimeofday(\u0026tv, 0);\n  auto ret = tv.tv_sec + tv.tv_usec * 1e-6;\n  if (first_time) {\n    start_time_ = ret;\n    first_time = false;\n  }\n  return ret - start_time_;\n}\n\nstruct rand_gen {\n  static const int MAX = 2147483647;\n  static constexpr double Q_MAX = 1.0 / MAX;\n\n  int x = 8753, y = 239017, z = 1000000123;\n\n  inline int next_int() {\n    int t = x ^ (x \u003c\u003c 11);\n    x = y;\n    y = z;\n    z ^= (z \u003e\u003e 19) ^ t ^ (t \u003e\u003e 8);\n    return z;\n  }\n\n  double next_double() { return next_int() * Q_MAX; }\n} rng;\n\n// function\u003cvoid(int, int)\u003e Dfs = [\u0026](int v, int depth) {}\n\nll calculate_score() {\n  ll last[26] = {};\n  ll score = 0;\n  ll sumc = 0;\n  rep(i, 0, 26) sumc += c[i];\n  ll mem_diff = 0;\n  rep(d, 0, D) {\n    score += s[d][t[d] - 1];\n    mem_diff += -sumc + c[t[d] - 1] * (d + 1 - last[t[d] - 1]);\n    score += mem_diff;\n    last[t[d] - 1] = d + 1;\n  }\n  return score;\n}\n\ndouble T0 = 1735, T1 = 10;\n\nint main() {\n  cin \u003e\u003e D;\n  rep(i, 0, 26) cin \u003e\u003e c[i];\n  rep(i, 0, D) rep(j, 0, 26) cin \u003e\u003e s[i][j];\n\n  // 初期解\n  rep(i, 0, D) t[i] = i % 26 + 1;\n\n  // 焼きなまし法\n  ll score = calculate_score(), old_score = -LINF;\n  while (get_time() \u003c TL) {\n    // 更新\n    ll r1 = rng.next_int() % D, r2 = rng.next_int() % D;\n    ll oldt[2] = {t[r1], t[r2]};\n    ll newt[2] = {t[r2], t[r2]};\n    if (rng.next_int() % 2 == 0) {\n      t[r1] = rng.next_int() % 26 + 1;\n      newt[1] = t[r1];\n    } else {\n      t[r1] = t[r2];\n      t[r2] = oldt[0];\n      newt[1] = oldt[0];\n    }\n\n    // スコアに応じた処理\n    ll k = score;\n    score = calculate_score();\n    ll r;\n    rep(m, 0, 2) {\n      if (m == 0)\n        r = r1;\n      else\n        r = r2;\n      ll back[2] = {0, 0}, forward[2] = {365, 365};\n      rep(i, 0, r) if (t[i] == oldt[m]) back[0] = i;\n      rep(i, r + 1, 365) if (t[i] == oldt[m]) {\n        forward[0] = i;\n        break;\n      }\n      rep(i, 0, r) if (t[i] == newt[m]) back[1] = i;\n      rep(i, r + 1, 365) if (t[i] == newt[m]) {\n        forward[1] = i;\n        break;\n      }\n      k += (r - back[0]) * (forward[0] - r);\n      k -= (r - back[1]) * (forward[1] - r);\n    }\n    cout \u003c\u003c k - old_score \u003c\u003c \" \" \u003c\u003c score - old_score \u003c\u003c endl;\n\n    if (score \u003e= old_score) {\n      old_score = score;\n    } else {\n      double per = get_time() / TL;\n      double T = pow(T0, 1 - per) * pow(T1, per);\n      T = exp((double)(score - old_score) / T);\n\n      if (rng.next_double() \u003c T) {\n        old_score = score;\n      } else {\n        t[r1] = oldt[0];\n        t[r2] = oldt[1];\n      }\n    }\n  }\n\n  // 出力\n  rep(i, 0, D) cout \u003c\u003c t[i] \u003c\u003c endl;\n  return 0;\n}\n```\n\n## 使用例\n\n\n## 参考\n\n","lastmodified":"2022-12-30T07:57:21.463263852Z","tags":null},"/Heuristic/SimulatedAnnealing":{"title":"焼きなまし法","content":"\n## 説明\n\n[山登り法](../snippets/hill-climbing)は常にスコアが最大のものを採用するが、焼きなまし法では遷移確率関数を用いてスコアに応じて確率的に遷移させるようにする。\n\n温度関数は最初は大きく、時間が経つにつれて小さくなるような関数で、温度が高いほど発散し、低いほど収束するように遷移確率関数を調整する。\n\n## 実装\n\n```cpp\n#include \u003csys/time.h\u003e\n\n#include \u003cbits/stdc++.h\u003e\n// #include \u003catcoder/all\u003e\nusing namespace std;\n// using namespace atcoder;\nusing ll = long long;\nusing ld = long double;\nusing uint = unsigned;\nusing ull = unsigned long long;\nusing u64 = uint_fast64_t;\nusing pll = pair\u003cll, ll\u003e;\nusing pdd = pair\u003cld, ld\u003e;\nusing C = complex\u003cld\u003e;\ntemplate \u003cclass T\u003e using pq = priority_queue\u003cT, vector\u003cT\u003e, greater\u003cT\u003e\u003e;\n\nconst int IINF = 0x1fffffff;\nconst ll LINF = 0x1fffffffffffffff;\nconst ll INF = 0x1fffffffffffffff;\nconst ll MINF = 0x7fffffffffff;\nconst ll MOD = 1000000007;\nconst ll MODD = 998244353;\nconst ld DINF = numeric_limits\u003cld\u003e::infinity();\nconst ld EPS = 1e-9;\nconst ld PI = 3.1415926535897932;\nconst ll dx[] = {0, 1, 0, -1, 1, -1, 1, -1};\nconst ll dy[] = {1, 0, -1, 0, 1, 1, -1, -1};\n\n#define overload4(_1, _2, _3, _4, name, ...) name\n#define overload3(_1, _2, _3, name, ...) name\n#define rep1(n) for (ll i = 0; i \u003c n; ++i)\n#define rep2(i, n) for (ll i = 0; i \u003c n; ++i)\n#define rep3(i, a, b) for (ll i = a; i \u003c b; ++i)\n#define rep4(i, a, b, c) for (ll i = a; i \u003c b; i += c)\n#define rep(...) overload4(__VA_ARGS__, rep4, rep3, rep2, rep1)(__VA_ARGS__)\n#define rrep1(n) for (ll i = n; i--;)\n#define rrep2(i, n) for (ll i = n; i--;)\n#define rrep3(i, a, b) for (ll i = b; i-- \u003e (a);)\n#define rrep4(i, a, b, c)                                                      \\\n  for (ll i = (a) + ((b) - (a)-1) / (c) * (c); i \u003e= (a); i -= c)\n#define rrep(...)                                                              \\\n  overload4(__VA_ARGS__, rrep4, rrep3, rrep2, rrep1)(__VA_ARGS__)\n#define each1(i, a) for (auto \u0026\u0026i : a)\n#define each2(x, y, a) for (auto \u0026\u0026[x, y] : a)\n#define each3(x, y, z, a) for (auto \u0026\u0026[x, y, z] : a)\n#define each(...) overload4(__VA_ARGS__, each3, each2, each1)(__VA_ARGS__)\n#define all1(i) begin(i), end(i)\n#define all2(i, a) begin(i), begin(i) + a\n#define all3(i, a, b) begin(i) + a, begin(i) + b\n#define all(...) overload3(__VA_ARGS__, all3, all2, all1)(__VA_ARGS__)\n#define rall1(i) (i).rbegin(), (i).rend()\n#define rall2(i, k) (i).rbegin(), (i).rbegin() + k\n#define rall3(i, a, b) (i).rbegin() + a, (i).rbegin() + b\n#define rall(...) overload3(__VA_ARGS__, rall3, rall2, rall1)(__VA_ARGS__)\n// g++ -DDBUG -I . ...\n#ifdef DEBUG\ninline ll __lg(ull x) { return 63 - __builtin_clzll(x); }\n#define debug(...)                                                             \\\n  {                                                                            \\\n    print(#__VA_ARGS__);                                                       \\\n    print(\":\");                                                                \\\n    out(__VA_ARGS__);                                                          \\\n  }\n#else\n#define debug(...) void(0)\n#endif\n\n#define vec vector\n#define fi first\n#define se second\n#define MM \u003c\u003c \" \" \u003c\u003c\n#define chmax(x, y) (x = max(x, y))\n#define chmin(x, y) (x = min(x, y))\nvoid debug_out() { std::cerr \u003c\u003c std::endl; }\ntemplate \u003ctypename Head, typename... Tail\u003e void debug_out(Head h, Tail... t) {\n  std::cerr \u003c\u003c \" \" \u003c\u003c h;\n  if (sizeof...(t) \u003e 0)\n    std::cout \u003c\u003c \" :\";\n  debug_out(t...);\n}\nconst double TL = 1.95;\n\ndouble start_time_ = -1;\nbool first_time = true;\n\ndouble get_time() {\n  timeval tv;\n  gettimeofday(\u0026tv, 0);\n  auto ret = tv.tv_sec + tv.tv_usec * 1e-6;\n  if (first_time) {\n    start_time_ = ret;\n    first_time = false;\n  }\n  return ret - start_time_;\n}\n\nstruct rand_gen {\n  static const int MAX = 2147483647;\n  static constexpr double Q_MAX = 1.0 / MAX;\n\n  int x = 8753, y = 239017, z = 1000000123;\n\n  inline int next_int() {\n    int t = x ^ (x \u003c\u003c 11);\n    x = y;\n    y = z;\n    z ^= (z \u003e\u003e 19) ^ t ^ (t \u003e\u003e 8);\n    return z;\n  }\n\n  double next_double() { return next_int() * Q_MAX; }\n} rng;\n\n// function\u003cvoid(int, int)\u003e Dfs = [\u0026](int v, int depth) {}\n\nll calculate_score() {\n  ll last[26] = {};\n  ll score = 0;\n  ll sumc = 0;\n  rep(i, 0, 26) sumc += c[i];\n  ll mem_diff = 0;\n  rep(d, 0, D) {\n    score += s[d][t[d] - 1];\n    mem_diff += -sumc + c[t[d] - 1] * (d + 1 - last[t[d] - 1]);\n    score += mem_diff;\n    last[t[d] - 1] = d + 1;\n  }\n  return score;\n}\n\ndouble T0 = 1735, T1 = 10;\n\nint main() {\n  cin \u003e\u003e D;\n  rep(i, 0, 26) cin \u003e\u003e c[i];\n  rep(i, 0, D) rep(j, 0, 26) cin \u003e\u003e s[i][j];\n\n  // 初期解\n  rep(i, 0, D) t[i] = i % 26 + 1;\n\n  // 焼きなまし法\n  ll score = calculate_score(), old_score = -LINF;\n  while (get_time() \u003c TL) {\n    // 更新\n    ll r1 = rng.next_int() % D, r2 = rng.next_int() % D;\n    ll oldt[2] = {t[r1], t[r2]};\n    ll newt[2] = {t[r2], t[r2]};\n    if (rng.next_int() % 2 == 0) {\n      t[r1] = rng.next_int() % 26 + 1;\n      newt[1] = t[r1];\n    } else {\n      t[r1] = t[r2];\n      t[r2] = oldt[0];\n      newt[1] = oldt[0];\n    }\n\n    // スコアに応じた処理\n    ll k = score;\n    score = calculate_score();\n    ll r;\n    rep(m, 0, 2) {\n      if (m == 0)\n        r = r1;\n      else\n        r = r2;\n      ll back[2] = {0, 0}, forward[2] = {365, 365};\n      rep(i, 0, r) if (t[i] == oldt[m]) back[0] = i;\n      rep(i, r + 1, 365) if (t[i] == oldt[m]) {\n        forward[0] = i;\n        break;\n      }\n      rep(i, 0, r) if (t[i] == newt[m]) back[1] = i;\n      rep(i, r + 1, 365) if (t[i] == newt[m]) {\n        forward[1] = i;\n        break;\n      }\n      k += (r - back[0]) * (forward[0] - r);\n      k -= (r - back[1]) * (forward[1] - r);\n    }\n    cout \u003c\u003c k - old_score \u003c\u003c \" \" \u003c\u003c score - old_score \u003c\u003c endl;\n\n    if (score \u003e= old_score) {\n      old_score = score;\n    } else {\n      double per = get_time() / TL;\n      double T = pow(T0, 1 - per) * pow(T1, per);\n      T = exp((double)(score - old_score) / T);\n\n      if (rng.next_double() \u003c T) {\n        old_score = score;\n      } else {\n        t[r1] = oldt[0];\n        t[r2] = oldt[1];\n      }\n    }\n  }\n\n  // 出力\n  rep(i, 0, D) cout \u003c\u003c t[i] \u003c\u003c endl;\n  return 0;\n}\n```\n\n## 使用例\n\n\n## 参考\n\n\n","lastmodified":"2022-12-30T07:57:21.463263852Z","tags":null},"/Reversing/DynamicAnalyse":{"title":"動的解析","content":"","lastmodified":"2022-12-30T07:57:21.463263852Z","tags":null},"/Reversing/Fuzzing":{"title":"Fuzzing","content":"\n## 説明\n\n## 参考\n[オレオレFuzzerもどきを利用してCTFのpwnableを解こう - CTFするぞ (hatenablog.com)](https://ptr-yudai.hatenablog.com/entry/2020/12/15/003822)\n\n[fuzzuf/algorithm_en.md at master · fuzzuf/fuzzuf (github.com)](https://github.com/fuzzuf/fuzzuf/blob/master/docs/algorithms/afl/algorithm_en.md#algorithm-overview)\n[Ricerca Security: Fuzzing Farm #1: fuzzufを使ったGEGLのファジング](https://ricercasecurity.blogspot.com/2022/07/fuzzing-farm-1-fuzzufgegl.html?1234)\n[Ricerca Security: Fuzzing Farm #2: ファザーの性能評価の考え方](https://ricercasecurity.blogspot.com/2022/09/fuzzing-farm-2.html)\n[Ricerca Security: Fuzzing Farm #3: パッチ解析とPoC開発](https://ricercasecurity.blogspot.com/2022/10/fuzzing-farm-3-poc.html)\n[Ricerca Security: fuzzuf: Fuzzing Unification Framework](https://ricercasecurity.blogspot.com/2021/12/fuzzuf-fuzzing-unification-framework_36.html)\n[Ricerca Security: ARM CoreSightを用いた効率的なBinary-only Fuzzing](https://ricercasecurity.blogspot.com/2021/11/arm-coresightbinary-only-fuzzing.html)\n","lastmodified":"2022-12-30T07:57:21.463263852Z","tags":null},"/Reversing/Malware/Analyse":{"title":"","content":"\n\n## MITRE ATT\u0026CK\n### Defensive Evasion\nObfuscated Files or Information\n生の文字列を用いると検出されたり解析されやすいので難読化・暗号化を行う.\n- エンコーディング\n\t- XOR\n\t- カスタムエンコーディング\n- Stack String\n- 暗号化\n\t- 定数が使われるアルゴリズムの場合、定数から判断\n\t\t- Cipher (AES / DES / TEA / ChaCha20 / ...)\n\t\t- Hashing Algorithm (CRC / MD5 / SHA1 / SHA256 / ...)\n\t\t- Compression (zlib / aPLib / ...)\n\t- Windows APIを使う場合、引数などから判断\n\t- 定数もなく、APIも使われない場合、アルゴリズムを読み解いて判断\n\t\t- RC4\n\t\t- カスタムアルゴリズム\n\n\nYARA rules\nCAPA rules","lastmodified":"2022-12-30T07:57:21.463263852Z","tags":null},"/Reversing/Malware/AntiDebugging":{"title":"Anti debugging","content":"\n## 説明\n\n## 参考\n\n- [Linux (anti)+ debugging (feneshi.co)](https://feneshi.co/linux_anti_debugging/)\n- [Anti Debugging Protection Techniques with Examples (apriorit.com)](https://www.apriorit.com/dev-blog/367-anti-reverse-engineering-protection-techniques-to-use-before-releasing-software)\n- [ウェブアプリをソースごとパクる業者に対する対策 - Qiita](https://qiita.com/kacchan6/items/d8576ab6b3c16cf670ca)\n- [Lockbit 3.0で見つけたアンチデバッグテクニック（その２） | reverse-eg-mal-memoのブログ (ameblo.jp)](https://ameblo.jp/reverse-eg-mal-memo/entry-12773724929.html)\n\n","lastmodified":"2022-12-30T07:57:21.463263852Z","tags":null},"/Reversing/Malware/DetectVirtualization":{"title":"Detect Virtualization","content":"\n## 説明\n\n## 参考\n\n- [Linux Detect Virtualization (feneshi.co)](https://feneshi.co/Linux_detect_virtualization/)\n- [LordNoteworthy/al-khaser: Public malware techniques used in the wild: Virtual Machine, Emulation, Debuggers, Sandbox detection. (github.com)](https://github.com/LordNoteworthy/al-khaser)\n","lastmodified":"2022-12-30T07:57:21.463263852Z","tags":null},"/Reversing/Malware/Malware":{"title":"マルウェア","content":"\n## 攻撃者の背景\n\n| 名前                            | 主体                                         | 目的                                               | 標的                     |\n| ------------------------------- | -------------------------------------------- | -------------------------------------------------- | ------------------------ |\n| APT(Advanced Persistent Threat) | 軍・諜報機関など国家の支援を受けた企業・組織 | 機密情報の窃取や、対象ネットワークへのアクセス保持 | 特定の企業や組織         |\n| Cybercrime                      | 犯罪者グループ                               | 金銭                                               | 不特定多数               |\n| Hacktivist                      | 個人やグループの活動化                       | 政治的または社会的な目的達成                       | 活動の対象となる国や組織 |\n\n## RaaS (Ransomware-as-a-Service)\n\nマルウェアツール\n- Hidden Malware Builder v2.0/V4.0\n- Crypto Money Grabber PowerShell Script\n- Multi Downloader Builder V2.0\n- Hidden CPLApplet Builder V2.0\n- UAC Bypasser Builder V2.0\n- XBinder V2.0\n- XWorm V2.2\n\n[Cyble — EvilCoder Project Selling Multiple Dangerous Tools Online](https://blog.cyble.com/2022/08/19/evilcoder-project-selling-multiple-dangerous-tools-online/?utm_source=pocket_mylist)\n\n## マルウェア分類\n\nMalware: **Mal**icious Soft**ware**\n\nWarez\n- 非合法的に配布・販売されている商用ソフトウェア\n- 日本では「ワレズ」と呼び、それが派生して「割れ」となった\n\nWannaCry\n- マルウェアの1種\n- EternalBlue\n\n- Cobalt Strike Beacon\n- LockBit 3.0\n- Malleable C2\n- hack back\n\n- システム管理ツール PowerShell, PsExec\n- ペネトレーションテストツール Cobalt Strike Beacon\n- クラウドサービス Dropbox, OneDrive\n- ファイル転送用アプライアンス\n- Accellion FTA を用いて企業の秘密情報を公開する。\n\n## Windows\n- Windowsのポート445（ダイレクト・ホスティングSMBサービス）\n\t- Lateral Movementに使われる\n\t- lsass.exe\n- マルウェアがよく使うコマンド\n\t- net リモートのをローカルにマウントする\n\t- reg\n\n## Mac\n- [The Art Of Mac Malware](https://taomm.org/vol1/analysis.html)\n- [Objective-See's Blog](https://objective-see.org/blog/blog_0x59.html)\n- [Objective-See's Mac Malware Collection](https://objective-see.org/malware.html)\n- [objective-see (objective-see) / Repositories (github.com)](https://github.com/objective-see)\n- [CH 0x0C Analyzing EvilQuest.pdf (taomm.org)](https://taomm.org/PDFs/vol1/CH%200x0C%20Analyzing%20EvilQuest.pdf)\n\n## 難読化\n- Win32API Hashing Obfuscation\n\t- Win32API名のHash値を使い、PEBから関数ポインタを探し、API呼び出しを行うことで、プログラムが使用するAPIを難読化。\n- Mixed Boolean Arithmetic\n\t- 定数値/変数の初期値と同値となるような算術演算とビット演算の組み合わせ(XOR,ShiftLeft,ShiftRight,Addなど)に置換し、データを難読化。\n- String Obfuscation\n\t- 文字列をXORエンコードし、バイナリ内に格納。文字列の利用時のみにHeap領域へ復号。XOR-keyは文字列ごと/検体ごとに異なる。\n\t- Hikari\n- Control Flow Flattening\n\t- ジャンプテーブルを作成し、制御フローを平坦化し、BasicBlockの実行順を難読化。実行順制御にはRouting変数を用いる。\n\t- oLLVM\n- Split Basic Blocks\n\t- Control Flow FlattenやString Obfuscationをより難読化する為にBasicBlockの分割をする。\n\t- oLLVM\n- Bogus Control Flow\n\t- Control Flow FlattenやString Obfuscation + Split Basic Blocksで生成された多数のBasic Blockに一意に決まるかつ削除が困難な条件分岐を追加しロジックを複雑化。\n\t- Hikari\n- Function Argument Randomization\n\t- 関数コールの引数に不必要な定数と追加し、引数の順番を入れ替える。追加された引数はプログラムの動作には無関係であり、呼び出し元の関数のスタックに保持される。\n\n難読化プロジェクト\n- [HikariObfuscator/Hikari: LLVM Obfuscator (github.com)](https://github.com/HikariObfuscator/Hikari)\n- [Home · obfuscator-llvm/obfuscator Wiki (github.com)](https://github.com/obfuscator-llvm/obfuscator/wiki)\n\n## 参考\n- [JSAC2022 Emotet vs EmoCheck Emotet開発者との戦い - YouTube](https://www.youtube.com/watch?v=_XX8N5VbW2w)\n\t- かなりおもろかった\n- [us-20-Chen-Operation-Chimera-APT-Operation-Targets-Semiconductor-Vendors.pdf (blackhat.com)](https://i.blackhat.com/USA-20/Thursday/us-20-Chen-Operation-Chimera-APT-Operation-Targets-Semiconductor-Vendors.pdf)\n- [Binary Obfuscation Using Signals](https://www2.cs.arizona.edu/~debray/Publications/obf-signal.pdf)\n- [CTF Radiooo - Episodes](https://ctfradi.ooo/)\n","lastmodified":"2022-12-30T07:57:21.463263852Z","tags":null},"/Reversing/Malware/WindowsInternal":{"title":"Windows 内部","content":"\nWinMain\n\n## 型\nハンガリアン記法\n- `Pxx / LPxx` -\u003e `* (pointer)`\n\t- `char *` -\u003e `PCHAR`\n- `Cxx -\u003e const`\n\t- `const char *` -\u003e `LPCSTR`\n- `Wxx` -\u003e ワイド文字: Unicodeのみの文字型\n- `Txx` -\u003e マルチバイト文字: UnicodeやSJISなどより一般の文字型\n- `Hxx` -\u003e HANDLE\n- `Ixx` / `Nxx` -\u003e 整数\n\n[Windows Data Types (BaseTsd.h) - Win32 apps | Microsoft Learn](https://learn.microsoft.com/en-us/windows/win32/winprog/windows-data-types)\n\n## Windows API (Win32 API)\n何ができる？\nファイル読み書き\nディスク読み取り\nメモリ\n\n仕組み\nDLL内のAPIを呼び出すことで詳細を知ることなくリソースを知ることができる.\n\n1. CreateFileA を呼び出す.\n2. kernel32.dll / ntdll.dll から sysenter / syscall してカーネルへ渡す.\n3. ntoskrnl.exe が実際にファイル作成する.\n\n利用\n- API 名を Google や [Microsoft Learn](https://learn.microsoft.com/en-us/) で検索\n- 引数の型情報\n\n## Registry\n\n| 名前               | 略称 | 説明                                               |\n| ------------------ | ---- | -------------------------------------------------- |\n| HKEY_CURRENT_USER  | HKCU | 現在ログオン中のユーザに関連づけられたデータを格納 |\n| HKEY_LOCAL_MACHINE | HKLM | システム関連の情報を格納                           |\n| HKEY_USERS         | HKU  | マシン上の全てのユーザに関する情報を格納           |\n| HKEY_CLASSES_ROOT  | HKCR | ファイルの関連付け情報などを格納                   |\n\n- [Predefined Keys - Win32 apps | Microsoft Learn](https://learn.microsoft.com/en-us/windows/win32/sysinfo/predefined-keys)\n\n## Heap\n\nRtlCreateHeap 関数は `_HEAP` 構造体へのポインタを返す.\n- [Terminus Project - _HEAP - combined view (rewolf.pl)](http://terminus.rewolf.pl/terminus/structures/ntdll/_HEAP_combined.html)\n- [Windows 10 Segment Heap Internals (blackhat.com)](https://www.blackhat.com/docs/us-16/materials/us-16-Yason-Windows-10-Segment-Heap-Internals-wp.pdf)","lastmodified":"2022-12-30T07:57:21.463263852Z","tags":null},"/Reversing/Reversing":{"title":"rev","content":"\nデータを\n\nidiom\n2倍+2をアロケート -\u003e wide char + null終端\n\n\n","lastmodified":"2022-12-30T07:57:21.463263852Z","tags":null},"/Reversing/StaticAnalyse":{"title":"静的解析","content":"\n## Ghidra\n\n- Rename Variable\n- Retype Variable\n\t- 配列や構造体にすると嬉しい\n\n文字列: 配列","lastmodified":"2022-12-30T07:57:21.463263852Z","tags":null},"/Reversing/SurfaceAnalysis":{"title":"表層解析","content":"\n- ファイル形式\n- インジケータ\n\t- 様々なソフトウェアやツールへの情報展開が容易となる.\n\t- ファイル全体のハッシュ値 (SHA)\n- 文字列の抽出\n\t- strings\n- PE解析\n\t- PEファイルのヘッダ領域\n\t\t- ライブラリや関数リソースなど様々な情報を付与される.\n\t- 内蔵ファイルの取得\n\t\t- Resource Hacker\n","lastmodified":"2022-12-30T07:57:21.463263852Z","tags":null},"/algebra/group_theory":{"title":"数学の花","content":"## 群の定義\n集合$S\\neq \\phi$ を考える。$\\forall a,b\\in S$ に対して$\\exists c \\in S$ を対応させる法則つまり直積$S\\times S$から$S$への写像を2項演算(law of composition)と呼ぶ.　記号的には\n$$\n\\begin{align}\nS\\times S \u0026\\to S\\\\\n(a,b)\u0026\\mapsto a\\cdot b=c\n\\end{align}\n$$\nと表現される. \n","lastmodified":"2022-12-30T07:57:21.463263852Z","tags":null},"/arithmetic/ArithmeticalFunction":{"title":"数論的関数/進数変換","content":"\nオイラーの$\\phi$関数\nメビウスの$\\mu$関数\nカーマイケルの$\\lambda$関数","lastmodified":"2022-12-30T07:57:21.463263852Z","tags":null},"/arithmetic/BitTrick":{"title":"Bit Trick","content":"\n- XOR swap\n\n## ビット演算\nInteger Overflow ([CWE-190](https://cwe.mitre.org/data/definitions/190.html)) 整数の上限値を超えると下限値付近になる\nInteger Underflow ([CWE-191](https://cwe.mitre.org/data/definitions/191.html)) 整数の下限値を下回ると上限値付近になる\nFloating Point Underflow   [x + 0.25 - 0.25 = xが成り立たないxとは何か｜Rui Ueyama｜note](https://note.com/ruiu/n/ndd60f403e8f2)\nStack Overflow\nStack Underflow","lastmodified":"2022-12-30T07:57:21.463263852Z","tags":null},"/arithmetic/crt":{"title":"中国剰余定理","content":"\n## 説明\n\nGarnerのアルゴリズム\n\n## 計算量\n\n$O(n^2 + n\\log(\\max p_i))$\n\n## 実装\n\n```cpp\n#include \u003cvector\u003e\n\n// x % m[i] = r[i] % m[i] を満たす正で最小の x を返す\n// mは互いに素であると仮定\n// とりあえず解の存在判定は保留\ntemplate \u003ctypename T\u003e\nT CRT(std::vector\u003cT\u003e r, std::vector\u003cT\u003e m) {\n  ll n = r.size();\n  ll m_prod = 1;\n  ll x = r[0] % m[0];\n  for (ll i = 1; i \u003c n; i++) {\n    m_prod *= m[i - 1];\n    ll t = ((r[i] - x) * invmod(m_prod, m[i])) % m[i];\n    if (t \u003c 0)\n      t += m[i];\n    x += t * m_prod;\n  }\n  return x;\n}\n```\n\n## 使用例\n","lastmodified":"2022-12-30T07:57:21.463263852Z","tags":null},"/arithmetic/fft":{"title":"高速フーリエ変換 (FFT)","content":"\n## 説明\n\n次の記事がわかりやすいです。\n\n[【競プロer向け】FFT を習得しよう！ | 東京工業大学デジタル創作同好会traP](https://trap.jp/post/1386/)\n\n## 計算量\n\n$O(N\\log{N})$\n\n## 実装\n\n```cpp\n#include \u003ccomplex\u003e\n#include \u003cvector\u003e\n\nusing namespace std;\nusing ll = long long;\nusing ld = long double;\nusing Complex = complex\u003cld\u003e;\nconst ld PI = 3.1415926535897932;\n\nvector\u003cComplex\u003e FFT(vector\u003cComplex\u003e \u0026A) {\n  const int N = A.size();\n  vector\u003cComplex\u003e even(N / 2), odd(N / 2);\n  for (int i = 0; i \u003c N / 2; i++) {\n    even[i] = A[2 * i];\n    odd[i] = A[2 * i + 1];\n  }\n  even = FFT(even);\n  odd = FFT(odd);\n  for (int i = 0; i \u003c N / 2; i++) {\n    odd[i] *= polar(1.0L, 2 * PI * i / N);\n    A[i] = even[i] + odd[i];\n    A[N / 2 + i] = even[i] - odd[i];\n  }\n  return A;\n}\n```\n\n## 使用例\n","lastmodified":"2022-12-30T07:57:21.463263852Z","tags":null},"/arithmetic/gcd":{"title":"最大公約数・最小公倍数","content":"\n## 説明\n\nユークリッドの互除法\n\n## 計算量\n\n$O(\\log{N})$\n\n## 実装\n\n```cpp\ntemplate \u003ctypename T\u003e\nT gcd(T a, T b) {\n  T r;\n  while (b \u003e 0) {\n    r = a % b;\n    a = b;\n    b = r;\n  }\n  return a;\n}\n\ntemplate \u003ctypename T\u003e\nT lcm(T a, T b) {\n  return a / gcd(a, b) * b;\n}\n\ntemplate \u003ctypename T\u003e\nT extgcd(T a, T b, T \u0026x, T \u0026y) {\n  T g = a;\n  x = 1;\n  y = 0;\n  if (b) {\n    g = extgcd(b, a % b, y, x);\n    y -= a / b * x;\n  }\n  return g;\n}\n```\n\n## 使用例","lastmodified":"2022-12-30T07:57:21.463263852Z","tags":null},"/arithmetic/matrix/matrix":{"title":"行列","content":"\n## 説明\n\n\n## 計算量\n\n\n## 実装\n\n```cpp\n#include \u003cbits/stdc++.h\u003e\n#include \u003cgcd.hpp\u003e\nusing namespace std;\n\nusing ll = long long;\nusing ull = uint_fast64_t;\nusing pll = pair\u003cll, ll\u003e;\nusing i64 = int_fast64_t;\nusing u64 = uint_fast64_t;\n\nconst ll MOD = 1e9 + 7;\nconst ll MODD = 998244353;\n\nll invmod(ll a, ll mod) {\n  ll x, y;\n  extgcd(a, mod, x, y);\n  x %= mod;\n  if (x \u003c 0)\n    x += mod;\n  return x;\n}\n\nconstexpr ll mx = 4;\nclass Matrix {\npublic:\n  using T = ll;\n  T m[mx][mx];\n  // コンストラクタ\n  constexpr Matrix() noexcept {}\n  // アクセス\n  const T *operator[](const ll i) const { return m[i]; } // read\n  T *operator[](const ll i) { return m[i]; }             // write\n  // 演算\n  inline constexpr Matrix \u0026operator+=(const Matrix \u0026x) noexcept {\n    for (ll i = 0; i \u003c mx; i++)\n      for (ll j = 0; j \u003c mx; j++)\n        m[i][j] += x[i][j];\n    return *this;\n  }\n  inline constexpr Matrix operator+(const Matrix x) const noexcept {\n    return Matrix(*this) += x;\n  }\n  inline constexpr Matrix \u0026operator-=(const Matrix \u0026x) noexcept {\n    for (ll i = 0; i \u003c mx; i++)\n      for (ll j = 0; j \u003c mx; j++)\n        m[i][j] -= x[i][j];\n    return *this;\n  }\n  inline constexpr Matrix operator-(const Matrix \u0026x) noexcept {\n    return Matrix(*this) -= x;\n  }\n  // O(N^3)\n  inline constexpr Matrix \u0026operator*=(Matrix \u0026x) noexcept {\n    *this = *this * x;\n    return *this;\n  }\n  inline constexpr Matrix operator*(Matrix \u0026x) {\n    Matrix c;\n    for (ll i = 0; i \u003c mx; i++)\n      for (ll j = 0; j \u003c mx; j++)\n        for (ll k = 0; k \u003c mx; k++) {\n          T a = m[i][j] * x[j][k];\n          c[i][k] += a;\n        }\n    return c;\n  }\n  // E^M O(N^3logM)\n  inline constexpr Matrix pow(ll b) const noexcept {\n    Matrix a = *this, c = E();\n    while (b) {\n      if (b \u0026 1)\n        c *= a;\n      if (b \u003e\u003e= 1)\n        a *= a;\n    }\n    return c;\n  }\n  inline constexpr Matrix static E() noexcept {\n    Matrix a;\n    for (ll i = 0; i \u003c mx; i++)\n      a[i][i] = 1;\n    return a;\n  }\n  inline constexpr bool operator==(const Matrix \u0026a) {\n    bool flg = true;\n    for (ll i = 0; i \u003c mx; i++)\n      for (ll j = 0; j \u003c mx; j++)\n        if (m[i][j] != a[i][j])\n          flg = false;\n    return flg;\n  }\n  // 行列とスカラの演算\n  inline constexpr Matrix \u0026operator+=(const T \u0026a) {\n    for (ll i = 0; i \u003c mx; i++)\n      for (ll j = 0; j \u003c mx; j++)\n        m[i][j] += a;\n    return *this;\n  }\n  inline constexpr Matrix \u0026operator-=(const T \u0026a) {\n    for (ll i = 0; i \u003c mx; i++)\n      for (ll j = 0; j \u003c mx; j++)\n        m[i][j] -= a;\n    return *this;\n  }\n  inline constexpr Matrix \u0026operator*=(const T \u0026a) {\n    for (ll i = 0; i \u003c mx; i++)\n      for (ll j = 0; j \u003c mx; j++)\n        m[i][j] *= a;\n    return *this;\n  }\n  inline constexpr Matrix \u0026operator/=(const T \u0026a) {\n    for (ll i = 0; i \u003c mx; i++)\n      for (ll j = 0; j \u003c mx; j++)\n        m[i][j] /= a;\n    return *this;\n  }\n  inline constexpr Matrix operator+(const T \u0026a) const {\n    return Matrix(*this) += a;\n  }\n  inline constexpr Matrix operator-(const T \u0026a) const {\n    return Matrix(*this) -= a;\n  }\n  inline constexpr Matrix operator*(const T \u0026a) const {\n    return Matrix(*this) *= a;\n  }\n  inline constexpr Matrix operator/(const T \u0026a) const {\n    return Matrix(*this) /= a;\n  }\n  // 転置行列\n  inline constexpr Matrix t() {\n    Matrix m2;\n    for (ll i = 0; i \u003c mx; i++)\n      for (ll j = 0; j \u003c mx; j++)\n        m2[i][j] = m[j][i];\n    return m2;\n  }\n\n  inline constexpr void show() {\n    for (ll i = 0; i \u003c mx; i++) {\n      for (ll j = 0; j \u003c mx; j++) {\n        if (j != 0)\n          cout \u003c\u003c \" \";\n        cout \u003c\u003c m[i][j];\n      }\n      cout \u003c\u003c endl;\n    }\n    return;\n  }\n};\n```\n```cpp\n\nusing D = double;\nconst D EPS = 1e-10;\n\n// matrix\ntemplate\u003cclass T\u003e struct Matrix {\n    vector\u003cvector\u003cT\u003e \u003e val;\n    Matrix(int n, int m, T x = 0) : val(n, vector\u003cT\u003e(m, x)) {}\n    void init(int n, int m, T x = 0) {val.assign(n, vector\u003cT\u003e(m, x));}\n    size_t size() const {return val.size();}\n    inline vector\u003cT\u003e\u0026 operator [] (int i) {return val[i];}\n};\n\ntemplate\u003cclass T\u003e int GaussJordan(Matrix\u003cT\u003e \u0026A, bool is_extended = false) {\n    int m = A.size(), n = A[0].size();\n    int rank = 0;\n    for (int col = 0; col \u003c n; ++col) {\n        // 拡大係数行列の場合は最後の列は掃き出ししない\n        if (is_extended \u0026\u0026 col == n-1) break;\n\n        // ピボットを探す\n        int pivot = -1;\n        T ma = EPS;\n        for (int row = rank; row \u003c m; ++row) {\n            if (abs(A[row][col]) \u003e ma) {\n                ma = abs(A[row][col]);\n                pivot = row;\n            }\n        }\n        // ピボットがなかったら次の列へ\n        if (pivot == -1) continue;\n\n        // まずは行を swap\n        swap(A[pivot], A[rank]);\n\n        // ピボットの値を 1 にする\n        auto fac = A[rank][col];\n        for (int col2 = 0; col2 \u003c n; ++col2) A[rank][col2] /= fac;\n\n        // ピボットのある列の値がすべて 0 になるように掃き出す\n        for (int row = 0; row \u003c m; ++row) {\n            if (row != rank \u0026\u0026 abs(A[row][col]) \u003e EPS) {\n                auto fac = A[row][col];\n                for (int col2 = 0; col2 \u003c n; ++col2) {\n                    A[row][col2] -= A[rank][col2] * fac;\n                }\n            }\n        }\n        ++rank;\n    }\n    return rank;\n}\n\nconst int MAX_ROW = 510; // to be set appropriately\nconst int MAX_COL = 510; // to be set appropriately\nstruct BitMatrix {\n    int H, W;\n    bitset\u003cMAX_COL\u003e val[MAX_ROW];\n    BitMatrix(int m = 1, int n = 1) : H(m), W(n) {}\n    inline bitset\u003cMAX_COL\u003e\u0026 operator [] (int i) {return val[i];}\n};\n\nint GaussJordan(BitMatrix \u0026A, bool is_extended = false) {\n    int rank = 0;\n    for (int col = 0; col \u003c A.W; ++col) {\n        if (is_extended \u0026\u0026 col == A.W - 1) break;\n        int pivot = -1;\n        for (int row = rank; row \u003c A.H; ++row) {\n            if (A[row][col]) {\n                pivot = row;\n                break;\n            }\n        }\n        if (pivot == -1) continue;\n        swap(A[pivot], A[rank]);\n        for (int row = 0; row \u003c A.H; ++row) {\n            if (row != rank \u0026\u0026 A[row][col]) A[row] ^= A[rank];\n        }\n        ++rank;\n    }\n    return rank;\n}\n\nint linear_equation(BitMatrix A, vector\u003cint\u003e b, vector\u003cint\u003e \u0026res) {\n    int m = A.H, n = A.W;\n    BitMatrix M(m, n + 1);\n    for (int i = 0; i \u003c m; ++i) {\n        for (int j = 0; j \u003c n; ++j) M[i][j] = A[i][j];\n        M[i][n] = b[i];\n    }\n    int rank = GaussJordan(M, true);\n\n    // check if it has no solution\n    for (int row = rank; row \u003c m; ++row) if (M[row][n]) return -1;\n\n    // answer\n    res.assign(n, 0);\n    for (int i = 0; i \u003c rank; ++i) res[i] = M[i][n];\n    return rank;\n}\n```\n\n## 使用例\n\n","lastmodified":"2022-12-30T07:57:21.463263852Z","tags":null},"/arithmetic/modulo/ArbitraryModint":{"title":"任意Modint","content":"\n## 説明\n\n| 演算                   | 方法                          | 計算量                      |\n| :--------------------  | :---------------------------- | :------------------------- |\n| 足し算   $a + b$       | 足してN以上になったらN引く    | $O(1)$            |\n| 引き算   $a - b$       | 引いて0未満になったらN足す    | $O(1)$            |\n| 掛け算   $a \\times b$  | 掛けてNで割った余り           | $O(1)$            |\n| 割り算   $a \\div b$    | 拡張ユークリッドの互除法      | $O(\\log^2 N)$   |\n| 累乗     $a ^ e$       | 繰り返し二乗法                | $O(\\log N)$       |\n| 平方根   $\\sqrt{a}$    | Tonelli Shanksのアルゴリズム  | $O(\\log^2 N)$   |\n| 累乗根   $\\sqrt[e]{a}$ | Tonelli Shanksのアルゴリズム     | $O(\\min(N^{1/4},\\sqrt{e})\\log{e}\\log^2{N})$     |\n| 対数     $\\log_e{a}$   | 離散対数問題            | $O(\\sqrt{N})$     |\n\n(参考: [整数論テクニック集のpdf](https://kirika-comp.hatenablog.com/entry/2018/03/12/210446) など)\n\n## 実装\n\n```cpp\n#include \u003ccstdint\u003e\n#include \u003cistream\u003e\n#include \u003cvector\u003e\n\nusing ll = long long;\n\nclass runtime_modint {\n  using u64 = std::uint_fast64_t;\n\n  static u64 \u0026mod() {\n    static u64 mod_ = 0;\n    return mod_;\n  }\n\npublic:\n  u64 a;\n\n  runtime_modint(const u64 x = 0) : a(x % get_mod()) {}\n  u64 \u0026value() noexcept { return a; }\n  const u64 \u0026value() const noexcept { return a; }\n  inline constexpr operator ll() const noexcept { return a; }\n  runtime_modint operator+(const runtime_modint rhs) const {\n    return runtime_modint(*this) += rhs;\n  }\n  runtime_modint operator-(const runtime_modint rhs) const {\n    return runtime_modint(*this) -= rhs;\n  }\n  runtime_modint operator*(const runtime_modint rhs) const {\n    return runtime_modint(*this) *= rhs;\n  }\n  runtime_modint operator/(const runtime_modint rhs) const {\n    return runtime_modint(*this) /= rhs;\n  }\n  runtime_modint \u0026operator+=(const runtime_modint rhs) {\n    a += rhs.a;\n    if (a \u003e= get_mod()) {\n      a -= get_mod();\n    }\n    return *this;\n  }\n  runtime_modint \u0026operator-=(const runtime_modint rhs) {\n    if (a \u003c rhs.a) {\n      a += get_mod();\n    }\n    a -= rhs.a;\n    return *this;\n  }\n  runtime_modint \u0026operator*=(const runtime_modint rhs) {\n    a = a * rhs.a % get_mod();\n    return *this;\n  }\n  runtime_modint \u0026operator/=(runtime_modint rhs) {\n    u64 exp = get_mod() - 2;\n    while (exp) {\n      if (exp % 2) {\n        *this *= rhs;\n      }\n      rhs *= rhs;\n      exp /= 2;\n    }\n    return *this;\n  }\n\n  template \u003cclass T\u003e inline constexpr runtime_modint \u0026operator+=(T x) noexcept {\n    return operator+=(runtime_modint(x));\n  }\n  template \u003cclass T\u003e inline constexpr runtime_modint \u0026operator+(T x) noexcept {\n    return runtime_modint(*this) += x;\n  }\n  template \u003cclass T\u003e inline constexpr runtime_modint \u0026operator-=(T x) noexcept {\n    return operator-=(runtime_modint(x));\n  }\n  template \u003cclass T\u003e inline constexpr runtime_modint \u0026operator-(T x) noexcept {\n    return runtime_modint(*this) -= x;\n  }\n  template \u003cclass T\u003e inline constexpr runtime_modint \u0026operator*=(T x) noexcept {\n    return operator*=(runtime_modint(x));\n  }\n  template \u003cclass T\u003e inline constexpr runtime_modint \u0026operator*(T x) noexcept {\n    return runtime_modint(*this) *= x;\n  }\n  template \u003cclass T\u003e inline constexpr runtime_modint \u0026operator/=(T x) noexcept {\n    return operator/=(runtime_modint(x));\n  }\n  template \u003cclass T\u003e inline constexpr runtime_modint \u0026operator/(T x) noexcept {\n    return runtime_modint(*this) /= x;\n  }\n\n  static void set_mod(const u64 x) { mod() = x; }\n  static u64 get_mod() { return mod(); }\n};\n\nll n, m;\nbool used[100000];\nstd::vector\u003cstd::pair\u003cll, runtime_modint\u003e\u003e G[100000];\n\nruntime_modint dfs(ll x) {\n  used[x] = true;\n  bool end = true;\n  runtime_modint res = 1;\n  for (auto \u0026p : G[x]) {\n    if (used[p.first] == true)\n      continue;\n    end = false;\n    if (p.second != 0) {\n      res *= p.second;\n    } else {\n      p.second = dfs(p.first);\n      // cout \u003c\u003c x MM p.fi MM p.se \u003c\u003c endl;\n      res *= p.second;\n    }\n  }\n  used[x] = false;\n  return res + 1;\n}\n```\n\n## 使用例\n\n\n## 関連項目\n- [Modint](Modint.md)","lastmodified":"2022-12-30T07:57:21.463263852Z","tags":null},"/arithmetic/modulo/modint":{"title":"Modint","content":"\n## 説明\n\n| 演算                   | 方法                          | 計算量                      |\n| :--------------------  | :---------------------------- | :------------------------- |\n| 足し算   $a + b$       | 足してN以上になったらN引く    | $O(1)$            |\n| 引き算   $a - b$       | 引いて0未満になったらN足す    | $O(1)$            |\n| 掛け算   $a \\times b$  | 掛けてNで割った余り           | $O(1)$            |\n| 割り算   $a \\div b$    | 拡張ユークリッドの互除法      | $O(\\log^2 N)$   |\n| 累乗     $a ^ e$       | 繰り返し二乗法                | $O(\\log N)$       |\n| 平方根   $\\sqrt{a}$    | Tonelli Shanksのアルゴリズム  | $O(\\log^2 N)$   |\n| 累乗根   $\\sqrt[e]{a}$ | Tonelli Shanksのアルゴリズム     | $O(\\min(N^{1/4},\\sqrt{e})\\log{e}\\log^2{N})$     |\n| 対数     $\\log_e{a}$   | 離散対数問題            | $O(\\sqrt{N})$     |\n\n(参考: [整数論テクニック集のpdf](https://kirika-comp.hatenablog.com/entry/2018/03/12/210446) など)\n\n## 実装\n\n```cpp\n#include \u003ccstdint\u003e\n#include \u003cistream\u003e\n#include \u003ctype_traits\u003e\n#include \u003cvector\u003e\n\nusing ll = long long;\nusing u64 = std::uint_fast64_t;\n\nconst ll MOD = 1000000007;\nconst ll MODD = 998244353;\n\nconstexpr u64 Modulus = MOD;\nclass Modint {\npublic:\n\tu64 num = 0;\n\tconstexpr Modint() noexcept {}\n\tconstexpr Modint(const u64 x) noexcept : num(x % Modulus) {}\n\tinline constexpr operator ll() const noexcept { return num; }\n\tinline constexpr Modint \u0026operator+=(const Modint rhs) noexcept { num += rhs.num; if (num \u003e= Modulus) num -= Modulus; return *this; }\n\tinline constexpr Modint operator+(const Modint rhs) const noexcept { return Modint(*this) += rhs; }\n\tinline constexpr Modint \u0026operator-=(const Modint rhs) noexcept { if (num \u003c rhs.num) num += Modulus; num -= rhs.num; return *this; }\n\tinline constexpr Modint operator-(const Modint rhs) const noexcept { return Modint(*this) -= rhs; }\n\tinline constexpr Modint \u0026operator*=(const Modint rhs) noexcept { num = num * rhs.num % Modulus; return *this; }\n\tinline constexpr Modint operator*(const Modint rhs) const noexcept { return Modint(*this) *= rhs; }\n\tinline constexpr Modint \u0026operator/=(const Modint rhs) noexcept { return operator*=(rhs.inv()); }\n\tconstexpr Modint operator/(const Modint rhs) const noexcept { return Modint(*this) /= rhs; }\n\tinline constexpr Modint\u0026 operator++() noexcept { if (num == Modulus - 1) num = 0; else num++; return *this; }\n\tinline constexpr Modint operator++(int) noexcept { Modint ans(*this); operator++(); return ans; }\n\tinline constexpr Modint\u0026 operator--() noexcept { if (num == 0) num = Modulus - 1; else num--; return *this; }\n\tinline constexpr Modint operator--(int) noexcept { Modint ans(*this); operator--(); return ans; }\n\tinline constexpr Modint operator-() noexcept { return Modint(0) -= *this; }\n\ttemplate\u003cclass T\u003e inline constexpr Modint \u0026operator+=(T x) noexcept { return operator+=(Modint(x)); }\n\ttemplate\u003cclass T\u003e inline constexpr Modint \u0026operator+(T x) noexcept { return Modint(*this) += x; }\n\ttemplate\u003cclass T\u003e inline constexpr Modint \u0026operator-=(T x) noexcept { return operator-=(Modint(x)); }\n\ttemplate\u003cclass T\u003e inline constexpr Modint \u0026operator-(T x) noexcept { return Modint(*this) -= x; }\n\ttemplate\u003cclass T\u003e inline constexpr Modint \u0026operator*=(T x) noexcept { return operator*=(Modint(x)); }\n\ttemplate\u003cclass T\u003e inline constexpr Modint \u0026operator*(T x) noexcept { return Modint(*this) *= x; }\n\ttemplate\u003cclass T\u003e inline constexpr Modint \u0026operator/=(T x) noexcept { return operator/=(Modint(x)); }\n\ttemplate\u003cclass T\u003e inline constexpr Modint \u0026operator/(T x) noexcept { return Modint(*this) /= x; }\n\tinline constexpr Modint inv() const noexcept { ll x = 0, y = 0; extgcd(num, Modulus, x, y); return x; }\n\tstatic inline constexpr ll extgcd(ll a, ll b, ll \u0026x, ll \u0026y) noexcept { ll g = a; x = 1; y = 0; if(b){ g = extgcd(b, a % b, y, x); y -= a / b * x; } return g; }\n\tinline constexpr Modint pow(u64 x) const noexcept { Modint ans = 1, cnt = *this; while(x){ if(x \u0026 1) ans *= cnt; cnt *= cnt; x /= 2; } return ans; }\n\ttemplate\u003cclass T\u003e constexpr Modint(T x) noexcept {\n\t\tusing U = typename std::conditional\u003csizeof(T) \u003e= 4, T, int\u003e::type;\n\t\tU y = x; y %= U(Modulus); if(y \u003c 0) y += Modulus; num = uint(y);\n\t}\n};\nstd::istream\u0026 operator\u003e\u003e(std::istream\u0026 is, Modint\u0026 x){ ll a; is \u003e\u003e a; x = a; return is; }\n// inline constexpr Modint operator\"\"_M(ull x) noexcept { return Modint(x); }\nstd::vector\u003cModint\u003e fac(1, 1), inv(1, 1);\ninline void reserve(ll a){\n\tif(fac.size() \u003e= a) return;\n\tif(a \u003c fac.size() * 2) a = fac.size() * 2;\n\tif(a \u003e= Modulus) a = Modulus;\n\twhile(fac.size() \u003c a) fac.push_back(fac.back() * Modint(fac.size()));\n\tinv.resize(fac.size());\n\tinv.back() = fac.back().inv();\n\tfor(ll i = inv.size() - 1; !inv[i - 1]; i--) inv[i - 1] = inv[i] * i;\n}\ninline Modint fact(ll n){ if(n \u003c 0) return 0; reserve(n + 1); return fac[n]; }\ninline Modint perm(ll n, ll r){\n\tif(r \u003c 0 || n \u003c r) return 0;\n\tif(n \u003e\u003e 24){ Modint ans = 1; for(ll i = 0; i \u003c r; i++) ans *= n--; return ans; }\n\treserve(n + 1); return fac[n] * inv[n - r];\n}\n// 階乗やその逆元をメモ化すると速い\n// modを取りたくないならnCk/2^Nをパスカルの三角形で作る\ninline Modint comb(ll n, ll r){ if(r \u003c 0 || n \u003c r) return 0; reserve(r + 1); return perm(n, r) * inv[r]; }\ninline Modint Mcomb(ll n, ll r){ return comb(n + r - 1, n - 1); } // r balls into n boxes\ninline Modint catalan(ll n){ reserve(n * 2 + 1); return fac[n * 2] * inv[n] * inv[n + 1]; }\n```\n\n## 使用例\n\n[ABC262 D - I Hate Non-integer Number](https://atcoder.jp/contests/abc262/submissions/33693576)\n\n## 関連項目\n- [任意Modint](ArbitraryModint.md)","lastmodified":"2022-12-30T07:57:21.463263852Z","tags":null},"/arithmetic/ntt":{"title":"数論変換","content":"\n## 説明\n\n複素数上のFFTを有限体上に取り替えたのがNTT。乗法群の位数が大きな2のべき乗を持っていると精度を落とさずに計算できて嬉しい。\n\n## 計算量\n\n$O(N\\log{N})$\n\n## 実装\n\n\n## 使用例\n","lastmodified":"2022-12-30T07:57:21.463263852Z","tags":null},"/arithmetic/primes/FastFactorize":{"title":"高速素因数分解 (Pollard-ρ法/Miller-Rabin法)","content":"\n## 説明\n\nPollard-$\\rho$ 法と Miller-Rabin 法を用いて $O(n^{\\frac{1}{4}}\\log^3n)$ で素因数分解できる。\n\n### Miller–Rabin 素数判定法\n\nMiller-Rabin 素数判定法は与えられた数 $n$ が素数かどうかを計算時間 $O(k\\log^3 n)$ で誤り率 $4^{-k}$ 以下で判定する確率的素数判定アルゴリズムである。\n\nフェルマーの小定理について考える。素数である剰余 $n$ について、その乗法群の位数 $n-1$ はそれを $2$ で割れるだけ割った数を $d$ として $n-1 = 2^sd$ と書ける。\n\n$$\n\\begin{aligned}\na^{n-1} \u0026= a^{2^sd} ≡ 1 \\quad \\pmod n \\\\\na^{2^sd}-1 \u0026= (a^d-1)(a^d+1)(a^{2d}+1)(a^{4d}+1)\\cdots(a^{2^{s-1}d}+1)\\\\\n\u0026≡ 0 \\\\\n\\iff\u0026\\begin{cases}\na^d \u0026≡ 1 \u0026 \\pmod n \\\\\na^{2^rd} \u0026≡ -1 \u0026 \\pmod n \u0026 (\\exists r \\in \\mathbb{Z}, 0\\leq r\\leq s-1)\n\\end{cases}\n\\end{aligned}\n$$\n\nこの対偶をとると、「次の2式を満たす $a$ が存在するならば\n\n$$\n\\begin{aligned}\n\\begin{cases}\na^d \u0026\\neq 1 \u0026 \\pmod n \\\\\na^{2^rd} \u0026\\neq -1 \u0026 \\pmod n \u0026 (\\forall r \\in \\mathbb{Z}, 0\\leq r\\leq s-1)\n\\end{cases}\n\\end{aligned}\n$$\n\n$n$ は合成数である」と言える。\n\nこれを用い、次のステップを実行することで確率的な素数判定ができる。\n\n1. ランダムに $a \\in [1, n-1]$ をとってくる\n2. 上の条件を満たしたら composite と返す\n3. 満たさなければ probably prime と返す\n\nこれを繰り返すことで判定の精度が高まります。この処理をMiller–Rabin素数判定法と呼びます。\n\n2, 325, 9375, 28178, 450775, 9780504, 1795265022\n\n## 計算量\n\n$O(k\\log^3 n)$ 、FFTベースの乗算を用いると $Õ(k\\log^2 n)$\n\n## 実装\n\n## 使用例\n\n## 参考\n[Deterministic variants of the Miller-Rabin primality test](http://miller-rabin.appspot.com/)\n\n## 関連項目\n- [素因数分解](Factorize.md)\n- [素数列挙](Primes.md)","lastmodified":"2022-12-30T07:57:21.463263852Z","tags":null},"/arithmetic/primes/factorize":{"title":"素因数分解","content":"\n## 説明\n\n\n## 計算量\n\n\n## 実装\n\n```cpp\n#include \u003cvector\u003e\n\ntemplate \u003ctypename T\u003e\nstd::vector\u003cstd::pair\u003cT, int\u003e\u003e factors(T N) {\n  std::vector\u003cstd::pair\u003cT, int\u003e\u003e res;\n  for (T a = 2; a * a \u003c= N; ++a) {\n    if (N % a != 0)\n      continue;\n    int e = 0;\n    while (N % a == 0) {\n      ++e;\n      N /= a;\n    }\n    res.push_back({a, e});\n  }\n  if (N != 1)\n    res.push_back({N, 1});\n  return res;\n}\n```\n\n## 使用例\n\n\n## 関連項目\n- [高速素因数分解 (Pollard-ρ法/Miller-Rabin法)](FastFactorize.md)\n- [素数列挙](Primes.md)\n","lastmodified":"2022-12-30T07:57:21.463263852Z","tags":null},"/arithmetic/primes/primes":{"title":"素数列挙","content":"\n## 説明\n\nエラトステネスの篩\n\n## 計算量\n\n\n## 実装\n\n```cpp\n#include \u003cvector\u003e\n\nstd::vector\u003cint\u003e primes;\nstd::vector\u003cbool\u003e Eratosthenes(int N) {\n  std::vector\u003cbool\u003e isprime(N + 1, true);\n  isprime[0] = isprime[1] = false;\n\n  for (int p = 2; p \u003c= N; ++p) {\n    if (!isprime[p])\n      continue;\n    primes.push_back(p);\n    for (int q = p * 2; q \u003c= N; q += p) {\n      isprime[q] = false;\n    }\n  }\n  return isprime;\n}\n```\n\n## 使用例\n\n\n## 関連項目\n- [素因数分解](Factorize.md)\n- [高速素因数分解 (Pollard-ρ法/Miller-Rabin法)](FastFactorize.md)","lastmodified":"2022-12-30T07:57:21.463263852Z","tags":null},"/arithmetic/zeta":{"title":"高速ゼータ変換・高速メビウス変換","content":"\n## 説明\n\n\n\n## 計算量\n\n\n## 実装\n\n```cpp\n#include \u003cvector\u003e\n\ntemplate \u003ctypename T\u003e\nclass Eratosthenes {\npublic:\n  std::vector\u003cbool\u003e isprime; // 素数\n  std::vector\u003cT\u003e minfactor;  // 最小の素因数\n  // メビウス関数 μ\n  // μ(1)=1\n  // n がある素数pで2回以上割り切れるとき、μ(n)=0\n  // n=p1×p2×…pK と素因数分解できるとき、μ(n)=(−1)^K\n  // f(1)=∑[i=1~N]μ(i)F(i) 約数系包除原理\n  std::vector\u003cT\u003e mobius;\n\n  // エラトステネスの篩 O(NloglogN)\n  Eratosthenes(int N)\n      : isprime(N + 1, true), minfactor(N + 1, -1), mobius(N + 1, 1) {\n    isprime[1] = false;\n    minfactor[1] = 1;\n\n    for (T p = 2; p \u003c= N; ++p) {\n      if (!isprime[p])\n        continue;\n      minfactor[p] = p;\n      mobius[p] = -1;\n      for (T q = p * 2; q \u003c= N; q += p) {\n        isprime[q] = false;\n        if (minfactor[q] == -1)\n          minfactor[q] = p;\n        if ((q / p) % p == 0)\n          mobius[q] = 0;\n        else\n          mobius[q] = -mobius[q / p];\n      }\n    }\n  }\n\n  // 高速素因数分解 O(NlogN)\n  std::vector\u003cpT\u003e factorize(int n) {\n    std::vector\u003cpT\u003e res;\n    while (n \u003e 1) {\n      T p = minfactor[n];\n      T exp = 0;\n\n      while (minfactor[n] == p) {\n        n /= p;\n        ++exp;\n      }\n      res.emplace_back(p, exp);\n    }\n    return res;\n  }\n\n  // 高速約数列挙 O(\\sigma n)\n  std::vector\u003cT\u003e divisors(T n) {\n    std::vector\u003cT\u003e res({1});\n    std::vector\u003cpT\u003e pf = factorize(n);\n\n    for (auto [p, e] : pf) {\n      T s = (T)res.size();\n      for (T i = 0; i \u003c s; ++i) {\n        T v = res[i];\n        for (T j = 0; j \u003c e; ++j) {\n          v *= p;\n          res.push_back(v);\n        }\n      }\n    }\n    return res;\n  }\n\n  // 高速ゼータ変換 O(NloglogN)\n  // F(n)=∑[n|i]f(i)\n  template \u003cclass T\u003e\n  void fast_zeta(std::vector\u003cT\u003e \u0026f) {\n    T N = f.size();\n    for (T p = 2; p \u003c N; ++p) {\n      if (!isprime[p])\n        continue;\n      for (T k = (N - 1) / p; k \u003e= 1; --k) {\n        f[k] += f[k * p];\n      }\n    }\n  }\n\n  // 高速メビウス変換 O(NloglogN)\n  // f(n)=∑[n|i]μ(i/n)F(i)\n  template \u003cclass T\u003e\n  void fast_mobius(std::vector\u003cT\u003e \u0026F) {\n    T N = F.size();\n    for (T p = 2; p \u003c N; ++p) {\n      if (!isprime[p])\n        continue;\n      for (T k = 1; k * p \u003c N; ++k) {\n        F[k] -= F[k * p];\n      }\n    }\n  }\n\n  // 添字GCD畳み込み O(NloglogN)\n  // h(n)=∑[GCD(i,j)=n]f(i)g(j)\n  // H(n)=F(n)G(n)\n  template \u003cclass T\u003e\n  std::vector\u003cT\u003e gcd_conv(const std::vector\u003cT\u003e \u0026f, const std::vector\u003cT\u003e \u0026g) {\n    T N = max(f.size(), g.size());\n    std::vector\u003cT\u003e F(N, 0), G(N, 0), H(N);\n    for (T i = 0; i \u003c f.size(); ++i)\n      F[i] = f[i];\n    for (T i = 0; i \u003c g.size(); ++i)\n      G[i] = g[i];\n\n    fast_zeta(F);\n    fast_zeta(G);\n\n    for (T i = 1; i \u003c N; ++i)\n      H[i] = F[i] * G[i];\n\n    fast_mobius(H);\n\n    return H;\n  }\n};\n```\n\n## 使用例\n","lastmodified":"2022-12-30T07:57:21.463263852Z","tags":null},"/blog/Chinese":{"title":"","content":"前置詞\n\n\n助動詞\n| 助動詞 | 意味                | 否定形      | 意味 |\n| ------ | ------------------- | ----------- | ---- |\n| 会     | 可能                | 不会        |      |\n| 能     | 客観的に可能        | 不能        |      |\n| 可以   | 許可                | 不可以      |      |\n| 想     | 希望, 願望          | 不想        |      |\n| 要     | 希望, 願望, have to | 不想, 不要  | 禁止 |\n| 得     | have to             | 不用,不必要 |      | \n\nにゃんぱすー\n\n\n\n\n\n\n\n\n\n\n\nwǒ jiào Yǔzuǒjiàn dàxī.\nwǒ shì Dōngjīng gōngyè gōngyè de xuésheng\nwǒ xuési Zhōngguóhuà yīnián\nwǒ you xihuen chi Zhōngguócai, you bu zuo\nwǒ hun hao Zhōngguó wénhuà.\nwǒ hai bu ti Zhōngguó, wo ti kankan Zhōngguó.","lastmodified":"2022-12-30T07:57:21.463263852Z","tags":null},"/blog/ChromeExtension":{"title":"","content":"","lastmodified":"2022-12-30T07:57:21.463263852Z","tags":null},"/blog/Vim":{"title":"","content":"### Matering Vim Language\nhttps://www.youtube.com/watch?v=wlR5gYd6um0\n\nhttps://vim.help/12-clever-tricks#12.2\nhttps://career.levtech.jp/guide/knowhow/article/29/\n\n### 僕がVimで愛用しているプラグイン30連発\nhttps://liginc.co.jp/469142\n\n### Vim の operator プラグインをまとめた\nhttps://qiita.com/rbtnn/items/a47ed6684f1f0bc52906\n\n### vimcolorschemes\nhttps://vimcolorschemes.com\n\n競プロのライブラリをネットからインポート、スニペットを入れる必要がない\nワンラインif/forをブロックに展開するoperator\n","lastmodified":"2022-12-30T07:57:21.463263852Z","tags":null},"/blog/WindowsPower":{"title":"","content":"\n電源のスリープが上手く作動しない\n原因の調べ方\nコマンドプロンプトで `powercfg /requests` 阻害しているアプリが分かる.\nSYSTEM...","lastmodified":"2022-12-30T07:57:21.463263852Z","tags":null},"/blog/global_cyber":{"title":"","content":"（1）What is your cyber security experience?\nI am familiar with cryptography and pwn and used to participate in CTF as traP and thehackerscrew. I studied kernel exploits from kernel modules and eBPF bugs, malware analysis, and Windows forensics at the security camp. I have a weekly reading group of math books on elliptic curve cryptography with professionals in the cryptography field, and I often read papers in the cryptography field. We created a programming language for mini-symbolic execution and IoT security.\n\n（2）What is your English proficiency?\nEIKEN Grade 2\n\n（3）セキュリティ・キャンプに参加したことがある人は、参加した大会名と、クラス/トラック/受講講義等を教えてください。 (ない場合は「なし」と記載。)\nセキュリティ・キャンプ全国大会2022 オンライン (Cトラック 脅威解析クラス)\n\n（4）公開してる技術系の活動や資料(ブログや、Twitter、GitHub、Slideshare、Speaker Deckなど)がありましたらURL等を記載してください。\nhttps://twitter.com/Anko_9801\nhttps://github.com/anko9801\nhttps://www.slideshare.net/DaikiUsami\nhttps://speakerdeck.com/anko9801\nhttps://qiita.com/Anko_9801\n\n（5）PowerShellマルウェアではよく「IEX」という文字列が利用されています。なぜでしょうか？攻撃者目線で回答してください。\nPowershell において IEX は Invoke-Expression のエイリアスとして知られている. Invoke-Expression は文字列を Powershell スクリプトとして評価し実行します. これを用いることでコマンドをそのまま実行するよりも難読化を施すことができたり, ダウンロードしたスクリプトを実行し, ファイル検知を回避することができます. またそれを xor や base64 エンコードすることでセキュリティソフトに検出されにくく, 悪意のあるスクリプトを実行することができます.\nhttps://learn.microsoft.com/ja-jp/powershell/module/microsoft.powershell.utility/invoke-expression?view=powershell-7.3\n\n（6）HP募集要項の申込方法から取得した「FindTheKey.exe」のコードを Python3 に移植してください。（2022年11月21日追加）\n```python3\nkey = [0xCB, 0xF7, 0xFA, 0xBF, 0xE8, 0xF0, 0xF2, 0xFA, 0xF1, 0xBF, 0xF6, 0xF1, 0xBF, 0xD6, 0xDB, 0xDE, 0xBF, 0xF3, 0xF0, 0xF8, 0xF0, 0xBF, 0xF6, 0xEC, 0xBF, 0xD2, 0xFE, 0xFB, 0xFE, 0xF2, 0xFA, 0xBF, 0xFB, 0xFA, 0xBF, 0xD2, 0xFE, 0xF6, 0xF1, 0xEB, 0xFA, 0xF1, 0xF0, 0xF1, 0xB1]\n\nnumber_for_the_key = int(input(\"Input a number for the key (0-255):\"))\n\nif 0 \u003c= number_for_the_key \u003c 0x100:\n    for i in range(3):\n        key[i] ^= number_for_the_key\n\n    prefix = b\"The\"\n    flag = True\n    for i in range(3):\n        if key[i] != prefix[i]:\n            flag = False\n\n    if flag:\n        for i in range(3,0x2d):\n            key[i] ^= number_for_the_key\n        print(bytes(key))\n    else:\n        print(\"Wrong key!!\")\n```\n","lastmodified":"2022-12-30T07:57:21.463263852Z","tags":null},"/blog/memo":{"title":"","content":"\nESQuery\nhttps://zenn.dev/ubie_dev/articles/a5c8fb2d219258\n既存のルールをチェックしないでやれる\n簡易的なコードを書くことでlintしてくれるやつが欲しい.\nrust-analyzerにclippyが入った.\nhttps://keens.github.io/blog/2019/12/23/jisakulintru_rutocargo_fixderustnoko_doworifakutasuru/\n整形\n\nsmart replacer\n\njavascript optimizerで最強らしい\nhttps://github.com/google/closure-compiler\nTyped AST\nproto\nhttps://github.com/facebookarchive/prepack\nhttps://prepack.io/repl.html#BQMwrgdgxgLglgewgAmASmQbwFDOeaeJZAWwEM4J0tc9kokBnGZAJwFNHkBefdWvAwiMEAG3YA6UQgDmwDozS0AvrXKV0Abmy0CsRChCoMOOvSYsAHj2QBmAW3YwwrFJZXZlaLUA\n\noptimizer 図鑑を作りたい\n\ntest suite\nやばいエッジケースを収録\nhttps://github.com/tc39/test262\n\nOcaml multicore -\u003e ReactのFiberに影響\n\nREASON OCaml がベース FacebookにはOCaml派閥がいる\nhttps://reasonml.github.io/\n\ntraQ fuzzy search\n\nRust ORM Diesel","lastmodified":"2022-12-30T07:57:21.463263852Z","tags":null},"/blog/security_camp":{"title":"","content":"セキュリティ・キャンプ全国大会2022 オンライン\n専門コース C【脅威解析クラス】応募課題\n\n以下の問1から問8について、それぞれ5,000文字以内で回答してください。\n\n問5および問6については配布ファイルを使用します。以下に配布ファイルのSHA-256ハッシュ値を記載しますので、正しいファイルを取得できていることを確認した上で課題に取り組んでください。\n\n- sc2022_challenge05.zip\n  - 0292b1972845b6c3a57129acfd0de403f6f8080a4e2a3eef93c3913c63efe0df\n\n- sc2022_20220322T230402.zip\n  - 088e8fb04f486bae5d2dca1ccf9e5b971044c297bd03f7a5bd05bfaded6f27c3\n\nなお、正解がある設問については、\"正解していること\"よりも\"正解にたどり着くまでのプロセスや熱意\"を重要視しています。答えにたどり着くまでの試行錯誤や自分なりの工夫等を書いて、精一杯アピールしてください。\n\n## 問1\nあなたがセキュリティ・キャンプ全国大会に応募する理由を教えてください。受講生や講師とのコミュニケーション、受講したい講義、なりたい自分など、何でも構いません。\n\n私は大学のサークルでCTF班と呼ばれる班に所属し、毎週CTFに参加し、セキュリティについて学んでいます。先月、そのサークルが主催するCTFの問題の作成から開発、運営まで携わる機会を頂き、それらを経験した結果、自分がセキュリティについて知らないことがあまりにも多く、知っていても表面的で断片的なことに過ぎないことを痛感しました。それでセキュリティについて、徹底的に勉強したいと強く思ったことがセキュキャンに応募する理由です。\n\n箇条書きにすると以下の通りです。\n\n- CTFに強くなりたい\n- 強い人や知らない分野と出会って刺激されたい`\n- カーネルエクスプロイトを出来るようになってカーネルの脆弱性を見つけ、修正、報告したい\n- ウイルスを実際に読んでAnti Virusソフトを自作してみたい\n- 物理レイヤーへの攻撃や複数レイヤーを通じた攻撃、他分野と合わせた攻撃(シーケンサーの脆弱性を踏むようなDNAの生成など)、最近の技術であるTEEやeBPFへの攻撃について知りたい\n- 攻撃/防御を抽象化したい\n\n欲張りですが、何でも学んで経験してみたいです。\n\n## 問2\n今までに解析したことのあるソフトウェアやハードウェアにはどのようなものがありますか？解析の目的や解析方法、結果として得られた知見などを含めて教えてください。\n\nCTFで実行ファイルを読んだりすることはありますが、世のソフトウェアのバイナリを読むと言った経験が乏しくて本当の解析の例を出せません。ただ、ソースコードを読むという体験なら幾つかあります。\n\nLinuxカーネルを知りたいという欲求からサークルの2人でLinuxカーネルを読むことをしています。syscallの実装やスケジューラ、メモリ管理やKASLRなどの実装を読んでいました。高速化の為に読みにくく雑(?)な実装になるのが面白いなと感じます。得られた知見というと大きなコードを読む力です。自分はどんなコードであれ、気になった機能を一番下まで深掘りして読みたくなってしまうのですが、もう1人の方が途中で切り上げてくださり、丁度いい塩梅で読むことが出来ていると思います。(それでも抑えきれず、途中から読んでる場所が全然違ってきて知見を共有できないことが多々ありました笑)\n\n後は必要に応じて OSS 例えば python や golang などの言語の実装だったり V8 だったり CTF では Crypto を担当してるので SageMath の実装だったりをよく読みます。\n\nハードウェア系であれば購入してきたLEDランプの光量が少ない為、回路を読んではんだ付けして光量を増やしました。また物を分解する癖があり、キーボード、ラジオ、タップ、ルーターなどを分解したりしました。\n\n## 問3\n今までに作成したソフトウェアやハードウェアにはどのようなものがありますか？\nどんな言語やライブラリ、パーツを使って作ったのか、どこにこだわって作ったのか、などたくさん自慢してください。\n\n- 自作プログラミング言語\n2018年度のSecHack365に参加し、IoT向け言語として安全性と手軽さ、速度を持ち合わせた言語を作りました。C++のライブラリを用い、LLVMベースの言語で、C++, Rust, Kotlinに影響されていて、他とは違う所はライフタイムに関連する機能を実装したりした所です。その当時はそれで満足していたようですが、今の視点からするとおもちゃなのでより安全で心地よい言語を書きたいなと思います。\n\n- 量子コンピュータ用のC++ライブラリ\nJOIの夏季合宿でqasmと呼ばれる言語へのトランスパイラと古典コンピュータ上でのシミュレート(もちろんqubit数に対し指数時間/メモリ)をIBM Qにある演算に対し実装しました。\n\n- 将棋AI\n高校生のころ、ディープラーニングを用いて何か作りたいと思い、将棋AIを学習させました。どこかのサイトにある棋譜を元に Chainer で書いたものに学習させました。その当時は探索アルゴリズムに弱く、アルファベータ法などを知らなかった為、序盤/中盤は強いですが終盤はかなり弱いというものになりました。最近では GPT-3 などの Transformer が流行っていて、もう一度勉強し直して音声変換技術やブラウザのタブについてカテゴリに応じて自動的にグループ化するもの、あとは文章を書くのが苦手なのでブログを書くお手伝いをしてくれるものなどを作りたいなと思っています。\n\n- 水中ロボット\n高校のときに水中ロボットをチームで開発し、水中ロボコンinJAMSTECに芝浦工業大学附属高校として参加し、優勝しました。自分はプログラムを書いただけなのでほぼ他の方のおかげですが、それがきっかけとなり、今は水中ロボコンのサークルで回路を組む手伝いをしています。\n\n- レイトレーシング\nシェーダーについてあまり理解できてなかったのでレイトレーシング技術が面白そうと思いそのエンジンを開発しました。Ray Tracing in One Weekend という記事を参考にしてRustで書き、ppmと呼ばれる形式で出力して表示するというものを作りました。レイマーチングはまだ出来てないのでやりたいなと思っています。\n\n- ELF解析ツール\nELFの静的解析と動的解析ができるツールです。ELFファイルをバイナリで直読みできるようになりたいと思い開発しました。\n静的解析は ELF header, Program header table, Section header table などを読んで Spotify TUI などで使われているライブラリ tui-rs で TUI 表示してもらうものです。動的解析は実質自作デバッガーでそれを実行するプロセスを起動してptraceでアタッチし、レジスタやアセンブリなどの情報を取ってきて表示してくれるものです。メモリの値から大体の型を決めてアドレスは参照先のも表示したり文字列は文字列として表示しました。\n\n- 自作シンボリック実行エンジン\nrev問をやっているとangrと呼ばれるシンボリック実行エンジンをよく使うのですが、その仕組みがあんまり理解できてなかったので自作しました。開発期間が3日間なのでx64アーキテクチャで本当に小規模なものを作りました(本当はボーっと生きてたら3日後にLTがあることに気付き、やばいと思いつつ、この無謀なネタにしたら作れてしまったという締切駆動開発の凄さと恐ろしさを知りました)。\nシンボリック実行エンジン自体の仕組みは命令列をSMTに投げるだけというものです。実際はSMTまで自作したかったですが、資料が見つからず、z3に任せることにしました。実装はx64アーキテクチャの必要最小限の命令を実装しました。ネタを考えたときにその時流行っていたCVE-2022-0778: OpenSSLの無限ループの脆弱性を検出しようと考えていましたが、普通にやると(よく考えればできそうですが)ループ回数に対し、指数時間掛かり、5,6回くらいのループで数時間のオーダーとなり、数十回までループすれば無限ループと決定できたのですが、その検出は不可能と後で気付きました。\nまた言語はRustで開発したのですが設計の段階で大きな間違いを犯していて、どのようにしても解決できないような循環参照に陥り、その修正にかなり悩ませられ、開発のほとんど時間はこれに注ぎ込みました。おかげでRustの設計思想が分かるようになり、ライフタイムに頭を抱えるということがほぼ無くなりました。\n\n- 競技プログラミングとCTFのコンテストの運営、開発、作問\n開発では Rust, React で競プロのコード実行とフロントを繋ぐ部分の修正をしたり、 Ansible を書きました。作問は Crypto 分野を主に作り、他は簡単なものを1つずつほど作りました。改めて CTFer としてよわいなと感じ、これから1年強くなろうと決意しました。\n\n- その他\nこれは車輪の再発明で開発には入らないと思いますが、理解したくなったら自作することがあり、OS, シェル, ALU, DB, ゲームエンジン などを自作しました。\n\n## 問4\nここ数年に発表された、以下のキーワードに関連するニュースや記事や学術論文から1つ選び、それに関して調べた内容を記述してください。内容には、1.選んだ理由、2.技術的詳細、3.被害規模または影響範囲、4.対策、の4点を必ず含めてください。なお、対策は今ある技術のみに捕われず、将来的な技術や法律など、自由な発想で書いてください。\n\nキーワード：\n- サイバーセキュリティインシデント\n- マルウェア\n- 攻撃キャンペーン\n- 脆弱性\n- 新たな攻撃手法\n- 未知の脅威\n\nサイバーセキュリティインシデントの1つとしてサプライチェーン攻撃があります。これはどうすれば攻撃を防ぐことができるか気になったため選びました。\nサプライチェーン攻撃とは例えばOSSであればライブラリに悪意のあるスクリプトが埋め込められるとそれに依存する全てのプロジェクトに被害が波及するような攻撃です。今年3月にもnpmでサプライチェーン攻撃がありました。ハードウェアであれば、部品のボードに微小なチップが埋め込まれていたり、ハードウェアトロイと呼ばれる集積回路に不正な処理が埋め込まれていたりする可能性があり、それをベースに組んだ製品は機密情報を盗まれたり妨害されることが考えられます。\nこれらに対しセキュリティを担保するためには、悪意のあるスクリプトを検知する手法やハードウェアトロイを検出する手法を開発する必要があり、それが出来なければ DevSecOps の思想のように部品調達からサービス化まで全体を通じたセキュリティの評価手法を社会的な仕組みや制度を通して行えればよいと思います。\nまた、これは実現可能かどうかは分かりませんが、私はより進んだ攻撃/防御の概念の理解によって言語側からサポートできると思っています。\n\n## 問5\n配布ファイル（sc2022_challenge05.zip）に含まれるsafe.exe.gzfは解析対象のPEプログラムをGhidraデータベース形式に変換したものです。data.datは解析対象のプログラムが使用するデータです。safe.exe.gzfを解析して以下の問題に対して回答してください。\n\n※Ghidraのインストールおよびgzfに関する補足: https://hackmd.io/@qKyR9Y4rS7y7ytUCRr6FRg/H188XOvXq\n\n### 問5-1 \nこのプログラムの目的、挙動を説明せよ。\n\nWindows関連の様々な関数があることがわかり、 WinMain 関数についてデコンパイラを用いて調べると、 'C:\\Users\\Public\\KB59E7269.log' というファイルを開き、その内容を暗号化したものをアプリのディレクトリ名としてウィンドウを起動しているようです。他の関数はライブラリや内部情報を取得してプロセスの起動準備を行うイニシャライザのような関数群などがありましたがプログラムとは関係がなさそうなのでこれらは無視します。\nつまり、このプログラムはWindowsのログファイルを暗号化するプログラムです。\n\n### 問5-2 \ndata.datがどのような形式で暗号化されているか答えよ。また、復号されるデータの内容がどのようなものか答えよ。\n\n察するに暗号化されたものが data.dat に書かれてあると考えられます。\n暗号化の手法について読んでみると、まずファイルを16バイトのヘッダとそれ以外に分割し、ヘッダは共通鍵として、具体的には内部状態(S-box)を生成するのに使い、内部状態を用いて後半の内容を暗号化します。内部状態は0x00から0xffまでの値の順列となっており具体的な生成方法は以下の通りです。ただし演算は $\\mathbb{Z}/256\\mathbb{Z}$ 上で行うこととします。\n\n1. 256バイトの内部状態に0x00から0xffまで書き込む。\n2. 数 w をおき、現在見ている内部状態の値とヘッダの値を w に足し、内部状態の w の位置にある値とスワップする。\n3. 2を内部状態の最初から順番に最後まで繰り返す。\n\n暗号化の具体的な方法は以下の通りです。\n\n1. 数 p をおき、現在見ている内部状態の値を p に足し、内部状態の p の位置にある値とスワップする。\n2. スワップしたそれぞれの数を足した位置にある内部状態の値の位置にある内部状態の値を暗号化したい内容とxorする。\n3. 1,2を暗号化したい内容の最初から順番に最後まで繰り返す。\n\n復号することについて考えます。この暗号は共通鍵方式のストリーム暗号に属し、秘密鍵であるヘッダさえ分かれば内部状態が分かり復号することができます。つまり復号する方法は2つあり、1つは秘密鍵を当てる方法、もう1つはこの暗号の脆弱性を発見する方法があります。\nまず秘密鍵を直接当てる方法です。気付いたことはログファイルということなのでまず ASCII で書かれている可能性が高いということがあります。これで128ビット全探索が約112ビット全探索となりましたが目標は大体32ビット全探索なのでこれは誤差です。他にもWindowsのログファイル特有の性質を調べましたが無さそうでした。また以下のように定式化しても構造が複雑で秘密鍵の特定が難しかったです。\n\n$$\n\\begin{aligned}\n\u0026\\begin{cases}\np_{i+1} = p_i + s_i + h_i \\\\\ns_i \\iff s_{p_{i}} \\\\\n\\end{cases} \\\\\n\u0026\\begin{cases}\np_{i+1} = p_i + s_i \\\\\ns_i \\iff s_{p_{i}} \\\\\nm_{i} = c_i \\oplus ss(s_i + s_{p_{i}}) \\\\\n\\end{cases}\n\\end{aligned}\n$$\n\nそこで2つ目、暗号の規則性を発見することを考えます。調べてみると差分解析法や線形解読法が当てはまりそうなのでそれをやろうとしたのですが、文献の少なさと難しさから応募するまでに試すことが出来ませんでした。\n\n### 問5-3\ndata.datを復号するスクリプト作成して提出せよ。\n\n秘密鍵を全探索するスクリプトを書きました。\n\n```python\nfrom string import printable\n\nstrs = printable\n\ndef search(h):\n    if len(h) == 16:\n        dec = decrypt(list(reversed(h)))\n        m = []\n        for i in range(size):\n            c = next(dec)\n            m.append(cipher[i] ^ c)\n            if chr(m[i]) not in strs:\n                if i \u003e 5:\n                    print(bytes(reversed(h)), bytes(m))\n                break\n        return\n    for s in strs:\n        h.append(ord(s))\n        search(h)\n        h.pop()\n\ndef decrypt(h):\n    sbox = [0] * 0x100\n    for i in range(0x100):\n        sbox[i] = i\n    swap = 0\n    for i in range(0x100):\n        swap += h[i \u0026 0xf] + sbox[i]\n        swap \u0026= 0xff\n        sbox[i], sbox[swap] = sbox[swap], sbox[i]\n    swap = 0\n    i = 0\n    while True:\n        swap += sbox[i]\n        swap \u0026= 0xff\n        sbox[i], sbox[swap] = sbox[swap], sbox[i]\n        yield sbox[sbox[(sbox[i] + sbox[swap]) \u0026 0xff]]\n        i = (i + 1) \u0026 0xff\n\nwith open('data.dat', 'rb') as f:\n    cipher = f.read()\n    size = len(cipher)\n    search([])\n```\n\n## 問6\n配布ファイル（sc2022_20220322T230402.zip）は、Windows 10 PCのユーザsc2022のホームディレクトリ(C:¥Users¥sc2022¥)以下を取得し、zip形式で圧縮したファイルです。このユーザは、あるファイルサーバ上のファイルにアクセスしていたこと、あるオンラインストレージサービスを利用していたこと、が判明しています。\n\n以下の問題に対して、配布ファイルをどのように解析したかも含めて回答してください。\n\n### 問6-1\nユーザがアクセスしたファイルサーバー上のファイルに関連する情報を可能な限り記載してください(例: ファイル名、ファイルパス、日時等)。\n\nまず一通り見て関係がないと断言できるものを見つけます。以下のようなものは関係ないと言えます。\n\n- NTUSER.DATなど: Windowsレジストリの実体\n- desktop.ini: デスクトップの表示方法\n\nこれよりAppData以下が怪しいことがわかるのでそれらを中心に調べます。まず cloud, storage, drive, file などのストレージサービスで使われていそうな単語で grep し、ブラウザの閲覧履歴にありそうというアタリを付けました。\n\n```\n$ rg \"storage\" --binary -M 1 -m 1\n```\n\nそしてFireFoxの閲覧履歴を保存している以下のファイルから使ったファイルサーバーは firestorage だということがわかります。\n\n`C/Users/sc2022/AppData/Roaming/Mozilla/Firefox/Profiles/hc93rfhn.default-release/places.sqlite`\n\nhttps://fire.st/ZM7Nt1u などからcanary.txtというファイルにアクセスし、last_visit_dateから2022-03-22 22:35に閲覧していることがわかります。\n\n### 問6-2 \nユーザが利用していたオンラインストレージサービスに関連する情報を可能な限り記載してください(例: サービス名、アクセス方法、日時等)。\n\nユーザーが利用していたオンラインストレージサービスは FireStorage で WindowsSearch のよくみるサイトなどから FireFox を起動し、2022年03月22日の22:35に閲覧した。\n\n### 問6-3\nユーザは、ファイルサーバ上のファイルをオンラインストレージサービスにアップロードしたか、していた場合はどのファイルであったかを回答してください。\n\nアップロードしたファイルはこのようなファイルである。\ncanary.txt\n```\nFDGG\n\n```\n\n## 問7\nBinary Exploitに関して、次の各問に回答してください。\n\n### 問7-1\nHeap Buffer Overflowとはどのような脆弱性かを簡潔に説明してください。また、この脆弱性を攻撃者がどのように攻撃に利用するかを説明してください。\n\nコンピュータは様々な方法でメモリを管理しています。その中でプロセスごとに持つメモリ領域として スタック(Stack) と ヒープ(Heap) があります。また、Buffer Overflowとは想定されるサイズ以上に書き込むことができてしまう脆弱性です。つまり、Heap Buffer Overflowとはヒープというメモリ領域で必要以上に書き込みが出来てしまう脆弱性です。\n具体的な攻撃方法はヒープの構造について知らなければ説明できないので先にそれについて整理します。\n\nヒープはメモリを動的に確保、解放する仕組みをもつメモリ領域です。プログラムは malloc()/free() 関数によって確保/解放します。\n最初に malloc() が呼ばれると syscall の1つである sbrk() が呼び出され、ヒープ領域を作ります。malloc() で確保され続け、ヒープ領域に空きが少なくなってくると sbrk syscall によってヒープ領域を拡張します。基本戦略としてそれぞれの空き領域をチャンクとして管理し、それらチャンクをいかに上手く使い回すかで速度が変わります。例えば、図書館の事務を想像してもらって、借りて返した本をもう一度借りるということが頻繁に起こるときに、いちいち元にあった場所に戻してまた取ってくるというのは手間で、手元に置いておく方が便利です。ただ全ての本を手元に置いておける訳ではありません。どうやって制限された場所で効率よく管理するか。これと同じようにチャンクを一旦保持しておくということをします。また、フラグメンテーションが起こるとそのチャンク free lilst と呼ばれる連結リストとして管理しています。この malloc()/free() は確保するメモリサイズを指定できるのですがサイズによって格納方法を変えています。\n以下64bitのシステムを前提にして考えます。\n\n- tcache\n始めの7つのチャンクはtcacheでキャッシュされます。per-thread cache の略らしいです。\n- fastbins\n128B(`global_max_fast`)までの小さな領域は fastbins によってキャッシュされます。fastbins ではサイズに応じて16Bおきにリストを作成しています。これにより best-fit allocator となります。実装は main_arena にあるfastbinsY からチャンクが伸びています。\n- unsorted bins\nmalloc_consolidate() などで他の bin で管理されなくなったものを保持します。これらは確保されるか bin に登録されるまで残り続けます。\n- smallbins\n1KB(`MIN_LARGE_SIZE`)までの領域は smallbins によって管理されます。8Bおきにリストを作ります。\n- largebins\n1KB(`MIN_LARGE_SIZE`)以上の大きな領域は largebins によって管理されます。サイズに対し指数的に間隔を広く取ってリストで管理します。\n- mmap/munmap\n128KB(`M_MMAP_THRESHOLD`)以上の場合は mmap/munmap によりカーネルから直接確保されます。\n\nそして Heap Buffer Overflow はそれを使うことでデータの上書きができ、それによってヒープの管理構造を乗っ取ることができることがあります。\n\nまた、OSの核であるカーネルもヒープ領域を持ち、それに対しての BOF はKernel Heap Buffer Overflow と呼びます。ここら辺はあまり試したことがなく説明できるものが少ないですが、1回だけ meowmow という問題で Kernel Exploit を勉強していたときに kmalloc がサイズごとに分けられ、Slabと呼ばれるページ単位を小分けにして管理しているものに HBOF が出来る構造体と tty_struct 構造体を載せ、 tty_struct を書き換えて攻撃できるというものを知りました。それ以外の攻撃手法は全く知らないのでこれから理解していこうと思います。\n\n### 問7-2\nUse-after-Freeとはどのような脆弱性かを簡潔に説明してください。また、この脆弱性を攻撃者がどのように攻撃に利用するかを説明してください。\n\nヒープ領域のチャンクを解放した後でも使えてしまう脆弱性です。例えば、unsorted bin で Use-after-Free ができると管理領域の情報を覗くことができ、例えば fd から libc base が分かったりします。libc base が分かれば、libc 上のガジェットから Stack Buffer Overflow などで ROP を組む事ができ、シェルを起動できます。\n\n### 問7-3\n以下のx64アーキテクチャのROP gadgetを組み合わせ、後の各処理を実現するROP chainを構築してください。ROP chainは、64-bitのアドレスや値をカンマ(,)区切りで書いてください。ただし、関数A, Bのアドレスはそれぞれ0x401aa0, 0x401bb0、64-bit非負整数型変数xのアドレスは0x602080とします。また、関数A, Bの呼び出し規約はAMD64 ABIに従っており、引数・戻り値ともに64-bitの非負整数値とします。\n\nこのROP gadgetの組み合わせだけでは実現できないと判断した場合は、その理由を書いてください。\n\n0x401027: pop rdi; ret;\n0x40103a: pop rcx; ret;\n0x4011f2: pop rsi; pop r12; ret;\n0x40132a: mov rdi, rax; rep movsq; ret;\n0x401401: xchg eax, edi; ret;\n\n(例) A(1); B(2);\n--\u003e 0x401027, 1, 0x401aa0, 0x401027, 2, 0x401bb0\n\n(1) A(1, 2); B(3);\n(2) A(B(0));\n(3) A(x);\n(4) x = 0xdeadbeefcafebabe;\n\n問題の意味が分からない場合はReturn Oriented Programmingについて調べ、ROPについてあなたが理解した内容を書いてください。\n\n(1) A(1, 2); B(3);\n0x401027, 1, 0x4011f2, 2, 0, 0x401aa0, 0x401027, 3, 0x401bb0\n\n(2) A(B(0));\n0x401027, 0, 0x401bb0, 0x401401, 0x401aa0\n\n(3) A(x);\nメモリ参照のガジェットが無いため、xの値をレジスタに格納することが出来ず、実現できません。\n\n(4) x = 0xdeadbeefcafebabe;\nスタックのアドレスが分からず、スタック上に書き込みたい値を書いてもストリング命令の転送前のアドレスを指定することが出来ないため、実現できません。\n\nA: 0x401aa0, B: 0x401bb0\nx: 0x602080\n\n## 問8\neBPF(extended Berkeley Packet Filter)はLinuxカーネルが提供する機能の名前です。eBPFについて次の各問に答えてください。\n\n### 問8-1\neBPFとはどのような機能かを「JIT」という言葉を用いて説明してください。\n\neBPF は extended Berkley Packet Filter の略で、カーネルの特定のポイントでフックさせて実行するコードを安全に仕込める技術です。これを利用することで安全で高速にカーネルの制御や活用ができます。例えばカーネルのトレースをしたり、内部情報を取得したり、パケットフィルタリングさせたり、syscallに制限を掛けたりすることができます。eBPF の中身は BPF 独自の命令セットを解釈する仮想マシンとカーネル空間とユーザー空間で共有するストレージオブジェクトがあります。ストレージオブジェクトによってカーネルの情報をユーザーにわたすことが出来ます。\n\nプログラムは次のようにロードします。\n\nC言語のBPFプログラム -\u003e BPFバイトコード -\u003e マシンコード\n\nC言語のBPFプログラムからBPFバイトコードへはLLVM/Clangを用いてコンパイルします。生成されたBPFバイトコードは bpf syscall によりカーネルに渡され、BPF Verifierと呼ばれる検査機を用いて安全に実行できるか確認してから、マシンコードへJIT (Just In Time) コンパイラでコンパイルし、ロードされます。これによりカーネルを再起動せずにカーネル内で安全にサンドボックス化されたプログラムを実行できます。\n\n### 問8-2\nあなたが身近に使っているアプリケーションでBPF/eBPFを利用するものを探し、どのような使われ方がしているかを説明してください。見つからない場合は、普段使っていないアプリケーションでも構いません。\n\n普段使っているアプリケーションにeBPFは用いられていなかったので、Pixieと呼ばれるアプリケーションについて調べました。\nPixie は Kubernetes クラスタのプロファイラやメトリクスの可視化を行うアプリケーションです。eBPFを用いることで様々なレイヤーでのスループットやレイテンシ、エラーを収集することができ、それらの情報を統合させてHTTPリクエストやネットワークトラフィック、それらのフロー、スロークエリ、NodeやPodのモニタリングなどをしてくれます。\n","lastmodified":"2022-12-30T07:57:21.463263852Z","tags":null},"/crypto/AES/AES":{"title":"AES","content":"\n- AES-ECB (Electronic Codeblock)\n- AES-CBC (Cipher Block Chaining)\n- AES-CTR\n- PCBC (Propagating Cipher Block Chaining)\n- CFB (Cipher Feedback)\n- AES-GCM (Galois/Counter Mode)\n\nAES-NI\n\n","lastmodified":"2022-12-30T07:57:21.463263852Z","tags":null},"/crypto/AES/Symmetric_cryptography":{"title":"","content":"最新の状況はこの発表を見ればすべてわかる\n[Invited talk: Symmetric Cryptography for Long Term Security, by Maria Naya Plasencia - YouTube](https://www.youtube.com/watch?v=kcaPL2xxXiY)\n軽量な\nセキュリティ vs. 効率\n応用に合わせた性質\n- ZK-friendly\n- FHE-friendly\n- low latency\n- easy-masking\n- quantum safe\n\n最近の大きな研究10選\n- SHA-1 collision and Chosen-prefix collision\n- Practical attacks on 15-year old operating mode and ISO standard OCB2\n- Attacks on $\\approx2^{40}$ on GEA-1(back door) and GEA-2\n- Division property: Generalization of integrals, higher order diff.\n\t- Can be combined with cube attacks\n\t- Provides best known attacks on several stream ciphers\n\t- First full break of MISTY1, a widely implemented primitive\n- Partial non-linear layers: Zorro, LowMC attacks, Malicious, Hades/Poseidon\n- Stream cipher based: Kreyvium, FLIP\n- Large fields: MiMC round $x^3$\n![[Pasted image 20221024224251.png]]\n\nPost-Quantum Cryptography\nAsymmetric (e.g. RSA)\nShor's algorithm: Polynomial time\nSolution: lattice-based, code-based,...\n\nSymmetric (e.g. AES)\nGrover's algorithm: $2^{K}\\to 2^{K/2}$\n鍵長を倍の長さにすることで同じセキュリティを担保できる。","lastmodified":"2022-12-30T07:57:21.463263852Z","tags":null},"/crypto/DLP/BSGS":{"title":"Baby-step Giant-step","content":"\n## 説明\n\n半分全列挙を用いて $O(\\sqrt{N}\\log{N})$ でDLPが解ける。\n\n位数 $N$ の巡回群 $G$ について $a, b\\in G$ が与えられるので $a^n = b$ となる最小の $n\\in \\mathbb{N}$ を求める問題を考える。このとき $m = \\lceil\\sqrt{N}\\rceil$ とおき、$n$ を $m$ で割ると $n = qm + r \\ (q, r\\in[0, \\lceil\\sqrt{N}\\rceil)\\ )$ と表せられる。すると $r$ に対して $ba^{-r}$ を全列挙し、そのリストに対して $a^{qm}$ が含まれているような $q$ を探索すると高速に解が求まる。\n\n例えば、有限体 $\\mathbb{F}_p$ 上なら乗法群の位数 $p-1$ から\n\n楕円曲線 $E$ 上であれば加法群の位数 $\\#E$ から\n\n## 計算量\n$O(\\sqrt{N}\\log N)$\n\n## 実装\n\n## 使用例\n\n## 参考\n","lastmodified":"2022-12-30T07:57:21.463263852Z","tags":null},"/crypto/DLP/DLP":{"title":"離散対数問題 (DLP)","content":"\n## 説明\n\n離散対数問題 (DLP: Discrete Logarithm Problem) とは巡回群 $G$ について $a, b\\in G$ が与えられるので $a^n = b$ となる最小の $n\\in \\mathbb{N}$ を求める問題である。\n\n例えば、有限体 $\\mathbb{F}_q$ のDLP\n\n楕円曲線 $E$ 上でのDLP\n\n## 実装\n\n## 使用例\n\n## 参考\n\n- [General purpose integer factoring](https://eprint.iacr.org/2017/1087)","lastmodified":"2022-12-30T07:57:21.463263852Z","tags":null},"/crypto/DLP/IndexCalculus":{"title":"指数計算法 (Index Calculus Algorithm)","content":"\n## 説明\n\n## 実装\n\n## 使用例\n\n## 参考\n","lastmodified":"2022-12-30T07:57:21.463263852Z","tags":null},"/crypto/DLP/NumberFieldSieve":{"title":"数体ふるい法","content":"\n## 説明\n\n## 実装\n\n## 使用例\n\n## 参考\n","lastmodified":"2022-12-30T07:57:21.463263852Z","tags":null},"/crypto/DLP/Pohlig_Hellman":{"title":"Pohlig-Hellman","content":"\n## 説明\n\n中国剰余定理を用いて大きな群を複数の小さな群の直積に分割する。\n\n## 実装\n\n```python\nfact = factor(G.order())\nord = int(G.order())\ndlogs = []\nfor p, e in fact:\n    t = ord // p ^ e\n    dlog = discrete_log(t * Q, t * G, operation=\"+\")\n    dlogs += [dlog]\n\nprint(crt(dlogs, primes))\n```\n\n## 使用例\n\n## 参考\n","lastmodified":"2022-12-30T07:57:21.463263852Z","tags":null},"/crypto/DLP/Pollard_rho":{"title":"Pollard's rho 法","content":"\n## 説明\n\n初期点 $x_0$ と適当な副作用のない疑似乱数関数 $f(x)$ を決めて $x_{i+1} = f(x_i)$ となるように数列 $(x_0, x_1, \\ldots)$ を生成する。このとき $0 \\leq \\exists i \u003c \\exists j \u003c N$, $x_i = x_j$ となる $i,j$ を見つけられたらDLPが解けるという仕組みです。\n\nよく用いられる関数 $f(x)$ は次のようなものがあります。ただし、$G_1, G_2, G_3$ は巡回群 $G$ の集合をランダムに振り分けられるように3つに区別したものです。\n\n$$\nf(x)=\n\\begin{cases}\nbx \u0026 (x \\in G_1 \\mathrm{のとき}) \\\\\nx^2 \u0026 (x \\in G_2 \\mathrm{のとき}) \\\\\nax \u0026 (x \\in G_3 \\mathrm{のとき}) \\\\\n\\end{cases}\n$$\n\nこのとき $x_0 = a$ とすると $x_i$ は $x_i = a^{s_i}b^{t_i}$, $s_i, t_i \\in \\mathbb{N}$ と表せられる。すると $x_i = x_j$ において $n$ は巡回群の位数 $N$ を用いて次のように表せられる。\n\n$$\n\\begin{aligned}\nx_i \u0026= a^{s_i}b^{t_i} = a^{s_i + nt_i} \\\\\nx_j \u0026= a^{s_j + nt_j} \\\\\na^{s_i - s_j} \u0026= a^{n(t_j - t_i)} \\\\\nn \u0026= \\frac{s_i - s_j}{t_j - t_i} \\pmod N\n\\end{aligned}\n$$\n\nこれよりDLPが解ける。\nPollard-$\\rho$ 法の $\\rho$ は文字 $\\rho$ の形が由来となっている。\n\n\u003c!-- Pollard's Kangaroo 法 (Lambda 法)\n$\\rho$ 法は動く点が1つの値だったのに対し、 $\\lambda$ 法は2つの値がランダムに動いていき、一方がもう一方の点に衝突したときDLPが解ける。\n\n$$\n\\begin{aligned}\nx_0 \u0026= g^{a_0} \u0026 y_0 \u0026= g^{b_0} \\\\\nx_{i+1} \u0026= x_ig^{r(x_i)} \u0026 y_{i+1} \u0026= y_i g^{r(y_i)} \\\\\n\\end{aligned}\n$$\n\n$x_i = y_j$ となるとき --\u003e\n\n## 計算量\n\n$O(\\sqrt{N})$\n\n計算量の期待値集合 $S$ に対してそれぞれ相違な $x_0, x_1, \\ldots, x_{k-1}$ を選ぶ事象 $A$ と\n\n$$\n\\begin{aligned}\nP(A) \u0026= \\prod_{i = 0}^{k-1}\\left(1-\\frac{i}{N}\\right) \\approx \\prod_{i = 0}^{k-1}e^{-i/N} \\approx e^{-k^2/2N} \\\\\nP(B) \u0026= \\frac{k}{N}e^{-k^2/2N} \\\\\nE(B) \u0026= \\sum_{k=1}^N k\\cdot\\frac{k}{N}e^{-k^2/2N} \\\\\n\u0026\\approx \\sqrt{N}\\int_0^\\infty t^2e^{-t^2/2} dt \\\\\n\u0026= \\sqrt{\\frac{\\pi N}{2}}\n\\end{aligned}\n$$\n\n\n## 実装\n\n## 使用例\n\n## 参考\n\n- The Arithmetic of Elliptic Curves. p.383","lastmodified":"2022-12-30T07:57:21.463263852Z","tags":null},"/crypto/ECC/ECC":{"title":"楕円曲線暗号","content":"\n# 楕円曲線暗号\n\n## 楕円曲線\n$K$ を任意の体、 $f(x) \\in K[x]$ を3次方程式とする。ただし $f(x)$ の3解は相異なる。ここで次の方程式を考える。\n\n$$\ny^2 = f(x)\n$$\n\n$x, y$ 線形変換によって2次の項は消すことができ、\n\n$$\ny^2 = x^3 + ax + b\n$$\n\n- グラフ(一般性なし)\n- 特異性 -\u003e 無限遠点\n- 和\n\n![[Pasted image 20220907220335.png]]\n\n$C: F(x, y) = 0$ について\n$C$ が点 $(x_0, y_0)$ で非特異であるとは2つの偏微分 $\\partial F/\\partial x, \\partial F/\\partial y$ のうちの1つが $(x_0, y_0)$ で $0$ でないということである。$K'$ が実数体 $\\mathbb{R}$ であるとき $C$ がその点で接線を持つための条件と一致する。 $F(x, y) = y^2 - f(x)$ の場合、偏微分は $- f'(x_0)$ と $2y_0$ である。2つの微分が同時に $0$ であるためには、 $y_0 = 0$ かつ $x_0$ は $f(x)$ の重解であることが必要十分である。この理由の為に楕円曲線の定義において、$f(x)$ が相違なる根を持つということを仮定したのである。つまり楕円曲線はすべての点において非特異である。\n\n楕円曲線上の点全体に加えてその曲線上に存在すると考えたいきわめて重要な無限遠点と呼ばれるものがある。これは複素関数論において、複素平面に無限遠点を添加してリーマン球面を形成することと同じようなものである。このことを正確に扱う為に今、射影座標を導入する。\n\n単項式 $x^iy^j$ の全次数(total degree) とは $i + j$ を意味する。多項式 $F(x,y)$ の全次数とは、 $0$ でない係数を持って出てくる単項式の全次数の最大値を意味する。$F(x,y)$ の全次数が $n$ のとき、対応する $3$ 変数の同次多項式 $\\widetilde{F}(x,y,z)$ を $F(x,y)$ における各多項式 $x^iy^j$ に、 $x, y, z$ に関する全次数が $n$ になるように $z^{n-i-j}$ を掛けて得られる多項式と定義する。言い換えると\n\n$$\n\\widetilde{F}(x,y,z) = z^nF\\left(\\frac{x}{z}, \\frac{y}{z}\\right)\n$$\n\nとなる。例えば楕円曲線の1つ $F(x, y) = y^2 - (x^3 + ax + b)$\n\n$$\n\\begin{aligned}\n\\widetilde{F}(x,y,z) \u0026= y^2z - x^3 - axz^2 - bz^3 \\\\\n\\end{aligned}\n$$\n\n$\\widetilde{F}(x, y, 1) = F(x, y)$ とか $\\widetilde{F}(\\lambda x,\\lambda y,\\lambda z) = \\lambda^n\\widetilde{F}(x, y, z)$ みたいな性質がある。\n\n無限遠点の解説\n自明な3つ組 $(0,0,0)$ を除いた射影平面 $\\mathbb{P}_K^2$ を非自明な3つ組の同値類を体のなす集合として定義する。\n射影平面を同値類で考えることが好きな正常な人間などいるわけないが、ありがたいことにこれを幾何学的に考えることができる。\n$(x,y,z)$ の同値類\n$\\{(x,1,0)\\ |\\ x \\in K\\}$ は $y = 1$ の直線と無限遠点 $(1,0,0)$ の和として視覚化できる。\n\n和の定義\n群構造をなす証明\n\n和の定義\n楕円曲線上の点 $P, Q$ に対し、直線 $PQ$ と曲線との交点の $y$ 座標を符号反転した点を $P + Q$ とします。\n\n![[Pasted image 20220907220413.png]]\n\nこの定義を踏まえて、具体的に式を立てて計算すると $P(x_1, y_1), Q(x_2, y_2)$ として $R(x_3, y_3) = P + Q$ は次のように計算できます。ただし、$P = Q$ のときの直線 $PQ$ は曲線に対する点 $P$ の接線と考えます。\n\n$$\n\\begin{aligned}\nx_3 \u0026= \\lambda^2 - x_1 - x_2 \\\\\ny_3 \u0026= \\lambda(x_1 - x_3) - y_1 \\\\\n\\lambda \u0026=\n\\begin{dcases}\n\\frac{y_2 - y_1}{x_2 - x_1} \\quad (P \\neq Q) \\\\\n\\frac{3x_1^2 + a}{2y_1} \\quad (P = Q)\n\\end{dcases}\n\\end{aligned}\n$$\n\n## 2重周期関数\n複素平面内の格子 $L$ とは、与えられた2つの複素数 $\\omega_1, \\omega_2$ の整数係数の1次結合全体のなす集合を意味する。ただし、$\\omega_1$ と $\\omega_2$ は原点を通る同一の直線状に無いものとする。\n例えば $\\omega_1 = 1, \\omega_2 = i$ の場合、ガウス整数全体のなす格子 $\\{m + ni\\ |\\ m, n \\in \\mathbb{Z}\\}$ を得る。\n基本平行四辺形\n\n$$\n\\begin{aligned}\nL \u0026= \\{m\\omega_1 + n\\omega_2\\ |\\ m, n \\in \\mathbb{Z}\\} \\\\\n\\Pi \u0026= \\{a\\omega_1 + b\\omega_2\\ |\\ 0 \\leq a \\leq 1, 0 \\leq b \\leq 1\\} \\\\\n\\end{aligned}\n$$\n\n与えられた格子 $L$ に対し、 $\\mathbb{C}$ 上の有理型関数 $f$ はすべての $\\lambda \\in L$ について $f(z + \\lambda) = f(z)$ になるとき、 $L$ に関する楕円関数と言われる。 $\\lambda = \\omega_1$ と $\\lambda = \\omega_2$ についてこの性質を確認すれば十分であることを注意しておく。\n\n2重周期関数\n複素多様体 トーラス\n実多様体 円\n\n楕円関数の重要な例となるものを定義する。この関数はワイエルシュトラスの $\\wp$ -関数(ペー関数)と呼ばれる。\n\n$$\n\\wp(z) = \\wp(z; L) = \\frac{1}{z^2} + \\sum_{\\lambda \\in L, \\lambda \\neq 0} \\left(\\frac{1}{(z-\\lambda)^2} - \\frac{1}{\\lambda^2} \\right)\n$$\n\n\n\n$$\n\\begin{aligned}\n\\wp(z) \u0026= \\frac{1}{z^2} + \\sum_{\\lambda \\in L, \\lambda \\neq 0} \\left(\\frac{1}{(z-\\lambda)^2} - \\frac{1}{\\lambda^2} \\right) \\\\\n\u0026= \\frac{1}{z^2} + \\sum_{\\lambda \\in L, \\lambda \\neq 0} \\frac{1}{\\lambda^2}\\left(\\frac{1}{(1-z/\\lambda)^2} - 1\\right) \\\\\n\u0026= \\frac{1}{z^2} + \\sum_{\\lambda \\in L, \\lambda \\neq 0} \\frac{1}{\\lambda^2}\\sum_{k=1}^{\\infty}(k+1)\\left(-\\frac{z}{\\lambda}\\right)^k \\\\\n\u0026= \\frac{1}{z^2} + \\sum_{k=1}^{\\infty}(k+1)(-1)^k\\sum_{\\lambda \\in L, \\lambda \\neq 0} \\frac{1}{\\lambda^{k+2}}z^k \\\\\n\u0026= \\frac{1}{z^2} + \\frac{g_2}{20}z^2 + \\frac{g_3}{28}z^4 + \\mathcal{O}(z^6) \\\\\ng_2 \u0026:= 60\\sum_{\\lambda \\in L}\\frac{1}{\\lambda^4}, \\quad\ng_3 := 140\\sum_{\\lambda \\in L}\\frac{1}{\\lambda^6} \\\\\n\\end{aligned}\n$$\n\n$$\n\\begin{aligned}\n\\wp'(z) \u0026= -2\\sum_{\\lambda \\in L} \\frac{1}{(z-\\lambda)^3} \\\\\n\u0026= - \\frac{2}{z^3} + 2\\sum_{\\lambda \\in L,\\lambda\\neq0} \\frac{1}{\\lambda^3}\\sum_{k=0}^{\\infty}(2k+1)\\left(\\frac{z}{\\lambda}\\right)^k \\\\\n\u0026= 2\\sum_{k=0}^{\\infty} (2k+1)\\sum_{\\lambda \\in L,\\lambda\\neq0}\\frac{1}{\\lambda^{k+3}}z^k\n\\end{aligned}\n$$\n\n$$\n\\begin{aligned}\n\\wp(z) \u0026= \\frac{1}{z^2} + \\frac{g_2}{20}z^2 + \\frac{g_3}{28}z^4 + \\mathcal{O}(z^6) \\\\\n\\wp'(z) \u0026= -\\frac{2}{z^3} + \\frac{g_2}{10}z + \\frac{g_3}{7}z^3 + \\mathcal{O}(z^5) \\\\\n\\wp^3(z) \u0026= \\frac{1}{z^6} + \\frac{3g_2}{20}\\frac{1}{z^2} + \\frac{3g_3}{28} + \\mathcal{O}(z^2) \\\\\n\\wp'^2(z) \u0026= \\frac{4}{z^6} - \\frac{2g_2}{5}\\frac{1}{z^2} - \\frac{4g_3}{7} + \\mathcal{O}(z^2) \\\\\n\\end{aligned}\n$$\n\n![[Pasted image 20220907220319.png]]\n\n\n![[Pasted image 20220907220303.png]]\n楕円関数体\n楕円曲線\n\n## ペアリング\nweil pairing\ntate pairing\n大人数\nペアリング\n\n## 超楕円曲線\n超楕円曲線\nヤコビ多様体\n\n## 保型形式\n上半平面 $\\mathbb{H}$\n\n$$\n\\gamma(x) = \\frac{ax + b}{cx + d}\n$$\n\nの変換について不変\n\n同型写像\nSIDH\n楕円曲線暗号をそこまで理解してないので、これから学ぶ人がより先へ開拓していき、よりよい記事が出されることを期待しています。\n\n### 楕円曲線暗号とは\n\n楕円曲線暗号 (ECC) はRSA暗号と同時期に開発された暗号で1985年頃に Victor S. Miller と Neal Koblitz が同時期かつ独立に発明しました(ちなみにMiller-Rabin素数判定法のMillerはGary L. Millerで別人です)。特徴としてRSA暗号よりも純粋に強い暗号であることや同じ強度のRSA暗号と比べて鍵長が短いなどがあります。\n\n楕円曲線というのは次の関数からなる曲線のことです。\n\n$$\ny^2 = x^3 + ax + b\n$$\n\nここにグラフ\n\n楕円曲線上の点 $P, Q$ に対し、直線 $PQ$ と曲線との交点の $y$ 座標を符号反転した点を $P + Q$ とします。\n\nここに図\n\nこの定義を踏まえて、具体的に式を立てて計算すると $P(x_1, y_1), Q(x_2, y_2)$ として $R(x_3, y_3) = P + Q$ は次のように計算できます。ただし、$P = Q$ のときの直線 $PQ$ は曲線に対する点 $P$ の接線と考えます。\n\n$$\n\\begin{aligned}\nx_3 \u0026= \\lambda^2 - x_1 - x_2 \\\\\ny_3 \u0026= \\lambda(x_1 - x_3) - y_1 \\\\\n\\lambda \u0026=\n\\begin{dcases}\n\\frac{y_2 - y_1}{x_2 - x_1} \\quad (P \\neq Q) \\\\\n\\frac{3x_1^2 + a}{2y_1} \\quad (P = Q)\n\\end{dcases}\n\\end{aligned}\n$$\n\nここに具体例\n\nまた加法について群となることが証明でき結合法則 $P + (Q + R) = (P + Q) + R$ が成り立つことが証明でき、$nP = \\underbrace{P + P + \\ldots + P}_n$ と書けます。これを楕円曲線上のスカラー積と呼びます。\n\nここに具体例\n\n$8P$\n\nここに実装\n\nさて、ここでこの楕円曲線上の加法を用いた次のような問題を作れます。\n\n---\n\n楕円曲線上の点 $P, Q$ に $Q=dP$ という関係があるとき $d$ を求めよ。\n\n---\n\nつまり楕円曲線の世界で「割り算」をしなさいという問題です。\n\n実はこの問題はとても難しく、これを解く効率的なアルゴリズムは現在見つかっていません。これを楕円曲線上の離散対数問題 (ECDLP : Elliptic Curve Discrete Logarithm Problem) と呼びます。この ECDLP を利用して暗号の形にしたものが楕円曲線暗号です。\n\n具体例としては色々ありますがCTFで最もよく出るのがECDHです。\n\n#### ECDH (Elliptic curve Diffie–Hellman key exchange)\n\n暗号通信をする為に使われる暗号プロトコルです。\n\nAlice と Bob は AES などの共通鍵暗号を用いて暗号通信しようとしていますが、始めに2人だけの秘密である共有鍵が必要です。しかしそれを直接共有してしまうと、第三者から鍵を盗聴されて通信を覗き見られてしまいます。そこで暗号を用いることで鍵を直接共有することなく共有鍵を構築することができます。この手法をディフィーヘルマン鍵共有 (DH) と呼び、DH の中でも ECDLP を安全性根拠とする DH を楕円曲線ディフィーヘルマン鍵共有 (ECDH) と呼びます。\n\n具体的には次のような方法で ECDH を実現します。\n\nここに図\n\n1. AliceとBobが楕円曲線のパラメータとベースポイント $G$ を共有する。\n2. AliceとBobはそれぞれランダムな値 $d_A, d_B$ を生成し、$d_A, d_B$ を秘密鍵、$Q_A = d_AG, Q_B = d_BG$ を公開鍵として公開する。\n3. AliceとBobは自分の秘密鍵と相手の公開鍵を掛けると $S = d_Ad_BG = d_AQ_B = d_BQ_A$ となり、$S$ の $x$ 座標をハッシュ化したものが Alice と Bob のみが知る共通鍵となる。\n\nこのように攻撃者は $(G, dG)$ が分かっても ECDLP が解けない為に $d$ が分からず、安全に共通鍵を共有することができます。\n\nここに実装\n\n暗号標準を定める国際機関によって楕円曲線が\nhttps://neuromancer.sk/std/\n\n### 楕円曲線とは\n\n掴みを見れたと思うのですがよく理解するには正確な定義が必要です。\n数学的な話はあんまり\n\n射影平面上の楕円曲線\n\n射影平面で定義する理由\n\n- 無限遠点を数学的に定義できる\n- 実装時に割り算の遅延ができ高速化できる\n\n\nさてそろそろ攻撃したくてムズムズし始めたんじゃないでしょうか？ではやっていきましょう！\n\n### 攻撃手法\n\nこの ECDLP を解くことができれば ECDH を含め、様々な楕円曲線暗号を解くことができます。さて主に攻撃対象となる楕円曲線暗号は以下のようなものがあります。\n\n1. 現在見つかっている最も高速なアルゴリズムで ECDLP を解く。計算量は $O(\\sqrt{\\#E/\\mathbb{F}_p})$ となる。\n2. $\\#E/\\mathbb{F}_p = p_1^{e_1}p_2^{e_2}\\ldots p_k^{e_k}$ (位数が Smooth number なとき) ならば位数 $p_i$ の小さな ECDLP に分解できる。それぞれ計算量は $O(\\sqrt{p_i})$ である。\n3. $\\#E/\\mathbb{F}_p = p$ (Anomalous なとき) ならば $\\mathbb{F}_p^+$ 上の DLP に帰着できる。\n4. $\\#E/\\mathbb{F}_p = p+1$ (Supersingular なとき) ならば埋め込み次数 $k$ を用いて $\\mathbb{F}_{p^k}^\\times$ 上の DLP に帰着できる。実践上 $k$ はそこまで大きくならない。\n5. $\\Delta(E/\\mathbb{F}_p) = 0$ (Singular なとき) ならば $\\mathbb{F}_p^+$ や $\\mathbb{F}_p^\\times, \\mathbb{F}_{p^2}^\\times$ 上の DLP に帰着できる。\n6. 楕円曲線上に存在しない点や位数の少ない点を指定できるならば秘密鍵の情報を取り出すことができる。\n\nそれぞれ\n\n### 1. ECDLP\n\n### 2. Polig-Hellman Attack\n\n### 3. MOV/FR Reduction\nMOV Reduction (Menezes-Okamoto-Vanstone Reduction)\nWeil-pairing\nFR Reduction (Frey-Rück Reduction)\nTate-pairing\n\nTate-pairing, Bilinear-pairingのいい資料がみつからない\n\n### 4. SSSA Attack / Supersingularな曲線を用いてはいけない\n$E/\\mathbb{F}_q, \\gcd(t, q) \u003e 1$ 埋め込み次数 $k\\leq6$ 全埋込み次数は既知\n$E[p]  \\mathbb{Z}/p\\mathbb{Z}$\n$\\pi:\\mathbb{P}^2(\\mathbb{Q}_p) \\to \\mathbb{P}^2(\\mathbb{F}_p)$\n$\\phi:\\ker\\pi \\to \\mathcal{E}(p\\mathbb{Z}_p)$\n\n\n### 5. Singularな曲線を用いてはいけない\n\nSingular な楕円曲線の場合、特異点が存在し、特異点には尖点 (cusp) 、節点 (node) の2種類がある。$c_4 = 0$ と尖点は同値である。\n\n$y = 0$ 上の特異点が原点 $O(0, 0)$ となるように平行移動させる。すると任意の Singular な楕円曲線は $y^2 = x^3 + kx^2$ の形となる。\n\n$$\n\\begin{aligned}\n\\begin{dcases}\nE(\\mathbb{F}_p) \\rightarrow \\mathbb{F}_p^+: (x,y)↦\\frac{x}{y},\u0026∞↦0 \u0026 (cuspのとき)\\\\\nE(\\mathbb{F}_p) \\rightarrow \\mathbb{F}_p^\\times: (x,y)↦\\frac{y + \\sqrt{k}x}{y - \\sqrt{k}x},\u0026∞↦1 \u0026 (nodeのとき) \\\\\n\\end{dcases}\n\\end{aligned}\n$$\n\n↑これはなぜ？\n\n### 6. Invalid Curve Attack\n\n\n### Weil decsent\n### ECFFT\n\n\nより面白い話題として楕円曲線暗号にバックドアが仕込まれていたという事件がある。\n- Dual EC DRBG\n\n構成\n- SIDH SIKE\n- ECDH\n- CSIDH\n\nhttps://blog.z.cash/new-snark-curve/ :  BLS12-381: New zk-SNARK Elliptic Curve Construction\nunefficient key recovery\n\nDiffie Hellman\nE/P/Q = E/Q/P\nECDDH\nE/P E/Q -\u003e E/PQ\n\nCall Stack Graph\nエラーが起きたところをいい感じにたどれる\n","lastmodified":"2022-12-30T07:57:21.463263852Z","tags":null},"/crypto/ECC/ECFFT":{"title":"ECFFT","content":"\n[ECFFT1.pdf (toronto.edu)](https://www.math.toronto.edu/swastik/ECFFT1.pdf)","lastmodified":"2022-12-30T07:57:21.463263852Z","tags":null},"/crypto/ECC/GHS-Attack":{"title":"GHS Attack","content":"Weil descent 攻撃とも呼ばれる","lastmodified":"2022-12-30T07:57:21.463263852Z","tags":null},"/crypto/ECC/Invalid-Curve-Attack":{"title":"Invalid Curve Attack","content":"\n## 説明\n\nざっくり言うと楕円曲線上に点が乗っていないときに位数が低くなることを利用する攻撃です。\n\n適当に選んだ数は小さな素数で割れやすい\nのと同じように\n\n\n[Google CTF Tiramisu write up (zenn.dev)](https://zenn.dev/kurenaif/articles/9cf509d9a15815)","lastmodified":"2022-12-30T07:57:21.463263852Z","tags":null},"/crypto/ECC/MOV-FR-Reduction":{"title":"MOV/FR Reduction","content":"\n## MOV Reduction\n$R=dP$ となるECDLPを解く\n\nWeil pairing $e_n: E[n]\\times E[n]\\to \\mu_n\\subseteq \\mathbb{F}_{p^k}^*$\n\n1. $E[n]\\subseteq E(\\mathbb{F}_{p^k})$ となる最小の $k$ を持ってくる\n2. 位数 $n$ の $\\alpha=e_n(P, Q)$ となるように $Q \\in E[n]$ を取ってくる\n3. $\\beta = e_n(dP, Q)$\n4. $\\mathbb{F}_{p^k}^*$ 上のDLPを $\\alpha, \\beta$ を用いて解く\n\n$k$ は多くとも6まで\n$E(\\mathbb{F}_{p^k}^*)\\cong\\mathbb{Z}_{c_1n_1}\\oplus\\mathbb{Z}_{c_2n_1}$\n\n","lastmodified":"2022-12-30T07:57:21.463263852Z","tags":null},"/crypto/ECC/Millar":{"title":"Millar","content":"","lastmodified":"2022-12-30T07:57:21.463263852Z","tags":null},"/crypto/ECC/Pohlig-Hellman":{"title":"Pohlig-Hellman Attack","content":"\n## 説明\n\n中国剰余定理を用いて大きな群を複数の小さな群の直積に分ける。\n\n楕円曲線暗号の楕円曲線の位数は細かく素因数分解できることが多い。\n\n楕円曲線の位数 $\\#E = p_1^{e_1}p_2^{e_2}\\ldots p_k^{e_k}$ と素因数分解できる。$Q = dP$ となるとき次のように $d_i$ を置く。\n\n$$\n\\begin{aligned}\nd_1 \u0026= d \\pmod{p_1^{e_1}} \\\\\nd_2 \u0026= d \\pmod{p_2^{e_2}} \\\\\n\u0026\\vdots \\\\\nd_k \u0026= d \\pmod{p_k^{e_k}} \\\\\n\\end{aligned}\n$$\n\nそれぞれの $d_i$ について次のように書ける。\n\n$$\nd_i=z_0+z_1p_i+z_2p_i^2+\\ldots+z_{e_i−1}p_i^{e_i−1} \\pmod{p_i^{e_i}} \\quad (∀k:z_k \\in [0,p_i))\n$$\n\nここで $P_{i,j}=\\frac{\\#E}{p_i^j}P, Q_i=\\frac{\\#E}{p_i^j}Q$ とおくと\n\n$$\nQ_{i,1} = d_{i,1}P_{i,1} = (z_0+z_1p_i+z_2p_i^2+\\ldots+z_{e_i−1}p_i^{e_i−1})P_{i,1} = z_0P_i\n$$\n\nとなり, $z_0 \u003c p_i$ である $Q_i = z_0P_i$ についてDLPを解けば良い。\n\n他については $Q_i' = (Q_i - z_0P_i) / p_i$ とおいて同様に解けると思っていたけど除算は ECC の DDH 問題から不可能っぽいので $p_i^{e_i}$ 全探索するしかないかも。\n\n## 実装\n\n```python\nfact = factor(G.order())\nord = int(G.order())\ndlogs = []\nfor p, e in fact:\n    t = ord // p ^ e\n    dlog = discrete_log(t * Q, t * G, operation=\"+\")\n    dlogs += [dlog]\n\nprint(crt(dlogs, primes))\n```\n\n## 使用例\n\n## 参考\n","lastmodified":"2022-12-30T07:57:21.467263831Z","tags":null},"/crypto/ECC/SIKE":{"title":"Attacks on SIKE","content":"\n[Attacks on SIDH/SIKE | ellipticnews (wordpress.com)](https://ellipticnews.wordpress.com/2022/08/12/attacks-on-sidh-sike/)\n[jack4818/Castryck-Decru-SageMath: A SageMath implementation of the Castryck-Decru Key Recovery attack on SIDH (github.com)](https://github.com/jack4818/Castryck-Decru-SageMath)","lastmodified":"2022-12-30T07:57:21.467263831Z","tags":null},"/crypto/ECC/SSSA-Attack":{"title":"SSSA Attack","content":"\n## 説明\n$$\n\\newcommand{\\calO}{\\mathcal{O}}\n\\newcommand{\\FF}{\\mathbb{F}}\n\\newcommand{\\tE}{\\tilde{E}}\n\\newcommand{\\ZZ}{\\mathbb{Z}}\n\\newcommand{\\QQ}{\\mathbb{Q}}\n\\DeclareMathOperator{\\Ker}{Ker}\n\\DeclareMathOperator{\\ord}{ord}\n$$\n## Definition\n- $\\FF_p$\n    - 素数$p$に対して$p$個の元からなる有限体\n    - 素数$p$の剰余群\n    - $\\mathbb{Z}/p\\mathbb{Z}$\n- $\\mathbb{Q}_p$\n    - p進数体\n    - $27=2.5+2.25 + 27.125 + O(5^4)$ 射影極限による導入\n    - $27 = 2 + 5^2 + O(5^3)$ p進展開による導入\n    - $\\mathbb{Q}$のp進付値による完備化をする導入\n    - $n\\times 100 = n.10^{-2}$\n- $\\mathbb{Z}_p$\n    - p進整数環\n    - $Q_p$の整数部分\n    - 論文にも注釈があるが$\\mathbb{Z}/n\\mathbb{Z}$の略記$\\mathbb{Z}_n$とは別物\n- $\\mathbb{Z}\\text{-algebra}$に対する$\\mathbb{P}^n(R)$\n    - $\\mathbb{Z}$から$R$への凖同型がある\n    - 雪江代数学2巻 Def. 1.3.13 (p.15)の定義\n      + $k, A$を環とする.　$k$から$A$への準同型があるとき, $A$を$k$代数, あるいは$k$上の代数という.\n- $\\calO=(0 : 1 : 0)$で楕円曲線の群演算に関する単位元\n- 持ち上げ\n    - 準同型の移動\n- Rが体のとき$E(R)$は群であることは受け入れる\n- $\\mathscr{L}$は同型写像\n\n$\\mathbb{Q}_p$, $\\mathbb{Z}_p$ はそれぞれp進体、p進整数環とする。\n\n次の同型写像 $\\lambda_E$ を用いて楕円曲線 $\\tilde{E}(\\mathbb{F}_p)$ 上が $\\mathbb{F}_p$ 上の DLP、つまり $\\bmod p$ の割り算に帰結する。\n\n$$\n\\lambda_E \\colon \\tilde{E}(\\mathbb{F}_p) \\overset{u}{\\to} E(\\mathbb{Q}_p)\\xrightarrow{p倍}\\ker\\pi \\xrightarrow{\\mathscr{L}} p\\mathbb{Z}_p\\xrightarrow{\\bmod p^2}p\\mathbb{Z}_p/p^2 \\mathbb{Z}_p\\simeq \\mathbb{F}_p\n$$\n\n\n\n## 参考\n\n[Fermat Quotient と Anomalous 楕円曲線の離散対数の多項式時間解法アルゴリズムについて(代数的整数論とその周辺)](https://repository.kulib.kyoto-u.ac.jp/dspace/bitstream/2433/61761/1/1026-15.pdf)\n","lastmodified":"2022-12-30T07:57:21.467263831Z","tags":null},"/crypto/ECC/Schoof":{"title":"Schoof Algorithm","content":"\nHasse-Weil 定理より\n\n$$\nq+1-2\\sqrt{q}\\leq|E(\\mathbb{F}_q)|\\leq q+1+2\\sqrt{q}\n$$\n\n$|E(\\mathbb{F}_q)|=q+1+t$ とおける。$\\mathbb{F}_q$ のフロベニウス写像 $\\sigma$ のトレース $t$ を計算できれば位数が求まる。しかし $t$ は $2\\sqrt{q}$ のオーダーであるため、直接計算できない。そこで素数 $l$ を剰余にとってそれぞれの $t$ の値を求め、中国剰余定理によって $t$ を求める。\n\n具体的には特性多項式の $t$ に $0,\\ldots,\\frac{l-1}{2}$ の値を代入して確かめる。\n\n$$\n\\begin{aligned}\n\\sigma_q^2-t\\sigma_q+q \u0026= 0 \\\\\n\\pm[t_l]\\circ\\sigma_q \u0026= \\sigma_q^2+[q_l]\n\\end{aligned}\n$$\n\n1つの $l$ 等分点 $P$ に対して成り立てばすべての $l$ 等分点に対して成り立つ。\n","lastmodified":"2022-12-30T07:57:21.467263831Z","tags":null},"/crypto/Hash/DifferencialCryptoanalysis":{"title":"Differencial cryptoanalysis","content":"\n\nhttps://github.com/aappleby/smhasher/wiki/MurmurHash2Flaw\n\nDifferencial cryptanalysis\nこれはハッシュ関数の実装に踏み込む手法である. スケッチとしては何かしらのパラメータが同じなどの特殊な場合のとき, 簡約化ができ, 単純な算術演算による条件式をいくつか生成できる. これを SMT で解くらしい.\n","lastmodified":"2022-12-30T07:57:21.467263831Z","tags":null},"/crypto/Hash/hash":{"title":"ハッシュ関数","content":"\n## 説明\n\n- 原像計算困難性 与えられた $h$ に対して $H(m) = h$ となる $m$ を見つけることが困難である．\n- 第二原像計算困難性 $m1$ が与えられたときに $H(m1) = H(m2)$ となる $m2(̸= m1)$ を求めるのが困難である．\n- 衝突困難性 相異なる $m1$ と $m2$ で，$H(m1) = H(m2)$ となるメッセージを見つけることが困難である．\n\nHMAC (Hash-based MAC)\n\n伸長攻撃\n- Merkle-Damgård construction","lastmodified":"2022-12-30T07:57:21.467263831Z","tags":null},"/crypto/Lattice/BKZ":{"title":"BKZ(Block Korkine-Zolotareff) 基底簡約","content":"\n## 説明\n\nHKZ(Hermite-Korkine-Zolotareff) 基底簡約\n\n1. サイズ基底簡約\n2. 条件に合うように基底ベクトルの交換\n\n## 計算量\n\n\n## 実装\n\n\n## 使用例\n\n## 参考\n","lastmodified":"2022-12-30T07:57:21.471263809Z","tags":null},"/crypto/Lattice/GSO":{"title":"Gram-Schmidt 直交化","content":"\n## 説明\n\nGram-Schmidt 直交化 (GSO; Gram-Schmidt Orthonormalization) とは実 $m$ 次元ベクトル空間 $\\mathbb{R}^m$ の任意の $\\mathbb{R}$ ベクトル空間としての基底を直交基底に変換する方法です. $\\mathbf{b} _ n$ の直交化は $\\mathbf{b} _ {1},\\ldots, \\mathbf{b} _ {n-1}$ すべてと直交するように元の高さのまま移動させます. [GSOのWikipedia](https://ja.wikipedia.org/wiki/%E3%82%B0%E3%83%A9%E3%83%A0%E3%83%BB%E3%82%B7%E3%83%A5%E3%83%9F%E3%83%83%E3%83%88%E3%81%AE%E6%AD%A3%E8%A6%8F%E7%9B%B4%E4%BA%A4%E5%8C%96%E6%B3%95) のgifがわかりやすいです.\n\n![[400px-Gram-Schmidt_orthonormalization_process.gif]]\n\n**Definition 1** (GSOベクトル)\n$n$ 次元格子 $L\\subseteq \\mathbb{R}^m$ の順序付き基底 $\\{\\mathbf{b} _ {1},\\ldots, \\mathbf{b} _ {n}\\}$ に対するGSOベクトル $\\mathbf{b} _ {1}^* ,\\ldots, \\mathbf{b} _ {n}^ *\\in\\mathbb{R}^m$ を次のように定義する. また $\\mu _ {i,j}$ をGSO係数と呼ぶ.\n\n$$\n\\begin{aligned}\n\u0026\\begin{dcases}\n\\mathbf{b} _ 1^* := \\mathbf{b} _ 1 \\\\\n\\mathbf{b} _ i^ * := \\mathbf{b} _ i - \\sum _ {j=1}^{i-1} \\mu _ {i, j} \\mathbf{b} _ j^ * \u0026 (2\\leq i\\leq n) \\\\\n\\end{dcases} \\\\\n\u0026\\quad\\mu _ {i, j} := \\frac{\\langle \\mathbf{b} _ i, \\mathbf{b}_j^ * \\rangle}{\\| \\mathbf{b} _ j^ * \\|^2} \\qquad (1\\leq j\u003ci\\leq n)\n\\end{aligned}\n$$\n\n行列を用いて表現すると次のように(要詳細) $B, B^* , U$ を定義したとき $B = UB^ *$ が成り立つと書ける.\n\n$$\n\\begin{aligned}\nB \u0026=\n\\begin{pmatrix}\n\\mathbf{b} _ 1 \\\\\n\\vdots \\\\\n\\mathbf{b} _ n \\\\\n\\end{pmatrix}\n\u0026 B^* \u0026=\n\\begin{pmatrix}\n\\mathbf{b} _ 1^ * \\\\\n\\vdots \\\\\n\\mathbf{b} _ n^ * \\\\\n\\end{pmatrix}\n\u0026 U \u0026=\n\\begin{pmatrix}\n1 \u0026 0 \u0026 0 \u0026 \\cdots \u0026 0 \\\\\n\\mu _ {2,1} \u0026 1 \u0026 0 \u0026 \\cdots \u0026 0 \\\\\n\\mu _ {3,1} \u0026 \\mu_{3,2} \u0026 1 \u0026 \\cdots \u0026 0 \\\\\n\\vdots \u0026 \\vdots \u0026 \\vdots \u0026 \\ddots \u0026 \\vdots \\\\\n\\mu _ {n,1} \u0026 \\mu _ {n,2} \u0026 \\mu _ {n,3} \u0026 \\cdots \u0026 1 \\\\\n\\end{pmatrix}\n\\end{aligned}\n$$\n\n**Theorem 2** (GSOベクトルの基本性質)\n1. 任意の $1\\leq i\u003cj\\leq n$ に対して $\\langle\\mathbf{b}_ i^* , \\mathbf{b} _j^ *\\rangle = 0$ が成り立つ.\n2. 任意の $1\\leq i\\leq n$ に対して $\\|\\mathbf{b}_ i^ * \\|\\leq\\|\\mathbf{b} _i\\|$ が成り立つ.\n3. 任意の $1\\leq i\\leq n$ に対して $\\langle\\mathbf{b} _ 1^* ,\\ldots,\\mathbf{b} _ i^ *\\rangle_{\\mathbb{R}} = \\langle\\mathbf{b} _ 1,\\ldots,\\mathbf{b} _ i\\rangle _ {\\mathbb{R}}$ が成り立つ.\n4. $\\mathrm{vol}(L) = \\prod _ {i=1}^n\\|\\mathbf{b} _ i^*\\|$ が成り立つ.\n\n**Proof.**\n1. $j$ に関する数学的帰納法により示す. $j=1$ のときは証明すべきことはない. $1,\\ldots,j$ について成立していると仮定する. $j+1$ のとき任意の $1\\leq i\u003cj+1$ に対して\n$$\n\\begin{aligned}\n\\langle\\mathbf{b} _ i^ * , \\mathbf{b} _ {j+1}^ * \\rangle \u0026= \\left\\langle\\mathbf{b} _ i^ * , \\mathbf{b} _ {j+1} - \\sum _ {k=1}^j\\mu _ {j+1, k}\\mathbf{b} _ {k}^ * \\right\\rangle \\\\\n\u0026= \\langle\\mathbf{b} _ i^ * , \\mathbf{b} _ {j+1}\\rangle - \\mu _ {j+1,i}\\langle\\mathbf{b} _ i^ * , \\mathbf{b} _ {i}^ * \\rangle \\\\\n\u0026= \\langle\\mathbf{b} _ i^ * , \\mathbf{b} _ {j+1}\\rangle - \\frac{\\langle \\mathbf{b} _ {j+1}, \\mathbf{b} _ i^ * \\rangle}{\\| \\mathbf{b} _ i^ * \\|^2}\\|\\mathbf{b} _ i^ * \\|^2 \\\\\n\u0026= 0\n\\end{aligned}\n$$\nが成り立つ. よって, 数学的帰納法より任意の $1\\leq i\u003cj\\leq n$ に対して $\\langle\\mathbf{b} _ i^ * , \\mathbf{b} _ j^ * \\rangle = 0$ が成り立つ.\n\n2. $i=1$ のとき $\\mathbf{b} _ 1^* = \\mathbf{b} _ 1$ より明らか. $i\\geq 2$ のとき\n$$\n\\|\\mathbf{b}_ i\\|^2 = \\|\\mathbf{b} _ i^ * \\|^2 + \\sum_{j=1}^{i-1}\\mu _ {i,j}^2\\|\\mathbf{b}_j^ * \\|^2\\geq\\|\\mathbf{b} _ i^ * \\|^2\n$$\nより成り立つ.\n\n3. 任意の $1\\leq k\\leq i$ に対し, $\\mathbf{b} _ k = \\mathbf{b} _ k^* + \\sum _ {j=1}^{k-1} \\mu _ {k, j}\\mathbf{b} _ j^ *$ より, $\\mathbf{b} _ k\\in\\langle\\mathbf{b} _ 1^ * ,\\ldots,\\mathbf{b} _ i^ * \\rangle _ {\\mathbb{R}}$ がわかる. よって $\\langle\\mathbf{b} _ 1,\\ldots,\\mathbf{b} _ i\\rangle _ {\\mathbb{R}}\\subseteq\\langle\\mathbf{b} _ 1^ * ,\\ldots,\\mathbf{b} _ i^ * \\rangle _ {\\mathbb{R}}$ が成り立つ. 逆向きの包含関係は $i$ に関する数学的帰納法で示す. $i = 1$ のとき $\\mathbf{b} _ 1^ * = \\mathbf{b} _ 1$ より明らか. $i=k-1$ のとき成り立つと仮定すると $i=k$ のとき $\\mathbf{b} _ k^ * = \\mathbf{b} _ k - \\sum _ {j=1}^{k-1} \\mu _ {k, j}\\mathbf{b} _ j^ *$ より $\\mathbf{b} _ k^ * \\in\\langle\\mathbf{b} _ 1,\\ldots,\\mathbf{b} _ i\\rangle _ {\\mathbb{R}}$ , よって任意の $i$ について示された. よって $\\langle\\mathbf{b} _ 1^ * ,\\ldots,\\mathbf{b} _ i^ * \\rangle _ {\\mathbb{R}}=\\langle\\mathbf{b} _ 1,\\ldots,\\mathbf{b} _ i\\rangle _ {\\mathbb{R}}$ である.\n\n4. $B=UB^*$ と $\\det(U) = 1$, GSOベクトルの直交性より\n$$\n\\begin{aligned}\n\\mathrm{vol}(L)^2 \u0026= \\det(BB^\\top) \\\\\n\u0026= \\det(UB^ * (B^ * )^\\top U^\\top) \\\\\n\u0026= \\det(B^ * (B^ * )^\\top) \\\\\n\u0026= \\prod _ {i=1}^n\\|\\mathbf{b} _ i^ * \\|^2\n\\end{aligned}\n$$\n\n**Theorem 3** (Hadamardの不等式)\nGSOベクトルの基本性質 2, 4 より次のことが分かる.\n\n$$\n\\mathrm{vol}(L)\\leq\\prod _ {i=1}^n\\|\\mathbf{b} _ i\\|\n$$\n\nつまり, $\\{\\mathbf{b} _ {1},\\ldots, \\mathbf{b} _ {n}\\}$ が直交基底$\\iff\\mathrm{vol}(L)=\\prod _ {i=1}^n\\|\\mathbf{b} _ i\\|$ である.\n\n**Definition 4** (射影格子)\n$n$ 次元格子 $L\\subseteq\\mathbb{R}^m$ の基底 $\\{\\mathbf{b} _ {1},\\ldots, \\mathbf{b} _ {n}\\}$ に対し, 各 $1\\leq l\\leq n$ に対して $\\langle\\mathbf{b} _ {1},\\ldots, \\mathbf{b} _ {l-1}\\rangle _ \\mathbb{R}$ の直交補空間への直交射影を $\\pi _ l:\\mathbb{R}^m\\to\\langle\\mathbf{b} _ {1},\\ldots, \\mathbf{b} _ {l-1}\\rangle _ \\mathbb{R}^\\bot$ とする. 定理 2 の 1,3 より\n\n$$\n\\begin{aligned}\n\\langle\\mathbf{b} _ {1},\\ldots, \\mathbf{b} _ {l-1}\\rangle _ \\mathbb{R}^\\bot \u0026= \\langle\\mathbf{b} _ {1}^ * ,\\ldots, \\mathbf{b} _ {l-1}^ * \\rangle _ \\mathbb{R}^\\bot = \\langle\\mathbf{b} _ {l}^ * ,\\ldots, \\mathbf{b} _ {n}^ * \\rangle _ \\mathbb{R} \\\\\n\\pi _ l(\\mathbf{b}_i) \u0026= \\sum _ {j=l}^i\\mu _ {i,j}\\mathbf{b} _ j^ * \\\\\n\\end{aligned}\n$$\n\nとなる. すると集合 $\\pi _ l(L)$ は $\\{\\pi _ l(\\mathbf{b} _ {l}),\\ldots,\\pi _ l(\\mathbf{b} _ {n})\\}$ を基底に持つ $n-l+1$ 次元の格子であり, $\\pi _ l(L)$ を射影格子 (projected lattice) と呼ぶ.\n\n## 計算量\n$O(N^3)$\n\n## 実装\n\n```python\ndef gram_schmidt():\n```\n\n## 使用例\n\n## 参考\n- 格子暗号解読のための数学的基礎 ー格子基底簡約アルゴリズム入門ー\n","lastmodified":"2022-12-30T07:57:21.471263809Z","tags":null},"/crypto/Lattice/LLL":{"title":"LLL 基底簡約","content":"\n## 説明\n\n$n$ 次元格子 $L$ の基底 $\\lbrace\\mathbf{b_1},\\ldots,\\mathbf{b_n}\\rbrace$ について以下の条件を満たすとき、その基底は LLL 簡約されている (Lenstra-Lenstra-Lovasz(LLL)-reduced)と呼ぶ。\n\n1. 基底 $\\lbrace\\mathbf{b_1},\\ldots,\\mathbf{b_n}\\rbrace$ がサイズ簡約されている。\n2. Lovasz条件: 任意の $2 \\leq k \\leq n$ に対して $\\delta\\|\\mathbf{b}_{k-1}^*\\| \\leq \\|\\pi_{k-1}(\\mathbf{b}_{k-1})\\|$ を満たす。ただし、各 $1 \\leq l \\leq n$ に対して、$\\pi_l$ は $\\mathbb{R}$-ベクトル空間 $\\langle\\mathbf{b} _1,\\ldots,\\mathbf{b} _{l-1}\\rangle _\\mathbb{R}$ の直交補空間への直交射影とする。\n\nこれに対し、LLL 基底簡約アルゴリズムは次のように行う。\n\n1. サイズ簡約する。\n2. Lovasz条件を満たすように隣り合う基底ベクトルを交換する。\n\n基底ベクトルを交換した際に GSO ベクトルも更新しなければならない。高速化出来る。\n\nさらに LLL について精度を上げたり、機能を拡張することができ、DeepLLLやMLLLなどの手法がある。\n\n- LLL は隣り合う基底ベクトルのみを比較するが、DeepLLL は全ての基底ベクトルを比較する。\n- MLLL は一次従属なベクトルでも適用できる。\n\n## 計算量\n\n\n## 実装\n\n```\ndef LLL(B, delta):\n    n = len(B)\n    assert 1 / 4 \u003c delta \u003c 1\n    B = matrix(B)\n    i = 1\n    G, mu = B.gram_schmidt()\n    while i \u003c n:\n        for j in range(i - 1, -1, -1):\n            print(i, j)\n            if mu[i][j].abs() \u003e 1 / 2:\n                q = mu[i][j].round()\n                B[i] -= q * B[j]\n                mu[i] -= q * mu[j]\n        if B[i].norm() \u003e= (delta - mu[i][i - 1] ^ 2) * B[i - 1].norm():\n            i += 1\n        else:\n            B[i - 1], B[i] = B[i], B[i - 1]\n            mu = GSOUpdate(B, mu, i)\n            i = max(i - 1, 1)\n    return B\n\n\ndef GSOUpdate(B, mu, i):\n    n = B.nrows()\n    nu = mu[i][i - 1]\n    b = B[i] + nu ^ 2 * B[i - 1]\n    print(nu, B[i - 1], b)\n    mu[i][i - 1] = nu * B[i - 1] / b\n    B[i] = B[i] * B[i - 1] / b\n    B[i - 1] = b\n    for j in range(i - 1):\n        mu[i - 1][j], mu[i][j] = mu[i][j], mu[i - 1][j]\n    for k in range(i + 1, n):\n        t = mu[k][i]\n        mu[k][i] = mu[k][i - 1] - nu * t\n        mu[k][i - 1] = t + mu[i][i - 1] * mu[k][i]\n    return mu\n```\n\n## 使用例\n\n```python\nB = [vector([5, -3, -7]), vector([2, -7, -7]), vector([3, -10, 0])]\nprint(LLL(B, 0.8))\n```\n\n## 参考\n\n","lastmodified":"2022-12-30T07:57:21.471263809Z","tags":null},"/crypto/Lattice/Lagrange":{"title":"Lagrange 基底簡約 (Gauss 基底簡約)","content":"\n## 説明\n\nLagrange 基底簡約アルゴリズムは2次元格子上の SVP を解く効率的なアルゴリズムである.\n\n**Definition 1** (Lagrange 簡約)\n任意の $q \\in \\mathbb{Z}$ に対して $\\|\\mathbf{b}_1\\| \\leq \\|\\mathbf{b}_2\\| \\leq \\|\\mathbf{b}_1 + q\\mathbf{b}_2\\|$ を満たすとき, 2次元格子の基底 $\\{\\mathbf{b}_1, \\mathbf{b}_2\\}$ は Lagrange 簡約されているという.\n\n**Theorem 2** (Lagrange 簡約によって逐次最小基底)\n2次元格子の基底 $\\{\\mathbf{b}_1, \\mathbf{b}_2\\}$ について次の2つは同値である.\n1. 基底 $\\{\\mathbf{b}_1, \\mathbf{b}_2\\}$ は Lagrange 簡約されている.\n2. 基底 $\\{\\mathbf{b}_1, \\mathbf{b}_2\\}$ は格子 $L$ の逐次最小基底である.\n\n**Proof.**\n($\\implies$)\n任意の非零ベクトル $\\mathbf{v} = x _ 1\\mathbf{b} _ 1 + x _ 2\\mathbf{b} _ 2 \\in L$ について $x _ 2 = 0$ のとき $\\|\\mathbf{v}\\| = |x _ 1|\\|\\mathbf{b} _ 1\\| \\geq \\|\\mathbf{b} _ 1\\|$, $x _ 2 \\neq 0$ のとき $\\|\\mathbf{v}\\| \\geq \\|\\mathbf{b} _ 2\\| \\geq \\|\\mathbf{b} _ 1\\|$ を示す.\n\n$$\n\\begin{aligned}\n\\|\\mathbf{v}\\| \u0026= \\|x _ 1\\mathbf{b} _ 1 + x _ 2\\mathbf{b} _ 2\\| \\\\\n\u0026= \\|r\\mathbf{b} _ 1 + x _ 2(\\mathbf{b} _ 2 + q\\mathbf{b} _ 1)\\| \\\\\n\u0026\\geq x _ 2\\|\\mathbf{b} _ 2 + q\\mathbf{b} _ 1\\| - r\\|\\mathbf{b} _ 1\\| \\\\\n\u0026= (x _ 2 - r)\\|\\mathbf{b} _ 2 + q\\mathbf{b} _ 1\\| + r(\\|\\mathbf{b} _ 2 + q\\mathbf{b} _ 1\\| - \\|\\mathbf{b} _ 1\\|) \\\\\n\u0026\\geq \\|\\mathbf{b} _ 2 + q\\mathbf{b} _ 1\\| \\\\\n\u0026\\geq \\|\\mathbf{b} _ 2\\| \\geq \\|\\mathbf{b} _ 1\\|\n\\end{aligned}\n$$\n\nEuclidの互除法を2次元格子に対して行うことで Lagrange 簡約されているような基底を生み出せる。\n\n## 計算量\n\n$O(\\log{N})$\n\n## 実装\n\n```python\ndef lagrange(b1, b2):\n    if b1.norm() \u003e b2.norm():\n        b1, b2 = b2, b1\n    while b1.norm() \u003c b2.norm():\n        q = - round(b1.dot_product(b2) / b1.norm() ^ 2)\n        b1, b2 = b2 + q * b1, b1\n    return b2, b1\n```\n\n## 使用例\n\n## 参考\n","lastmodified":"2022-12-30T07:57:21.471263809Z","tags":null},"/crypto/Lattice/Lattice":{"title":"格子","content":"\n## 説明\n\n### 格子 (Lattice)\n\n図でイメージ掴むのが速い\n\n線形独立な $n$ 個のベクトル $\\mathbf{b}_1, \\mathbf{b}_2, \\ldots , \\mathbf{b}_n \\in \\mathbb{R}^m$ について整数係数の線形結合によって生成されるベクトルの集合を格子 $L$ と定義します。\n\n$$\nL = \\left\\{ \\sum_{i=0}^{n} a_i\\mathbf{b}_i \\ \\middle| \\ a_i \\in \\mathbb{Z} \\right\\}\n$$\n\n### Shortest Vector Problem(SVP)\n\n格子上の非零なベクトルの中で最もノルムが小さなベクトルを見つけ出す問題です。\nそのベクトルを $\\mathbf{v}$ とおくと次のように表せられます。\n\n$$\n\\mathbf{v} = v_1\\mathbf{b}_1 + \\ldots + v_n\\mathbf{b}_n \\qquad (\\exists v_1, \\ldots , v_n \\in \\mathbb{Z}) \\\\\n$$\n\nこの問題はNP困難\n\n逐次最小\n\n$$\n\\lambda _ i(L) := \\min\\limits _ {\\mathbf{b} _ 1,\\ldots,\\mathbf{b} _ i\\in L}\\max\\{\\|\\mathbf{b} _ 1\\|,\\ldots,\\|\\mathbf{b} _ i\\|\\}\n$$\n\n### 最短ベクトルの数え上げ\n\nまずは全探索してみます。\n考えてみると帰納的に求めるのでは正確な最短ベクトルは求められないでしょう。\n考えてみるとある基底 $\\mathbf{b}_i$ に対し、それ以下の基底 $\\mathbf{b}_1, \\ldots \\mathbf{b}_{i-1}$ で組み立てられたベクトル $\\mathbf{v}$ に対し、$\\mathbf{b}_i$ を用いて短くする\n\n効率的に数え上げる為には基底簡約すると良いということが知られています。\n\n\n## 使用例\n\n## 参考\n\n\n","lastmodified":"2022-12-30T07:57:21.471263809Z","tags":null},"/crypto/Lattice/NTRU":{"title":"NTRU 暗号","content":"\nNTRU (N-th Degree Truncated Polynomial Ring)\n\n$f: \\mathbb{Z}_p[x]/(x^n-1) \\to \\mathbb{Z}_q[x]/(x^n-1)$\n\n$$\nF = \\sum_{i=0}^nF_ix^i\n$$\n\n平文 $M\\in\\mathbb{Z}_p[x]/I$ とする, 乱数 $R\\in\\mathcal{L}(d_R, d_R)$ を\n$$\nC = pHR + M \\pmod q \\pmod I\n$$\n暗号文 $C$ 秘密鍵 $F$ によって $A$ を求め, $\\mathbb{Z} _ p[x]/I$ における逆元 $F _ p^{-1}$ によって復号文 $M'$ を求める.\n$$\n\\begin{aligned}\nA \u0026= CF\\pmod q\\pmod I \\\\\nM' \u0026= AF_p^{-1} \\pmod p\\pmod I\n\\end{aligned}\n$$\n","lastmodified":"2022-12-30T07:57:21.471263809Z","tags":null},"/crypto/Lattice/TFHE":{"title":"TFHE (Torus Fully Homomorphic Encryption)","content":"\n## 説明\n\n完全準同型暗号の1つ\n\n完全なる Zero Trust なサーバーを作れる。\n\n## 参考\n\n- [セキュキャンの資料](https://nindanaoto.github.io/)\n","lastmodified":"2022-12-30T07:57:21.471263809Z","tags":null},"/crypto/Lattice/size_reduction":{"title":"サイズ基底簡約","content":"\n## 説明\n\n$n$ 次元格子 $L$ の基底 $\\\\{\\mathbf{b_1},\\ldots,\\mathbf{b_n}\\\\}$ を GSO 係数 $\\mu_{i,j}$ が\n\n$$\n|\\mu_{i,j}| \\leq \\frac{1}{2} \\quad (1 \\leq \\forall j \u003c \\forall i \\leq n)\n$$\n\nを満たすとき、基底 $\\\\{\\mathbf{b_1},\\ldots,\\mathbf{b_n}\\\\}$ はサイズ簡約されているという。\n\n## 計算量\n\n\n## 実装\n\n```python\ndef size_reduction(B):\n    n = len(B)\n    B = matrix(B)\n    G, mu = B.gram_schmidt()\n    for i in range(n):\n        for j in range(i - 1, -1, -1):\n            if mu[i][j].abs() \u003e 1 / 2:\n                q = mu[i][j].round()\n                B[i] -= q * B[j]\n                mu[i] -= q * mu[j]\n    return B\n```\n\n## 使用例\n\n```python\nB = [vector([5, -3, -7]), vector([2, -7, -7]), vector([3, -10, 0])]\nprint(size_reduction(B))\n```\n\n## 参考\n\n","lastmodified":"2022-12-30T07:57:21.471263809Z","tags":null},"/crypto/Lattice/tour_of_Lattice":{"title":"Tour of Lattice","content":"\n# 格子暗号を極める！\n\n無限工事編\n\n## はじめに\n\n// TODO 説明\n耐量子暗号です！あとはセキュキャンで話題のTFHEとか紹介したいな\n\nこれは大学1年で習う線形代数を前提知識として扱います。\n\n- 量子アルゴリズムはどこで解説すべき？\n\t- 暗号関連で解説すべきなのはGroverとShorのアルゴリズムの2つだけやが量子コンピューター上の演算や量子フーリエが前提知識無しやとキツイかもしれん。\n\t- 量子コンピュータという題材で分けた方が良さそう？本に頼ればいいは一理あるが論文以外の文献は未だ少なく暗号専門の解説がほしいところ\n\t- 自分の文章力と時間に要相談ということで\n\n## 格子 (Lattice)\n\n図でイメージ掴むのが速い\n\n線形独立な $n$ 個のベクトル $\\mathbf{b}_1, \\mathbf{b}_2, \\ldots , \\mathbf{b}_n \\in \\mathbb{R}^m$ について整数係数の線形結合によって生成されるベクトルの集合を格子 $L$ と定義します。\n\n$$\nL = \\left\\{ \\sum_{i=0}^{n} a_i\\mathbf{b}_i \\ \\middle| \\ a_i \\in \\mathbb{Z} \\right\\}\n$$\n\n化学の格子っぽいもの\n\n格子 $L$ に囲まれた空間を1つ\n具体例\n\n### 困難な問題\n\n今回のキーとなる問題です\n\nSVP\nCVP\n\nnear SVP\nnear CVP\n\n### LWE格子暗号\n\n機械学習理論から派生した求解困難な問題で、有限体 $\\mathbb{F}_q$ 上の秘密ベクトル $\\mathbf{s} \\in \\mathbb{F}_q^n$ に関するランダムな連立線形「近似」方程式が与えられたとき、その秘密ベクトルを復元する問題である。\n\n\n\n\n### Gram-Schmidt の直交化 (GSO: Gram-Schmidt Orthonormalization)\n\n任意の $R$ ベクトル空間直交化\nベクトルをGSO化させることで任意の2つのベクトルの内積が0となる、つまり直交化できます。イメージは[Wikipedia](https://ja.wikipedia.org/wiki/%E3%82%B0%E3%83%A9%E3%83%A0%E3%83%BB%E3%82%B7%E3%83%A5%E3%83%9F%E3%83%83%E3%83%88%E3%81%AE%E6%AD%A3%E8%A6%8F%E7%9B%B4%E4%BA%A4%E5%8C%96%E6%B3%95)のgifがわかりやすいです。$\\mathbf{b}_n$ の直交化は $\\mathbf{b}_{1},\\ldots, \\mathbf{b}_{n-1}$ までと直行するように高さを保持しながら移動させる。\n\n$$\n\\begin{aligned}\n\\begin{dcases}\n\\mathbf{b}_1^* = \\mathbf{b}_1 \\\\\n\\mathbf{b}_i^* = \\mathbf{b}_i - \\sum\\limits_{j=1}^{i-1} \\mu_{i, j}\\mathbf{b}_j^* \\qquad \\left( \\mu_{i, j} = \\frac{\\langle \\mathbf{b}_i, \\mathbf{b}_j^* \\rangle}{\\| \\mathbf{b}_j^* \\|^2} \\right) \\\\\n\\end{dcases}\n\\end{aligned}\n$$\n\n$$\n\\begin{aligned}\nB \u0026=\n\\begin{pmatrix}\n\\mathbf{b}_1 \\\\\n\\mathbf{b}_2 \\\\\n\\mathbf{b}_3 \\\\\n\\mathbf{b}_4 \\\\\n\\end{pmatrix}\n\u0026 U \u0026=\n\\begin{pmatrix}\n1 \u0026 0 \u0026 0 \u0026 0 \\\\\n\\mu_{2,1} \u0026 1 \u0026 0 \u0026 0 \\\\\n\\mu_{3,1} \u0026 \\mu_{3,2} \u0026 1 \u0026 0 \\\\\n\\mu_{4,1} \u0026 \\mu_{4,2} \u0026 \\mu_{4,3} \u0026 1 \\\\\n\\end{pmatrix}\n\u0026 B^* \u0026=\n\\begin{pmatrix}\n\\mathbf{b}_1^* \\\\\n\\mathbf{b}_2^* \\\\\n\\mathbf{b}_3^* \\\\\n\\mathbf{b}_4^* \\\\\n\\end{pmatrix} \\\\\n\\end{aligned}\n$$\n\n$$\nB = UB^*\n$$\n\nこれらをGSOベクトル $\\mathbf{b}_i^*$ , GSO係数 $\\mu_{i, j}$ と呼びます。\n\n具体例\n### Shortest Vector Problem(SVP)\n\n格子上の非零なベクトルの中で最もノルムが小さなベクトルを見つけ出す問題です。\nそのベクトルを $\\mathbf{v}$ とおくと次のように表せられます。\n\n$$\n\\mathbf{v} = v_1\\mathbf{b}_1 + \\ldots + v_n\\mathbf{b}_n \\qquad (\\exists v_1, \\ldots , v_n \\in \\mathbb{Z}) \\\\\n$$\n\nこの問題はNP困難\n\n#### 最短ベクトルの数え上げ\n\nまずは全探索してみます。\n考えてみると帰納的に求めるのでは正確な最短ベクトルは求められないでしょう。\n考えてみるとある基底 $\\mathbf{b}_i$ に対し、それ以下の基底 $\\mathbf{b}_1, \\ldots \\mathbf{b}_{i-1}$ で組み立てられたベクトル $\\mathbf{v}$ に対し、$\\mathbf{b}_i$ を用いて短くする\n\n効率的に数え上げる為には基底簡約すると良いということが知られています。\n\n#### Lagrange 基底簡約 (Gaussian Reduction)\n\nサイズ基底簡約\nGSO ベクトルを簡約 -\u003e 基底ベクトルを簡約\nGSO 係数 $μ_{i,j}$ について\n\n$$\n\\|μ_{i,j}\\| \\leq \\frac{1}{2} \\qquad (\\forall 0 \\leq i \u003c j \u003c n)\n$$\n\nEuclid の互除法を用いて基底の簡約化をする。\n具体例\n\n#### LLL(Lenstra-Lenstra-Lovasz) 基底簡約\n\nLagrange 基底簡約に Lovasz 条件を追加した基底簡約を LLL 基底簡約と呼びます。\nLovasz条件 $\\frac{1}{4} \u003c \\delta \u003c 1$ として\n\n$$\n\\delta \\|b_{k-1}^*\\|^2 \\leq \\|\\pi_{k-1}(b_k)\\|^2\n$$\n\n1. サイズ基底簡約\n2. 条件に合うように基底ベクトルの交換\n\n具体例\n\n#### BKZ(Block Korkine-Zolotareff) 基底簡約\n\nHKZ(Hermite-Korkine-Zolotareff) 基底簡約\n\n1. サイズ基底簡約\n2. 条件に合うように基底ベクトルの交換\n\n具体例\n\n### Closest Vector Problem(CVP)\n\n#### Babai’s Algorithm\n\n#### Kannan’s embedding method\n","lastmodified":"2022-12-30T07:57:21.471263809Z","tags":null},"/crypto/Note":{"title":"Note","content":"\n# Crypto in CTF writeup\n[Crypto in CTF :: Mystify (mystiz.hk)](https://mystiz.hk/crypto-in-ctf/) を解いていく。\n\n## Q3 2021\n## Pwn2Win CTF 2021\n### t00 rare\n- ECDSAで署名/検証ができるが、特定のハッシュ値のときは不可\n- $q=q_1q_2+1$ として秘密鍵が $x=(7^{q_2})^y$, $P = kG$, $s=\\frac{h+rx}{k}\\iff P=\\frac{h+rx}{s}G\\iff g^yG=r^{-1}(sP-hG)$ である\n- 特定のハッシュ値のとき $kP=G$ を求める\n\n#### 解法\n- $h+q$ でバイパス\n- BSGSで $g^yG$ の $y$ を求める\n- 高速なライブラリfastecdsaを使う\n\n### A2S\n- AESのラウンドを10回から2回に変更\n\n#### 解法\n\n## 0CTF 2021 Quals\n### zer0lfsr-\n\n\n## Crypto CTF 2022\n","lastmodified":"2022-12-30T07:57:21.471263809Z","tags":null},"/crypto/PRNG/MersenneTwister":{"title":"メルセンヌ ツイスタ","content":"\n## 説明\n\n長い周期 $2^{19937}-1$ を持つ疑似乱数生成器。連続した624回の32ビット出力から内部状態を復元できてしまう。\n2つの値で十分のときもあるらしい\nhttps://www.ambionics.io/blog/php-mt-rand-prediction\n\n## 参考\n\n- [メルセンヌ・ツイスタをわかった気になる](https://6715.jp/posts/5/)\n- [Mersenne Twisterの出力を推測してみる](https://inaz2.hatenablog.com/entry/2016/03/07/194147)","lastmodified":"2022-12-30T07:57:21.471263809Z","tags":null},"/crypto/RSA/Boneh-DurfeeAttack":{"title":"Boneh-Durfee Attack","content":"\n## 説明\n\n$e$ が大きすぎると以下の式に対し Coppersmith Method を用いて攻撃できる。\n\n$$\n\\begin{aligned}\ned \u0026= 1 \u0026 \\pmod{\\phi} \\\\\ned \u0026= k \\phi + 1 \u0026 (\\mathrm{over}\\ \\mathbb{Z}) \\\\\n0 \u0026= k \\phi + 1 \u0026 \\pmod e \\\\\n\u0026= k (N + 1 - p - q) + 1 \u0026 \\pmod e \\\\\n\u0026= 2k \\left(\\frac{N + 1}{2} + \\frac{-p -q}{2}\\right) + 1 \u0026 \\pmod e \\\\\n\\end{aligned}\n$$\n\n## 実装\n\n```python\nload('coppersmith.sage')\n\ndef boneh_durfee(N, e):\n    bounds = (floor(N^.25), 2^1024)\n    P.\u003ck, s\u003e = PolynomialRing(Zmod(e))\n    f = 2*k*((N+1)//2 - s) + 1\n    print(small_roots(f, bounds, m=3, d=4))\n```\n\n## 使用例\n","lastmodified":"2022-12-30T07:57:21.471263809Z","tags":null},"/crypto/RSA/CommonModulusAttack":{"title":"Common Modulus Attack","content":"\n## 説明\n\n共通の平文を異なる $e$ で暗号化した暗号文が分かっているとき平文を求められる。\n\n$$\n\\begin{aligned}\nc_1 \u0026≡ m^{e_1} \u0026 \\pmod N \\\\\nc_2 \u0026≡ m^{e_2} \u0026 \\pmod N \\\\\n\\gcd(e_1, e_2) \u0026= s_1e_1 + s_2e_2 \\\\\nc_1^{s_1} c_2^{s_2} \u0026= m^{s_1e_1 + s_2e_2} = m^{\\gcd(e_1, e_2)} \u0026 \\pmod N\n\\end{aligned}\n$$\n\n## 実装\n\n\n## 使用例\n","lastmodified":"2022-12-30T07:57:21.471263809Z","tags":null},"/crypto/RSA/Franklin-ReiterRelatedMessageAttack":{"title":"Franklin-Reiter Related Message Attack","content":"\n## 説明\n\n$f(m_1) = m_2$\n$m_1 = pad_1 + m, m_2 = pad_2 + m, m_2 = m_1 + (pad_2 - pad_1)$\n\n$$\n\\begin{aligned}\nc_1 \u0026= m_1^{e_1} \u0026 \\pmod N \\\\\nc_2 \u0026= m_2^{e_2} = f(m_1)^{e_2} \u0026 \\pmod N \\\\\nx - m_1 \u0026= \\gcd(x^{e_1} - c_1, f(x)^{e_2} - c_2) \u0026 \\pmod N \\\\\n\\end{aligned}\n$$\n\n## 実装\n\n\n## 使用例\n\n\n## 参考\n\n","lastmodified":"2022-12-30T07:57:21.471263809Z","tags":null},"/crypto/RSA/H%C3%A5stadsBroadcastAttack":{"title":"Håstad’s Broadcast Attack","content":"\n## 説明\n\n平文を互いに素な $N_1, \\ldots, N_e$ で暗号化された暗号文が分かっているとき、中国剰余定理を用いて $m$ を求められる。\n\n$$\n\\begin{aligned}\nc_1 \u0026≡ m^e \\pmod{N_1} \\\\\nc_2 \u0026≡ m^e \\pmod{N_2} \\\\\n\\vdots \\\\\nc_e \u0026≡ m^e \\pmod{N_e} \\\\\nm^e \u0026≡ CRT(c_1, c_2, \\dots , c_e) \\pmod{N_1N_2\\cdots N_e} \\\\\nm^e \u0026= CRT(c_1, c_2, \\dots , c_e)\n\\end{aligned}\n$$\n\n## 実装\n\n\n## 使用例\n\n## 関連\n\n- [They Were Eleven - BSides Ahmedabad CTF 2021 author's writeup](https://furutsuki.hatenablog.com/entry/2021/12/07/020611)\n","lastmodified":"2022-12-30T07:57:21.471263809Z","tags":null},"/crypto/RSA/LSB-DecryptionOracleAttack":{"title":"LSB Decryption Oracle Attack","content":"\n## 説明\n\n全てが分かっていなくとも偶奇さえ分かれば任意の暗号文を復号できる。\nある暗号文 $c$ に対し、$2^e$ をx回掛けた値を復号した下位1bitを得て平文を求めます。得られる下位1bitは次の関数 $f(x)$ を用いて $f(x) \\bmod 2$ と表せられます。decは復号化関数です。\n\n$$\n\\begin{aligned}\nf(x) \u0026= Dec(2^{ex}c \\bmod N) = 2^xm \\bmod N \\\\\n\\end{aligned}\n$$\n\n$x = 1$ のとき\nまず $0 \\leq m \u003c N$ であるから $f(1)$ は $2m \\bmod N = 2m, 2m - N$ のどちらかとなる。また $2m$ は偶数、$N$ は奇数であるから $f(1)$ が偶数か奇数かで $2m, 2m - N$ のどちらかが分かります。すると $m$ が存在する区間が分かります。\n\n$$\n\\begin{aligned}\n\u0026f(1) = 2m \\bmod N \\\\\n\u0026\n\\begin{cases}\n    f(1) \\bmod 2 = 1 \\Leftrightarrow f(1) = 2m - N \u0026 \\Leftrightarrow \\frac{N}{2} \\leq m \u003c N \\\\\n    f(1) \\bmod 2 = 0 \\Leftrightarrow f(1) = 2m \u0026 \\Leftrightarrow 0 \\leq m \u003c \\frac{N}{2} \\\\\n\\end{cases}\n\\end{aligned}\n$$\n\nつまり $m$ は $[0, N)$ の範囲に対して最下位ビットが1のとき区間の右半分、0のとき区間の左半分だと言えます。\n\n$x = 2$ のとき\n前の結果を用いて場合分けして考えると同様の考え方で次のように導けます。\n\n$$\n\\begin{aligned}\nf(2) \u0026= 2(2m \\bmod N) \\bmod N \\\\\nf(1) \u0026= 2m - N \\Rightarrow f(2) = 4m - 2N \\bmod N \\\\\n\u0026\n\\begin{cases}\n    f(2) \\bmod 2 = 1 \\Leftrightarrow f(2) = 4m - 3N \u0026 \\Leftrightarrow \\frac{3N}{4} \\leq m \u003c N \\\\\n    f(2) \\bmod 2 = 0 \\Leftrightarrow f(2) = 4m - 2N \u0026 \\Leftrightarrow \\frac{N}{2} \\leq m \u003c \\frac{3N}{4} \\\\\n\\end{cases}\n\\\\\nf(1) \u0026= 2m \\Rightarrow f(2) = 4m \\bmod N \\\\\n\u0026\n\\begin{cases}\n    f(2) \\bmod 2 = 1 \\Leftrightarrow f(2) = 4m - N \u0026 \\Leftrightarrow \\frac{N}{4} \\leq m \u003c \\frac{N}{2} \\\\\n    f(2) \\bmod 2 = 0 \\Leftrightarrow f(2) = 4m \u0026 \\Leftrightarrow 0 \\leq m \u003c \\frac{N}{4} \\\\\n\\end{cases}\n\\end{aligned}\n$$\n\nつまり $m$ は $[0, N/2)$ 、 $[N/2, N)$ のそれぞれの範囲に対して最下位ビットが1のとき区間の右半分、0のとき区間の左半分だと言えます。\n\n$x \\geq 3$ のときも同様に行って $m$ の値を求めることができます。\n\n## 実装\n\n\n## 使用例\n\n\n## 参考\n\n","lastmodified":"2022-12-30T07:57:21.471263809Z","tags":null},"/crypto/RSA/NoInverse":{"title":"逆元が存在しないとき","content":"\n## 説明\n\n乗法群の位数が $\\phi(N) = se^n$ と表されるとき $e$ の逆元が取れない.\n\nこのとき位数 $se^n$ から $e^n$ 乗することで位数 $s$ の乗法群に落とし, そこでなら逆元を取れるので, 位数 $se^n$ の元を $e^n$ 回掛けて全探索すると平文が見つかる.\n\n1. \n\n## 計算量\n\n$O(e^n)$\n\n## 実装\n\n\n## 使用例\n\n\n## 参考\n\n[p - 1 ≡ 0 (mod e) のときの RSA 復号方法](https://blog.y011d4.com/20201026-not-coprime-e-phi)\n","lastmodified":"2022-12-30T07:57:21.471263809Z","tags":null},"/crypto/RSA/PartialKeyExposureAttack":{"title":"Partial Key Exposure Attack","content":"\n## 説明\n\n秘密鍵を部分的に知っていさえいれば、Coppersmith Method を用いて解けてしまう。\n$n$ を $N$ のビット数とする。\n\n### $p, q$ のどちらかを $n/4$ ビット程度知っているとき\n\n$$\n\\begin{aligned}\nf(x) \u0026= p_{upper} + x \u0026 \\pmod p \\\\\nf(x) \u0026= 2^{k}x + p_{lower} \u0026 \\pmod p \\\\\nf(x,y) \u0026= 2^kx + p_{mid} + y \u0026 \\pmod p \\\\\n\\end{aligned}\n$$\n\n### 平文 $m$ のビットを $(1-1/e)n$ 程度知っているとき\n\n$$\n\\begin{aligned}\nf(x) \u0026= (m_{upper} + x)^e - c \u0026 \\pmod N \\\\\nf(x) \u0026= (2^kx + m_{lower})^e - c \u0026 \\pmod N \\\\\nf(x,y) \u0026= (2^kx + m_{mid} + y)^e - c \u0026 \\pmod N \\\\\n\\end{aligned}\n$$\n\n### $d$ を $n/4$ ビット程度知っているとき\n\n$e$ が総当り出来るくらい小さいときに $d$ を $n/4$ ビットだけ知っていれば元の $d$ を構成できる。大体の場合は $e = 65537$ であるから十分可能である。$d \u003c \\phi(N)$ より $0 \u003c k \\leq e$ となり、この $k$ に対して総当たりする。\n\n- 上位ビットの場合\n$d$ と $p, q$ の関係式を立てる。\n\n$$\n\\begin{aligned}\ned \u0026= 1 \u0026 \\pmod{\\phi(N)} \\\\\ned \u0026= 1 + k(N - p - q + 1) \\\\\nd \u0026= \\frac{kN}{e} - \\frac{k(p+q-1) -1}{e} \\\\\ne(d_{upper} + x) \u0026= - k (y - 1) + 1 \u0026 \\pmod N \\\\\n\\end{aligned}\n$$\n\n第三式について $p + q \\approx \\sqrt{N}$ より第二項は上位ビットに関連する情報を持たない。これより第一項の $k$ について総当りして上位ビットと一致する $k$ を見つければよい。すると第4式に対し Multivariate CopperSmith を用いて、$d$ がわかる。\n\n- 下位ビットの場合\n$d$ の下位ビットから $k$ について総当りして $p$ の下位ビットを求める。すると先程の問題に帰着できて $p$ がわかり $d$ がわかる。\n\n$$\n\\begin{aligned}\ned \u0026= 1 + k\\left(N - p - \\frac{N}{p} + 1\\right) \\\\\nedp \u0026= p + kp(N - p + 1) - kN \u0026 \\pmod {2^{n/4}} \\\\\n\\end{aligned}\n$$\n\n### CRTの秘密鍵 $d$ のビットを $n/4$ 程度知っているとき\n\n上と同様にして解けます。\n\n$$\n\\begin{aligned}\ned_p \u0026= 1 \u0026 \\pmod{p-1} \\\\\ned_p \u0026= 1 + k_p(p − 1) \\\\\n\\end{aligned}\n$$\n\n## 実装\n\n```python\nfrom Crypto.Util.number import *\n\np = getPrime(512)\nq = getPrime(512)\nn = p * q\ne = 3\n\nbeta = 0.5\nepsilon = beta^2/7\n\npbits = p.nbits()\nkbits = floor(n.nbits() * (beta^2 - epsilon))\n# p upper\npbar = p \u0026 (2^pbits - 2^kbits)\n\nprint(f\"upper {pbits - kbits} bits (of {pbits} bits) is given\")\n\nPR.\u003cx\u003e = PolynomialRing(Zmod(n))\nf = x + pbar\n\nprint(p)\nx0 = f.small_roots(X=2^kbits, beta=0.3)[0]\nprint(x0 + pbar)\n```\n\n## 使用例\n\n```python\ndef partial_p(p0, kbits, n):\n    PR.\u003cx\u003e = PolynomialRing(Zmod(n))\n    nbits = n.nbits()\n\n    f = 2^kbits*x + p0\n    f = f.monic()\n    roots = f.small_roots(X=2^(nbits//2-kbits), beta=0.3)  # find root \u003c 2^(nbits//2-kbits) with factor \u003e= n^0.3\n    if roots:\n        x0 = roots[0]\n        p = gcd(2^kbits*x0 + p0, n)\n        return ZZ(p)\n\ndef find_p(d0, kbits, e, n):\n    X = var('X')\n\n\t# edx - kx(n-x+1) + kn = x mod 2^k\n\t# (ed - 1)x - kx(n-x+1) + kn = 0 mod 2^k\n    for k in xrange(1, e+1):\n        results = solve_mod([e*d0*X - k*X*(n-X+1) + k*n == X], 2^kbits)\n        for x in results:\n            p0 = ZZ(x[0])\n            p = partial_p(p0, kbits, n)\n            if p:\n                return p\n\n\nif __name__ == '__main__':\n    n = 0x00bef498e6eb2cffe71312da47ab89d2c47db7438ea2cfa992ddddbc2a01978001fc51e286e6ebf028396cdb8b3323c60e6b9d50cd84187cf7f48e3875a2f0890f70b02333ad89db2923863ce146562286f63fb0a1d0198e3a6862ba5ac12e85a5c6d0d27cb1c81bdf69cc5bc95b8001a2f744517f9437b4ddd5a076fc0e9a5de1a7a268c40f31aa29e8dc27c0b3a182299ca7a9335b4bd4585452f6107c238e486c98dd73a5f9862e9e80b152f53381c72f897107551c281259ac3ee32c4b4f46cc03127d1bf699acd0266f3c6729253c70da0c69b1560fa172735709866b375b6eba294e1ce8b46fba798ba380080b4bf9603998cac199d9cd46e30ae8da9e7f\n    e = 3\n    d = 0x7f4dbb449cc8aa9a0cb73c2fc7b1372da924d7b46c8a710c93e9281c010faaabfd8bec59ef47f5702648925cccc284099d138b33ad65a8a54db425a3c1f5b0b4f5cac22273b13cc617aed340d98ec1af4ed5206be011097c459726e72b7459192f35e1a8768567ea46883d30e7aaabc1fa2d8baa62cfcde93915a4a809bc3e9547bb07e1ecca16e51078312e89f0561e31b55db8b0ea5bc87a6ca7464a3d7c28a68c60e2ba88fe6a7d2b300d723e549910a987da89fc0a1c0de197a3d62c501b1f0e819891b1c32a0d6c233f2a285df87bb9e5c6c72d983ff3e706696bba639f573f9c3646968f02f3a615a438e20bb7c38d53621079f2899547a95350f3abeb\n\n    beta = 0.5\n    epsilon = beta^2/7\n\n    nbits = n.nbits()\n    kbits = floor(nbits*(beta^2+epsilon))\n    d0 = d \u0026 (2^kbits-1)\n    print \"lower %d bits (of %d bits) is given\" % (kbits, nbits)\n\n    p = find_p(d0, kbits, e, n)\n    print \"found p: %d\" % p\n    q = n//p\n    print d\n    print inverse_mod(e, (p-1)*(q-1))\n```\n\n## 参考\n\n","lastmodified":"2022-12-30T07:57:21.471263809Z","tags":null},"/crypto/RSA/ROCA":{"title":"Return Of Coppersmith Attack","content":"\n## 説明\n\n主要な暗号ハードウェアメーカで使われているライブラリ RSALib の鍵生成アルゴリズムの欠陥。\n\n$$\n\\begin{aligned}\np \u0026= kM + (e^a \\bmod M) \\\\\nq \u0026= lM + (e^b \\bmod M) \\\\\nN \u0026= pq = e^{a + b} \\pmod M\n\\end{aligned}\n$$\n\nM の素因数分解して中国剰余定理からのDLPを適用\n$P_n = 2\\cdot 3\\cdot\\ldots\\cdot p_n$\n512bit RSA $M = P_{39}$, $k$ 37bit, $a$ 62bit\n1024bit RSA $M = P_{71}$\n2048bit RSA $M = P_{126}$\n\n## 実装\n\n\n## 使用例\n\n\n## 参考\n\n[The Return of Coppersmith's Attack:Practical Factorization of Widely Used RSA Moduli (acmccs.github.io)](https://acmccs.github.io/papers/p1631-nemecA.pdf)\n\n","lastmodified":"2022-12-30T07:57:21.471263809Z","tags":null},"/crypto/RSA/RSA":{"title":"RSA暗号","content":"\n## 説明\n\n暗号化\n$c = m^{e} \\pmod N$ を計算します。\n\n1. 秘密鍵である大きな素数 $p, q$ を生成し、公開鍵 $N = pq$ を公開します。\n2. そして数値化した平文 $m$ に対して暗号文 $c$ は $c = m^e \\pmod N$ となります。\n\n復号化\n$m = c^{e^{-1}} \\pmod N$ を計算します。\n\n1. まず秘密鍵 $\\phi(N) = (p - 1)(q - 1)$ を計算する。\n2. $c$ に対して $d = e^{-1} \\pmod{\\phi(N)}$ 乗することで復号できます。\n\n$$\n\\begin{aligned}\nc \u0026≡ m^e \u0026\\pmod N \\\\\nc^d \u0026≡ m^{ed} ≡ m \u0026\\pmod N\n\\end{aligned}\n$$\n\nこれはオイラーの定理より肩の数が $\\phi(N)$ を法として計算できるからです。\n\n$$\n\\begin{aligned}\nm^{\\phi(N)} \u0026≡ m^{(p - 1)(q - 1)} ≡ 1 \u0026 \\pmod N \\\\\nm^{ed} \u0026= m^{k\\phi(N) + 1} ≡ m^{k\\phi(N)}m ≡ m \u0026 \\pmod N \\\\\ned \u0026= k\\phi(N) + 1 ≡ 1 \u0026 \\pmod{\\phi(N)}\n\\end{aligned}\n$$\n\nここで $N, e$ を知っていても $p, q, d$ を知らないとき、暗号化は簡単でも復号化は難しいという事が知られています。これを用いた暗号をRSA暗号 (Rivest-Shamir-Adleman encryption) と呼びます。\n\n具体的には次の手順で暗号化された通信します。\n\n1. AliceがBobに公開鍵 $N, e$ を渡す\n2. Bobは公開鍵を用いて平文を暗号化\n3. BobからAliceへ暗号文を送る\n4. Aliceは秘密鍵 $p, q$ を用いて復号化し、平文を得る\n\nここに図\n\nこのようにして送っている最中に盗聴されても秘密鍵がなければ解読できず、安全な通信ができます。\nまたこれは一方向通信ですが、逆も同様に行えば双方向通信もできます。\n\n### RSA-CRT\n\nRSAの復号をする際に $c^d$ を計算しますが、 $d = e^{-1} \\pmod {\\phi (N)}$ は比較的大きいので処理が重くなります。これに対してRSA-CRTは中国剰余定理(CRT)を利用して高速化を図っています。\n\n$$\n\\begin{aligned}\nm_p \u0026= c^{d \\ \\bmod \\ p−1} \u0026 \\pmod p \\\\\nm_q \u0026= c^{d \\ \\bmod \\ q−1} \u0026 \\pmod q \\\\\nm \u0026= \\mathrm{CRT}(m_p, m_q) \u0026 \\pmod {N} \\\\\n\u0026= m_q + (m_p - m_q) (q^{-1} \\bmod p) q \u0026 \\pmod {N} \\\\\n\\end{aligned}\n$$\n\nこれより下の値を秘密鍵として持つことになります。\n\n$$\n\\begin{aligned}\nd_p \u0026= d \\bmod p−1 \\\\\nd_q \u0026= d \\bmod q−1 \\\\\nq_{inv} \u0026= q^{-1} \\bmod p \\\\\n\\end{aligned}\n$$\n\n### padding\nメッセージが改ざんされずに届けられていることを確認するのにパディングは用いられる。RSAでは主に次の3つのパディングが使われる。\n\nRFC 8017: PKCS #1 V2.2(RSA Cryptography Specifications Version 2.2)\n\n- PKCS#1 v1.5; Public-Key Cryptography Standards#1 v1.5\n- OAEP; Optimal Asymmetric Encryption Padding\n- PSS; Probabilistic Signature Scheme\n\nこのようなパディングを用いたRSAをRSA-[パディング名]などと呼んだりする。\n\n## 実装\n\n```python\nfrom Crypto.Util.number import *\n\np = getPrime(512)\nq = getPrime(512)\nN = p * q\nphi = (p - 1) * (q - 1)\ne = 65537\nd = pow(e, -1, phi)\n\n\ndef encrypt(plaintext):\n    m = bytes_to_long(plaintext)\n    c = pow(m, e, N)\n    cipher = long_to_bytes(c)\n    return cipher\n\n\ndef decrypt(cipher):\n    c = bytes_to_long(cipher)\n    m = pow(c, d, phi)\n    plaintext = long_to_bytes(m)\n    return plaintext\n\n\ncipher = encrypt(b\"This is RSA\")\nprint(cipher)\nplaintext = decrypt(cipher)\nprint(plaintext)\n```\n\n## 使用例\n\n## 関連項目\n- [Boneh-Durfee Attack](/crypto/RSA/Boneh-DurfeeAttack)\n- [Common Modulus Attack](/crypto/RSA/CommonModulusAttack)\n- [Franklin-Reiter Related Message Attack](/crypto/RSA/Franklin-ReiterRelatedMessageAttack)\n- [Håstad’s Broadcast Attack](/crypto/RSA/HåstadsBroadcastAttack)\n- [LSB Decryption Oracle Attack](/crypto/RSA/LSB-DecryptionOracleAttack)\n- [逆元が存在しないとき](/crypto/RSA/NoInverse)\n- [Partial Key Exposure Attack](/crypto/RSA/PartialKeyExposureAttack)\n- [Return Of Coppersmith Attack](/crypto/RSA/ROCA)\n- [RSA-CCA](/crypto/RSA/RSA-CCA)\n- [RSA-CRT Fault Attack](/crypto/RSA/RSA-CRT-FaultAttack)\n- [Small Common Private Exponent Attack](/crypto/RSA/SmallCommonPrivateExponentAttack)\n- [Wiener's Attack](/crypto/RSA/WienersAttack)","lastmodified":"2022-12-30T07:57:21.471263809Z","tags":null},"/crypto/RSA/RSA-CCA":{"title":"Chosen-ciphertext Attack","content":"\n## 説明\n\n任意の暗号を復号した結果を知っているとき、ある暗号文の復号結果を防がれていたとしても他の暗号を送ることで解読できます。\n$2^e$ を暗号文に掛けて復号した結果を $2$ で割ればその平文がわかります。\n\n$$\n\\begin{aligned}\nDec(2^ec) = 2m \\pmod N\n\\end{aligned}\n$$\n\nこれに対する防御方法として平文にパディングを施し、復号化した際にパディング形式が違うときは相手に渡さないようにするという方法があります。これによって正当な暗号文しか受け入れず、適応的選択暗号文攻撃を防げます。\n\nパディング形式の1つにPKCS #1 v1.5があります。\n\n`0002\u003crandom\u003e00\u003chashprefix\u003e\u003cmessage\u003e`\n\nこれについてパディングが合っているかどうかを相手に送ってしまうとPadding Oracle Attackで攻撃でき、PKCS #1 v1.5では200万程度送ると平文が読めてしまいます。\n\n対してPadding Oracle Attackで破られないようなパディング形式はInD-CCA2と呼びます。\n\nその1つであるOAEP(Optimal Asymmetric Encryption Padding)については次の記事を読むとよいです。\n\n## 実装\n\n\n## 使用例\n\n\n## 参考\n\n- [RSAに対する適応的選択暗号文攻撃とパディング方式](https://inaz2.hatenablog.com/entry/2016/01/26/222303)\n","lastmodified":"2022-12-30T07:57:21.471263809Z","tags":null},"/crypto/RSA/RSA-CRT-FaultAttack":{"title":"RSA-CRT Fault Attack","content":"\n## 説明\n\nRSAの復号をする際に $c^d$ を計算しますが、 $d = e^{-1} \\pmod {\\phi (N)}$ は比較的大きいので処理が重くなります。これに対してRSA-CRTは中国剰余定理(CRT)を利用して高速化を図っています。\n\n$$\n\\begin{aligned}\nm_p \u0026= c^{d \\ \\bmod \\ p−1} \u0026 \\pmod p \\\\\nm_q \u0026= c^{d \\ \\bmod \\ q−1} \u0026 \\pmod q \\\\\nm \u0026= \\mathrm{CRT}(m_p, m_q) \u0026 \\pmod {N} \\\\\n\u0026= m_q + (m_p - m_q) (q^{-1} \\bmod p) q \u0026 \\pmod {N} \\\\\n\\end{aligned}\n$$\n\nこれより下の値を秘密鍵として持つことになります。\n\n$$\n\\begin{aligned}\nd_p \u0026= d \\bmod p−1 \\\\\nd_q \u0026= d \\bmod q−1 \\\\\nq_{inv} \u0026= q^{-1} \\bmod p \\\\\n\\end{aligned}\n$$\n\nしかし $d_p, d_q$ のどちらかが何らかの方法で書き換えられてしまったとき次のようにできます。\n\n$$\n\\begin{aligned}\nm_p \u0026= c^{d_p} \\pmod p \\\\\nm_q' \u0026= c^{d_q'} \\pmod q \\\\\nm \u0026= CRT(m_p, m_q) = kp + m_p \\\\\nm' \u0026= CRT(m_p, m_q') = k'p + m_p \\\\\nm - m' \u0026= (k - k')p \\\\\np \u0026= \\gcd(m - m', N) \\\\\n\\end{aligned}\n$$\n\nこれより平文 $m, m'$ を知ることができれば解くことができます。\n\n## 実装\n\n\n## 使用例\n\n\n## 参考\n\n","lastmodified":"2022-12-30T07:57:21.471263809Z","tags":null},"/crypto/RSA/SmallCommonPrivateExponentAttack":{"title":"Small Common Private Exponent Attack","content":"\n## 説明\n\n\n## 実装\n\n\n## 使用例\n\n\n## 参考\n\n","lastmodified":"2022-12-30T07:57:21.471263809Z","tags":null},"/crypto/RSA/WienersAttack":{"title":"Wiener's Attack","content":"\n## 説明\n\n$3d \u003c N^{\\frac{1}{4}}$ のとき ( $d$ が小さすぎるか $e$ が大きすぎるとき)、$e/N$ に対し主近似分数を並べると $k/d$ がある。\n\n$$\n\\begin{aligned}\ned \u0026≡ 1 = k\\phi(N) + 1 = k(N - p - q + 1) + 1 \\\\\n\\frac{e}{N} \u0026= \\frac{k}{d}\\left(1-\\frac{p + q - 1 - \\frac{1}{k}}{N}\\right) \\approx \\frac{k}{d} \\\\\n\\frac{e}{N} \u0026\\approx q_0 + \\cfrac{1}{q_1 + \\cfrac{1}{q_2 + \\cfrac{1}{\\ddots \\cfrac{}{q_{m-1} + \\cfrac{1}{q_m}}}}} = \\frac{k_m}{d_m} \\\\\n\\end{aligned}\n$$\n\n次の漸化式を用いて主近似分数は求まる。\n\n$$\n\\begin{aligned}\nr_{-2} \u0026= e \u0026 k_{-2} \u0026= 0 \u0026d_{-2} \u0026= 1 \\\\\nr_{-1} \u0026= N \u0026 k_{-1} \u0026= 1 \u0026d_{-1} \u0026= 0 \\\\\nr_{i-2} \\div r_{i-1} \u0026= q_{i} \\cdots r_{i} \u0026 k_i \u0026= q_i k_{i−1} + k_{i−2} \u0026d_i \u0026= q_i d_{i−1}+d_{i−2} \\\\\n\\end{aligned}\n$$\n\n## 実装\n\n```python\nimport gmpy2\n\ndef convergents(a, b):\n    r0, r1 = a, b\n    a0, a1 = 0, 1\n    b0, b1 = 1, 0\n\n    i = 0\n    while r1 != 0:\n        i += 1\n        q = r0 // r1\n        r0, r1 = r1, r0 % r1\n        a0, a1 = a1, q*a1 + a0\n        b0, b1 = b1, q*b1 + b0\n\n        if i % 2 == 0:\n            a = a1 + a0\n            b = b1 + b0\n        else:\n            a = a1\n            b = b1\n\n        yield a, b\n\ndef has_integer_roots(a, b, c):\n    D = b*b - 4*a*c\n    if D \u003e 0:\n        sD = gmpy2.isqrt(D)\n        if sD * sD == D and (-b + sD) % (2*a) == 0:\n            return 2\n    elif D == 0 and b % (2*a) == 0:\n        return 1\n    return 0\n\ndef WienersAttack(n, e):\n    for d, k in convergents(n, e):\n        if k == 0 or (e * d - 1) % k != 0:\n            continue\n        phi = (e * d - 1) // k\n        if has_integer_roots(1, phi - n - 1, n) \u003e 0:\n            return d\n    return -1\n```\n\n## 使用例\n","lastmodified":"2022-12-30T07:57:21.471263809Z","tags":null},"/crypto/RSA/tour-of-RSA":{"title":"Tour of RSA","content":"\n# RSA暗号を極める！(理論編)\n\nというか無限工事編です(文章が拙くて申し訳ない)\n\n## はじめに\n\nすぐそこに秘密の世界があります。この記事を読んでいるなら、あなたは暗号化された通信を通してサーバーから電気線を通り、遥々その端末に届いている文字を読んでいます。\n\nこんなことを考えてみてほしい。機器から暗号を使って通信をしていますが、私達が触れていないだけで暗号は誰でも解けるものであり、近くを通った人が自分の通信を盗聴しているかもしれない。ゾクッとしませんか。\n\nそんなことが2017年に起こりました。ROCA攻撃と呼ばれるものです。暗号の中でも最も世界で活躍していると言われる「RSA暗号」が簡単に解けてしまうというものです。\n\nその「RSA暗号」の本当の世界を覗いてみましょう。\n\nCryptoはCTF特有のメタ的な能力よりかは数学力に重きが置かれる分野です。最近では発想だけではなくテクニックを知らないと解けないような問題が多くなってきました。そこでこの記事ではRSA関連の問題でよく使うテクニックを体系的に1から習得します。\n\nテクニック\nGCD, 中国剰余定理, 終結式, グレブナー基底, LLL, Approximate GCD, Coppersmith\n\n前提知識は出来る限り高校数学に絞っていますが、それでも少し大学での数学が出てきますので適宜補ってほしいです。\n\n## 時計の世界\n\nRSA暗号を語る上で最も根幹を成すのが、Nを自然数として「Nを法とする」算術です。\n\nこの算術は日々触れていて例えば時間についてこんな問題を考えてみましょう。\n\n午前10時に仕事を始めて、8時間働くとすると、仕事が終わるのはいつでしょうか？\n\n10 + 8 = 18 だから「18時に終わる」と答えるのが自然でしょうか。18から12を引き 18 - 12 = 6 で「午後6時に終わる」とも答えられますね。どちらにしても数はある範囲に入るように調整されます。午前午後で分ける方法であれば数は0から11の間に入り、24時間制であれば数は0から23の間に入ります。\n\n角度でもこの算術に出くわします。例えば2つの角度の和を求めるとき、360度を超えてしまった場合はそこから360を引いて1から360までの間に収まるようにします。例えば 450 - 360 = 90 だから、450度の回転は90度の回転に等しいです。\n\n他にも曜日や\n以上の出してきたものに共通していることは結果がある範囲に収まるようにしていることです。このようなタイプの計算をNを法とする算術と呼びます。先ほどの例だと午前午後であれば「12を法とする」足し算、角度であれば「360を法とする」足し算をしています。\n\n$$\n\\begin{aligned}\n10 + 8 \u0026= 6 \\pmod{12} \\\\\n450 \u0026= 90 \\pmod{360} \\\\\n810 \u0026= 90 \\pmod{360}\n\\end{aligned}\n$$\n\nより広く考えると810度は90度であるようにこの算術はNで割った余りが同じなら等しく扱う算術であるとも言えます。この算術の上では一般の自然数NでNを法とする足し算を考えることができます。\n\nこのNを法とする算術をしっかり考えるために定義を与えます。\n\nまず $0$ から $N-1$ までの数を集めた集合をもってきて、それを $\\mathbb{Z}/N\\mathbb{Z}$ と名付けます。\n\n$$\n\\mathbb{Z}/N\\mathbb{Z} := \\{0, 1, ..., N - 2, N - 1\\}\n$$\n\n例えば $\\mathbb{Z}/12\\mathbb{Z}$ はAM/PMで時間を表す数、$\\mathbb{Z}/24\\mathbb{Z}$ は24時間表記で時間を表す数となります。\n\nこれらの数の集合に対し、加法(足し算)を定義します。この集合の中から任意の2つの数が与えられたとして、それらを足したものが $N$ より大きくなるなら、$N$ を引いて計算結果が自分の中に入るようにします。\n\nこの集合にこう定義した加法を入れることで集合は群となります。群とは集合と1つの演算がよく馴染んでいるようなもので次のような条件を満たします。\n\n- 単位元の存在\n演算しても変わらない値 ex.) $a + 0 = a, a \\times 1 = a$\n- 逆元の存在\n演算して単位元となる値 ex.) $a + (- a) = 0, a \\times \\frac{1}{a} = 1$\n- 結合法則\nどこから演算しても同じ結果になる ex.) $(a + b) + c = a + (b + c)$\n\n群のうれしいことは、群であればどのような集合や演算であれ、必ず成り立つ法則があり、その法則を流用できることにあります。今回はそれらの法則をそれほど使いませんが暗号全般的に使われるので覚えておいて損は無いでしょう。\nさて、加法について群を満たすかチェックしてみます。\n\n- 加法の単位元　　 $0$\n- 加法の逆元　　　 $a + (-a) = 0 \\pmod N \\iff -a = N - a$\n- 加法の結合法則　 $(a + b) + c = a + (b + c) \\pmod N$\n\nこのように群の条件を満たすので $\\mathbb{Z}/N\\mathbb{Z}$ は加法について群となります。\n\n同じように乗法(掛け算)も定義してみます。集合から任意の2つの数を取ってきて、それらを掛けた後に $N$ で割った余りを計算します。乗法についても群を満たすかチェックしてみましょう。\n\n- 乗法の単位元　　 $1$\n- 乗法の逆元　　　 $aa^{-1} = 1 \\pmod N \\iff a^{-1} = \\frac{kN + 1}{a}$\n- 乗法の結合法則　 $(a \\times b) \\times c = a \\times (b \\times c) \\pmod N$\n\nよく考えると乗法の逆元が常に存在する訳ではないです。だから乗法については群になりません。\n\n乗法での逆元とは掛けて1になる数で具体的にはこのようになります。\n\n$$\n\\begin{aligned}\n1^{-1} \u0026= 1 \u0026\u0026 (1 \\times 1 = 1 = 1) \u0026 \\pmod{13} \\\\\n2^{-1} \u0026= 7 \u0026\u0026 (2 \\times 7 = 14 = 1) \u0026 \\pmod{13} \\\\\n3^{-1} \u0026= 9 \u0026\u0026 (3 \\times 9 = 27 = 1) \u0026 \\pmod{13} \\\\\n4^{-1} \u0026= 10 \u0026\u0026 (4 \\times 10 = 40 = 1) \u0026 \\pmod{13} \\\\\n5^{-1} \u0026= 8 \u0026\u0026 (5 \\times 8 = 40 = 1) \u0026 \\pmod{13} \\\\\n\\vdots\n\\end{aligned}\n$$\n\nではどういうときに逆元が存在しないのかを考えてみます。逆元 $x$ が存在する条件について式変形していくと( $\\gcd$ は最大公約数 (Greatest Common Divisor) とします)\n\n$$\n\\begin{aligned}\nax \u0026= 1 \u0026 \\pmod N \\\\\nax - kN \u0026= 1 \\\\\n\\gcd(a, N)(a'x - kN') \u0026= 1 \u0026 (a = \\gcd(a, N)a', N = \\gcd(a, N)N') \\\\\n\\gcd(a, N) \u0026= 1 \\\\\n\\end{aligned}\n$$\n\nとなります。つまり $a$ と $N$ とが互いに素であれば $\\bmod N$ で $a$ の逆元が存在します。逆に $a$ が $0$ や $N$ の約数である場合は逆元が存在しません。\n\n具体的に法に対して逆元が存在する数を羅列すると\n\n$$\n\\begin{aligned}\n\\bmod 10 \u0026\\to 1, 3, 7, 9 \\\\\n\\bmod 11 \u0026\\to 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 \\\\\n\\bmod 12 \u0026\\to 1, 5, 7, 11 \\\\\n\\bmod 13 \u0026\\to 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12 \\\\\n\\bmod 14 \u0026\\to 1, 3, 5, 9, 11, 13 \\\\\n\\end{aligned}\n$$\n\n意外と逆元を取れる元が少ないですね。その中で法の数が素数のときは $0$ 以外の数と互いに素となるので任意の $0$ ではない元に対して逆元が存在します。また、逆元の逆元は元の数となるため、逆元を取れる集合に対して逆元を取っても元の集合と等しくなります。\n\n$$\n\\begin{aligned}\n1^{-1} \u0026= 1 \\pmod{10} \\\\\n3^{-1} \u0026= 7 \\pmod{10} \\\\\n7^{-1} \u0026= 3 \\pmod{10} \\\\\n9^{-1} \u0026= 9 \\pmod{10} \\\\\n\\{1, 3, 7, 9\\} \u0026= \\{1, 7, 3, 9\\}\n\\end{aligned}\n$$\n\nここで逆元を取れる集合、つまり $\\mathbb{Z}/N\\mathbb{Z}$ から $0$ や $N$ の約数を除いた集合を $(\\mathbb{Z}/N\\mathbb{Z})^\\times$ と名付けます。そして $(\\mathbb{Z}/N\\mathbb{Z})^\\times$ は乗法について群となります。特に素数 $p$ として $(\\mathbb{Z}/p\\mathbb{Z})^\\times$ は $0$ のみ除いた集合でとても扱いやすいです。\n\n$$\n\\begin{aligned}\n(\\mathbb{Z}/p\\mathbb{Z})^\\times \u0026= \\{1, 2, ..., p - 2, p - 1\\} \\\\\n\\end{aligned}\n$$\n\nこのように加法も乗法も群となっている集合を体と呼びます。体であると面倒くさい場合分けをしなくて済むのでしばらくは法を素数として考えます。法が合成数でも互いに素なら逆元がありますし、その後の定義、定理も互いに素なら大体成り立ちます。\n\nでは逆元について一通り分かったので実装してみましょう。\nTODO: 拡張ユークリッドの互除法\n\n-----\n\n加法、乗法の他にも実数の世界で扱うような演算を $N$ を法とする世界でも定義できます。\n\n#### 平方根・累乗根\nある数 $a$ に対し $x^2 = a \\pmod N$ となるような $x$ を $a$ の平方根 $\\sqrt{a}$ とする。また $x^n = a \\pmod N$ となる $x$ を $a$ の累乗根 $\\sqrt[n]{a}$ とする。\n\n平方根や累乗根の解は存在しない場合や複数ある場合などがあります。後述する乗法と加法の関係を証明する際に補題として証明するものを用いて、$x^n = 1 \\pmod p$ の解の個数は $\\gcd(n, p-1)$ 個だけ存在することを示せます。\n# 本当ですか？\n\n#### 対数\nある数 $e, a$ に対し $e^x = a \\pmod N$ となるような $x$ を $e$ を底とする $a$ の対数 $\\log_e{a}$ とする。\n\n対数に関しては原始根を底にすると解が一意に決まります。原始根とはその値を $a$ とおいて $a^k \\bmod{p} \\ (k=0, \\ldots, p-2)$ がそれぞれ違う値を取る数です。\n\n具体例\n\n$$\n\\begin{aligned}\n3 + 4 \u0026= 0 \u0026 \\pmod 7 \\\\\n3 - 4 \u0026= -1 = 6 \u0026 \\pmod 7 \\\\\n3 \\times 4 \u0026= 12 = 5 \u0026 \\pmod 7 \\\\\n3 \\div 4 \u0026= 3 \\times 4^{-1} = 3 \\times 2 = 6 \u0026 \\pmod 7 \\\\\n3^4 \u0026= 9^2 = 2^2 = 4 \u0026 \\pmod 7 \\\\\n\\sqrt{4} \u0026= 2, 5 \u0026 \\pmod 7 \\\\\n\\sqrt[3]{6} \u0026= 3, 5, 6 \u0026 \\pmod 7 \\\\\n\\log_3{6} \u0026= 3 \u0026 \\pmod 7 \\\\\n\\end{aligned}\n$$\n\n-----\n\nこれで剰余上の演算は一通りできるようになりました。さてコンピューターはこれらをどのようにして計算するのでしょうか。代表的なアルゴリズムで組んだ場合だと以下の表のようになります。(簡単の為、基本的な演算の計算量はビット数に依らないとする)\n\n| 演算                   | 方法                          | 計算量                      |\n| :--------------------  | :---------------------------- | :-------------------------: |\n| 足し算   $a + b$       | 足してN以上になったらN引く    | $O(1)$            |\n| 引き算   $a - b$       | 引いて0未満になったらN足す    | $O(1)$            |\n| 掛け算   $a \\times b$  | 掛けてNで割った余り           | $O(1)$            |\n| 割り算   $a \\div b$    | 拡張ユークリッドの互除法      | $O(\\log^2 N)$   |\n| 累乗     $a ^ e$       | 繰り返し二乗法                | $O(\\log N)$       |\n| 平方根   $\\sqrt{a}$    | Tonelli Shanksのアルゴリズム  | $O(\\log^2 N)$   |\n| 累乗根   $\\sqrt[e]{a}$ | Tonelli Shanksのアルゴリズム     | $O(\\min(N^{1/4},\\sqrt{e})\\log{e}\\log^2{N})$     |\n| 対数     $\\log_e{a}$   | 離散対数問題            | $O(\\sqrt{N})$     |\n(参考: [整数論テクニック集のpdf](https://kirika-comp.hatenablog.com/entry/2018/03/12/210446) など)\n\nそれぞれのアルゴリズムは参考などの資料を見てください。累乗は多項式時間しか掛かりませんが、累乗根や対数は指数時間掛かるということを頭の隅に置いておいてください。\n\nそれと剰余と合わせて、普段よく使っている整数 $\\mathbb{Z}$ 上での演算は $\\bmod N$ と対比して $\\mathrm{over}\\ \\mathbb{Z}$ と書くことにします。\n\nまとめ\n実数で扱っている演算は剰余でも同じようにできることがある。\n\n## 剰余上の掛け算と足し算\n\n剰余のことが少しわかった所で累乗について少し深く掘り下げてみます。\n\n累乗に関する有名な定理としてフェルマーの小定理があります。\n\n-----\n\n#### フェルマーの小定理\n$p$ を素数として、$a \\neq 0 \\pmod p$ のとき次の式が成り立つ。\n\n$$\na^{p-1} = 1 \\pmod p\n$$\n\n証明\n$a \\neq 0 \\pmod p$ より同値な $a^p = a \\pmod p$ を示す。$a = 1$ は自明で、 $a = k$ を仮定すると\n\n$$\n(k + 1)^p = k^p + {}_p\\mathrm{C}_1k + ... + 1 = k^p + 1 = k + 1 \\pmod p\n$$\n\nより数学的帰納法から成り立つ。\n\n-----\n\n数式だけだとあまり良くわからないので具体的に $\\bmod 7$ で考えてみます。 $a^k$ を計算した表がこちらになります。\n\n| k ＼ a |  1  |  2  |  3  |  4  |  5  |  6  |\n|:-----:|:---:|:---:|:---:|:---:|:---:|:---:|\n|   1   |  1  |  2  |  3  |  4  |  5  |  6  |\n|   2   |  1  |  4  |  2  |  2  |  4  |  1  |\n|   3   |  1  |  1  |  6  |  1  |  6  |  6  |\n|   4   |  1  |  2  |  4  |  4  |  2  |  1  |\n|   5   |  1  |  4  |  5  |  2  |  3  |  6  |\n|   6   |  1  |  1  |  1  |  1  |  1  |  1  |\n\nこのようにどんな $a$ を使って計算しても必ず $a^6 = 1$ になります。これが一般の素数 $p$ で法を取ったなら必ず $p-1$ 乗で $1$ となるという不思議な定理です。\n\nここではこの定理についてもう少し膨らませてみます。\n\nフェルマーの小定理では指数について考えましたが逆に対数について考えてみます。具体例として先ほどの $\\bmod 7$ で $\\log_3 n$ を計算してみます。\n\n|     $n$    |   $1$   |   $2$   |   $3$   |   $4$   |   $5$   |   $6$   |\n|:----------:|:-----:|:-----:|:-----:|:-----:|:-----:|:-----:|\n|  $n = 3^k$ | $3^0$ | $3^2$ | $3^1$ | $3^4$ | $3^5$ | $3^3$ |\n| $\\log_3 n$ |   $0$   |   $2$   |   $1$   |   $4$   |   $5$   |   $3$   |\n\nじっくり見てみると、対数を取ったもの同士の $\\bmod 6$ での足し算はそれに対応する値同士の $\\bmod 7$ の掛け算と一致しているということが見えてきます。\n\n$$\n\\begin{aligned}\n4 \u0026\\times 6 = 3 \\pmod 7 \\\\\n\u0026\\downarrow \\log_3 \\\\\n4 \u0026+ 3 = 1 \\pmod 6 \\\\\n\\end{aligned}\n$$\n\n他の素数で考えてみても同じような法則が成り立ち、一般に $\\bmod p$ での乗法は対数を取れば $\\bmod p - 1$ での加法に変換できるということが成り立ちそうです。このような性質を同型と呼び、記号 $\\cong$ を使って $(\\mathbb{Z}/p\\mathbb{Z})^\\times \\cong \\mathbb{Z}/(p−1)\\mathbb{Z}$ と表します。\n\n-----\n\n#### 乗法と加法の関係\n\n$$\n(\\mathbb{Z}/p\\mathbb{Z})^\\times \\cong \\mathbb{Z}/(p−1)\\mathbb{Z}\n$$\n\n証明\n任意の素数 $p$ の法で原始根が存在することを示す。\nまず $n$ が $p - 1$ の約数であるとき $x^n = 1$ は $n$ 個の解を持つことを示す。仮定より $p - 1 = nk$ とおけ、次のそれぞれの式について解の個数について考える。\n\n$$\nx^{p-1} - 1 = (x^n - 1)((x^n)^{k-1} + \\ldots + x^n + 1)\n$$\n\n$x^{p-1} - 1 = 0$ はフェルマーの小定理より $p - 1$ 個\n$(x^n)^{k-1} + \\ldots + x^n + 1 = 0$ は代数学の基本定理より $n(k-1)$ 個以下\nよって $x^{n} - 1 = 0$ は解の個数を比較して $n$ 個存在する。\n\nこれより $p-1$ と互いに素な数の個数だけ原始根が存在する。\n\n原始根 $a$ を1つ選んでくると $a^k \\bmod{p} \\ (k=0, \\ldots, p-2)$ はそれぞれ違う値を取り、$(\\mathbb{Z}/p\\mathbb{Z})^\\times, \\mathbb{Z}/(p−1)\\mathbb{Z}$ を対応させる。そして剰余上の指数法則 $a^m \\times a^n = a^{m + n} \\pmod p$ は成り立つ。よって $(\\mathbb{Z}/p\\mathbb{Z})^\\times \\cong \\mathbb{Z}/(p−1)\\mathbb{Z}$ である。\n\n-----\n\n:::details\nまた、法の数を素数から一般の自然数に一般化することができます。\n\n-----\n\n#### カーマイケルの定理\n\n$$\n\\begin{aligned}\n(\\mathbb{Z}/p_1^{e_1}\\ldots p_n^{e_n}\\mathbb{Z})^\\times \u0026\\cong (\\mathbb{Z}/p_1^{e_1}\\mathbb{Z})^\\times \\times \\ldots \\times (\\mathbb{Z}/p_n^{e_n}\\mathbb{Z})^\\times\\\\\n(\\mathbb{Z}/2^e\\mathbb{Z})^× \u0026≅ \\left\\{\n\\begin{array}{ll}\n\\mathbb{Z}/1\\mathbb{Z} \u0026 (e = 1) \\\\\n\\mathbb{Z}/2\\mathbb{Z} \\times \\mathbb{Z}/2^{e-2}\\mathbb{Z} \u0026 (e \\geq 2)\n\\end{array}\n\\right.\\\\\n(\\mathbb{Z}/p^e\\mathbb{Z})^× \u0026≅ \\mathbb{Z}/p^{e-1}(p−1)\\mathbb{Z} \\\\\n\\end{aligned}\n$$\n\n証明\nせきゅーんさんの記事がおすすめです。\nhttps://integers.hatenablog.com/entry/2016/07/24/163831\nhttps://integers.hatenablog.com/entry/2017/06/08/191649\n\n-----\n:::\n\nこうして掛け算を足し算に置き換えられ、問題が簡単にできることが多いです。\n\n#### RSA暗号が解ける？\nRSA暗号はこれを使えば簡単に解けます。\nRSAは $c = m^e \\pmod {N}$ という式について $e, c$ が分かっているので累乗根を求める問題なのですが、原始根 $a$ で対数を取るとカーマイケルの定理より\n\n$$\n\\begin{aligned}\nc \u0026= m^e \u0026 \\pmod {N} \\\\\nm \u0026= c^{1/e} \u0026 \\pmod {N} \\\\\n\\end{aligned}\n$$\n\nと累乗根を計算できます。\n\nここまでは数学の話でしたが、ここから計算機科学に移ります。\n\n確かに、掛け算を足し算に変換することで簡単な問題になります。しかし、それ以前にコンピュータが剰余上の対数を計算する事は結構難しく、離散対数問題 (DLP: Discrete Logarithm Problem) と呼ばれ、現在見つかっている最も速いアルゴリズムでも完全指数時間も掛かります。\n\nでは諦めて掛け算だけで解く、というだけではなく他に1つ方法があります。直接数に対応させなくても、ある数だけ累乗すると $1$ や $-1$ になるという情報を使うことである程度情報を引き出すことができます。いわゆる平方剰余と呼ばれるものなどです。\n\n$$\nn^{\\frac{p-1}{2}}\n$$\n\n例えば Tonelli Shanks のアルゴリズムは平方剰余を使っています。\n\n剰余上の平方根を計算することについてじっくり考えてみます。定義より $x^2 = a \\pmod p$ となる $x$ を求めればよいです。\nまずは具体的に $\\bmod 13$ の場合について平方根を全て求めてみます。\n\n| $n$ | $2^0$ | $2^1$ | $2^2$ | $2^3$ | $2^4$ | $2^5$ | $2^6$ | $2^7$ | $2^8$ | $2^9$ | $2^{10}$ | $2^{11}$ |\n|:--------:|:-:|:-:|:--:|:--:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|\n| $\\sqrt{n}$ | $2^0, 2^6$ | なし | $2^1, 2^7$ | なし | $2^2, 2^8$ | なし | $2^3, 2^9$ | なし | $2^4, 2^{10}$ | なし | $2^5, 2^{11}$ | なし |\n\nとこのようになります。\n\n例えば $\\sqrt{10} \\pmod{13}$ については $\\sqrt{10} = \\sqrt{2^{10}} = 2^5, 2^{11} = 6, 7 \\pmod{13}$ となります。このように DLP が解けるとき、つまり肩の数がわかるなら、それを半分にするだけで平方根となります。\n\nでは DLP が解けないときはどうすればよいのでしょうか。\n\n最初に思いつくのは $2^{-1} \\bmod p-1$ 乗すれば平方根になるということです。しかし $2$ と $p-1$ は互いに素ではないので $2$ の逆数を定義できません。なので一旦逆数を定義できるところだけやって、後で定義できない部分を考えることにします。\n\n$$\n(\\mathbb{Z}/13\\mathbb{Z})^×≅\\mathbb{Z}/12\\mathbb{Z}≅\\mathbb{Z}/3\\mathbb{Z}\\times\\mathbb{Z}/2^2\\mathbb{Z}\n$$\n\n中国剰余定理から上のように分解でき、$\\bmod 3$ なら $2$ の逆数が定義できるので $2^{-1} \\bmod 3  = 2$ 乗します。すると $10^2 = 9 \\pmod{13}$ となり、これは $9 = 2^8 \\pmod{13}$ で下の表をみるとしっかり $8$ は $5, 11$ のある $2 \\bmod 3$ の行にあります。ここから上下に動かさずに左右だけを動かして本当の平方根を求めます。\n\n| $\\times$ | 0 | 1 |  2 |  3 |\n|:--------:|:-:|:-:|:--:|:--:|\n|     0    | 0 | 9 |  6 |  3 |\n|     1    | 4 | 1 | 10 |  7 |\n|     2    | 8 | 5 |  2 | 11 |\n\n本当の平方根を求める為に誤差を取り除くことが必要です。誤差とは $x$ が平方根であれば $a^{-1}x^2 = 1 \\pmod p$ となるのに対し、現在仮に求まっている平方根が $x=9$ であるから $a^{-1}x^2 = 10^{-1}9^2 = 2 \\pmod{13}$ と異なっているこの誤差です。\n\nこの誤差をより詳しく調べる為に累乗して情報、肩の数の trailing zero ( $\\bmod 2^n$ 上)を求めます。trailing zero とは2進数で考えたときに末尾に0が何個あるのかというものです。例えば 8 であれば 1000 より 3 となり、10 であれば 1010 で 1 となります。\n\n例えば $s = a^{-1}x^2$ についてこんなことが成り立つとします。\n\n$$\ns \\neq 1, s^2 \\neq 1, s^4 \\neq 1, s^8 = 1\n$$\n\nこの場合、肩の数は1,2,4倍しても0にはならず、ちょうど8倍して0になる数であることがわかります。つまり $\\underbrace{bb1000\\ldots}_n$ というようになっているはずです(分からないビットは $b$ としています)。これより trailing zero は $n - 3$ と分かります。\n\nこれに加えて平方剰余ではない数 $u$ をランダムに取ってきて $q$ 乗します。平方剰余ではないので肩の数は奇数、つまり一番下のビットが $1$ であることが分かってます。するとこの肩の数を $n - 4$ だけ左シフトすればその2乗は $\\underbrace{bb1000\\ldots}_n$ となり、それと $x$ を掛け合わせることで$bb1000\\ldots + bb1000\\ldots = bb0000\\ldots$ と最下位ビットを 0 にできて誤差の対数の trailing zero を増やしていくことができます。そして最終的に全て 0 になったとき、誤差はなくなります。\n\nつまり $\\sqrt{a} \\pmod{p}$ を計算するには次を行えばよいです。\n\n1. $p - 1 = q \\times 2^e$ から $2^{-1} \\pmod q = (q + 1)/2$ 乗する。\n2. $a^{-1}x^2$ の対数の trailing zero $t$ を求め、非平方剰余 $u$ を用いて $\\mathrm{pow}(u^q, 2^{e - t - 1})$ を $x$ に掛けることを繰り返す。\n\nこれを Tonelli Shanks のアルゴリズムと呼びます。\n\nまとめ\n累乗は様々な情報を持っている。\n\n## RSA暗号\n\nようやくRSA暗号です。\n\nRSA暗号とは剰余上での累乗は簡単でも累乗根は難しいという非対称性を使った暗号です。\n\n事前に大きな素数 $p, q$ と自然数 $e$ を生成し、$N = pq$ を公開します。(素数生成の方法はコラムへ)\nそして平文 $m$ に対して暗号文を $m^e \\bmod N$ とします。そして復号化については逆に $e^{-1}$ 乗します。具体的にはカーマイケルの定理から $(\\mathbb{Z}/pq\\mathbb{Z})^×≅\\mathbb{Z}/\\mathrm{lcm}((p−1), (q-1))\\mathbb{Z}$ より $\\phi(N) = (p - 1)(q - 1)$ として $d = e^{-1} \\pmod{\\phi(N)}$ 乗すれば $m$ を復号できます。\n\n$$\n\\begin{aligned}\nc \u0026= m^e \u0026\\pmod N \\\\\nm \u0026= c^{d} \u0026\\pmod N\n\\end{aligned}\n$$\n\nここで $N, e$ を知っていても $p, q, d$ いずれも知らないとき、素因数分解の計算困難性から復号化は難しいとされています。これを用いた暗号をRSA暗号 (Rivest-Shamir-Adleman encryption) と呼びます。\n\n具体的には次の手順で暗号化された通信します。\n\n1. AliceがBobに公開鍵 $N, e$ を渡す\n2. Bobは公開鍵を用いて平文を暗号化\n3. BobからAliceへ暗号文を送る\n4. Aliceは秘密鍵 $p, q$ を用いて復号化し、平文を得る\n\nここに図\n\nこのようにして送っている最中に盗聴されても秘密鍵がなければ解読できず、安全な通信ができます。またこれ自体は一方向通信ですが、逆も同様に行えば双方向通信もできます。\n\n実装するにはそれぞれの具体的なパラメータについて知っておきましょう。\n$e$ は慣例的に `0x10001 = 65537` が使われています。攻撃されないような丁度よい大きさの数であり、かつ暗号化する際にバイナリ法を用いると素早く計算できる数であるという理由が挙げられます。\n\n```python\nfrom Crypto.Util.number import getPrime, long_to_bytes, bytes_to_long\n\np = getPrime(512)\nq = getPrime(512)\nN = p * q\nphi = (p - 1) * (q - 1)\ne = 0x10001\nd = pow(e, -1, phi)\n\ndef encrypt(plaintext):\n    m = bytes_to_long(plaintext)\n    c = pow(m, e, N)\n    cipher = long_to_bytes(c)\n    return cipher\n\ndef decrypt(cipher):\n    c = bytes_to_long(cipher)\n    m = pow(c, d, phi)\n    plaintext = long_to_bytes(m)\n    return plaintext\n\ncipher = encrypt(b\"This is RSA\")\nprint(cipher)\n#\nplaintext = decrypt(cipher)\nprint(plaintext)\n# This is RSA\n```\n\n:::details ライブラリの説明\n| pycryptodomeライブラリの関数 | 説明                                          |\n| :--                          | :--                                           |\n| `getPrime(n)`                  | n bit長のランダムな素数を生成                 |\n| `bytes_to_long(bytes)`         | バイト文字列をASCIIとしてデコードし数に変換   |\n| `long_to_bytes(n)`             | 数をASCIIとしてエンコードしバイト文字列に変換 |\n:::\n\n## 素因数分解\n\nもし巨大な数の素因数分解が簡単に解けるとするつまり公開鍵 N を素因数分解して秘密鍵 p,q が求められるとどうなるか。 ϕ,d を求められ、任意の暗号文を復号化できてしまいます。\n\n暗号化は簡単でも復号化は難しいという非対称性を用いて暗号は作られます。\n\n代表的な暗号の安全性の根拠\n- RSA暗号 素因数分解\n- ElGamal暗号 DLP\n- 楕円曲線暗号 ECDLP\n\n## 素因数分解する方法はなにがあるのか\n\n素因数分解アルゴリズムは Pollard-$\\rho$ 法、p-1 法などがありますが、今回は比較的簡単で汎用的に適用できる Pollard-$\\rho$ 法を紹介します。\n\n誕生日のパラドックスを聞いたことありますか？ 誕生日が同じな2人を見つけたいときに人を何人集めればそうなる確率が50%を超えるのかという問題です。鳩ノ巣原理から366人いれば必ず同じ誕生日の人が出てきます。さて、同じ誕生日の組が 50% の確率でいる場合、何人いればよいでしょうか。\n\n答えは 23 人いれば十分です。\n\nこれを使って素因数分解する方法があります。\n\n$\\bmod p$ 上で同じ2つの数を見つけたいときに $\\sqrt{p\\ln 4} \\fallingdotseq 1.18\\sqrt{p}$ だけ集めれば 50% の確率で見つかります。そしてその差は $p$ の倍数となっているため、これと $N$ で最大公約数を取って素因数 $p$ を求めることができます。\n\nコンピュータ上ではランダムな数を集める為に擬似的な乱数を生成する関数 $f$ を用いて最大公約数が $p$ になるまで回し続けます。\n\n$$\n\\begin{aligned}\nf(x) \u0026= x^2 + c \\pmod N \\\\\nx_{i+1} \u0026= f(x_i) \\\\\ny_{i+1} \u0026= f(f(y_i)) \\\\\np \u0026= \\gcd(N, |x_i - y_i|) \\\\\n\\end{aligned}\n$$\n\n計算量は $O(\\sqrt{p})$ で $N \\approx 10^{20}$ くらいまでなら現実的な時間で素因数分解できます。\nほんまか？\n\n上の方法だと完全指数時間掛かりますがそれより速い準指数時間のアルゴリズム、Index calculus や数体ふるい法などがあります。\n整数をランダムに選んできたとき、それは小さい素数、たとえば 2, 3, 5, 7 などのべき乗を掛け合わせたもの、言い換えると、これらの小さい素数だけで生成されるものになる確率は高いことが知られています。これらの小さな素数を「ファクターベース」これらの数が暗号に使われている数に比べて大変小さく、たとえばその準指数関数のサイズ\n\n:::details 量子コンピュータ\n最近は量子コンピュータが開発されており、古典計算機では指数時間掛かる問題も多項式時間で解けるようになるという画期的な技術です。素因数分解もその範疇であり、Shorのアルゴリズムを用いて $O((\\log⁡N)^2)$ です。\nそこで量子コンピュータでも解けないような暗号、耐量子暗号が開発されています。代表的な暗号は格子暗号や符号暗号などがあります。詳しくは楕円曲線暗号\n:::\n\n#### 近い値の素数を使ってはいけない (Fermat's Method)\n\n$p, q$ が近いと中心から順に調べることで素数の組を見つけられます。様々な探索の方法がありますが、以下のような方法がよく用いられています。\n\n$$\n\\begin{aligned}\nN \u0026= pq \\\\\n  \u0026= (x + y)(x - y) \\\\\n  \u0026= x^2 - y^2 \\\\\ny^2 \u0026= x^2 - N \\\\\n\\end{aligned}\n$$\n\nより初期値を $x = \\lceil\\sqrt N\\rceil, y = 0$ として $x$ の値を1ずつ上げながら $y$ の値も上げていき、右辺と左辺の計算結果が一致したとき $p, q$ が求まるという仕掛けです。\n\n#### 近似比\n前の問題だと素数 $p, q$ が近い値のときしか対応できませんが、素数同士の近似比 $p:q \\approx a:b$ が与えられる場合だったらどうでしょうか。([RSA暗号攻撃で他でも使える n のこと](https://project-euphoria.dev/blog/27-rsa-attacks/) より)\n\n:::details 解法\n$$\n\\begin{aligned}\n\\frac{a}{b} \u0026\\approx \\frac{p}{q} \\\\\naq \u0026\\approx bp \\\\\naq \\times bp \u0026= abN\n\\end{aligned}\n$$\n\nこれより $abN$ に対し Fermat's method を適用することで $p, q$ が求まります。\n:::\n\n## 攻撃\n\n実際のRSAではこのような攻撃が発見されてきました。\n\n| アンチケース                                                              | 攻撃技                                                           | 方法                                                   |\n| --------------------------------------                                    | ---------------------------------------------------------------- | -------------------------------------------------      |\n| 公開鍵 $N$ の値が小さくてはいけない                                       | Pollard-$\\rho$ 素因数分解法                                      | 素因数分解                                             |\n| 近い値の素数を使ってはいけない                                            | Fermat's method                                                  | 素因数分解                                             |\n| $e$ の値が小さすぎてはいけない                                            | Low Public Exponent Attack                                       | 剰余ではなく整数上のe乗根となる                        |\n| $d$ の値が小さすぎてはいけない($e$の値が大きすぎてはいけない)             | Wiener's Attack, Boneh-Durfee Attack                             | 近似分数から見積もる, Coppersmith Method               |\n| 同一の平文を異なる $e$ で暗号化した暗号文を与えてはいけない               | Common Modulus Attack                                            | $e$ について拡張ユークリッドの互除法                   |\n| 同一の平文を異なる $N$ で暗号化した暗号文を与えてはいけない               | Håstad's Broadcast Attack                                        | 中国剰余定理                                           |\n| 同一の平文を同一の $d$ 異なる $e, N$ で暗号化した暗号文を与えてはいけない | Small Common Private Exponent Attack                             | Coppersmith Method                                     |\n| 任意の暗号文を復号した結果を知られてはいけない                            | 適応的選択暗号文攻撃                                             | $a^ec$ を復号すると $am$ となる                        |\n| 暗号文を復号した結果の偶奇を知られてはいけない                            | LSB Decryption Oracle Attack                                     | 二分探索                                               |\n| RSA-CRTにバグがあってはならない                                               | RSA-CRT Fault Attack                                             | 秘密鍵が書き換えれると平文の差分が $p, q$ の倍数となる |\n| 上位ビットが共通する二つの平文に対する暗号文を知られてはいけない          | Franklin-Reiter Related Message Attack                           | 最大公約式                                             |\n| 秘密鍵が部分的にでも知られてはならない                                    | Partial Key Exposure Attack                                      | Coppersmith Method                                     |\n(参考: [RSA暗号運用でやってはいけない n のこと](https://www.slideshare.net/sonickun/rsa-n-ssmjp))\n\nこれらの攻撃手法はCrypto問を解く上で基本的なアイデアとなります。解き方やソースコードなど詳しいことは実践編で取り扱いますが、ここではそれぞれのアイデアの中で特に重要な性質をここで紹介します。\n\n#### まとめ\nRSA暗号は素因数分解の困難性が安全性の根拠である。\nうまく実装しないと素因数分解を解かなくても攻撃が出来てしまう。\n\n## 中国剰余定理\n\n// TODO 中国剰余定理とは\nこれを使えば大きな問題を小さな問題に分割して計算することができます。\n\n$$\n\\bmod pq \\iff \\bmod p, \\bmod q\n$$\n\n-----\n\n#### 中国剰余定理 (CRT: Chinese Remainder Theorem)\n\n$$\n\\mathbb{Z}/p_1^{e_1}\\ldots p_n^{e_n}\\mathbb{Z} \\cong \\mathbb{Z}/p_1^{e_1}\\mathbb{Z}\\times\\ldots \\times\\mathbb{Z}/p_n^{e_n}\\mathbb{Z}\n$$\n\n証明\n//TODO\n\n$$\n\\mathbb{Z}/pq\\mathbb{Z} \\cong \\mathbb{Z}/p\\mathbb{Z}\\times\\mathbb{Z}/q\\mathbb{Z}\n$$\n\nをユークリッドの互除法で証明すれば大体証明できる。\n\n-----\n\n例えば $\\mathbb{Z}/15\\mathbb{Z} \\cong \\mathbb{Z}/3\\mathbb{Z}\\times\\mathbb{Z}/5\\mathbb{Z}$ となるので法が15の数と法が3, 5の数のペアは1対1に対応させることができます。\n\n| $\\times$ |  0  |  1  |  2  |  3  |  4  |\n|:--------:|:---:|:---:|:---:|:---:|:---:|\n|    0     |  0  |  6  | 12  |  3  |  9  |\n|    1     | 10  |  1  |  7  | 13  |  4  |\n|    2     |  5  | 11  |  2  |  8  | 14  |\n\n数自体だけではなく加法、乗法についても対応します。\n\n$$\n\\begin{aligned}\n8 \u0026+ 9 = 2 \u0026 \\pmod{15} \\\\\n\u0026\\downarrow \\\\\n(2, 3) \u0026+ (0, 4) = (2, 2) \u0026 \\pmod{(3, 5)} \\\\\n\\end{aligned}\n$$\n\n$$\n\\begin{aligned}\n8 \u0026\\times 9 = 12 \u0026 \\pmod{15} \\\\\n\u0026\\downarrow \\\\\n(2, 3) \u0026+ (0, 4) = (0, 2) \u0026 \\pmod{(3, 5)} \\\\\n\\end{aligned}\n$$\n\nコンピュータではどう計算するのでしょうか。\nまずは $\\bmod pq \\to \\bmod p, \\bmod q$ についてです。これは簡単で $a \\bmod p$ と $a \\bmod q$ を計算すればよいです。なぜかというと\n\n$$\n\\begin{aligned}\na \\bmod{pq} \\bmod{p} \u0026= (a - k_1pq) - k_2p \\\\\n\u0026= a - (k_1q + k_2)p \\\\\n\u0026= a \\bmod{p} \\\\\n\\end{aligned}\n$$\n\nとなるからです。注意すべきなのは2つが約数の関係となる剰余でしかこのような式は有効ではないです。例えば有効ではない式として $20 \\bmod 15 \\bmod 9 \\neq 20 \\bmod 9$ があります。\n\n逆に $\\bmod p, \\bmod q \\to \\bmod pq$ はどうやって計算するのでしょうか。この操作は持ち上げ(lift)とよばれていて、Garnerのアルゴリズムを用いて持ち上げます。\n\nこのような関係があるとします。\n\n$$\n\\begin{cases}\nx = r_1 \\pmod{m_1} \\\\\nx = r_2 \\pmod{m_2} \\\\\n\\end{cases}\n$$\n\nこれに対しては次のようにすることで持ち上げることができます。\n\n$$\n\\begin{aligned}\nx + q_1m_1 \u0026= r_2 \u0026 \\pmod{m_2} \\\\\nq_1m_1 \u0026= r_2 - x \u0026 \\pmod{m_2} \\\\\nq_1 \u0026= (r_2 - x)m_1^{-1} \u0026 \\pmod{m_2} \\\\\nx \u0026= x + (r_2 - x)(m_1^{-1} \\bmod{m_2})m_1 \u0026 \\pmod{m_1m_2} \\\\\n\\end{aligned}\n$$\n\n例えば「3 で割ったあまりが 2」かつ「5 で割ったあまりが 3」であるようなものは $2 + (3 - 2)2\\times3 = 8 \\pmod{15}$ となります。\n\nこれで中国剰余定理をコンピュータで再現できました。それではこれを使った代表的な攻撃について紹介します。\n\n#### 同一の平文を異なる $N$ で暗号化した暗号文を与えてはいけない(Håstad's Broadcast Attack)\n\n同一の平文を異なる $e$ 個の $N$ で暗号化した暗号文を与えられたとします。\n\n$$\n\\begin{cases}\nc_1 = m^e \\pmod{N_1} \\\\\nc_2 = m^e \\pmod{N_2} \\\\\n\\qquad \\vdots \\\\\nc_e = m^e \\pmod{N_e} \\\\\n\\end{cases}\n$$\n\nこれらの暗号文を中国剰余定理によって整数上の $m^e$ を作り $e$ 乗根して平文 $m$ を得られます。\n\n$$\n\\begin{aligned}\nm^e \u0026= \\mathrm{CRT}(c_1, c_2, \\ldots, c_e) \\pmod{N_1N_2\\ldots N_e} \\\\\n\u0026= \\mathrm{CRT}(c_1, c_2, \\ldots, c_e) \\quad (\\mathrm{over} \\ \\mathbb{Z}) \\\\\n\\end{aligned}\n$$\n\n#### Smooth な ElGamal暗号\n\n累乗を求めることは簡単でもDLPが難しいという非対称性を用いた暗号が ElGamal暗号 です。通常は素数を法としますが、多くの小さな素数で割り切れるようなsmoothな数を法とした場合はどうなるのか考えてみます。\n\n$$\nc = a^{m} \\pmod{p_1p_2\\ldots p_n}\n$$\n\nまずは素因数分解をします。今回はそれぞれの素数が小さいので Pollard-$\\rho$ 法を用いて素因数分解できます。そして暗号文をそれぞれの素因数について剰余を取ります。\n\n$$\n\\begin{aligned}\nc_1 \u0026= a^{m_1} \\pmod{p_1} \\\\\nc_2 \u0026= a^{m_2} \\pmod{p_2} \\\\\n\\vdots \\\\\nc_n \u0026= a^{m_n} \\pmod{p_n} \\\\\n\\end{aligned}\n$$\n\nそれぞれの式の法の数が小さいので DLP が解けます。\n\n$$\n\\begin{aligned}\nm_1\u0026 \\pmod{p_1 - 1} \\\\\nm_2\u0026 \\pmod{p_2 - 1} \\\\\n\\vdots \\\\\nm_n\u0026 \\pmod{p_n - 1} \\\\\n\\end{aligned}\n$$\n\nそれらを持ち上げることで平文を求めることができます。\n\n$$\nm = \\mathrm{CRT}(m_1, m_2, \\ldots, m_n)\n$$\n\n#### RSA-CRT Fault Attack\n\nRSAの復号をする際に $c^d$ を計算しますが、 $d = e^{-1} \\pmod {\\phi (N)}$ は比較的大きいので処理が重くなります。これに対してRSA-CRTは中国剰余定理(CRT)を用いて高速化を図っています。\n\n$$\n\\begin{aligned}\n\u0026\\begin{cases}\nd_p = d \u0026 \\pmod{p-1} \\\\\nd_q = d \u0026 \\pmod{q-1} \\\\\n\\end{cases} \\\\\n\u0026\\begin{cases}\nm_p = c^{d_p} \u0026 \\pmod p \\\\\nm_q = c^{d_q} \u0026 \\pmod q \\\\\n\\end{cases} \\\\\n\u0026\\quad \\ m = \\mathrm{CRT}(m_p, m_q) \u0026 \\pmod {N} \\\\\n\u0026\\qquad \\ = m_q + (m_p - m_q) (q^{-1} \\bmod p) q \u0026 \\pmod {N} \\\\\n\\end{aligned}\n$$\n\nこれより下の値を秘密鍵として持つことになります。\n\n$$\n\\begin{aligned}\nd_p \u0026= d \\bmod p−1 \\\\\nd_q \u0026= d \\bmod q−1 \\\\\nq_{inv} \u0026= q^{-1} \\bmod p \\\\\n\\end{aligned}\n$$\n\nしかし $d_p, d_q$ のどちらかが何らかの方法で書き換えられてしまったとき次のようにできます。\n\n$$\n\\begin{aligned}\nm_p \u0026= c^{d_p} \\pmod p \\\\\nm_q' \u0026= c^{d_q'} \\pmod q \\\\\nm \u0026= \\mathrm{CRT}(m_p, m_q) = kp + m_p \\\\\nm' \u0026= \\mathrm{CRT}(m_p, m_q') = k'p + m_p \\\\\n|m - m'| \u0026= |k - k'|p \\\\\np \u0026= \\gcd(|m - m'|, N) \\\\\n\\end{aligned}\n$$\n\nこれより元々の平文と書き換えられた平文の差が素数の倍数となり、解くことができます。\n\n## 一般の方程式を解く\n\nここからが本題です！！\nRSAというe次方程式の解を求めるだけに絞らず、任意の方程式を解くことができたらうれしいですよね。さっそく考えてみましょう。\n\n$$\n\\begin{cases}\n2x + 3y = 2 \u0026 \\pmod{13} \\\\\n3x + 5y = 1 \u0026 \\pmod{13} \\\\\n\\end{cases}\n$$\n\nまずは簡単そうな連立方程式を解くことを考えてみます。上の方程式を加減法を用いて解いてみます。中学生の頃を思い出しますね。\n\n$$\n\\begin{aligned}\n\u0026\\begin{cases}\n2x + 3y = 2 \u0026 \\pmod{13} \\\\\n3x + 5y = 1 \u0026 \\pmod{13} \\\\\n\\end{cases} \\\\\n\\iff\u0026\\begin{cases}\n6x + 9y = 6 \u0026 \\pmod{13} \\\\\n6x + 10y = 2 \u0026 \\pmod{13} \\\\\n\\end{cases} \\\\\n\\iff\u0026\\begin{cases}\nx = 7 \u0026 \\pmod{13} \\\\\ny = 9 \u0026 \\pmod{13} \\\\\n\\end{cases} \\\\\n\\end{aligned}\n$$\n\n普通の方程式と同様に解けました！\nより一般の連立方程式を解く為に行列を用いて解いてみます。拡大係数行列にしてガウスの消去法を行います！大学1年の復習ですね。\n\n$$\n\\begin{aligned}\n\\begin{pmatrix}\n2 \u0026 3 \\\\\n3 \u0026 5 \\\\\n\\end{pmatrix}\n\\begin{pmatrix}\nx \\\\\ny \\\\\n\\end{pmatrix}\n\u0026=\\begin{pmatrix}\n2 \\\\\n1 \\\\\n\\end{pmatrix} \\\\\n\n\\left(\n\\begin{array}{cc|c}\n2 \u0026 3 \u0026 2 \\\\\n3 \u0026 5 \u0026 1 \\\\\n\\end{array}\n\\right)\n\u0026\\to\n\\left(\n\\begin{array}{cc|c}\n0 \u0026 -1 \u0026 4 \\\\\n1 \u0026 2 \u0026 -1 \\\\\n\\end{array}\n\\right) \\\\\n\n\u0026\\to\n\\left(\n\\begin{array}{cc|c}\n1 \u0026 0 \u0026 7 \\\\\n0 \u0026 1 \u0026 9 \\\\\n\\end{array}\n\\right) \\\\\n\n\\begin{pmatrix}\nx \\\\\ny \\\\\n\\end{pmatrix}\n\u0026=\\begin{pmatrix}\n7 \\\\\n9 \\\\\n\\end{pmatrix} \\\\\n\\end{aligned}\n$$\n\n一般の連立方程式は次のように解けます。行列の次元が行数と一致すれば逆行列が存在します。\n\n$$\n\\begin{aligned}\nA\\mathbf{x} \u0026= \\mathbf{b} \\\\\n\\mathbf{x} \u0026= A^{-1}\\mathbf{b}\n\\end{aligned}\n$$\n\n$$\n\\begin{aligned}\nA = \\begin{pmatrix}\na_{11} \u0026 a_{12} \u0026 \\ldots \u0026 a_{1n} \\\\\na_{21} \u0026 a_{22} \u0026 \\ldots \u0026 a_{2n} \\\\\n\\vdots \u0026 \\vdots \u0026 \\ddots \u0026 \\vdots \\\\\na_{m1} \u0026 a_{m2} \u0026 \\ldots \u0026 a_{mn}\n\\end{pmatrix}\n\u0026\u0026\n\\mathbf{x} = \\begin{pmatrix}\nx_1 \\\\\n\\vdots \\\\\nx_n \\\\\n\\end{pmatrix}\n\u0026\u0026\n\\mathbf{b} = \\begin{pmatrix}\nb_1 \\\\\n\\vdots \\\\\nb_m \\\\\n\\end{pmatrix}\n\\pmod{p}\n\\end{aligned}\n$$\n\nなるほど。次元が式の数と一致する連立1次方程式は必ず解けそうですね。\n\nでは与えられる1次方程式が1つのみであればどうでしょうか。複数の解が出てきますが、その中で具体的な解を1つ返したいと思います。\n\n$$\na_1x_1 + a_2x_2 + \\ldots + a_nx_n = b \\pmod N\n$$\n\n1変数方程式であれば逆元を掛けて解けますが、2変数、3変数、n変数の場合だと難しそうです。\n\nこれに対抗し得るCrypto界最強の道具があります。LLL 基底簡約アルゴリズムです。詳しいことは格子暗号の回で紹介しますが、行列の値が全体的に小さくなるように変形してくれます。\n\nそれだけ？と言われそうですがこれがとても強くてRSA暗号以外にもナップサック暗号、格子暗号、楕円曲線暗号に使えたりします。\n\nこれをどうやって方程式に適用するかというと次のような行列を考えます。\n\n$$\n\\begin{pmatrix}\n1 \u0026 0 \u0026 0 \u0026 \\ldots \u0026 ? \u0026 ? \\\\\n0 \u0026 1 \u0026 0 \u0026 \\ldots \u0026 ? \u0026 ? \\\\\n0 \u0026 0 \u0026 1 \u0026 \\ldots \u0026 ? \u0026 ? \\\\\n\\vdots \u0026 \\vdots \u0026 \\vdots \u0026 \u0026 \\vdots \u0026 \\vdots \\\\\n0 \u0026 0 \u0026 0 \u0026 \\ldots \u0026 N \u0026 N \\\\\n\\end{pmatrix}\n$$\n\n例えば、\n\n$$\n8053x+343y+1362z\n$$\n\nの絶対値を小さくするような、全てが0ではない $x, y, z$ の値を求めたいときは、\n\n$$\n\\begin{pmatrix}\n1 \u0026 0 \u0026 0 \u0026 8053 \\\\\n0 \u0026 1 \u0026 0 \u0026 343 \\\\\n0 \u0026 0 \u0026 1 \u0026 1362 \\\\\n\\end{pmatrix}\n$$\n\nをLLLに投げれば良いです。実際に投げたら、次の答えが返ってきました。\n\n$$\n\\begin{pmatrix}\n0 \u0026 -4 \u0026 1 \u0026 -10 \\\\\n-3 \u0026 -5 \u0026 19 \u0026 4 \\\\\n-2 \u0026 35 \u0026 3 \u0026 -15 \\\\\n\\end{pmatrix}\n$$\n\n例えば2行目は、$x=−3, y=−5, z=19$ という解に対応しています。\n\n$$\n8053 \\times (−3) + 343 \\times (−5) + 1362 \\times 19 = 4\n$$\n\n応用すると解がある程度小さなことが分かっていると次のようにできます。\n\n$$\na_1x_1 + a_2x_2 + a_3x_3 + b = 0 \\pmod N \\\\\nx_1 \u003c 2^{32}, x_2 \u003c 2^{16}, x_3 \u003c 2^{8}\n$$\n\n定数は1回しか使ってはいけないという気持ちを込めて大きな数を設定して、他は解の制約に合わせて設定します。最下段は法の数を入れておくことで剰余上で計算してくれます。\n\n$$\n\\begin{pmatrix}\n1 \u0026 0 \u0026 0 \u0026 0 \u0026 a_1 \\\\\n0 \u0026 2^{16} \u0026 0 \u0026 0 \u0026 a_2 \\\\\n0 \u0026 0 \u0026 2^{24} \u0026 0 \u0026 a_3 \\\\\n0 \u0026 0 \u0026 0 \u0026 2^{32} \u0026 b \\\\\n0 \u0026 0 \u0026 0 \u0026 0 \u0026 N \\\\\n\\end{pmatrix}\n$$\n\n詳しくは次の記事で紹介されています。\n\nhttps://qiita.com/kusano_k/items/5509bff6e426e5043591\n\n一般の線形方程式は解けるようになりました！\nやったね！\n\nこうなってくると1次方程式だけではなく2次、3次、n次方程式も解いてみたいですね。\nまずは次のような方程式を考えてみます。\n\n$$\na_nx^n + \\ldots + a_1x + a_0 = 0 \\pmod N\n$$\n\n$x, y = x^2, z = x^3, \\ldots$ というように変数を設定してLLLで乗り切るという方法が1つあります。しかし $x, y, z$ には関係性という情報を失っています。それをうまく使ってあげたいですね。\nそこでHowgrave-Grahamの補題というものがあります。\n\n-----\n\n#### Thm. Howgrave-Grahamの補題\n$N$ を法、 $g(x) \\in \\mathbb{Z}[x]$ を整数多項式とし、含まれる単項式の数を $\\omega$ とする。$g(x)$ に対してある $X$ が存在し、$g(x_0) = 0 \\pmod{N}$ なる $x_0 \\in \\mathbb{Z}$ について $|x_0| \\leq X$ であると仮定する。このとき\n\n$$\n\\|g(xX)\\| \u003c \\frac{N}{\\sqrt{\\omega}}\n$$\n\nが成立するならば $g(x_0) = 0$ が整数方程式として成立する。ただし\n\n$$\n\\|g(x)\\| = \\left\\|\\sum_{i=0}^{\\deg g(x)}g_i\\right\\| = \\sqrt{\\sum_{i=0}^{\\deg g(x)}g_i^2}\n$$\n\nであり、 $\\deg g(x)$ は $g(x)$ の次数である。\n\n証明\n\n$$\n\\begin{aligned}\n|g(x_0)| \u0026= \\left|\\sum_{i=0}^{\\deg g(x_0)}g_ix_0^i\\right| \\\\\n\u0026\\leq \\sum_{i}|g_ix_0^i| \\\\\n\u0026\\leq \\sum_{i}|g_i|X^i \\\\\n\u0026= \\sum_{i}(1\\cdot|g_i|X^i) \\\\\n\u0026\\leq \\sqrt{\\sum_{i, g_i \\neq 0}1} \\sqrt{\\sum_{i}(|g_i|X^i)^2} \u0026\u0026 \\left(\\because \\text{コーシー＝シュワルツの不等式}\\right) \\\\\n\u0026= \\sqrt{\\omega}\\|g(xX)\\| \u003c N \u0026\u0026 \\left(\\because \\|g(xX)\\| \u003c \\frac{N}{\\sqrt{\\omega}}\\right)\n\\end{aligned}\n$$\n\n$g(x_0) = 0 \\pmod N$ より $g(x_0) = 0$ となる。\n\n-----\n\nつまり、「剰余の方程式は係数がある程度小さければそのまま整数方程式となるよ」と言っています。ここで勘のいい人はLLLを用いて係数を小さくすれば整数方程式に変換できて解けるのでは...！？と気付くでしょう。実際に考えてみましょう。\n\nとりあえず状況を整理すると、LLLに入れる値は各係数として、LLLを使う為には複数の方程式が必要になってきます。そしてそれらの方程式は同じ解を持つ必要があります。現在、その解が分からないのですが、どうしたらそんな方程式が作れるでしょうか。\n\n実は $\\bmod {N}$ では難しいので、$\\bmod {N^m}$ に持ち上げることで同じ解の方程式を増やすことができます。\n\n-----\n\n#### Lemma\n$N$ を法、$f(x)$ を多項式とする。自然数 $m, l$ について\n\n$$\ng_{i,j}(x) := N^{m−i}x^j f^i(x) \\ (0 \\leq i \\leq m, 0 \\leq j\\leq l)\n$$\n\nとおく。このとき、 $f(x_0) = 0 \\pmod N$ をみたす $x_0 \\in \\mathbb{Z}$ について、 $g_{i,j}(x_0) = 0 \\pmod{N^m}$ となる。\n\n証明\n\n$f(x_0) = 0 \\pmod N$ なので $f(x_0) = kN$ とおける。\n\n$$\n\\begin{aligned}\ng_{i,j}(x_0) \u0026= N^{m−i}x_0^j f^i(x_0) \\\\\n\u0026= N^{m−i}x_0^j (kN)^i \\\\\n\u0026= k^ix_0^j N^m \\\\\ng_{i,j}(x_0) \u0026= 0 \\pmod{N^m} \\\\\n\\end{aligned}\n$$\n\n-----\n\nこれで方程式を増やすことができました！ちゃんとLLLで動くかちょっと不安ですがとりあえずやってみます。\n\n小さくしたい方程式は $g_{i,j}(xX)$ であることに注意して。\n$g_{i,j}(x)$ の $k$ 次の係数のことを $g_{i,j}^{(k)}$ と表すことにします。\n\n$$\n\\begin{pmatrix}\ng_{0,0}^{(0)} \u0026 g_{0,0}^{(1)}X \u0026 g_{0,0}^{(2)}X^2 \u0026 g_{0,0}^{(3)}X^3 \u0026 g_{0,0}^{(4)}X^4 \u0026 g_{0,0}^{(5)}X^5 \\\\\ng_{0,1}^{(0)} \u0026 g_{0,1}^{(1)}X \u0026 g_{0,1}^{(2)}X^2 \u0026 g_{0,1}^{(3)}X^3 \u0026 g_{0,1}^{(4)}X^4 \u0026 g_{0,1}^{(5)}X^5 \\\\\ng_{1,0}^{(0)} \u0026 g_{1,0}^{(1)}X \u0026 g_{1,0}^{(2)}X^2 \u0026 g_{1,0}^{(3)}X^3 \u0026 g_{1,0}^{(4)}X^4 \u0026 g_{1,0}^{(5)}X^5 \\\\\ng_{1,1}^{(0)} \u0026 g_{1,1}^{(1)}X \u0026 g_{1,1}^{(2)}X^2 \u0026 g_{1,1}^{(3)}X^3 \u0026 g_{1,1}^{(4)}X^4 \u0026 g_{1,1}^{(5)}X^5 \\\\\ng_{2,0}^{(0)} \u0026 g_{2,0}^{(1)}X \u0026 g_{2,0}^{(2)}X^2 \u0026 g_{2,0}^{(3)}X^3 \u0026 g_{2,0}^{(4)}X^4 \u0026 g_{2,0}^{(5)}X^5 \\\\\ng_{2,1}^{(0)} \u0026 g_{2,1}^{(1)}X \u0026 g_{2,1}^{(2)}X^2 \u0026 g_{2,1}^{(3)}X^3 \u0026 g_{2,1}^{(4)}X^4 \u0026 g_{2,1}^{(5)}X^5 \\\\\n\\end{pmatrix}\n$$\n\nこれをLLLに通してあげると無事小さな値の方程式が返ってきます。これがHowgrave-Grahamの補題を満たしていれば整数方程式となります。後は適当に増減表書いたりして探索すれば解けます。\n\n### ほんまか？\n\nこれらの操作はCoppersmithの定理と呼ばれています。\n\n-----\n\n#### Thm. Coppersmithの定理\n$N$ を法とし $f(x)$ をモニックな 1変数 $\\delta$ 多項式とする。このとき $f(x_0) = 0 \\pmod{N}$ と次の条件を満たすような $x_0$ を効率よく求めることができる\n\n$$\n|x_0| \\leq N^{\\frac{1}{\\delta}}\n$$\n\n-----\n\nこれで一般のn次方程式について小さな解を求めることができるようになりました！\n\n// TODO ここに具体例\n\n$$\nax^5 + bx + c = 0\n$$\n\nさらにCoppersmithの定理には拡張できることが2つあります。\n\n- 未知の法について解ける。素因数分解が出来ないほど大きな数を法としたときに既知の法の約数を法とする式の解を求められます。法が小さいほど方程式に対する制約がゆるくなります。\n- 多変数の方程式も解ける。これは変数が1つだけでしたが、複数の変数でもできます。変数の数が多いほど方程式に対する制約がキツくなります。\n\nこれらは Howgrave-Grahamの補題 などを見直すことで簡単に拡張できます。興味ある方は考えてみてください。\n\nこれらをまとめてCoppersmith Methodと呼びます。\n\nこれを使って様々な攻撃ができます。\nCoppersmith Method はRSAをそのまま与えても解けませんが何かしらの値が一部分だけ分かっていると解けるというものです。\n\n解きたい方程式の法の数の下限 $\\beta$ と解が存在しうる上限 $X$ を決めて関数を与えると解が返ってきます。\n\n### Boneh-Durfee Attack\n\nまず以下のように変形します。\n\n$$\n\\begin{aligned}\ned \u0026= 1 \u0026 \\pmod{\\phi} \\\\\ned \u0026= k \\phi + 1 \u0026 (\\mathrm{over}\\ \\mathbb{Z}) \\\\\n0 \u0026= k \\phi + 1 \u0026 \\pmod e \\\\\n\u0026= k (N + 1 - p - q) + 1 \u0026 \\pmod e \\\\\n\u0026= 2k \\left(\\frac{N + 1}{2} + \\frac{-p -q}{2}\\right) + 1 \u0026 \\pmod e \\\\\n\\end{aligned}\n$$\n\nこの方程式について $f(x,y) = x (A + y) + 1$ とおき、関数 $f(x,y)$ に対して Coppersmith Method を用いることで $p + q$ が求まり、解くことができます。\n\n### 秘密鍵が部分的にでも知られてはいけない (Partial Key Exposure Attack)\n\n秘密鍵を部分的に知っていさえいれば、Coppersmith Method を用いて解けてしまう。\n$n$ を $N$ のビット数とする。\n\n#### p, q のどちらかを n/4 ビット程度知っているとき\n\n例えば p を部分的に知っているときこのような関数を作ります。\n\n$$\n\\begin{aligned}\nf(x) \u0026= p_{upper} + x \u0026 \\pmod N \\\\\nf(x) \u0026= 2^{k}x + p_{lower} \u0026 \\pmod N \\\\\nf(x,y) \u0026= 2^kx + p_{mid} + y \u0026 \\pmod N \\\\\n\\end{aligned}\n$$\n\nこれに対して法の数を $p$ としたいので $\\beta \\approx 0.3$ として、実行すると出てきます。\n\n#### d を n/4 ビット程度知っているとき\n\n$e$ が総当り出来るくらい小さいときに $d$ を $n/4$ ビットだけ知っていれば元の $d$ を構成できる。大体の場合は $e = 65537$ であるから十分可能である。$d \u003c \\phi(N)$ より $0 \u003c k \\leq e$ となり、この $k$ に対して総当たりする。\n\n##### 上位ビットの場合\n$d$ と $p, q$ の関係式を立てる。\n\n$$\n\\begin{aligned}\ned \u0026= 1 \u0026 \\pmod{\\phi(N)} \\\\\ned \u0026= 1 + k(N - p - q + 1) \\\\\nd \u0026= \\frac{kN}{e} - \\frac{k(p+q-1) -1}{e} \\\\\ne(d_{upper} + x) \u0026= - k (y - 1) + 1 \u0026 \\pmod N \\\\\n\\end{aligned}\n$$\n\n第三式について $p + q \\approx \\sqrt{N}$ より第二項は上位ビットに関連する情報を持たない。これより第一項の $k$ について総当りして上位ビットと一致する $k$ を見つければよい。すると第4式に対し Coppersmith Method を用いて、$d$ がわかる。\n\n##### 下位ビットの場合\nまずは $d$ の下位ビットから $p$ の下位ビットを求める。\n\n$$\n\\begin{aligned}\ned \u0026= 1 + k\\left(N - p - \\frac{N}{p} + 1\\right) \\\\\nedp \u0026= p + kp(N - p + 1) - kN \u0026 \\pmod {2^{n/4}} \\\\\n\\end{aligned}\n$$\n\n $k$ について総当りして $p$ の最下位ビットを求める。すると先程の問題に帰着できて $p$ がわかり $d$ がわかる。\n\n\n#### RSA-CRT の秘密鍵 d を n/4 ビット程度知っているとき\n\n$$\n\\begin{aligned}\ned_p \u0026= 1 \u0026 \\pmod{p-1} \\\\\ned_p \u0026= 1 + k_p(p − 1) \\\\\n\\end{aligned}\n$$\n\n上と同様です。\n\n#### 平文 m を (1-1/e)n ビット程度知っているとき\n\n次数が大きいのである程度知っていないと解けません。\n\n$$\n\\begin{aligned}\nf(x) \u0026= (m_{upper} + x)^e - c \u0026 \\pmod N \\\\\nf(x) \u0026= (2^kx + m_{lower})^e - c \u0026 \\pmod N \\\\\nf(x,y) \u0026= (2^kx + m_{mid} + y)^e - c \u0026 \\pmod N \\\\\n\\end{aligned}\n$$\n\n\nこのようにある程度知っているとCoppersmith Methodで解けるものが多いです。\n\nCoppersmith method を使ったより様々な攻撃を知りたければ次の資料を読むことををおすすめします。\n\nhttps://eprint.iacr.org/2020/1506.pdf\n\n### その他の道具\n\nさて多変数連立n次方程式の場合はどうでしょう。Coppersmithも使うこともできますが、精度は出にくいです。これに対して使われる道具は多項式GCD, 終結式, Gröbner基底があります。\n\n#### 多項式GCD\n\nまずは多項式GCDです。\n例えば $x$ について同じ解を持つ次のような方程式を考えてみましょう。\n\n$$\n\\begin{cases}\nf_1 = x^e - c_1 \u0026 \\pmod{N} \\\\\nf_2 = (x + y)^e - c_2 \u0026 \\pmod{N} \\\\\n\\end{cases} \\\\\n$$\n\nこれは多項式GCDを取ると解けます。その名の通り、ある2つの方程式に公約式があったとき、最も次数が大きい公約式を返します。Half-GCDというアルゴリズムを用いると $O(N(\\log{N})^2)$ でGCDが取れます。(N is 何)\n\n$$\n\\begin{aligned}\n\u0026\\begin{cases}\nf_1 = x^e - c_1 \u0026 \\pmod{N} \\\\\nf_2 = (x + y)^e - c_2 \u0026 \\pmod{N} \\\\\n\\end{cases} \\\\\n\\iff\n\u0026\\begin{cases}\nf_1 = (x - m)g_1 \u0026 \\pmod{N} \\\\\nf_2 = (x - m)g_2 \u0026 \\pmod{N} \\\\\n\\end{cases} \\\\\n\u0026\\gcd(f_1, f_2) = x - m\n\\end{aligned}\n$$\n\n#### 終結式\n式増やしてgcd\n\n#### Gröbner基底\n\nGröbner基底のお気持ちは多項式イデアルを格子にしたものに対して順序を与えて基底簡約するものです。\n\n\n\nBuchberger's Algorithmと呼ばれています。\n\n\n表に解き方をまとめるとこんな感じです。\n\n|            |           1変数          |               多変数              |\n|:----------:|:------------------------:|:---------------------------------:|\n| 線型方程式 | 拡張ユークリッドの互除法 |                LLL                |\n|  n次方程式 |    Coppersmith Method    | 多項式GCD, 終結式, Gröbner基底 |\n\n\n\n## 理論編まとめ\n\nこのようにしてRSA暗号は解くことは出来ます。\n\nこれらを知っておけばRSA暗号の研究論文が追えるようになっていると思います。\n興味がある人は暗号に特化した論文サイト [ePrint Archive](https://eprint.iacr.org/) を覗いてみると良いと思います。\n\n## コラム 素数生成\n\n暗号として機能する素数の大きさは $2^{512}$ や $2^{1024}$ 程度のオーダーとなっています。素数定理より、ある数 $n$ が素数である確率は約 $1/\\log n$ です。例えば $n=2^{512}$ で2.8%、 $n=2^{1024}$ で1.4%となります。つまり、500回乱数を生成すれば99.65%で素数を見つけられるということです。\n素数判定のアルゴリズムは多くありますが、ここではMiller-Rabin素数判定法を紹介します。\n\n#### Miller–Rabin 素数判定法\n\n素数判定法とはその名の通り、数を与えるとそれが素数かどうかが分かる判定法です。その中で Miller-Rabin 素数判定法は与えられた数 $n$ が素数かどうかを計算時間 $O(k\\log^3 n)$ で誤り率 $4^{-k}$ 以下で判定する確率的素数判定アルゴリズムです。\n\n$n$ が素数のとき、$n-1$ はそれを $2$ で割れるだけ割った数を $d$ として $n-1 = 2^sd$ と書けます。フェルマーの小定理より $a≠0 \\pmod n$ のとき\n\n$$\n\\begin{aligned}\na^{n-1} \u0026= a^{2^sd} ≡ 1 \\quad \\pmod n \\\\\na^{2^sd}-1 \u0026= (a^d-1)(a^d+1)(a^{2d}+1)(a^{4d}+1)\\cdots(a^{2^{s-1}d}+1)\\\\\n\u0026≡ 0 \\\\\n\\end{aligned}\n$$\n\nこれより次の2式のどちらかが成り立ちます。\n\n$$\n\\begin{aligned}\n\\left\\{\n\\begin{array}{ll}\na^d \u0026≡ 1 \u0026 \\pmod n \\\\\na^{2^rd} \u0026≡ -1 \u0026 \\pmod n \\qquad (\\exists r \\in \\mathbb{Z}, 0\\leq r\\leq s-1)\n\\end{array}\n\\right.\n\\end{aligned}\n$$\n\nこの対偶をとると、「ある $a$ をとってきて次の2式をどちらも満たすとき\n\n$$\n\\begin{aligned}\n\\left\\{\n\\begin{array}{ll}\na^d \u0026\\neq 1 \u0026 \\pmod n\\\\\na^{2^rd} \u0026\\neq -1 \u0026 \\pmod n \\qquad (\\forall r \\in \\mathbb{Z}, 0\\leq r\\leq s-1)\n\\end{array}\n\\right.\n\\end{aligned}\n$$\n\n$n$ は合成数である」と言えます。\n\nこれを用い、次のステップを実行することで確率的な素数判定ができます。\n1. $1\\leq a \\leq n-1$ でaの値をランダムにとってくる。\n2. 上の条件を満たしたらcompositeと返す。\n3. 満たさなければprobably primeと返す。\n\nこれを繰り返すことで判定の精度が高まります。この処理をMiller–Rabin素数判定法といって、実行時間は $O(k\\log^3 n)$ 、FFTベースの乗算で $Õ(k\\log^2 n)$ となります。\n\n具体例を考えてみましょう。\n判定時にprobably primeを返す時 p、compositeを返す時 c として具体値を入れると次のようになります。\n$n = 25$ (合成数)のとき\n$n-1 = 24 = 2^3 \\times 3$ より $s = 3, d = 3$\n\n| a | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10 | 11 | 12 | 13 | 14 | 15 | 16 | 17 | 18 | 19 | 20 | 21 | 22 | 23 | 24 |\n|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|\n| $a^3 \\bmod 25$ | 1 | 8 | 2 | 14 | 0 | 16 | 18 | 12 | 4 | 0 | 6 | 3 | 22 | 19 | 0 | 21 | 13 | 7 | 9 | 0 | 11 | 23 | 17 | 24 |\n| $a^6 \\bmod 25$ | 1 | 14 | 4 | 21 | 0 | 6 | 24 | 19 | 16 | 0 | 11 | 9 | 9 | 11 | 0 | 16 | 19 | 24 | 6 | 0 | 21 | 4 | 14 | 1 |\n| $a^{12} \\bmod 25$ | 1 | 21 | 16 | 16 | 0 | 11 | 1 | 11 | 6 | 0 | 21 | 6 | 6 | 21 | 0 | 6 | 11 | 1 | 11 | 0 | 16 | 16 | 21 | 1 |\n| 判定 | p | c | c | c | c | c | p | c | c | c | c | c | c | c | c | c | c | p | c | c | c | c | c | p |\n\n$n = 17$ (素数)のとき\n$n-1 = 16 = 2^4 \\times 1$ より $s = 4, d = 1$\n\n| a | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10 | 11 | 12 | 13 | 14 | 15 | 16 |\n|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|:-:|\n| $a \\bmod 17$ | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 | 10 | 11 | 12 | 13 | 14 | 15 | 16 |\n| $a^2 \\bmod 17$ | 1 | 4 | 9 | 16 | 8 | 2 | 15 | 13 | 13 | 15 | 2 | 8 | 16 | 9 | 4 | 1 |\n| $a^4 \\bmod 17$ | 1 | 16 | 13 | 1 | 13 | 4 | 4 | 16 | 16 | 4 | 4 | 13 | 1 | 13 | 16 | 1 |\n| $a^8 \\bmod 17$ | 1 | 1 | 16 | 1 | 16 | 16 | 16 | 1 | 1 | 16 | 16 | 16 | 1 | 16 | 1 | 1 |\n| 判定 | p | p | p | p | p | p | p | p | p | p | p | p | p | p | p | p |\n\nかなり正確に判定できていることがわかるでしょう。\n\n素数については必ず成功し、合成数のときは誤る可能性が $1/4$ 以下ということが示せるので、 $k$ 回試行すれば誤り率は $4^{-k}$ 以下となります。つまり、ある値に対して10回素数判定法を回せば99.9999046%成功するということです。\n\n\n# RSA暗号を極める！(実践編)\n\n理論編を読んでRSA暗号で使われる道具たちを把握できたかと思います。(理論編を読んでない方は...読んでも読まなくてもどちらでもいいです。気になったときに読んだ方がたのしいです。)\n\nここでは実際にスクリプトを書いて攻撃していきます！攻撃したことない人はコードを書きながら勉強でき、CTFerにはライブラリ保管庫として使ってほしいと思って書いてます。\n// TODO ちゃんと書く\n\n### 紹介するRSA暗号の解読方法\n\n| アンチケース                                                              | 攻撃技                                                           | 方法                                                   |\n| --------------------------------------                                    | ---------------------------------------------------------------- | -------------------------------------------------      |\n| 公開鍵 $N$ の値が小さくてはいけない                                       | Pollard-$\\rho$ 素因数分解法                                      | 素因数分解                                             |\n| 近い値の素数を使ってはいけない                                            | Fermat's method                                                  | 素因数分解                                             |\n| $e$ の値が小さすぎてはいけない                                            | Low Public Exponent Attack                                       | 剰余ではなく整数上のe乗根となる                        |\n| $d$ の値が小さすぎてはいけない($e$の値が大きすぎてはいけない)             | Wiener's Attack, Boneh-Durfee Attack                             | 近似分数から見積もる, Coppersmith Method               |\n| 同一の平文を異なる $e$ で暗号化した暗号文を与えてはいけない               | Common Modulus Attack                                            | $e$ について拡張ユークリッドの互除法                   |\n| 同一の平文を異なる $N$ で暗号化した暗号文を与えてはいけない               | Håstad's Broadcast Attack                                        | 中国剰余定理                                           |\n| 同一の平文を同一の $d$ 異なる $e, N$ で暗号化した暗号文を与えてはいけない | Small Common Private Exponent Attack                             | Coppersmith Method                                     |\n| 任意の暗号文を復号した結果を知られてはいけない                            | 適応的選択暗号文攻撃                                             | $a^ec$ を復号すると $am$ となる                        |\n| 暗号文を復号した結果の偶奇を知られてはいけない                            | LSB Decryption Oracle Attack                                     | 二分探索                                               |\n| RSAにバグがあってはならない                                               | RSA-CRT Fault Attack                                             | 秘密鍵が書き換えれると平文の差分が $p, q$ の倍数となる |\n| 上位ビットが共通する二つの平文に対する暗号文を知られてはいけない          | Franklin-Reiter Related Message Attack                           | 最大公約式                                             |\n| 秘密鍵が部分的にでも知られてはならない                                    | Partial Key Exposure Attack                                      | Coppersmith Method                                     |\n\nそれとわかりやすいように暗号化, 復号化関数 $Enc, Dec$ を定義しておきます。\n\n$$\n\\begin{aligned}\nEnc(m) \u0026= m^e \u0026\\pmod N \\\\\nDec(c) \u0026= c^d \u0026\\pmod N \\\\\n\\end{aligned}\n$$\n\n#### N の値が小さくてはいけない (Pollard-rho 素因数分解法)\n\n公開鍵 $N$ が小さいと素因数分解されて秘密鍵 $p, q$ を求められてしまいます。素因数分解を行うアルゴリズムは多くありますが、今回はお手軽で高速に求められるアルゴリズムである Pollard-rho 法を解説します。\n\n以下のように擬似的にランダムな値を生成する関数 $f$ を用いて2つの値の差が $N$ との共通因数を持つまで繰り返します。これはパッと見、そこまで速いアルゴリズムに見えませんが、誕生日のパラドックスと同じようなカラクリになっていて平均計算量 $\\mathcal{O}(\\sqrt{N})$ で素因数を見つけられます。\n\n$$\n\\begin{aligned}\nf(x) \u0026= x^2 + c \\pmod N \\\\\nx_{i+1} \u0026= f(x_i) \\\\\ny_{i+1} \u0026= f(f(y_i)) \\\\\n\\end{aligned}\n$$\n\n:::details ライブラリ\n$c$ は $1$ とし、初期値は $2$ を用いることが多いらしいです。\n```python\ndef gcd(m, n):\n    while n:\n        m, n = n, m % n\n    return m\n\ndef pollard_rho(N):\n    f = lambda x: (x*x + 1) % N\n    x = y = 2\n    d = 1\n    while d == 1:\n        x = f(x)\n        y = f(f(y))\n        d = gcd(abs(x - y), N)\n    return d if d \u003c N else -1\n```\n:::\n\nまた素因数分解の結果をデータベースとして保管しているサイトがあって実戦で便利です。\nhttp://www.factordb.com/\n\n\n\n#### 近い値の素数を用いてはいけない (Fermat's method)\n\n$p, q$ が近いと中心から順に調べることで素数の組を見つけられます。様々な探索の方法がありますが、以下のような方法がよく用いられています。\n\n$$\n\\begin{aligned}\nN \u0026= pq \\\\\n  \u0026= (x + y)(x - y) \\\\\n  \u0026= x^2 - y^2 \\\\\ny^2 \u0026= x^2 - N \\\\\n\\end{aligned}\n$$\n\nより初期値を $x = \\lceil\\sqrt N\\rceil, y = 0$ として $x$ の値を1ずつ上げながら $y$ の値も上げていき、右辺と左辺の計算結果が一致したとき $p, q$ が求まるという仕掛けです。\n\nさらに、このままだと素数 $p, q$ が近い値のときしか対応できませんが、素数同士の近似比を与えればその付近で探索することが出来ます。素数 $p, q$ の近似比が $a : b$ と与えられれば次のように計算できます。\n\n$$\n\\begin{aligned}\n\\frac{a}{b} \u0026\\approx \\frac{p}{q} \\\\\naq \u0026\\approx bp \\\\\naq \\times bp \u0026= abN\n\\end{aligned}\n$$\n\nこれより $abN$ に対し Fermat's method を適用することで $p, q$ が求まります。\n\nまた、$p, q$ についてより複雑な関係がある場合には Coppersmith method が適用できます。\n\n:::details ライブラリ\n```python\ndef fermat(N):\n    x = floor(sqrt(N)) + 1\n    y = floor(sqrt(x * x - N))\n    while True:\n        w = x * x - N - y * y\n        if w == 0:\n            break\n        elif w \u003e 0:\n            y += 1\n        else:\n            x += 1\n    return (x - y, x + y)\n```\n:::\n\n#### eの値が小さすぎてはいけない (Low Public Exponent Attack)\n\n$e$ が小さいとき、$m^e \u003c N$ となって、累乗根を取ればそのまま平文になることがあります。\n\n$$\n\\begin{aligned}\nc \u0026≡ m^e \\pmod N \\\\\nc \u0026= m^e \\\\\nm \u0026= \\sqrt[e] c\n\\end{aligned}\n$$\n\n累乗根はニュートン法と呼ばれる近似法を用いると高速に求められます。これはPythonパッケージのgmpy2で実装されているのでそれを使います。\n\n$$\n\\begin{aligned}\nf(x) \u0026= x^e - c \\\\\n0 \u0026= f'(x_n)(x_n - x_{n+1}) + f(x_n) \\\\\nx_{n+1} \u0026= x_n - \\frac{f(x_n)}{f'(x_n)} \\\\\nx_{n+1} \u0026= x_n - \\frac{x_n}{e} + \\frac{c}{ex_n^{e-1}}\n\\end{aligned}\n$$\n\n\n:::details ライブラリ\n```python\nimport gmpy2\n\nm = gmpy2.iroot(c, e)[0]\n```\n:::\n\n#### eの値が大きすぎてはいけない (Wiener's Attack)\n\n$e$ が大きいとき $(e \\approx N)$ 、秘密鍵 $d = e^{-1}$ が小さくなり $d$ を求められます。\n\n次のように $e/N$ に対してユークリッドの互除法を用いて連分数展開し、適当な場所で打ち切って再構成することで近似分数を作ることが出来ます。そしてこの近似分数が $k/d$ と一致するとき秘密鍵 $d$ が求まります。\n\n$$\n\\begin{aligned}\ned \u0026≡ 1 \\pmod{\\phi(N)} \\\\\ned \u0026= k\\phi(N) + 1 = k(N - p - q + 1) + 1 \\\\\n\\frac{e}{N} \u0026= \\frac{k}{d}(1-\\delta) \u0026\\delta = \\frac{p + q - 1 - \\frac{1}{k}}{N} \\approx \\frac{1}{2^{512}} \\\\\n\\frac{e}{N} \u0026\\approx q_0 + \\cfrac{1}{q_1 + \\cfrac{1}{q_2 + \\cfrac{1}{\\ddots \\cfrac{}{q_{m-1} + \\cfrac{1}{q_m}}}}} = \\frac{k_m}{d_m} \\\\\n\\end{aligned}\n$$\n\n$q_i, k_i, d_i$ については次の漸化式を用いて計算できます。形式的に数列の $-1, -2$ 番目も定義することで分かりやすく計算できます。\n\n$$\n\\begin{aligned}\nr_{-2} \u0026= e \u0026 k_{-2} \u0026= 0 \u0026d_{-2} \u0026= 1 \\\\\nr_{-1} \u0026= N \u0026 k_{-1} \u0026= 1 \u0026d_{-1} \u0026= 0 \\\\\nr_{i-2} \\div r_{i-1} \u0026= q_{i} \\cdots r_{i} \u0026 k_i \u0026= q_i k_{i−1} + k_{i−2} \u0026d_i \u0026= q_i d_{i−1}+d_{i−2} \\\\\n\\end{aligned}\n$$\n\n$q_i, k_i, d_i$ の計算をどこで打ち切るかは2次方程式 $x^2 - (p + q)x + pq = 0$ の判別式を用いて判定します。判別式が正となるとき解 $p, q$ のが存在し、 $p+q$ が整数ならば $p, q$ も整数となるという方法です。\n\n$$\n\\begin{aligned}\np + q \u0026= N - \\frac{ed_i - 1}{k_i} + 1 \\in \\mathbb{N} \\\\\npq \u0026= N \\\\\nD \u0026= (p + q)^2 - 4N \\geq 0 \\\\\n\\end{aligned}\n$$\n\nこの攻撃は以下のように $d$ が十分小さいときしか成立しません。 $e$ が大きいと $d$ が小さくなりやすいという性質がある為、公開鍵 $e$ が大きいときと表現しますが、$d$ がこれ以上であれば攻撃は成立しません。\n\n$$\nd \u003c \\frac{N^{\\frac{1}{4}}}{3}\n$$\n\n:::details ライブラリ\n```python\nimport gmpy2\n\ndef WienersAttack(n, e):\n    r0, r1 = e, n\n    k0, k1 = 0, 1\n    d0, d1 = 1, 0\n\n    i = 0\n    while r1 != 0:\n        q = r0 // r1\n        r0, r1 = r1, r0 % r1\n        k0, k1 = k1, q*k1 + k0\n        d0, d1 = d1, q*d1 + d0\n\n        if i % 2 == 0:\n            k = k1 + k0\n            d = d1 + d0\n        else:\n            k = k1\n            d = d1\n\n        i += 1\n        if k == 0 or (e * d - 1) % k != 0:\n            continue\n        s = n - (e * d - 1) // k + 1\n        D = s*s - 4*n\n        sD = gmpy2.isqrt(D)\n        if D \u003e 0 and sD * sD == D:\n            return d\n    return -1\n```\n:::\n\nさらにWiener's Attackより強い攻撃としてBoneh-Durfee Attackがあります。まず以下のように変形します。\n\n$$\n\\begin{aligned}\ned \u0026= 1 \u0026 \\pmod{\\phi} \\\\\ned \u0026= k \\phi + 1 \u0026 (over \\ \\mathbb{Z}) \\\\\n0 \u0026= k \\phi + 1 \u0026 \\pmod e \\\\\n\u0026= k (N + 1 - p - q) + 1 \u0026 \\pmod e \\\\\n\u0026= 2k \\left(\\frac{N + 1}{2} + \\frac{-p -q}{2}\\right) + 1 \u0026 \\pmod e \\\\\n\\end{aligned}\n$$\n\nこの方程式について $f(x,y) = x (A + y) + 1$ とおき、関数 $f(x,y)$ に対して Multivariate Coppersmith Method を用いることで $p + q$ が求まり、解くことができます。\n\n:::details ライブラリ\nSageMath は標準に Multivariate Coppersmith Method を使うことができません。 [defund/coppersmith](https://github.com/defund/coppersmith) というリポジトリにそれが実装されているので、それを用いて攻撃することが多いです。\n\n```python\nload('coppersmith.sage')\n\ndef boneh_durfee(N, e):\n\tbounds = (floor(N^.25), 2^1024)\n\tP.\u003ck, s\u003e = PolynomialRing(Zmod(e))\n\tf = 2*k*((N+1)//2 - s) + 1\n\tprint(small_roots(f, bounds, m=3, d=4))\n```\n:::\n\n#### 同一の平文を異なるeで暗号化した暗号文を与えてはいけない (Common Modulus Attack)\n\n異なる $e$ で暗号化するとユークリッドの互除法を用いてより小さな $e$ の暗号文を作れて、解読できてしまいます。\n\n$$\n\\begin{aligned}\nc_1 \u0026≡ m^{e_1} \\pmod N \\\\\nc_2 \u0026≡ m^{e_2} \\pmod N \\\\\n\\end{aligned}\n$$\n\n$e_1, e_2$ について $\\gcd(e_1, e_2) = g$ のとき、拡張ユークリッドの互除法を用いることで次を満たす $s_1, s_2$ を求められます。\n\n$$\n\\begin{aligned}\ns_1e_1 + s_2e_2 \u0026= g \\\\\nc_1^{s_1} c_2^{s_2} = m^{s_1e_1 + s_2e_2} \u0026= m^g \\pmod N \\\\\n\\end{aligned}\n$$\n\nこれによって $e_1, e_2$ が互いに素のとき、または $g$ が小さいならばLow Public Exponent Attackを用いて $m$ を求められます。\n\n#### 同一の平文を異なるnで暗号化した暗号文を与えてはいけない (Håstad's Broadcast Attack)\n\n$n_1, \\ldots, n_e$ が互いに素ならば中国剰余定理を用いて $m$ を求められる。Garnerのアルゴリズムを用いて $m^e$ を計算する。\n\n$$\n\\begin{aligned}\nc_1 \u0026≡ m^e \\pmod{N_1} \\\\\nc_2 \u0026≡ m^e \\pmod{N_2} \\\\\n\\vdots \\\\\nc_e \u0026≡ m^e \\pmod{N_e} \\\\\nm^e \u0026≡ CRT(c_1, c_2, \\dots , c_e) \\pmod{N_1N_2\\cdots N_e} \\\\\nm^e \u0026= CRT(c_1, c_2, \\dots , c_e)\n\\end{aligned}\n$$\n\n:::details ライブラリ\n\n```python\nimport gmpy2\n\ne = 3\nc = [c1, c2, c3]\nN = [N1, N2, N3]\nme = crt(c, N)\nm = gmpy2.iroot(me, e)[0]\n```\n:::\n\n#### 任意の暗号文を復号した結果を知られてはいけない (適応的選択暗号文攻撃)\n\n任意の暗号を復号した結果を知っているとき、ある暗号文の復号結果を防がれていたとしても他の暗号を送ることで解読できます。\n$2^e$ を暗号文に掛けて復号した結果を $2$ で割ればその平文がわかります。\n\n$$\n\\begin{aligned}\nDec(2^ec) = 2m \\pmod N\n\\end{aligned}\n$$\n\nこれに対する防御方法として平文にパディングを施し、復号化した際にパディング形式が違うときは相手に渡さないようにするという方法があります。これによって正当な暗号文しか受け入れず、適応的選択暗号文攻撃を防げます。\n\nパディング形式の1つにPKCS #1 v1.5があります。\n\n`0002\u003crandom\u003e00\u003chashprefix\u003e\u003cmessage\u003e`\n\nこれについてパディングが合っているかどうかを相手に送ってしまうとPadding Oracle Attackで攻撃でき、PKCS #1 v1.5では200万程度送ると平文が読めてしまいます。\n\n対してPadding Oracle Attackで破られないようなパディング形式はInD-CCA2と呼びます。\n\nその1つであるOAEP(Optimal Asymmetric Encryption Padding)については次の記事を読むとよいです。\n\n##### 参考文献\nhttps://inaz2.hatenablog.com/entry/2016/01/26/222303\n\n#### 暗号文を復号した結果の偶奇を知られてはいけない (LSB Decryption Oracle Attack)\n\n全てが分かっていなくとも偶奇さえ分かれば任意の暗号文を復号できる。\nある暗号文 $c$ に対し、$2^e$ をx回掛けた値を復号した下位1bitを得て平文を求めます。得られる下位1bitは次の関数 $f(x)$ を用いて $f(x) \\bmod 2$ と表せられます。decは復号化関数です。\n\n$$\n\\begin{aligned}\nf(x) \u0026= Dec(2^{ex}c \\bmod N) = 2^xm \\bmod N \\\\\n\\end{aligned}\n$$\n\n$x = 1$ のとき\nまず $0 \\leq m \u003c N$ であるから $f(1)$ は $2m \\bmod N = 2m, 2m - N$ のどちらかとなる。また $2m$ は偶数、$N$ は奇数であるから $f(1)$ が偶数か奇数かで $2m, 2m - N$ のどちらかが分かります。すると $m$ が存在する区間が分かります。\n\n$$\n\\begin{aligned}\n\u0026f(1) = 2m \\bmod N \\\\\n\u0026\n\\begin{cases}\n    f(1) \\bmod 2 = 1 \\Leftrightarrow f(1) = 2m - N \u0026 \\Leftrightarrow \\frac{N}{2} \\leq m \u003c N \\\\\n    f(1) \\bmod 2 = 0 \\Leftrightarrow f(1) = 2m \u0026 \\Leftrightarrow 0 \\leq m \u003c \\frac{N}{2} \\\\\n\\end{cases}\n\\end{aligned}\n$$\n\nつまり $m$ は $[0, N)$ の範囲に対して最下位ビットが1のとき区間の右半分、0のとき区間の左半分だと言えます。\n\n$x = 2$ のとき\n前の結果を用いて場合分けして考えると同様の考え方で次のように導けます。\n\n$$\n\\begin{aligned}\nf(2) \u0026= 2(2m \\bmod N) \\bmod N \\\\\nf(1) \u0026= 2m - N \\Rightarrow f(2) = 4m - 2N \\bmod N \\\\\n\u0026\n\\begin{cases}\n    f(2) \\bmod 2 = 1 \\Leftrightarrow f(2) = 4m - 3N \u0026 \\Leftrightarrow \\frac{3N}{4} \\leq m \u003c N \\\\\n    f(2) \\bmod 2 = 0 \\Leftrightarrow f(2) = 4m - 2N \u0026 \\Leftrightarrow \\frac{N}{2} \\leq m \u003c \\frac{3N}{4} \\\\\n\\end{cases}\n\\\\\nf(1) \u0026= 2m \\Rightarrow f(2) = 4m \\bmod N \\\\\n\u0026\n\\begin{cases}\n    f(2) \\bmod 2 = 1 \\Leftrightarrow f(2) = 4m - N \u0026 \\Leftrightarrow \\frac{N}{4} \\leq m \u003c \\frac{N}{2} \\\\\n    f(2) \\bmod 2 = 0 \\Leftrightarrow f(2) = 4m \u0026 \\Leftrightarrow 0 \\leq m \u003c \\frac{N}{4} \\\\\n\\end{cases}\n\\end{aligned}\n$$\n\nつまり $m$ は $[0, N/2)$ 、 $[N/2, N)$ のそれぞれの範囲に対して最下位ビットが1のとき区間の右半分、0のとき区間の左半分だと言えます。\n\n$x \\geq 3$ のときも同様に行って $m$ の値を求めることができます。\n\n#### RSAにバグがあってはならない (RSA-CRT Fault Attack)\n\nRSAの復号をする際に $c^d$ を計算しますが、 $d = e^{-1} \\pmod {\\phi (N)}$ は比較的大きいので処理が重くなります。これに対してRSA-CRTは中国剰余定理(CRT)を利用して高速化を図っています。\n\n$$\n\\begin{aligned}\nm_p \u0026= c^{d \\ \\bmod \\ p−1} \u0026 \\pmod p \\\\\nm_q \u0026= c^{d \\ \\bmod \\ q−1} \u0026 \\pmod q \\\\\nm \u0026= \\mathrm{CRT}(m_p, m_q) \u0026 \\pmod {N} \\\\\n\u0026= m_q + (m_p - m_q) (q^{-1} \\bmod p) q \u0026 \\pmod {N} \\\\\n\\end{aligned}\n$$\n\nこれより下の値を秘密鍵として持つことになります。\n\n$$\n\\begin{aligned}\nd_p \u0026= d \\bmod p−1 \\\\\nd_q \u0026= d \\bmod q−1 \\\\\nq_{inv} \u0026= q^{-1} \\bmod p \\\\\n\\end{aligned}\n$$\n\nしかし $d_p, d_q$ のどちらかが何らかの方法で書き換えられてしまったとき次のようにできます。\n\n$$\n\\begin{aligned}\nm_p \u0026= c^{d_p} \\pmod p \\\\\nm_q' \u0026= c^{d_q'} \\pmod q \\\\\nm \u0026= CRT(m_p, m_q) = kp + m_p \\\\\nm' \u0026= CRT(m_p, m_q') = k'p + m_p \\\\\nm - m' \u0026= (k - k')p \\\\\np \u0026= \\gcd(m - m', N) \\\\\n\\end{aligned}\n$$\n\nこれより平文 $m, m'$ を知ることができれば解くことができます。\n\n#### 秘密鍵の上位ビットまたは下位ビットが知られてはいけない (Partial Key Exposure Attack)\n\n秘密鍵を部分的に知っていさえいれば、Coppersmith Method を用いて解けてしまう。\n$n$ を $N$ のビット数とする。\n\n##### p, q のどちらかを n/4 ビット程度知っているとき\n\n\n$$\n\\begin{aligned}\nf(x) \u0026= p_{upper} + x \u0026 \\pmod N \\\\\nf(x) \u0026= 2^{k}x + p_{lower} \u0026 \\pmod N \\\\\nf(x,y) \u0026= 2^kx + p_{mid} + y \u0026 \\pmod N \\\\\n\\end{aligned}\n$$\n\n##### d を n/4 ビット程度知っているとき\n\n$e$ が総当り出来るくらい小さいときに $d$ を $n/4$ ビットだけ知っていれば元の $d$ を構成できる。大体の場合は $e = 65537$ であるから十分可能である。$d \u003c \\phi(N)$ より $0 \u003c k \\leq e$ となり、この $k$ に対して総当たりする。\n\n- 上位ビットの場合\n$d$ と $p, q$ の関係式を立てる。\n\n$$\n\\begin{aligned}\ned \u0026= 1 \u0026 \\pmod{\\phi(N)} \\\\\ned \u0026= 1 + k(N - p - q + 1) \\\\\nd \u0026= \\frac{kN}{e} - \\frac{k(p+q-1) -1}{e} \\\\\ne(d_{upper} + x) \u0026= - k (y - 1) + 1 \u0026 \\pmod N \\\\\n\\end{aligned}\n$$\n\n第三式について $p + q \\approx \\sqrt{N}$ より第二項は上位ビットに関連する情報を持たない。これより第一項の $k$ について総当りして上位ビットと一致する $k$ を見つければよい。すると第4式に対し Multivariate CopperSmith を用いて、$d$ がわかる。\n\n- 下位ビットの場合\n$d$ の下位ビットから $k$ について総当りして $p$ の下位ビットを求める。すると先程の問題に帰着できて $p$ がわかり $d$ がわかる。\n\n$$\n\\begin{aligned}\ned \u0026= 1 + k\\left(N - p - \\frac{N}{p} + 1\\right) \\\\\nedp \u0026= p + kp(N - p + 1) - kN \u0026 \\pmod {2^{n/4}} \\\\\n\\end{aligned}\n$$\n\n\n\n##### CRTの秘密鍵 d のビットを n/4 程度知っているとき\n\n上と同様にして解けます。\n\n$$\n\\begin{aligned}\ned_p \u0026= 1 \u0026 \\pmod{p-1} \\\\\ned_p \u0026= 1 + k_p(p − 1) \\\\\n\\end{aligned}\n$$\n\n##### 平文 m のビットを (1-1/e)n 程度知っているとき\n\n$$\n\\begin{aligned}\nf(x) \u0026= (m_{upper} + x)^e - c \u0026 \\pmod N \\\\\nf(x) \u0026= (2^kx + m_{lower})^e - c \u0026 \\pmod N \\\\\nf(x,y) \u0026= (2^kx + m_{mid} + y)^e - c \u0026 \\pmod N \\\\\n\\end{aligned}\n$$\n\n```python\ndef partial_p(p0, kbits, n):\n    PR.\u003cx\u003e = PolynomialRing(Zmod(n))\n    nbits = n.nbits()\n\n    f = 2^kbits*x + p0\n    f = f.monic()\n    roots = f.small_roots(X=2^(nbits//2-kbits), beta=0.3)  # find root \u003c 2^(nbits//2-kbits) with factor \u003e= n^0.3\n    if roots:\n        x0 = roots[0]\n        p = gcd(2^kbits*x0 + p0, n)\n        return ZZ(p)\n\ndef find_p(d0, kbits, e, n):\n    X = var('X')\n\n\t# edx - kx(n-x+1) + kn = x mod 2^k\n\t# (ed - 1)x - kx(n-x+1) + kn = 0 mod 2^k\n    for k in xrange(1, e+1):\n        results = solve_mod([e*d0*X - k*X*(n-X+1) + k*n == X], 2^kbits)\n        for x in results:\n            p0 = ZZ(x[0])\n            p = partial_p(p0, kbits, n)\n            if p:\n                return p\n\n\nif __name__ == '__main__':\n    n = 0x00bef498e6eb2cffe71312da47ab89d2c47db7438ea2cfa992ddddbc2a01978001fc51e286e6ebf028396cdb8b3323c60e6b9d50cd84187cf7f48e3875a2f0890f70b02333ad89db2923863ce146562286f63fb0a1d0198e3a6862ba5ac12e85a5c6d0d27cb1c81bdf69cc5bc95b8001a2f744517f9437b4ddd5a076fc0e9a5de1a7a268c40f31aa29e8dc27c0b3a182299ca7a9335b4bd4585452f6107c238e486c98dd73a5f9862e9e80b152f53381c72f897107551c281259ac3ee32c4b4f46cc03127d1bf699acd0266f3c6729253c70da0c69b1560fa172735709866b375b6eba294e1ce8b46fba798ba380080b4bf9603998cac199d9cd46e30ae8da9e7f\n    e = 3\n    d = 0x7f4dbb449cc8aa9a0cb73c2fc7b1372da924d7b46c8a710c93e9281c010faaabfd8bec59ef47f5702648925cccc284099d138b33ad65a8a54db425a3c1f5b0b4f5cac22273b13cc617aed340d98ec1af4ed5206be011097c459726e72b7459192f35e1a8768567ea46883d30e7aaabc1fa2d8baa62cfcde93915a4a809bc3e9547bb07e1ecca16e51078312e89f0561e31b55db8b0ea5bc87a6ca7464a3d7c28a68c60e2ba88fe6a7d2b300d723e549910a987da89fc0a1c0de197a3d62c501b1f0e819891b1c32a0d6c233f2a285df87bb9e5c6c72d983ff3e706696bba639f573f9c3646968f02f3a615a438e20bb7c38d53621079f2899547a95350f3abeb\n\n    beta = 0.5\n    epsilon = beta^2/7\n\n    nbits = n.nbits()\n    kbits = floor(nbits*(beta^2+epsilon))\n    d0 = d \u0026 (2^kbits-1)\n    print \"lower %d bits (of %d bits) is given\" % (kbits, nbits)\n\n    p = find_p(d0, kbits, e, n)\n    print \"found p: %d\" % p\n    q = n//p\n    print d\n    print inverse_mod(e, (p-1)*(q-1))\n```\n\n\n\n:::details 例題\n```python\nfrom Crypto.Util.number import *\n\np = getPrime(512)\nq = getPrime(512)\nn = p * q\ne = 3\n\nbeta = 0.5\nepsilon = beta^2/7\n\npbits = p.nbits()\nkbits = floor(n.nbits() * (beta^2 - epsilon))\n# p upper\npbar = p \u0026 (2^pbits - 2^kbits)\n\nprint(f\"upper {pbits - kbits} bits (of {pbits} bits) is given\")\n\nPR.\u003cx\u003e = PolynomialRing(Zmod(n))\nf = x + pbar\n\nprint(p)\nx0 = f.small_roots(X=2^kbits, beta=0.3)[0]\nprint(x0 + pbar)\n```\n:::\n\n#### 上位ビットが共通する二つの平文に対する暗号文を知られてはいけない (Franklin-Reiter Related Message Attack)\n\n$f(m_1) = m_2$\n$m_1 = pad_1 + m, m_2 = pad_2 + m, m_2 = m_1 + (pad_2 - pad_1)$\n\n$$\n\\begin{aligned}\nc_1 \u0026= m_1^{e_1} \u0026 \\pmod N \\\\\nc_2 \u0026= m_2^{e_2} = f(m_1)^{e_2} \u0026 \\pmod N \\\\\nx - m_1 \u0026= \\gcd(x^{e_1} - c_1, f(x)^{e_2} - c_2) \u0026 \\pmod N \\\\\n\\end{aligned}\n$$\n\nHalf GCD\n\n#### Coppersmith's Short Pad Attack\n\n二つの暗号文について平文の上位bitがnのbit数の (1-1/e2) 程度共通する場合、これらからそれぞれの平文を求めることができる。 具体的には、次のような手順となる。\n\n1.  `g1 = x^e - c1`と`g2 = (x+y)^e - c2`の[終結式（resultant）](https://ja.wikipedia.org/wiki/%E7%B5%82%E7%B5%90%E5%BC%8F)を求め、その根としてyの値を得る\n2.  yの値を代入した上でg1(x)とg2(x)の最大公約式を求め、その根としてm1を得る\n3.  `m2 = m1 + y`よりm2を得る\n多項式GCD $O(n\\log^2n)$ を使う\nFranklin-Reiter Related Message Attack\n\n$$\n\\begin{aligned}\nm_1 \u0026= pad_1 + m \\\\\nm_2 \u0026= pad_2 + m \\\\\n\u0026= m_1 + pad_2 - pad_1 \\\\\nc_1 \u0026= m_1^e \\pmod N \\\\\nc_2 \u0026= m_2^e = (m_1 + pad_2 - pad_1)^e \\pmod N \\\\\nf_1(x) \u0026= x^e - c_1 \\\\\n\u0026= (x - m_1)h_1(x) \\\\\nf_2(x) \u0026= (x + pad_2 - pad_1)^e - c_2 \\\\\n\u0026= (x - m_1)h_2(x) \\\\\nx - m_1 \u0026= \\gcd(f_1, f_2) \\\\\n\\end{aligned}\n$$\n\nhttps://inaz2.hatenablog.com/entry/2016/01/20/022936\n\nRTACTF\nhttps://xagawa.hatenablog.com/entry/2021/12/20/232133\nCryptoのWriteupをまとめてる人\nhttps://mystiz.hk\n\n\n## 実践編まとめ\n\n今回はRSA暗号に絞りましたが実際のCTFはもっと広くて自由です！RSAに似てるけど解法が違う暗号やぱっと見RSAではなさそうな暗号もRSAに帰着させることが出来たりする暗号など様々あります。それでもここで扱った概念はそれらの基礎になります。\n\nあなたもCTFに出て暗号の世界を堪能してみませんか。\n\n### 参考文献\n[RSA暗号攻撃で他でも使える n のこと](https://project-euphoria.dev/blog/27-rsa-attacks/)\n[CTF crypto 逆引き](https://furutsuki.hatenablog.com/entry/2021/03/16/095021)\n[Recovering cryptographic keys from partial information, by example](https://eprint.iacr.org/2020/1506.pdf)\n[Twenty Years of Attacks on the RSA Cryptosystem](https://crypto.stanford.edu/~dabo/pubs/papers/RSA-survey.pdf)\n","lastmodified":"2022-12-30T07:57:21.471263809Z","tags":null},"/crypto/SSH":{"title":"SSH","content":"\nOpenSSH 9.0 ポスト量子暗号化時代への対応として、格子暗号系の「Streamlined NTRU Prime」と、楕円曲線暗号系の「x25519」からなるハイブリッド手法がデフォルトとなっている。\n\ned448\ned25519\n\n\nGnu Privacy Guard: GPG\nmaster key\nsub key\nPritty Good Privacy: PGP鍵\n[GPGで自分用の秘密鍵を1つに統一する · JoeMPhilips](http://joemphilips.com/post/gpg_memo/)\n\nSoloKey, Nitrokey","lastmodified":"2022-12-30T07:57:21.471263809Z","tags":null},"/crypto/SageMath":{"title":"SageMath チートシート","content":"\n## 説明\n\nSageMathのプログラムを書くときに参照したいと思うチートシートを作成したい。\n\n## 実装\n\n```python\n# import\nload('coppersmith.sage')\n\n# 整数環, 剰余環, 有限体\nZZ, Zmod(N), GF(q)\n\nR = GF(2 ^ m)\nR.fetch_int(12)\n# 多項式\nR = Zmod(N)\nP. \u003c x, y \u003e = PolynomialRing(R)\nf = x ^ 2 + 3*x + 3\nf.small_roots()\np /= p.leading_coefficient()  # 最高次項 モニック化\np = p.monic()\nideal(f).groebner_basis()\n\n# 行列\nM = matrix(QQ, [[1, 2], [3, 4]])\nM.LLL()\n\nA = matrix(Zn, [\n    [_a, _b, _c, _d, _e],\n    [1, 0, 0, 0, 0],\n    [0, 1, 0, 0, 0],\n    [0, 0, 1, 0, 0],\n    [0, 0, 0, 1, 0],\n])\n\nb11, b12, b13, b14, b15 = map(int, (A ^ e)[4])\n\nD, P = m.eigenmatrix_left()\nP ^ (-1)*D*P == m\n\nQ = diagonal_matrix(weights)\n\nB *= Q\nB = B.LLL()\nB /= Q\n\n# 素因数分解\nset(factor(n))\n\n# 楕円曲線\nEllipticCurve()\n```\n\n## 参考\n- [quickref](https://wiki.sagemath.org/quickref?action=AttachFile\u0026do=get\u0026target=quickref.pdf)\n- [quickref-linalg.pdf (shinshu-u.ac.jp)](http://math.shinshu-u.ac.jp/~nu/nora/sage/doc/refcard/quickref-linalg/200905/ja-utf8/quickref-linalg.pdf)\n","lastmodified":"2022-12-30T07:57:21.471263809Z","tags":null},"/crypto/books":{"title":"参考資料","content":"\n## Crypto books\n- 暗号理論入門―暗号アルゴリズム、署名と認証、その数学的基礎 （原書第３版）ブーフマン Buchmann (著)\n- The Block Cipher Companion\n- 現代暗号の誕生と発展：ポスト量子暗号・仮想通貨・新しい暗号 岡本 龍明 (著)\n- 現代暗号への招待 (ライブラリ情報学コア・テキスト) 黒澤 馨 (著)\n\n- 暗号理論のための格子の数学 絶版\n- [Complexity of Lattice Problems | SpringerLink](https://link.springer.com/book/10.1007/978-1-4615-0897-7)\n\n- The Arithmetic of Elliptic Curves (著: Silverman)\n- [kojima-shuron.pdf (kyoto-u.ac.jp)](https://www.math.kyoto-u.ac.jp/~yukie/kojima-shuron.pdf)\n\n- [Mathematics of Public Key Cryptography (auckland.ac.nz)](https://www.math.auckland.ac.nz/~sgal018/crypto-book/crypto-book.html)\n- [CRYSTALS - Kyber](https://eprint.iacr.org/2017/634.pdf)\n- [Meet The Signature Standard of the Future … SPHINCS+ | by Prof Bill Buchanan OBE | ASecuritySite: When Bob Met Alice | Medium](https://medium.com/asecuritysite-when-bob-met-alice/meet-the-standard-of-the-future-sphincs-ee2b9e4c7b5e)\n\n- [Advances in Elliptic Curve CryptographyLondon Mathematical Society Lecture Note Series ; 317 (preterhuman.net)](https://cdn.preterhuman.net/texts/cryptography/Cambridge%20University%20Press.%20Advances%20in%20Elliptic%20Curve%20Cryptography%20(2005).pdf)\n\n## Security\n- [Flatt Security Blog](https://blog.flatt.tech/)\n- [RET2 Systems Blog](https://blog.ret2.io/)\n\n## Mathematics books\n- 初学者のための代数幾何 (著: 永田雅宜)\n- 数学原論 (著: 斎藤 毅)\n- 岩波基礎数学選書 体とガロア理論 (著: 藤﨑源二郎)\n\n## Electric books\n- [ELM by ChaN (elm-chan.org)](http://elm-chan.org/)\n- [プロト基板の使いかた【電子工作】 - Niconico Video](https://www.nicovideo.jp/watch/sm22265444)\n- [揚げて炙ってわかるコンピュータのしくみ：書籍案内｜技術評論社 (gihyo.jp)](https://gihyo.jp/book/2020/978-4-297-11601-9)\n\n## Event\n- 1月 SCIS (Symposium on Cryptography and Information Security)\n- 8月 DEFCON AVTOKYO\n- CODE BLUE\n- GCC\n- SecHack365\n\nジュニア会員は学士3年まで\n\n## Crypto Paper\n- [Breaking SIDH in polynomial time (iacr.org)](https://eprint.iacr.org/2022/1038)\n\n## Certification\n- eJPT Certification\n- CISSP\n- OSCP\n- OSED\n- INE Cyber Security Training","lastmodified":"2022-12-30T07:57:21.471263809Z","tags":null},"/crypto/coppersmith":{"title":"Coppersmith Method","content":"\n## 説明\n\n#### Thm. Howgrave-Grahamの補題\n$N$ を法、 $g(x) \\in \\mathbb{Z}[x]$ を整数多項式とし、含まれる単項式の数を $\\omega$ とする。$g(x)$ に対してある $X$ が存在し、$g(x_0) = 0 \\pmod{N}$ なる $x_0 \\in \\mathbb{Z}$ について $|x_0| \\leq X$ であると仮定する。このとき\n\n$$\n\\|g(xX)\\| \u003c \\frac{N}{\\sqrt{\\omega}}\n$$\n\nが成立するならば $g(x_0) = 0$ が整数方程式として成立する。ただし\n\n$$\n\\|g(x)\\| = \\left\\|\\sum_{i=0}^{\\deg g(x)}g_i\\right\\| = \\sqrt{\\sum_{i=0}^{\\deg g(x)}g_i^2}\n$$\n\nであり、 $\\deg g(x)$ は $g(x)$ の次数である。\n\n証明\n\n$$\n\\begin{aligned}\n|g(x_0)| \u0026= \\left|\\sum_{i=0}^{\\deg g(x_0)}g_ix_0^i\\right| \\\\\n\u0026\\leq \\sum_{i}|g_ix_0^i| \\\\\n\u0026\\leq \\sum_{i}|g_i|X^i \\\\\n\u0026= \\sum_{i}(1\\cdot|g_i|X^i) \\\\\n\u0026\\leq \\sqrt{\\sum_{i, g_i \\neq 0}1} \\sqrt{\\sum_{i}(|g_i|X^i)^2} \u0026\u0026 \\left(\\because \\text{コーシー＝シュワルツの不等式}\\right) \\\\\n\u0026= \\sqrt{\\omega}\\|g(xX)\\| \u003c N \u0026\u0026 \\left(\\because \\|g(xX)\\| \u003c \\frac{N}{\\sqrt{\\omega}}\\right)\n\\end{aligned}\n$$\n\n$g(x_0) = 0 \\pmod N$ より $g(x_0) = 0$ となる。\n\n-----\n\nつまり、「剰余の方程式は係数がある程度小さければそのまま整数方程式となるよ」と言っています。ここで勘のいい人はLLLを用いて係数を小さくすれば整数方程式に変換できて解けるのでは...！？と気付くでしょう。実際に考えてみましょう。\n\nとりあえず状況を整理すると、LLLに入れる値は各係数として、LLLを使う為には複数の方程式が必要になってきます。そしてそれらの方程式は同じ解を持つ必要があります。現在、その解が分からないのですが、どうしたらそんな方程式が作れるでしょうか。\n\n実は $\\bmod {N}$ では難しいので、$\\bmod {N^m}$ に持ち上げることで同じ解の方程式を増やすことができます。\n\n-----\n\n#### Lemma\n$N$ を法、$f(x)$ を多項式とする。自然数 $m, l$ について\n\n$$\ng_{i,j}(x) := N^{m−i}x^j f^i(x) \\ (0 \\leq i \\leq m, 0 \\leq j\\leq l)\n$$\n\nとおく。このとき、 $f(x_0) = 0 \\pmod N$ をみたす $x_0 \\in \\mathbb{Z}$ について、 $g_{i,j}(x_0) = 0 \\pmod{N^m}$ となる。\n\n証明\n\n$f(x_0) = 0 \\pmod N$ なので $f(x_0) = kN$ とおける。\n\n$$\n\\begin{aligned}\ng_{i,j}(x_0) \u0026= N^{m−i}x_0^j f^i(x_0) \\\\\n\u0026= N^{m−i}x_0^j (kN)^i \\\\\n\u0026= k^ix_0^j N^m \\\\\ng_{i,j}(x_0) \u0026= 0 \\pmod{N^m} \\\\\n\\end{aligned}\n$$\n\n-----\n\nこれで方程式を増やすことができました！ちゃんとLLLで動くかちょっと不安ですがとりあえずやってみます。\n\n小さくしたい方程式は $g_{i,j}(xX)$ であることに注意して。\n$g_{i,j}(x)$ の $k$ 次の係数のことを $g_{i,j}^{(k)}$ と表すことにします。\n\n$$\n\\begin{pmatrix}\ng_{0,0}^{(0)} \u0026 g_{0,0}^{(1)}X \u0026 g_{0,0}^{(2)}X^2 \u0026 g_{0,0}^{(3)}X^3 \u0026 g_{0,0}^{(4)}X^4 \u0026 g_{0,0}^{(5)}X^5 \\\\\ng_{0,1}^{(0)} \u0026 g_{0,1}^{(1)}X \u0026 g_{0,1}^{(2)}X^2 \u0026 g_{0,1}^{(3)}X^3 \u0026 g_{0,1}^{(4)}X^4 \u0026 g_{0,1}^{(5)}X^5 \\\\\ng_{1,0}^{(0)} \u0026 g_{1,0}^{(1)}X \u0026 g_{1,0}^{(2)}X^2 \u0026 g_{1,0}^{(3)}X^3 \u0026 g_{1,0}^{(4)}X^4 \u0026 g_{1,0}^{(5)}X^5 \\\\\ng_{1,1}^{(0)} \u0026 g_{1,1}^{(1)}X \u0026 g_{1,1}^{(2)}X^2 \u0026 g_{1,1}^{(3)}X^3 \u0026 g_{1,1}^{(4)}X^4 \u0026 g_{1,1}^{(5)}X^5 \\\\\ng_{2,0}^{(0)} \u0026 g_{2,0}^{(1)}X \u0026 g_{2,0}^{(2)}X^2 \u0026 g_{2,0}^{(3)}X^3 \u0026 g_{2,0}^{(4)}X^4 \u0026 g_{2,0}^{(5)}X^5 \\\\\ng_{2,1}^{(0)} \u0026 g_{2,1}^{(1)}X \u0026 g_{2,1}^{(2)}X^2 \u0026 g_{2,1}^{(3)}X^3 \u0026 g_{2,1}^{(4)}X^4 \u0026 g_{2,1}^{(5)}X^5 \\\\\n\\end{pmatrix}\n$$\n\nこれをLLLに通してあげると無事小さな値の方程式が返ってきます。これがHowgrave-Grahamの補題を満たしていれば整数方程式となります。後は増減表書いたりして探索すれば解けます。\n\nこれらの操作はCoppersmithの定理と呼ばれています。\n\n---\n\n#### Thm. Coppersmithの定理\n$N$ を法とし $f(x)$ をモニックな 1変数 $\\delta$ 多項式とする。このとき $f(x_0) = 0 \\pmod{N}$ と次の条件を満たすような $x_0$ を効率よく求めることができる\n\n$$\n|x_0| \\leq N^{\\frac{1}{\\delta}}\n$$\n\n---\n\nさらにCoppersmithの定理には拡張できることが2つあります。\n\n- 未知の法について解ける。素因数分解が出来ないほど大きな数を法としたときに既知の法の約数を法とする式の解を求められます。法が小さいほど方程式に対する制約がゆるくなります。\n- 多変数の方程式も解ける。これは変数が1つだけでしたが、複数の変数でもできます。変数の数が多いほど方程式に対する制約がキツくなります。\n\nこれらは Howgrave-Grahamの補題 などを見直すことで簡単に拡張できます。興味ある方は考えてみてください。\n\nこれらをまとめてCoppersmith Methodと呼びます。\n\nBerlekamp-Zassenhause法\n\n## 実装\n\n## 使用例\n\n## 参考\n- [元論文](https://static.aminer.org/pdf/PDF/000/192/854/finding_a_small_root_of_a_univariate_modular_equation.pdf)\n- [katagaitai workshop 2018 winter](http://elliptic-shiho.github.io/slide/katagaitai_winter_2018.pdf)\n","lastmodified":"2022-12-30T07:57:21.471263809Z","tags":null},"/crypto/cryptography/AttackModel":{"title":"Attack Model","content":"\nランダムオラクルモデル\n\n- 選択平文攻撃(Chosen-plaintext attack; CPA)\n- 適応的選択平文攻撃(Adaptive chosen-plaintext attack; CPA2)\n- 選択暗号文攻撃(Chosen-ciphertext attack; CCA1)\n- 適応的選択暗号文攻撃(Adaptive Chosen-ciphertext attack; CCA2)\n- Side-channel attack\n\n↓めちゃくちゃわかりにくい、といってわかりやすさが上がる方法とは？定理証明だと思う.\n\n- 一方向性(Onewayness; OW)\n\t- 暗号文から平文を求めるのが困難\n- 強秘匿性(Semantic Security; SS)\n\t- 暗号文から平文のどんな部分情報も漏れない\n- 識別不可能性(Indistinguishability; IND)\n\t- 暗号文が平文AとBのどちらのものかを区別できない\n- 頑強性(Non-Malleability; NM)\n\t- 暗号文が与えられた時、ある関係性を持った別の暗号文の生成が不可\n\t- stream cipher\n\t- RSA暗号 $Enc(m)\\cdot t^e \\bmod n = Enc(mt)$ padding(OAEP, PKCS 1)\n\n","lastmodified":"2022-12-30T07:57:21.471263809Z","tags":null},"/crypto/cryptography/Diffie-Hellman":{"title":"Diffie-Hellman 鍵交換","content":"\n## 説明\n\n共有鍵を作る為の操作である。共有鍵を作ることができれば共有鍵暗号を用いて通信できる。\n\n1. AliceとBobが巡回群 $G$ とその生成元 $g$ を共有する。\n2. AliceとBobはそれぞれ秘密鍵 $x_a, x_b$ を生成し、公開鍵 $y_a = g^{x_a}, y_b = g^{x_b}$ を公開する。\n3. AliceとBobは自分の秘密鍵と相手の公開鍵を掛けると $s = g^{x_ax_b} = y_b^{x_a} = y_a^{x_b}$ となり、$s$ はAliceとBobのみが知る共有鍵となる。\n\nECDH だと $s$ の $x$ 座標をハッシュ化したものを共有鍵として使う。\n","lastmodified":"2022-12-30T07:57:21.471263809Z","tags":null},"/crypto/cryptography/Fiat-Shamir":{"title":"Fiat-Shamir 変換","content":"\nFiat-Shamir変換は、証明システムを非対話型にするために使用される有名なスキームで、検証者がランダムに選択するチャレンジの値を（ランダムオラクルモデルとして）暗号学的ハッシュ関数を使って決定論的に導出することで、証明システムのプロトコルを非対話型にする。\n\nチャレンジのハッシュ計算の際の入力に、証明するステートメントに関するすべての公開値（ランダムなコミットメント値を含む）を含める必要があるということ（↑の例だと入力は、G、V、P、UserID、OtherInfo）。","lastmodified":"2022-12-30T07:57:21.471263809Z","tags":null},"/crypto/cryptography/FrozenHeart":{"title":"Frozen Heart","content":"\nFrozen Heartは、Fiat-Shamir変換でチャレンジのハッシュ計算の際の入力に、証明するステートメントに関するすべての公開値（ランダムなコミットメント値を含む）を含める必要があるということ（↑の例だと入力は、G、V、P、UserID、OtherInfo）を遵守していないプロトコルや実装による脆弱性。\n\n詳しいことはすべてここに\n\n- [Fiat-Shamir変換の安全でない適用による脆弱性Frozen Heart - Develop with pleasure! (hatenablog.com)](https://techmedia-think.hatenablog.com/entry/2022/04/19/193400#:~:text=Fiat%2DShamir%E5%A4%89%E6%8F%9B%E3%81%A8%E3%81%AF,%E9%9D%9E%E5%AF%BE%E8%A9%B1%E5%9E%8B%E3%81%AB%E3%81%99%E3%82%8B%E3%80%82)\n- [Coordinated disclosure of vulnerabilities affecting Girault, Bulletproofs, and PlonK | Trail of Bits Blog](https://blog.trailofbits.com/2022/04/13/part-1-coordinated-disclosure-of-vulnerabilities-affecting-girault-bulletproofs-and-plonk/)\n","lastmodified":"2022-12-30T07:57:21.471263809Z","tags":null},"/crypto/cryptography/Fujisaki-Okamoto_Transformation":{"title":"Fujisaki-Okamoto Transformation","content":"\n## 説明\n\n## 証明\n\n\n## 参考文献\n[The Fujisaki-Okamoto Transformation (uni-paderborn.de)](https://cs.uni-paderborn.de/fileadmin/informatik/fg/cuk/Lehre/Abschlussarbeiten/Bachelorarbeiten/2014/BA_Lippert_FOT_final.pdf)\n","lastmodified":"2022-12-30T07:57:21.471263809Z","tags":null},"/crypto/cryptography/Schnorr":{"title":"Schnorr Signatures","content":"\n## 説明\n\n非対話型ゼロ知識証明な署名の一種。\n\n巡回群 $G$ 上で署名を行う。各パラメータは次のように定義する。\n\n- 生成元 $g$\n- 秘密鍵 $x$\n- 公開鍵 $y = g^x$\n- メッセージ $M$\n\n### 署名\n\n乱数 $k$ を生成し、次の値を計算する。\n\n$$\n\\begin{aligned}\nr \u0026= g^k \\\\\ne \u0026= H(r \\| M) \\\\\ns \u0026= k - xe\n\\end{aligned}\n$$\n\nこのとき $(s, e)$ を署名値として公開する。\n\n### 検証\n\n公開されている値 $(g, y, M)$ と署名 $(s, e)$ を用いて次の値を計算する。\n\n$$\n\\begin{aligned}\nr' \u0026= g^sy^e \\\\\ne' \u0026= H(r' \\| M)\n\\end{aligned}\n$$\n\nここで $e = e'$ となれば署名が有効であると検証されたことになる。\n\n## 参考\n\n- [Schnorr署名 ―― 30年の時を超えて注目を集める電子署名](https://blog.visvirial.com/articles/721)\n- [RFC8235](https://datatracker.ietf.org/doc/html/rfc8235)","lastmodified":"2022-12-30T07:57:21.471263809Z","tags":null},"/crypto/cryptography/ZeroKnowledgeProof":{"title":"ゼロ知識証明","content":"\nゼロ知識証明の性質\n- 完全性（Completeness）\n    - 証明者の主張が真であるならば、検証者は真であることが必ずわかること。\n- 健全性（Soundness）\n    - 証明者の主張が偽であれば、検証者はかなり高い確率でそれが偽であること見抜けること。\n- ゼロ知識性（Zero Knowledge）\n\t- あらゆる場合において、検証者が証明者から何らかの知識（情報）を盗もうとしても、証明者の主張が真であること以上の知識は得られない\n\n\n名前の通り対話型は有名な洞窟の例のように証明者と検証者がやりとりを繰り返し、証明者が本当に正しい情報を持っているかを確率的に検証する方です。\n\n一方、非対話型のゼロ知識証明は証明者と検証者はやりとりをせずに証明することが可能です。対話を行う代わりに証明者と検証者の間に第三者を置き、CRSと呼ばれる事前に公開される情報を証明者と検証者に送ります。証明者はそのCRSを用いて正しい情報を持っているという証明を生成し、それを検証者に一回だけ送ります。受け取った検証者はそれを検証するだけで非対話なゼロ知識証明が実現できます。事前にCRSを生成することを一般的に信頼されたセットアップといい、第三者は証明者、検証者にとって信頼される存在となります。\n\nzk-SNARKs\n- Succinct（簡潔）\n    - 証明のサイズがステートメントのサイズと比べて非常に小さい\n- Non-interactive（非対話型）\n    - 証明者と検証者の間で何度も対話をする必要がない\n- ARgument\n    - 証明者の計算能力には限りがある\n- Knowledge\n    - 証明者は、知識なしでは証明を生成することは不可能である。\n\n[ZenGo-X/zk-paillier: A collection of Paillier cryptosystem zero knowledge proofs (github.com)](https://github.com/ZenGo-X/zk-paillier)\n\n[zk-SNARKsの理論 (zenn.dev)](https://zenn.dev/kyosuke/articles/a1854b9be26c01df13eb)","lastmodified":"2022-12-30T07:57:21.471263809Z","tags":null},"/crypto/cryptography/homomorphism":{"title":"準同型暗号","content":"\nレベルn準同型 = 加法準同型 + n回の乗算準同型\n- 乗算回数に制約がある完全準同型\n- レベルnはn次方程式を計算できる\n- レベル2準同型なら乗算が1度だけ可能\n\n## Unpadded RSA\n乗法準同型\n$$\n\\begin{aligned}\n\\mathcal{E}(m_1)\\times\\mathcal{E}(m_2) \u0026= m_1^em_2^e \u0026 \\bmod n \\\\\n\u0026= (m_1m_2)^e \u0026 \\bmod n \\\\\n\u0026= \\mathcal{E}(m_1m_2)\n\\end{aligned}\n$$\n## ElGamal暗号\n乗法準同型\n$$\n\\begin{aligned}\n\\mathcal{E}(m_1)\\times\\mathcal{E}(m_2) \u0026= (g^{r_1},m_1h^{r_1})(g^{r_2},m_2h^{r_2}) \\\\\n\u0026= (g^{r_1+r_2},m_1m_2h^{r_1+r_2}) \\\\\n\u0026= \\mathcal{E}(m_1m_2)\n\\end{aligned}\n$$\n## Paillier暗号\n加法準同型\n$$\n\\begin{aligned}\n\\mathcal{E}(m_1)\\times\\mathcal{E}(m_2) \u0026= (g^{m_1}r_1^n)(g^{m_2}r_2^n) \u0026 \\bmod n^2 \\\\\n\u0026= g^{m_1+m_2}(r_1r_2)^n \u0026 \\bmod n^2 \\\\\n\u0026= \\mathcal{E}(m_1+m_2)\n\\end{aligned}\n$$\n## 岡本・内山暗号\n加法準同型\n\n## Lifted-ElGamal暗号\nレベル2準同型暗号\n位数 $p$ の楕円曲線 $E$, と生成元 $P\\in E$\n秘密鍵 $s\\in\\mathbb{F}_p$ と公開鍵 $sP$\n平文 $m$ に対して乱数 $r$ をとり $c=(mP+rsP, rP)$\n$c = (S, T)$ に対して $S-sT = (mP+rsP)-s(rP)=mP$ としDLPを解いて $m$ を得る\n\n加法準同型性\n$$\n\\begin{aligned}\n\\mathcal{E}(m_1)+\\mathcal{E}(m_2) \u0026= (m_1P+r_1sP,r_1P)+(m_2P+r_2sP,r_2P) \\\\\n\u0026= ((m_1+m_2)P, (r_1+r_2)sP, (r_1+r_2)P) \\\\\n\u0026= \\mathcal{E}(m_1+m_2)\n\\end{aligned}\n$$\n乗法準同型性\n$\\mathcal{E}(m_1)\\times\\mathcal{E}(m_2) := (e(S_1, S_2), e(S_1, T_2), e(T_1, S_2), e(T_1, T_2))$\n$$\n\\begin{aligned}\n\\mathcal{D}(c_1,c_2,c_3,c_4) \u0026= \\frac{c_1c_4^{s_1s_2}}{c_2^{s_2}c_3^{s_1}} = \\frac{e(S_1,s_2)e(s_1T_1,s_2T_2)}{e(S_1,s_2T_2)e(s_1T_1,S_2)} \\\\\n\u0026=e(S_1-s_1T_1,S_2-s_2T_2) \\\\\n\u0026=e(mP_1,m'P_2)=e(P_1,P_2)^{mm'}\n\\end{aligned}\n$$\n\n\n[ペアリングベースの効率的なレベル2準同型暗号（SCIS2018） (slideshare.net)](https://www.slideshare.net/herumi/2scis2018?next_slideshow=86572957)\n\n\n完全準同型 ex. Gentry, 格子ベース\n## Gentry\n完全準同型\n## TFHE\n完全準同型\n","lastmodified":"2022-12-30T07:57:21.471263809Z","tags":null},"/crypto/cryptography/other":{"title":"その他の暗号","content":"\n[GoogleがTLSでの採用を提唱している共通鍵暗号方式「ChaCha」についてまとめた - sonickun.log (hatenablog.com)](https://sonickun.hatenablog.com/entry/2016/04/03/183220)\nChaCha [RFC 7538](https://tools.ietf.org/html/rfc7539)\nSalsa20\n\n\n\n[Integer factorization](https://en.wikipedia.org/wiki/Integer_factorization \"Integer factorization\")\n\n-   [Benaloh](https://en.wikipedia.org/wiki/Benaloh_cryptosystem \"Benaloh cryptosystem\")\n-   [Blum–Goldwasser](https://en.wikipedia.org/wiki/Blum%E2%80%93Goldwasser_cryptosystem \"Blum–Goldwasser cryptosystem\")\n-   [Cayley–Purser](https://en.wikipedia.org/wiki/Cayley%E2%80%93Purser_algorithm \"Cayley–Purser algorithm\")\n-   [Damgård–Jurik](https://en.wikipedia.org/wiki/Damg%C3%A5rd%E2%80%93Jurik_cryptosystem \"Damgård–Jurik cryptosystem\")\n-   [GMR](https://en.wikipedia.org/wiki/GMR_(cryptography) \"GMR (cryptography)\")\n-   [Goldwasser–Micali](https://en.wikipedia.org/wiki/Goldwasser%E2%80%93Micali_cryptosystem \"Goldwasser–Micali cryptosystem\")\n-   [Naccache–Stern](https://en.wikipedia.org/wiki/Naccache%E2%80%93Stern_cryptosystem \"Naccache–Stern cryptosystem\")\n-   [Paillier](https://en.wikipedia.org/wiki/Paillier_cryptosystem \"Paillier cryptosystem\")\n-   [Rabin](https://en.wikipedia.org/wiki/Rabin_cryptosystem \"Rabin cryptosystem\")\n-   [RSA](https://en.wikipedia.org/wiki/RSA_(cryptosystem) \"RSA (cryptosystem)\")\n-   [Okamoto–Uchiyama](https://en.wikipedia.org/wiki/Okamoto%E2%80%93Uchiyama_cryptosystem \"Okamoto–Uchiyama cryptosystem\")\n-   [Schmidt–Samoa](https://en.wikipedia.org/wiki/Schmidt-Samoa_cryptosystem \"Schmidt-Samoa cryptosystem\")\n\n[Discrete logarithm](https://en.wikipedia.org/wiki/Discrete_logarithm \"Discrete logarithm\")\n\n-   [BLS](https://en.wikipedia.org/wiki/Boneh%E2%80%93Lynn%E2%80%93Shacham \"Boneh–Lynn–Shacham\")\n-   [Cramer–Shoup](https://en.wikipedia.org/wiki/Cramer%E2%80%93Shoup_cryptosystem \"Cramer–Shoup cryptosystem\")\n-   [DH](https://en.wikipedia.org/wiki/Diffie%E2%80%93Hellman_key_exchange \"Diffie–Hellman key exchange\")\n-   [DSA](https://en.wikipedia.org/wiki/Digital_Signature_Algorithm \"Digital Signature Algorithm\")\n-   [ECDH](https://en.wikipedia.org/wiki/Elliptic-curve_Diffie%E2%80%93Hellman \"Elliptic-curve Diffie–Hellman\") \n    -   [X25519](https://en.wikipedia.org/wiki/Curve25519 \"Curve25519\")\n    -   [X448](https://en.wikipedia.org/wiki/Curve448 \"Curve448\")\n-   [ECDSA](https://en.wikipedia.org/wiki/Elliptic_Curve_Digital_Signature_Algorithm \"Elliptic Curve Digital Signature Algorithm\")\n-   [EdDSA](https://en.wikipedia.org/wiki/EdDSA \"EdDSA\") \n    -   [Ed25519](https://en.wikipedia.org/wiki/EdDSA#Ed25519 \"EdDSA\")\n    -   [Ed448](https://en.wikipedia.org/wiki/EdDSA#Ed448 \"EdDSA\")\n-   [ECMQV](https://en.wikipedia.org/wiki/ECMQV \"ECMQV\")\n-   [EKE](https://en.wikipedia.org/wiki/Encrypted_key_exchange \"Encrypted key exchange\")\n-   [ElGamal](https://en.wikipedia.org/wiki/ElGamal_encryption \"ElGamal encryption\") \n    -   [signature scheme](https://en.wikipedia.org/wiki/ElGamal_signature_scheme \"ElGamal signature scheme\")\n-   [MQV](https://en.wikipedia.org/wiki/MQV \"MQV\")\n-   [Schnorr](https://en.wikipedia.org/wiki/Schnorr_signature \"Schnorr signature\")\n-   [SPEKE](https://en.wikipedia.org/wiki/SPEKE \"SPEKE\")\n-   [SRP](https://en.wikipedia.org/wiki/Secure_Remote_Password_protocol \"Secure Remote Password protocol\")\n-   [STS](https://en.wikipedia.org/wiki/Station-to-Station_protocol \"Station-to-Station protocol\")\n\n[Lattice/SVP/CVP](https://en.wikipedia.org/wiki/Lattice-based_cryptography \"Lattice-based cryptography\")/[LWE](https://en.wikipedia.org/wiki/Learning_with_errors \"Learning with errors\")/[SIS](https://en.wikipedia.org/wiki/Short_integer_solution_problem \"Short integer solution problem\")\n\n-   [NTRUEncrypt](https://en.wikipedia.org/wiki/NTRUEncrypt \"NTRUEncrypt\")\n-   [NTRUSign](https://en.wikipedia.org/wiki/NTRUSign \"NTRUSign\")\n-   [RLWE-KEX](https://en.wikipedia.org/wiki/RLWE-KEX \"RLWE-KEX\")\n-   [RLWE-SIG](https://en.wikipedia.org/wiki/RLWE-SIG \"RLWE-SIG\")\n-   [BLISS](https://en.wikipedia.org/wiki/BLISS_signature_scheme \"BLISS signature scheme\")\n-   [NewHope](https://en.wikipedia.org/wiki/NewHope \"NewHope\")\n\nOthers\n\n-   [AE](https://en.wikipedia.org/wiki/Algebraic_Eraser \"Algebraic Eraser\")\n-   [CEILIDH](https://en.wikipedia.org/wiki/CEILIDH \"CEILIDH\")\n-   [EPOC](https://en.wikipedia.org/wiki/Efficient_Probabilistic_Public-Key_Encryption_Scheme \"Efficient Probabilistic Public-Key Encryption Scheme\")\n-   [HFE](https://en.wikipedia.org/wiki/Hidden_Field_Equations \"Hidden Field Equations\")\n-   [IES](https://en.wikipedia.org/wiki/Integrated_Encryption_Scheme \"Integrated Encryption Scheme\")\n-   [Lamport](https://en.wikipedia.org/wiki/Lamport_signature \"Lamport signature\")\n-   [McEliece](https://en.wikipedia.org/wiki/McEliece_cryptosystem \"McEliece cryptosystem\")\n-   [Merkle–Hellman](https://en.wikipedia.org/wiki/Merkle%E2%80%93Hellman_knapsack_cryptosystem \"Merkle–Hellman knapsack cryptosystem\")\n-   [Naccache–Stern knapsack cryptosystem](https://en.wikipedia.org/wiki/Naccache%E2%80%93Stern_knapsack_cryptosystem \"Naccache–Stern knapsack cryptosystem\")\n-   [Three-pass protocol](https://en.wikipedia.org/wiki/Three-pass_protocol \"Three-pass protocol\")\n-   [XTR](https://en.wikipedia.org/wiki/XTR \"XTR\")\n\nTheory\n\n-   [Discrete logarithm cryptography](https://en.wikipedia.org/wiki/Discrete_logarithm#Cryptography \"Discrete logarithm\")\n-   [Elliptic-curve cryptography](https://en.wikipedia.org/wiki/Elliptic-curve_cryptography \"Elliptic-curve cryptography\")\n-   [Hash-based cryptography](https://en.wikipedia.org/wiki/Hash-based_cryptography \"Hash-based cryptography\")\n-   [Non-commutative cryptography](https://en.wikipedia.org/wiki/Non-commutative_cryptography \"Non-commutative cryptography\")\n-   RSA problem\n-   [Trapdoor function](https://en.wikipedia.org/wiki/Trapdoor_function \"Trapdoor function\")\n\nStandardization\n\n-   [CRYPTREC](https://en.wikipedia.org/wiki/CRYPTREC \"CRYPTREC\")\n-   [IEEE P1363](https://en.wikipedia.org/wiki/IEEE_P1363 \"IEEE P1363\")\n-   [NESSIE](https://en.wikipedia.org/wiki/NESSIE \"NESSIE\")\n-   [NSA Suite B](https://en.wikipedia.org/wiki/NSA_Suite_B_Cryptography \"NSA Suite B Cryptography\")\n-   [Post-Quantum Cryptography](https://en.wikipedia.org/wiki/NIST_Post-Quantum_Cryptography_Standardization \"NIST Post-Quantum Cryptography Standardization\")\n\nTopics\n\n-   [Digital signature](https://en.wikipedia.org/wiki/Digital_signature \"Digital signature\")\n-   [OAEP](https://en.wikipedia.org/wiki/Optimal_asymmetric_encryption_padding \"Optimal asymmetric encryption padding\")\n-   [Fingerprint](https://en.wikipedia.org/wiki/Public_key_fingerprint \"Public key fingerprint\")\n-   [PKI](https://en.wikipedia.org/wiki/Public_key_infrastructure \"Public key infrastructure\")\n-   [Web of trust](https://en.wikipedia.org/wiki/Web_of_trust \"Web of trust\")\n-   [Key size](https://en.wikipedia.org/wiki/Key_size \"Key size\")\n-   [Identity-based cryptography](https://en.wikipedia.org/wiki/Identity-based_cryptography \"Identity-based cryptography\")\n-   [Post-quantum cryptography](https://en.wikipedia.org/wiki/Post-quantum_cryptography \"Post-quantum cryptography\")\n-   [OpenPGP card](https://en.wikipedia.org/wiki/OpenPGP_card \"OpenPGP card\")","lastmodified":"2022-12-30T07:57:21.471263809Z","tags":null},"/geometry/geometry":{"title":"幾何ライブラリ","content":"\n## 説明\n\n幾何ライブラリ\n複素平面\n\n## 計算量\n\n## 実装\n\n```cpp\n#include \u003cbits/stdc++.h\u003e\nusing namespace std;\n// using namespace atcoder;\nusing ll = long long;\nusing ld = long double;\nusing uint = unsigned;\nusing ull = unsigned long long;\n\nusing Real = long double;\n\nconst Real EPS = 1e-9;\nconst Real PI = 3.1415926535897932;\ninline bool equal(const Real \u0026a, const Real \u0026b) { return fabs(a - b) \u003c EPS; }\nReal radian_to_degree(const Real \u0026r) { return r * 180.0 / PI; }\nReal degree_to_radian(const Real \u0026d) { return d * PI / 180.0; }\n\nusing Point = complex\u003cReal\u003e;\n\nistream \u0026operator\u003e\u003e(istream \u0026is, Point \u0026p) {\n  Real a, b;\n  is \u003e\u003e a \u003e\u003e b;\n  p = Point(a, b);\n  return is;\n}\nostream \u0026operator\u003c\u003c(ostream \u0026os, Point \u0026p) {\n  return os \u003c\u003c fixed \u003c\u003c setprecision(10) \u003c\u003c p.real() \u003c\u003c \" \" \u003c\u003c p.imag();\n}\n\n// 点 p を反時計回りに theta 度回転\nPoint rotate(const Point \u0026p, const Real \u0026theta) {\n  return Point(cos(theta) * p.real() - sin(theta) * p.imag(),\n               sin(theta) * p.real() + cos(theta) * p.imag());\n}\n\nstruct Line {\n  Point a, b;\n  Line() = default;\n  Line(Point a, Point b) : a(a), b(b) {}\n\n  // Ax+By=C\n  Line(Real A, Real B, Real C) {\n    if (equal(A, 0))\n      a = Point(0, C / B), b = Point(1, C / B);\n    else if (equal(B, 0))\n      b = Point(C / A, 0), b = Point(C / A, 1);\n    else\n      a = Point(0, C / B), b = Point(C / A, 0);\n  }\n\n  friend ostream \u0026operator\u003c\u003c(ostream \u0026os, Line \u0026p) {\n    return os \u003c\u003c p.a \u003c\u003c \" to \" \u003c\u003c p.b;\n  }\n  friend istream \u0026operator\u003e\u003e(istream \u0026is, Line \u0026a) { return is \u003e\u003e a.a \u003e\u003e a.b; }\n};\n\nstruct Segment : Line {\n  Segment() = default;\n  Segment(Point a, Point b) : Line(a, b) {}\n};\n\nstruct Circle {\n  Point p;\n  Real r;\n\n  Circle() = default;\n  Circle(Point p, Real r) : p(p), r(r) {}\n};\n\nusing Points = vector\u003cPoint\u003e;\nusing Polygon = vector\u003cPoint\u003e;\nusing Segments = vector\u003cSegment\u003e;\nusing Lines = vector\u003cLine\u003e;\nusing Circles = vector\u003cCircle\u003e;\n\nReal dot(const Point \u0026a, const Point \u0026b) {\n  return (a.real() * b.real() + a.imag() * b.imag());\n}\n\nReal cross(const Point \u0026a, const Point \u0026b) {\n  return (a.real() * b.imag() - a.imag() * b.real());\n}\n\n// 点の回転方向\nstatic const int COUNTER_CLOCKWISE = 1;\nstatic const int CLOCKWISE = -1;\nstatic const int ONLINE_BACK = 2;\nstatic const int ONLINE_FRONT = -2;\nstatic const int ON_SEGMENT = 0;\nint ccw(Point p0, Point p1, Point p2) {\n  Point a = p1 - p0, b = p2 - p0;\n  if (cross(a, b) \u003e EPS) return COUNTER_CLOCKWISE;\n  if (cross(a, b) \u003c -EPS) return CLOCKWISE;\n  if (dot(a, b) \u003c -EPS) return ONLINE_BACK;\n  if (norm(a) \u003c norm(b)) return ONLINE_FRONT;\n  return ON_SEGMENT;\n}\n\nbool parallel(const Line \u0026a, const Line \u0026b) {\n  return equal(cross(a.b - a.a, b.b - b.a), 0.0);\n}\n\nbool orthogonal(const Line \u0026a, const Line \u0026b) {\n  return equal(dot(a.b - a.a, b.b - b.a), 0.0);\n}\n\n// 射影(projection)\n// 直線(線分)lに点pから引いた垂線の足を求める\nPoint projection(const Line \u0026l, const Point \u0026p) {\n  Real t = dot(p - l.a, l.a - l.b) / norm(l.a - l.b);\n  return l.a + (l.a - l.b) * t;\n}\n\nPoint projection(const Segment \u0026l, const Point \u0026p) {\n  Real t = dot(p - l.a, l.a - l.b) / norm(l.a - l.b);\n  return l.a + (l.a - l.b) * t;\n}\n\n// 反射(reflection)\n// 直線lを対称軸として点pと線対称の位置にある点を求める\nPoint reflection(const Line \u0026l, const Point \u0026p) {\n  return p + (projection(l, p) - p) * 2.0L;\n}\n\n// 線分sと線分tが交差しているかどうか\nbool isIntersect(const Segment \u0026s, const Segment \u0026t) {\n  return ccw(s.a, s.b, t.a) * ccw(s.a, s.b, t.b) \u003c= 0 \u0026\u0026\n         ccw(t.a, t.b, s.a) * ccw(t.a, t.b, s.b) \u003c= 0;\n}\n\nint isIntersect(const Circle \u0026c1, const Circle \u0026c2) {\n  Real d = norm(c1.p - c2.p);\n  // 2つの円が離れている場合\n  if (d \u003e norm(c1.r + c2.r) + EPS) return 4;\n  // 外接している場合\n  if (equal(d, norm(c1.r + c2.r))) return 3;\n  // 内接している場合\n  if (equal(d, norm(c1.r - c2.r))) return 1;\n  // 内包している場合\n  if (d \u003c norm(c1.r - c2.r) - EPS) return 0;\n  // 交差している場合\n  return 2;\n}\n```\n\n## 使用例\n\n\n","lastmodified":"2022-12-30T07:57:21.471263809Z","tags":null},"/graph/ShortestPath/BellmanFord":{"title":"単一始点最短路 (Bellman-Ford)","content":"\n## 説明\n\n全ての辺を更新できなくなるまで更新する。\n$V$ 回目のループで更新が発生するなら負閉路が存在する。\n\n## 計算量\n\n$O(EV)$\n\n## 実装\n\n```cpp\n#include \u003cvector\u003e\n\nconst long long LINF = 0x1fffffffffffffff;\n\nstruct Edge {\n  int from, to, cost;\n};\n\nclass BellmanFord {\n  std::vector\u003cEdge\u003e edges;\n  std::vector\u003clong long\u003e d;\n  int V, E;\n\n  BellmanFord(int v) : V(v), E(0) {}\n\n  void add_edge(int from, int to, int cost) {\n    edges.push_back({from, to, cost});\n    E++;\n  }\n  void add_edge(std::vector\u003cEdge\u003e \u0026es) {\n    for (auto \u0026edge : es) edges.push_back(edge);\n    E += es.size();\n  }\n\n  bool shortest_path(int s) {\n    for (int i = 0; i \u003c V; i++) d[i] = LINF;\n    d[s] = 0;\n    for (int v = 0; v \u003c V; v++) {\n      bool update = false;\n      for (int i = 0; i \u003c E; i++) {\n        auto e = edges[i];\n        if (d[e.from] != LINF \u0026\u0026 d[e.to] \u003e d[e.from] + e.cost) {\n          d[e.to] = d[e.from] + e.cost;\n          update = true;\n        }\n      }\n      // negative loop\n      if (v == V - 1 \u0026\u0026 update) return false;\n      if (!update) break;\n    }\n    return true;\n  }\n};\n```\n\n## 使用例\n\n","lastmodified":"2022-12-30T07:57:21.471263809Z","tags":null},"/graph/ShortestPath/Dijkstra":{"title":"単一始点最短路 (Dijkstra)","content":"\n## 説明\n有向グラフに負の辺が存在しないとき次の事がいえる。\n\n「まだ最短距離が確定していない点の中で、始点からの距離が最小 $\\iff$ 最短距離として確定」\n\n## 仕様\n\n- `ShortestPath\u003cT\u003e`\n\t- 始点から終点までの距離 `dist` \n\t- 始点からの最短路のパスで終点の1つ前の点 `from`\n- `ShortestPath\u003cT\u003e dijkstra(const Graph\u003cT\u003e \u0026g, int s)`\n\t- グラフ `g` について始点 `s` からの最短経路を計算する.\n\t- 密グラフ 単純に探索 $O(V^2)$\n\t- 疎グラフ ヒープを用いると $O(E\\log{V})$\n\n## 実装\n\n```cpp\ntemplate \u003ctypename T\u003e\nstruct ShortestPath {\n  vector\u003cT\u003e dist;\n  vector\u003cint\u003e from;\n};\n\ntemplate \u003ctypename T\u003e\nShortestPath\u003cT\u003e dijkstra(const Graph\u003cT\u003e \u0026g, int s) {\n  const auto INF = numeric_limits\u003cT\u003e::max();\n  vector\u003cT\u003e dist(g.size(), INF);\n  dist[s] = 0;\n  vector\u003cint\u003e from(g.size(), -1);\n  pq\u003cpair\u003cT, int\u003e\u003e q;\n  q.emplace(dist[s], s);\n\n  while (!q.empty()) {\n    auto [cost, idx] = q.top(); q.pop();\n    if (dist[idx] \u003c cost) continue;\n    for (auto \u0026e : g[idx]) {\n      if (dist[e.to] \u003e dist[idx] + e.cost) {\n        dist[e.to] = dist[idx] + e.cost;\n        from[e.to] = idx;\n        q.emplace(dist[e.to], e.to);\n      }\n    }\n  }\n  return {dist, from};\n}\n```\n\n## 使用例\n\n\n## 参考\n- [ダイクストラ法のよくあるミスと落し方 - あなたは嘘つきですかと聞かれたら「YES」と答えるブログ (hatenablog.com)](https://snuke.hatenablog.com/entry/2021/02/22/102734)\n","lastmodified":"2022-12-30T07:57:21.471263809Z","tags":null},"/graph/ShortestPath/FloydWarshall":{"title":"全点対最短路 (Floyd-Warshall)","content":"\n## 説明\n\n不安なら3回やればいい\n\n## 計算量\n\n$O(V^3)$\n\n## 実装\n\n```cpp\n#include \u003cvector\u003e\n\nstd::vector\u003cstd::vector\u003cint\u003e\u003e d;\nint V;\n\nvoid floyd_warshall() {\n  for (int k = 0; k \u003c V; k++)\n    for (int i = 0; i \u003c V; i++)\n      for (int j = 0; j \u003c V; j++) d[i][j] = std::min(d[i][j], d[i][k] + d[k][j]);\n}\n```\n\n## 使用例\n\n\n","lastmodified":"2022-12-30T07:57:21.471263809Z","tags":null},"/graph/ShortestPath/ShortestPath":{"title":"最短経路問題","content":"\n各点間に距離があるから目的地まで最短で辿り着く道筋を解く問題. これ読め.\n- [実践・最短経路問題 ～最短経路問題の見抜き方・立ち向かい方～ - Qiita](https://qiita.com/keymoon/items/ec985e7466e69b3a8655)","lastmodified":"2022-12-30T07:57:21.471263809Z","tags":null},"/graph/SpanningTree/Kruskal":{"title":"全域木 (Kruscal)","content":"","lastmodified":"2022-12-30T07:57:21.471263809Z","tags":null},"/graph/SpanningTree/Prim":{"title":"全域木 (Prim)","content":"","lastmodified":"2022-12-30T07:57:21.471263809Z","tags":null},"/graph/SpanningTree/SpanningTree":{"title":"全域木","content":"\n行列木定理\n- [行列木定理 – 37zigenのHP](https://37zigen.com/matrix-tree-theorem/)","lastmodified":"2022-12-30T07:57:21.471263809Z","tags":null},"/graph/flow/FordFulkerson":{"title":"最大流 (Ford Fulkerson)","content":"\n## 説明\n\n## 計算量\n\n$O(FE)$\n\n## 実装\n\n```cpp\n#include \u003cvector\u003e\n\nclass FordFulkerson {\n  struct edge {\n    long long to, cap, rev;\n  };\n  const long long INF = 1 \u003c\u003c 60;\n  long long n;\n  std::vector\u003cstd::vector\u003cedge\u003e\u003e G;\n  std::vector\u003cbool\u003e used;\n\n  long long dfs(long long s, long long t, long long f) {\n    if (s == t)\n      return f;\n    used[s] = true;\n    for (edge \u0026e : G[s]) {\n      if (!used[e.to] \u0026\u0026 e.cap \u003e 0) {\n        long long d = dfs(e.to, t, std::min(f, e.cap));\n        if (d \u003e 0) {\n          e.cap -= d;\n          G[e.to][e.rev].cap += d;\n          return d;\n        }\n      }\n    }\n    return 0;\n  }\n\npublic:\n  FordFulkerson(long long n) : n(n), G(n), used(n) {}\n  void add_edge(long long from, long long to, long long cap) {\n    G[from].push_back({to, cap, (long long)(G[to].size())});\n    G[to].push_back({from, 0, (long long)(G[from].size()) - 1});\n  }\n\n  long long max_flow(long long s, long long t) {\n    long long flow = 0;\n    while (true) {\n      used.assign(n, 0);\n      long long f = dfs(s, t, INF);\n      if (f == 0)\n        return flow;\n      flow += f;\n    }\n  }\n};\n```\n\n## 使用例\n","lastmodified":"2022-12-30T07:57:21.471263809Z","tags":null},"/graph/flow/dinic":{"title":"最大流 (Dinic)","content":"\n## 説明\n\n## 計算量\n\n$O(V^2E)$\n\n## 実装\n\n```cpp\n#include \u003cqueue\u003e\n#include \u003cvector\u003e\n\nstruct Dinic {\n  struct edge {\n    long long to, cap, rev;\n  };\n\n  long long n;\n  std::vector\u003cstd::vector\u003cedge\u003e\u003e G;\n  std::vector\u003clong long\u003e level, iter;\n\n  // level[i] = sからiへの最短距離(Dijkstra法)\n  void bfs(long long s) {\n    level.assign(n, -1);\n    std::queue\u003clong long\u003e q;\n    q.push(s);\n    level[s] = 0;\n    while (!q.empty()) {\n      long long v = q.front();\n      q.pop();\n      for (long long i = 0; i \u003c G[v].size(); i++) {\n        edge \u0026e = G[v][i];\n        if (e.cap \u003e 0 \u0026\u0026 level[e.to] \u003c 0) {\n          level[e.to] = level[v] + 1;\n          q.push(e.to);\n        }\n      }\n    }\n  }\n\n  // v -\u003e tの増加パスを1つ見つけて流す\n  long long dfs(long long v, long long t, long long f) {\n    if (v == t) return f;\n    for (long long i = iter[v]; i \u003c G[v].size(); i++) {\n      edge \u0026e = G[v][i];\n      if (e.cap \u003e 0 \u0026\u0026 level[v] \u003c level[e.to]) {\n        long long d = dfs(e.to, t, std::min(f, e.cap));\n        if (d \u003e 0) {\n          e.cap -= d;\n          G[e.to][e.rev].cap += d;\n          return d;\n        }\n      }\n    }\n    return 0;\n  }\n\n  Dinic(long long n) : n(n), G(n), level(n), iter(n) {}\n\n  void add_edge(long long from, long long to, long long cap) {\n    G[from].push_back({to, cap, (long long)G[to].size()});\n    G[to].push_back({from, 0, (long long)G[from].size() - 1});\n  }\n\n  long long max_flow(long long s, long long t) {\n    long long flow = 0;\n    while (true) {\n      bfs(s);\n      if (level[t] \u003c 0) return flow;\n      iter.assign(n, 0);\n      long long f;\n      while ((f = dfs(s, t, 1e9)) \u003e 0) { flow += f; }\n    }\n  }\n};\n```\n\n## 使用例\n","lastmodified":"2022-12-30T07:57:21.471263809Z","tags":null},"/graph/flow/flow":{"title":"フロー","content":"\n## 最大流\n始点から終点へ水を流すと最大でどれくらい流せるかという問題.\n\n- 各辺には容量 $c$ があり流量はこれを超えない.\n- 流量は入ってくる量と出ていく量が保存される.\n- $s$-$t$ カット\n\t- 頂点 $V$ を分割して, 始点 $s$ 側の集合 $S$ と終点 $t$ 側の集合 $T$ をおく.\n- $s$-$t$ カットの容量\n\t- $S$ から出て $T$ へ入る辺の容量の総和.\n- 最大フロー最小カット定理 (max-flow min-cut theorem)\n\t- 最小の $s$-$t$ カットの容量は $s$ から $t$ への最大流と等しい.\n\t- Ford-Fulkerson で証明する.\n\n## 二部グラフへの応用\n// TODO 証明\n- 二部グラフ\n\t- 頂点が2つのグループに分けられる.\n- 最大マッチング\n\t- 二部グラフで $A$ と $B$ のそれぞれ相性が与えられるから相性が合う組数を最大化させる問題.\n\t- 辺の容量をすべて1として始点と $A$, $B$ と終点を繋げて最大流を流すと答え.\n- 最小頂点被覆\n\t- 二部グラフである頂点とその隣接点で $V$ を被覆する頂点数を最小化する問題.\n\t- マッチング問題の最小カットが答え.\n- 独立集合、安定集合\n\n## 最小費用流\n最も安く始点から終点へある流量を流す問題.\n","lastmodified":"2022-12-30T07:57:21.471263809Z","tags":null},"/graph/graph":{"title":"グラフ","content":"\n## 説明\nグラフ (Graph) とは頂点の集合 $V$ と辺の集合 $E$ の組 $(V, E)$ です. 頂点 (Node) は点と見なせるオブジェクトの概念で, 辺 (Edge) は頂点 $u$ から頂点 $v$ へ向かう組 $(u, v)$ です. 辺には様々な属性を付け加えることがあります. 最短経路問題ならコストを付けて辺の移動に重みを付け加えたり, フローなら容量の最大値を付けて流量の制限を加えます.\n\n## 仕様\n多相型 `T` は整数または小数の型であることを仮定してます.\n- `Edge(int from, int to, T cost = 1)`\n\t- 頂点 `from` から頂点 `to` へコスト `cost` の辺を生成します.\n- `Graph(int n)`\n\t- 頂点が `n` 個のグラフを作ります.\n- `void add_directed_edge(int from, int to, T cost = 1)`\n\t- 有向辺を張ります.\n- `void add_edge(int from, int to, T cost = 1)`\n\t- 無向辺を張ります.\n\n## 実装\n```cpp\ntemplate \u003ctypename T = int\u003e\nstruct Edge {\n  int from, to;\n  T cost;\n\n  Edge() = default;\n  Edge(int from, int to, T cost = 1) : from(from), to(to), cost(cost) {}\n\n  operator int() const { return to; }\n};\n\ntemplate \u003ctypename T = int\u003e\nstruct Graph {\n  std::vector\u003cstd::vector\u003cEdge\u003cT\u003e\u003e\u003e g;\n\n  Graph() = default;\n  Graph(int n) : g(n) {}\n\n  void add_directed_edge(int from, int to, T cost = 1) {\n    g[from].emplace_back(from, to, cost);\n  }\n  void add_edge(int from, int to, T cost = 1) {\n    g[from].emplace_back(from, to, cost);\n    g[to].emplace_back(to, from, cost);\n  }\n\n  inline std::vector\u003cEdge\u003cT\u003e\u003e \u0026operator[](const int k) {\n    return g[k];\n  }\n};\n```\n\n## 参考\n","lastmodified":"2022-12-30T07:57:21.471263809Z","tags":null},"/graph/scc":{"title":"強連結成分分解","content":"\n## 説明\n有向グラフにおいて、ある部分グラフが強連結であるとは部分グラフの任意の2点が互いに行き来可能であること。深さ優先探索の帰りがけ順(トポロジカルソート順)に逆グラフを探索したときそれらが通る点は強連結成分となる。\n\n## 仕様\n- `dag`\n\t- `g` の強連結成分を1つの頂点として見たグラフ. DAGとなる.\n- `comp`\n\t- 各頂点に強連結成分は同じ値となるように値を割り当てる.\n- `group`\n\t- 強連結成分の頂点のリスト.\n- `void build()`\n\t- `dag`, `comp`, `group` を計算する.\n\t- $O(V + E)$\n\n## 実装\n```cpp\ntemplate \u003ctypename T = int\u003e\nstruct SCC : Graph\u003cT\u003e {\npublic:\n  using Graph\u003cT\u003e::Graph;\n  using Graph\u003cT\u003e::g;\n  Graph\u003cT\u003e dag;\n  vector\u003cint\u003e comp;\n  vector\u003cvector\u003cint\u003e\u003e group;\n\n  void build() {\n    // reversed graph\n    rg = Graph\u003cT\u003e(g.size());\n    for (size_t i = 0; i \u003c g.size(); i++) {\n      for (auto \u0026e : g[i]) {\n        rg.add_directed_edge(e.to, e.from, e.cost);\n      }\n    }\n    // topological sort labeling\n    used.assign(g.size(), false);\n    for (size_t i = 0; i \u003c g.size(); i++) dfs(i);\n    reverse(order.begin(), order.end());\n    // scc labeling\n    int cnt = 0;\n    comp.assign(g.size(), -1);\n    for (auto idx : order) if (comp[idx] == -1) rdfs(idx, cnt), cnt++;\n    // build dag\n    dag = Graph\u003cT\u003e(cnt);\n    for (size_t i = 0; i \u003c g.size(); i++) {\n      for (auto \u0026e : g[i]) {\n        int from = comp[e.from], to = comp[e.to];\n        if (from == to) continue;\n        dag.add_directed_edge(from, to, e.cost);\n      }\n    }\n    // grouping scc\n    group.resize(cnt);\n    for (size_t i = 0; i \u003c g.size(); i++) {\n      group[comp[i]].emplace_back(i);\n    }\n  }\n\n  int operator[](int k) const {\n    return comp[k];\n  }\n\nprivate:\n  Graph\u003cT\u003e rg;\n  vector\u003cint\u003e order;\n  vector\u003cbool\u003e used;\n\n  void dfs(int idx) {\n    if (used[idx]) return;\n    used[idx] = true;\n    for (auto \u0026to : g[idx]) dfs(to);\n    order.push_back(idx);\n  }\n\n  void rdfs(int idx, int cnt) {\n    if (comp[idx] != -1) return;\n    comp[idx] = cnt;\n    for (auto \u0026to : rg[idx]) rdfs(to, cnt);\n  }\n};\n```\n\n## 使用例\n\n## 参考\n- [強連結成分（SCC） | technical-note (hkawabata.github.io)](https://hkawabata.github.io/technical-note/note/Algorithm/graph/scc.html)\n- [Strongly Connected Components(強連結成分分解) | Luzhiled’s Library (ei1333.github.io)](https://ei1333.github.io/library/graph/connected-components/strongly-connected-components.hpp)\n","lastmodified":"2022-12-30T07:57:21.471263809Z","tags":null},"/graph/tree/diameter":{"title":"木の直径","content":"\n## 説明\n\n木の直径とはある2点間が最大となる距離である。\n\nどの頂点から始めても、そこから最も遠い頂点は直径の端点の1つになる。端点から最も遠い頂点はもう1つの端点になる。その2点の距離が木の直径となる。\n\n## 計算量\n\n$O(V + E)$\n\n## 実装\n\n```cpp\n#include \u003cvector\u003e\n\ntemplate \u003ctypename T\u003e\nstruct Edge {\n  int to;\n  T cost;\n};\n\nusing Graph = std::vector\u003cstd::vector\u003cEdge\u003clong long\u003e\u003e\u003e;\n\ntemplate \u003ctypename T\u003e\nstd::pair\u003cT, int\u003e dfs(const Graph \u0026G, int u, int par) {\n  auto ret = {0, u};\n  for (auto \u0026e : G) {\n    if (e.to == par) continue;\n    auto next = dfs\u003cT\u003e(G, e.to, u);\n    next.first += e.cost;\n    ret = std::max(ret, next);\n  }\n  return ret;\n}\n\ntemplate \u003ctypename T\u003e\nT tree_diameter(const Graph \u0026G) {\n  auto p = dfs(G, 0, -1);\n  auto q = dfs(G, p.second, -1);\n  return q.first;\n}\n```\n\n## 使用例\n\n\n","lastmodified":"2022-12-30T07:57:21.471263809Z","tags":null},"/memo":{"title":"","content":"仮想デスクトップについて開ける分野のサイトを制限する\n\nOWON SPE6103\n\n[面白さ＝文脈変化×納得感 - CGMプランナーの思考 (hatenablog.com)](https://web-ken.hatenablog.com/entry/2017/10/23/172021)\n\nJoel on Software\n[プログラマのためのユーザインタフェースデザイン 第1章: 環境をコントロールできれば楽しく感じるもの - The Joel on Software Translation Project (archive.org)](https://web.archive.org/web/20190521175932/http://local.joelonsoftware.com/wiki/%E3%83%97%E3%83%AD%E3%82%B0%E3%83%A9%E3%83%9E%E3%81%AE%E3%81%9F%E3%82%81%E3%81%AE%E3%83%A6%E3%83%BC%E3%82%B6%E3%82%A4%E3%83%B3%E3%82%BF%E3%83%95%E3%82%A7%E3%83%BC%E3%82%B9%E3%83%87%E3%82%B6%E3%82%A4%E3%83%B3_%E7%AC%AC1%E7%AB%A0:_%E7%92%B0%E5%A2%83%E3%82%92%E3%82%B3%E3%83%B3%E3%83%88%E3%83%AD%E3%83%BC%E3%83%AB%E3%81%A7%E3%81%8D%E3%82%8C%E3%81%B0%E6%A5%BD%E3%81%97%E3%81%8F%E6%84%9F%E3%81%98%E3%82%8B%E3%82%82%E3%81%AE)\n\n技術的詳細を知りたくない人に対して途中を読まずに結論さえ読めばよいような書き方をする のとそのようにことわること.\nコードだけで十分な人にはコードのセクションを読めばよいような書き方をするのとそのようにことわること.\n\n\n- トランジスタ (NPN接合)\n- 自作AVRマイコンライター\n- 自作電源\n- JTAG によるデバッグ\n- 自作NCフライス\n- 自作3Dプリンタ\n- 自作ICチップ(ウェハや薬品の調達、ワイヤーボンディングなどの壁があるので今のところ個人だとだいぶ厳しい)\n- 自作マザーボード\n- 自作メモリ\n- 自作CPU\n- CPU Break\n- 自作GPU\n- 自作OS\n- Kernel Exploit\n- 自作コンパイラ\n- 自作言語\n- 自作toolchain\n- ロスレス音声コーデック (PARCOR係数・エンコード済み残差信号)\n- Video\n- 自作ブラウザ\n- 自作深層学習フレームワーク\n- 自作git\n- 自作エディタ\n- 自作ゲームエンジン\n- 自作HTTPサーバソフト\n- 自作TCP/IPプロトコルスタック(自作OSに入るかも)\n- 自作ネットワークルータ","lastmodified":"2022-12-30T07:57:21.471263809Z","tags":null},"/misc/BinaryFormat/ASCII":{"title":"ASCII","content":"\nASCII; American (National) Standard Code for Information Interchage (ASA X3.4-1963で定義されている)\n\n## ASCII コード表\n\n全部入り\n\n| 10進 | 16進 | ASCII | 10進 | 16進 | ASCII | 10進 | 16進 | ASCII | 10進 | 16進 | ASCII |\n| ---- | ---- | ----- | ---- | ---- | ----- | ---- | ---- | ----- | ---- | ---- | ----- |\n| 0    | 0x0  | NULL  | 32   | 0x20 | SP    | 64   | 0x40 | @     | 96   | 0x60 | \\`    |\n| 1    | 0x1  | SOH   | 33   | 0x21 | !     | 65   | 0x41 | A     | 97   | 0x61 | a     |\n| 2    | 0x2  | STX   | 34   | 0x22 | \"     | 66   | 0x42 | B     | 98   | 0x62 | b     |\n| 3    | 0x3  | ETX   | 35   | 0x23 | #     | 67   | 0x43 | C     | 99   | 0x63 | c     |\n| 4    | 0x4  | EOT   | 36   | 0x24 | $     | 68   | 0x44 | D     | 100  | 0x64 | d     |\n| 5    | 0x5  | ENG   | 37   | 0x25 | %     | 69   | 0x45 | E     | 101  | 0x65 | e     |\n| 6    | 0x6  | ACK   | 38   | 0x26 | \u0026     | 70   | 0x46 | F     | 102  | 0x66 | f     |\n| 7    | 0x7  | BEL   | 39   | 0x27 | '     | 71   | 0x47 | G     | 103  | 0x67 | g     |\n| 8    | 0x8  | BS    | 40   | 0x28 | (     | 72   | 0x48 | H     | 104  | 0x68 | h     |\n| 9    | 0x9  | HT    | 41   | 0x29 | )     | 73   | 0x49 | I     | 105  | 0x69 | i     |\n| 10   | 0xa  | LF    | 42   | 0x2a | *     | 74   | 0x4a | J     | 106  | 0x6a | j     |\n| 11   | 0xb  | VT    | 43   | 0x2b | +     | 75   | 0x4b | K     | 107  | 0x6b | k     |\n| 12   | 0xc  | FF    | 44   | 0x2c | ,     | 76   | 0x4c | L     | 108  | 0x6c | l     |\n| 13   | 0xd  | CR    | 45   | 0x2d | -     | 77   | 0x4d | M     | 109  | 0x6d | m     |\n| 14   | 0xe  | SO    | 46   | 0x2e | .     | 78   | 0x4e | N     | 110  | 0x6e | n     |\n| 15   | 0xf  | SI    | 47   | 0x2f | /     | 79   | 0x4f | O     | 111  | 0x6f | o     |\n| 16   | 0x10 | DLE   | 48   | 0x30 | 0     | 80   | 0x50 | P     | 112  | 0x70 | p     |\n| 17   | 0x11 | DC1   | 49   | 0x31 | 1     | 81   | 0x51 | Q     | 113  | 0x71 | q     |\n| 18   | 0x12 | DC2   | 50   | 0x32 | 2     | 82   | 0x52 | R     | 114  | 0x72 | r     |\n| 19   | 0x13 | DC3   | 51   | 0x33 | 3     | 83   | 0x53 | S     | 115  | 0x73 | s     |\n| 20   | 0x14 | DC4   | 52   | 0x34 | 4     | 84   | 0x54 | T     | 116  | 0x74 | t     |\n| 21   | 0x15 | NAK   | 53   | 0x35 | 5     | 85   | 0x55 | U     | 117  | 0x75 | u     |\n| 22   | 0x16 | SYN   | 54   | 0x36 | 6     | 86   | 0x56 | V     | 118  | 0x76 | v     |\n| 23   | 0x17 | ETB   | 55   | 0x37 | 7     | 87   | 0x57 | W     | 119  | 0x77 | w     |\n| 24   | 0x18 | CAN   | 56   | 0x38 | 8     | 88   | 0x58 | X     | 120  | 0x78 | x     |\n| 25   | 0x19 | EM    | 57   | 0x39 | 9     | 89   | 0x59 | Y     | 121  | 0x79 | y     |\n| 26   | 0x1a | SUB   | 58   | 0x3a | :     | 90   | 0x5a | Z     | 122  | 0x7a | z     |\n| 27   | 0x1b | ESC   | 59   | 0x3b | ;     | 91   | 0x5b | \\[    | 123  | 0x7b | {     |\n| 28   | 0x1c | FS    | 60   | 0x3c | \u003c     | 92   | 0x5c | \\\\     | 124  | 0x7c | \\|    |\n| 29   | 0x1d | GS    | 61   | 0x3d | =     | 93   | 0x5d | ]     | 125  | 0x7d | }     |\n| 30   | 0x1e | RS    | 62   | 0x3e | \u003e     | 94   | 0x5e | ^     | 126  | 0x7e | ~     |\n| 31   | 0x1f | US    | 63   | 0x3f | ?     | 95   | 0x5f | _     | 127  | 0x7f | DEL   |\n\n16進数のみ\n\n|      | 0x00 | 0x01 | 0x02 | 0x03 | 0x04 | 0x05 | 0x06 | 0x07 | 0x08 | 0x09 | 0x0a | 0x0b | 0x0c | 0x0d | 0x0e | 0x0f |\n| ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |\n| 0x00 | NULL | SOH  | STX  | ETX  | EOT  | ENG  | ACK  | BEL  | BS   | HT   | LF   | VT   | FF   | CR   | SO   | SI   |\n| 0x10 | DLE  | DC1  | DC2  | DC3  | DC4  | NAK  | SYN  | ETB  | CAN  | EM   | SUB  | ESC  | FS   | GS   | RS   | US   |\n| 0x20 | SP   | !    | \"    | #    | $    | %    | \u0026    | '    | (    | )    | *    | +    | ,    | -    | .    | /    |\n| 0x30 | 0    | 1    | 2    | 3    | 4    | 5    | 6    | 7    | 8    | 9    | :    | ;    | \u003c    | =    | \u003e    | ?    |\n| 0x40 | @    | A    | B    | C    | D    | E    | F    | G    | H    | I    | J    | K    | L    | M    | N    | O    |\n| 0x50 | P    | Q    | R    | S    | T    | U    | V    | W    | X    | Y    | Z    | \\[   | \\\\   | ]    | ^    | _    |\n| 0x60 | \\`   | a    | b    | c    | d    | e    | f    | g    | h    | i    | j    | k    | l    | m    | n    | o    |\n| 0x70 | p    | q    | r    | s    | t    | u    | v    | w    | x    | y    | z    | {    | \\|   | }    | ~    | DEL  |\n\n10進数のみ\n\n|     | 00  | 01  | 02  | 03  | 04  | 05  | 06  | 07  | 08  | 09  |\n| --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- |\n| 30  |     |     | SP  | !   | \"   | #   | $   | %   | \u0026   | '   |\n| 40  | (   | )   | *   | +   | ,   | -   | .   | /   | 0   | 1   |\n| 50  | 2   | 3   | 4   | 5   | 6   | 7   | 8   | 9   | :   | ;   |\n| 60  | \u003c   | =   | \u003e   | ?   | @   | A   | B   | C   | D   | E   |\n| 70  | F   | G   | H   | I   | J   | K   | L   | M   | N   | O   |\n| 80  | P   | Q   | R   | S   | T   | U   | V   | W   | X   | Y   |\n| 90  | Z   | [   | \\\\  | ]   | ^   | _   | \\`  | a   | b   | c   |\n| 100 | d   | e   | f   | g   | h   | i   | j   | k   | l   | m   |\n| 110 | n   | o   | p   | q   | r   | s   | t   | u   | v   | w   |\n| 120 | x   | y   | z   | {   | \\|  | }   | ~   |     |     |     |\n\n## 例\n```\nString:  Hello, World!\nASCII:   H   e   l   l   o   ,     W  o   r   l   d   !\nHex:     48  65  6C  6C  6F  2C 20 57 6F  72  6C  64  21\nDecimal: 72  101 108 108 111 44 32 87 111 113 108 100 33\n```\n\n## 制御文字\n\n| キー    | 16進数 | 意味                      |\n| ------- | ------ | ------------------------- |\n| Ctrl-@  | 00     | Null                      |\n| Ctrl-A  | 01     | Start of Heading          |\n| Ctrl-B  | 02     | Start of Text             |\n| Ctrl-C  | 03     | End of Text               |\n| Ctrl-D  | 04     | End of Transmission       |\n| Ctrl-E  | 05     | Enquiry                   |\n| Ctrl-F  | 06     | Acknowledge               |\n| Ctrl-G  | 07     | Bell                      |\n| Ctrl-H  | 08     | Backspace                 |\n| Ctrl-I  | 09     | Horizontal Tab            |\n| Ctrl-J  | 0A     | Line Feed                 |\n| Ctrl-K  | 0B     | Vertical Tab              |\n| Ctrl-L  | 0C     | Form Feed                 |\n| Ctrl-M  | 0D     | Carriage Return           |\n| Ctrl-N  | 0E     | Shift In                  |\n| Ctrl-O  | 0F     | Shift Out                 |\n| Ctrl-P  | 10     | Data Link Escape          |\n| Ctrl-Q  | 11     | Device Control 1          |\n| Ctrl-R  | 12     | Device Control 2          |\n| Ctrl-S  | 13     | Device Control 3          |\n| Ctrl-T  | 14     | Device Control 4          |\n| Ctrl-U  | 15     | Negative Acknowledge      |\n| Ctrl-V  | 16     | Synchronous idle          |\n| Ctrl-W  | 17     | End of Transmission Block |\n| Ctrl-X  | 18     | Cancel                    |\n| Ctrl-Y  | 19     | End of Medium             |\n| Ctrl-Z  | 1A     | Substitute                |\n| Ctrl-\\[ | 1B     | Escape                    |\n| Ctrl-\\\\ | 1C     | File Separator            |\n| Ctrl-]  | 1D     | Group Separator           |\n| Ctrl-^  | 1E     | Record Separator          |\n| Ctrl-_  | 1F     | Unit Separator            |\n| Ctrl-?  | 7F     | Delete                    |\n\n## 参考\n- [ASCIIコード表 (k-cube.co.jp)](https://www.k-cube.co.jp/wakaba/server/ascii_code.html)","lastmodified":"2022-12-30T07:57:21.471263809Z","tags":null},"/misc/BinaryFormat/Base64":{"title":"Base64","content":"\n## 説明\n10 進数は `0-9`, 16 進数は `0-9A-F` と拡張されてて, それじゃ文字を沢山使えば 64 進数も書けるよね～って発想を規格にしたものが Base64 です. 実際には Base64 変換前のデータは数字ではなくバイナリが指定されます. 特に Web 周辺において URL や Cookie など文字列しか受け付けない環境でバイナリを書きたいときに Base64 を使えば楽に文字に落とし込んで渡せるので嬉しいよね～.\n\n## 仕様\n\n\n## 使い方\n\n```shell\n\u003e base64\n```\n\n## 脆弱性\nBase64 の仕様上同じデータを表す複数の Base64 が存在する.\n\n// TODO 具体例\n\n例えば, あるトークンを Base64 として完全一致したときに何らかの処理している場合は上のように同じデータとなるような Base64 を渡すことでバイパスされてしまいます. こういうときは変換後の文字列に対して完全一致すれば確実です.\n","lastmodified":"2022-12-30T07:57:21.471263809Z","tags":null},"/misc/BinaryFormat/ELF":{"title":"ELF","content":"\nELF Header\nProgram Header\nSegment","lastmodified":"2022-12-30T07:57:21.471263809Z","tags":null},"/misc/BinaryFormat/FAT32":{"title":"File System","content":"\nファイルシステム VFS\n- File Allocation Table (FAT)\n- FAT32\n- NTFS\n- ExFAT\n\n\n## FAT32\nFAT とは Microsoft によって開発されたいくつかのファイルシステム(FAT12, FAT16, FAT32, VFAT, exFAT)の総称です。\n\nここでは実装より仕組みの理解を優先した書き方をするので実装する方は規格などを読んでください。TODO: 規格のURL\nえるむさんの記事など\n[FATファイルシステムのしくみと操作法 (elm-chan.org)](http://elm-chan.org/docs/fat.html)\nそれでも仕様は追うので脆弱性を見つけたい方には有効です。\n\nクラスタ番号は2から始まります.\n\n```\nReserved sectors\n- Boot Sector\n- FS Information Sector (FAT32 only)\n- More reserved sectors (optional)\nFAT Region\n- File Allocation Table 1\n- File Allocation Table 2 (optional)\nRoot Directory Region (FAT12, FAT16 only)\n- Root Directory Table\nData Region\n- Cluster 2\n- Cluster 3\n...\n- Cluster N\n```\n\nFile Allocation Table は片方向連結リストです。FATエントリはエントリ番号と同じクラスタ番号のクラスタを保持し、次のエントリを指すことでリスト構造となります。終端には番兵が配置されています。\n\n```\nFile Allocation Table\n entry2 -\u003e entry7 -\u003e ... -\u003e entry23 -\u003e entry (sentinel)\n   |         |                |\ncluster2  cluster7         cluster23\n```\n\nFAT32では32ビット\n\nBoot Sectorには BIOS Parameter Block BPB や MBR や GPT が配置されます。\n\nファイルアクセスの方法\n\next4 fourth exteneded filesystem\n","lastmodified":"2022-12-30T07:57:21.471263809Z","tags":null},"/misc/BinaryFormat/Unicode":{"title":"Unicode","content":"\nUnicode (ユニコード) は，世界中のすべての文字を扱うことを目的として作られた，文字コードの規格です。  \n2014 年現在，約 11 万もの文字が Unicode に収録されています。\n\nUnicode の文字符号化方式には，主に次のようなものがあります。\n\n- UTF-8: 1 文字を最小 8 ビット，最大 32 ビットで表現。\n- UTF-16: 1 文字を最小 16 ビット，最大 32 ビットで表現。\n- UTF-32: 1 文字を 32 ビットで表現。\n\nWindows では，Win32 世代から Unicode がサポートされています。  \nWindows が採用している Unicode の文字符号化方式は，UTF-16 です。\n","lastmodified":"2022-12-30T07:57:21.471263809Z","tags":null},"/misc/BinaryFormat/ZIP":{"title":"ZIP","content":"\n\n\n```\n[local file header 1]\n[file data 1]\n[data descriptor 1]\n.\n.\n.\n[local file header n]\n[file data n]\n[data descriptor n]\n[archive decryption header]\n[archive extra data record]\n[central directory header 1]\n.\n.\n.\n[central directory header n]\n[zip64 end of central directory record]\n[zip64 end of central directory locator]\n[end of central directory record]\n```\n\n### Local file header\n```\n      local file header signature     4 bytes  (0x04034b50)\n      version needed to extract       2 bytes\n      general purpose bit flag        2 bytes\n      compression method              2 bytes\n      last mod file time              2 bytes\n      last mod file date              2 bytes\n      crc-32                          4 bytes\n      compressed size                 4 bytes\n      uncompressed size               4 bytes\n      file name length                2 bytes\n      extra field length              2 bytes\n\n      file name (variable size)\n      extra field (variable size)\n```\n\n\n\n\n\nZIPはディレクトリの階層構造は関係せずファイルを順に並べる。\n\n```\n\\ hoge\n |- foo\n |-\nbar\n```\n\nならば`/`のついたファイル名をZIP化したらどうなるか\n\n\nZIPローカルファイルヘッダ\nシグネチャ `50 4b 03 04`\nバージョン `14 00` 2.0\n`00 00`\n圧縮方法 `08 00` deflate\n最終変更日時 `45 97 90 53`\nCRC-32 `f7 45 3e aa`\n圧縮サイズ `16 00 00 00` 20 byte\n非圧縮サイズ `42 00 00 00` 68 byte\nファイル名の長さ `04 00` 4 byte\n拡張フィールドの長さ `1c 00` 28 byte\nファイル名(文字列) `74 65 73 74` test\n拡張フィールド\nファイルエントリ\n55 54 09 00 03 b1 0d bb 61 b4 0d bb 61 75\n78 0b 00 01 04 e8 03 00 00 04 e8 03 00 00 f3 48\ncd c9 c9 d7 51 88 f2 0c 50 08 cf 2f ca 49 51 24\n15 70 01 00 50 4b 01 02 1e 03 14 00 00 00 08 00\n45 97 90 53 f7 45 3e aa 16 00 00 00 42 00 00 00\n04 00 18 00 00 00 00 00 01 00 00 00 a4 81 00 00\n00 00 74 65 73 74 55 54 05 00 03 b1 0d bb 61 75\n78 0b 00 01 04 e8 03 00 00 04 e8 03 00 00 50 4b\n05 06 00 00 00 00 01 00 01 00 4a 00 00 00 54 00\n00 00 00 00\n\nZIPセントラルディレクトリファイルヘッダ\nシグネチャ 02 01 4B 50\n作成されたバージョン\n展開に必要なバージョン\n汎用目的のビットフラグ\n圧縮メソッド　（0:無圧縮、8:deflate）\nファイルの最終変更時間\nファイルの最終変更日付\nCRC-32\n圧縮サイズ byte\n非圧縮サイズ byte\nファイル名の長さ byte\n拡張フィールドの長さ byte\nファイルコメントの長さ byte\nファイルが開始するディスク番号 byte\n内部ファイル属性\n外部ファイル属性\nローカルファイルヘッダの相対オフセット byte\nファイル名(文字列)\n拡張フィールド\nファイルコメント(文字列)\n\nZIPセントラルディレクトリ終端レコード\nシグネチャ 06 05 4B 50\nディスクの数 枚\nセントラルディレクトリが開始するディスク番号 枚目\nこのディスク上のセントラルディレクトリレコードの数 個\nセントラルディレクトリレコードの合計数 個\nセントラルディレクトリのサイズ byte\nセントラルディレクトリの開始位置のオフセット byte\nZIPファイルコメントの長さ byte\nZIPファイルコメント(文字列)\n\nこれみてこれをみろという気持ちになった\n- [pics/README.md at master · corkami/pics (github.com)](https://github.com/corkami/pics/blob/master/binary/README.md)","lastmodified":"2022-12-30T07:57:21.471263809Z","tags":null},"/misc/BinaryFormat/hexadecimal":{"title":"16進数","content":"\n| 0   | 1   | 2   | 3   | 4   | 5   | 6   | 7   | 8   | 9   | A   | B   | C   | D   | E   | F   |\n| --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- |\n| 0   | 1   | 2   | 3   | 4   | 5   | 6   | 7   | 8   | 9   | 10  | 11  | 12  | 13  | 14  | 15  |\n","lastmodified":"2022-12-30T07:57:21.475263787Z","tags":null},"/misc/Misc/Pyjail":{"title":"Pyjail","content":"\nPythonはASCIIだけではなくUnicode全部使える\n合字を使うと文字数節約出来る\n[Pythonの識別子におけるUnicode正規化(NFKC)とpyjail - Satoooonの物置 (hatenablog.com)](https://satoooon1024.hatenablog.com/entry/2022/08/20/Python%E3%81%AE%E8%AD%98%E5%88%A5%E5%AD%90%E3%81%AB%E3%81%8A%E3%81%91%E3%82%8BUnicode%E6%AD%A3%E8%A6%8F%E5%8C%96%28NFKC%29%E3%81%A8pyjail)\n","lastmodified":"2022-12-30T07:57:21.475263787Z","tags":null},"/misc/OSINT":{"title":"OSINT (Open Source INTelligence)","content":"\n\nOSINT \n- [www.example.com | DNSViz](https://dnsviz.net/d/www.example.com/dnssec/)\n- 消された投稿を探す\n\t- [https://archive.org/web/](https://archive.org/web/ \"https://archive.org/web/\")\n\t- twitter [https://twilog.org twilog]\n- Reverse Image Search\n\t- Google Lens\n\t- [Fake news debunker by InVID \u0026 WeVerify - Chrome ウェブストア (google.com)](https://chrome.google.com/webstore/detail/fake-news-debunker-by-inv/mhccpoafgdgbhnjfhkcmgknndkeenfhe?hl=ja\u0026gl=SG)\n- SNSユーザー名を探す\n\t- [https://instantusername.com/](https://instantusername.com/ \"https://instantusername.com/\")\n- ファイル・ドメインのレピュテーションチェック\n\t- [any.run](https://any.run/)\n\t- [VirusTotal](https://virustotal.com/)\n- Tor onionアドレス\n- [OSINT Framework](https://osintframework.com/)\n- [SunCalc - sun position, sunlight phases, sunrise, sunset, dusk and dawn times calculator](http://suncalc.net/#/51.508,-0.125,2/2022.08.08/17:00)j\n\n## OSINTをメインに活動している組織\n- [bellingcat - the home of online investigations](https://www.bellingcat.com/)\n- Project Owl\n\n## 参考文献\n- [普段の調査で利用するOSINTまとめ](https://qiita.com/00001B1A/items/4d8ceb53993d3217307e)","lastmodified":"2022-12-30T07:57:21.475263787Z","tags":null},"/misc/forensics/forensics":{"title":"Forensics","content":"\nMITRE ATT\u0026CK\n\nAutoPsy\n\n[Detecting Linux Anti-Forensics: Timestomping (inversecos.com)](https://www.inversecos.com/2022/08/detecting-linux-anti-forensics.html)\nVirus Total\n","lastmodified":"2022-12-30T07:57:21.475263787Z","tags":null},"/misc/forensics/windows":{"title":"windows log","content":"\n実行されたPowershell スクリプトのログ\nEvent Viewer\nApplications and Services Logs \u003e Microsoft \u003e Windows \u003e PowerShell \u003e Operational\nPrefetchファイルを閲覧するにはWinPrefetchView\n\nPowerShell版Mimikatz などのPowerShellを用いたスクリプトはここに記録されている。\n\nLSASS (LSA Server Service)\n\nRemote Desktop Protocol のログ\nApplications and Services Logs \u003e Microsoft \u003e Windows \u003e TerminalServices-ClientActiveXCore \u003e Microsoft-Windows-TerminalServices-RDPClient/Operational\n\n[残された攻撃の痕跡を追え！　～Post-Exploitationで起きていること～ | インフォメーション・ディベロプメント (idnet.co.jp)](https://www.idnet.co.jp/column/page_186.html)","lastmodified":"2022-12-30T07:57:21.475263787Z","tags":null},"/notes/CJK-+-Latex-Support-%E6%B5%8B%E8%AF%95":{"title":"CJK + Latex Support (测试)","content":"\n## Chinese, Japanese, Korean Support\n几乎在我们意识到之前，我们已经离开了地面。\n\n우리가 그것을 알기도 전에 우리는 땅을 떠났습니다.\n\n私たちがそれを知るほぼ前に、私たちは地面を離れていました。\n\n## Latex\n\nBlock math works with two dollar signs `$$...$$`\n\n$$f(x) = \\int_{-\\infty}^\\infty\n    f\\hat(\\xi),e^{2 \\pi i \\xi x}\n    \\,d\\xi$$\n\t\nInline math also works with single dollar signs `$...$`. For example, Euler's identity but inline: $e^{i\\pi} = 0$\n\nAligned equations work quite well:\n\n$$\n\\begin{aligned}\na \u0026= b + c \\\\ \u0026= e + f \\\\\n\\end{aligned}\n$$\n\nAnd matrices\n\n$$\n\\begin{bmatrix}\n1 \u0026 2 \u0026 3 \\\\\na \u0026 b \u0026 c\n\\end{bmatrix}\n$$\n\n## RTL\nMore information on configuring RTL languages like Arabic in the [config](notes/config.md) page.","lastmodified":"2022-12-30T07:57:21.475263787Z","tags":null},"/notes/callouts":{"title":"Callouts","content":"\n## Callout support\n\nQuartz supports the same Admonition-callout syntax as Obsidian.\n\nThis includes\n- 12 Distinct callout types (each with several aliases)\n- Collapsable callouts\n\nSee [documentation on supported types and syntax here](https://help.obsidian.md/How+to/Use+callouts#Types).\n\n## Showcase\n\n\u003e [!EXAMPLE] Examples\n\u003e\n\u003e Aliases: example\n\n\u003e [!note] Notes\n\u003e\n\u003e Aliases: note\n\n\u003e [!abstract] Summaries \n\u003e\n\u003e Aliases: abstract, summary, tldr\n\n\u003e [!info] Info \n\u003e\n\u003e Aliases: info, todo\n\n\u003e [!tip] Hint \n\u003e\n\u003e Aliases: tip, hint, important\n\n\u003e [!success] Success \n\u003e\n\u003e Aliases: success, check, done\n\n\u003e [!question] Question \n\u003e\n\u003e Aliases: question, help, faq\n\n\u003e [!warning] Warning \n\u003e\n\u003e Aliases: warning, caution, attention\n\n\u003e [!failure] Failure \n\u003e\n\u003e Aliases: failure, fail, missing\n\n\u003e [!danger] Error\n\u003e\n\u003e Aliases: danger, error\n\n\u003e [!bug] Bug\n\u003e\n\u003e Aliases: bug\n\n\u003e [!quote] Quote\n\u003e\n\u003e Aliases: quote, cite\n","lastmodified":"2022-12-30T07:57:21.475263787Z","tags":null},"/notes/config":{"title":"Configuration","content":"\n## Configuration\nQuartz is designed to be extremely configurable. You can find the bulk of the configuration scattered throughout the repository depending on how in-depth you'd like to get.\n\nThe majority of configuration can be found under `data/config.yaml`. An annotated example configuration is shown below.\n\n```yaml {title=\"data/config.yaml\"}\n# The name to display in the footer\nname: Jacky Zhao\n\n# whether to globally show the table of contents on each page\n# this can be turned off on a per-page basis by adding this to the\n# front-matter of that note\nenableToc: true\n\n# whether to by-default open or close the table of contents on each page\nopenToc: false\n\n# whether to display on-hover link preview cards\nenableLinkPreview: true\n\n# whether to render titles for code blocks\nenableCodeBlockTitle: true \n\n# whether to render copy buttons for code blocks\nenableCodeBlockCopy: true \n\n# whether to render callouts\nenableCallouts: true\n\n# whether to try to process Latex\nenableLatex: true\n\n# whether to enable single-page-app style rendering\n# this prevents flashes of unstyled content and improves\n# smoothness of Quartz. More info in issue #109 on GitHub\nenableSPA: true\n\n# whether to render a footer\nenableFooter: true\n\n# whether backlinks of pages should show the context in which\n# they were mentioned\nenableContextualBacklinks: true\n\n# whether to show a section of recent notes on the home page\nenableRecentNotes: false\n\n# whether to display an 'edit' button next to the last edited field\n# that links to github\nenableGitHubEdit: true\nGitHubLink: https://github.com/jackyzha0/quartz/tree/hugo/content\n\n# whether to use Operand to power semantic search\n# IMPORTANT: replace this API key with your own if you plan on using\n# Operand search!\nenableSemanticSearch: false\noperandApiKey: \"REPLACE-WITH-YOUR-OPERAND-API-KEY\"\n\n# page description used for SEO\ndescription:\n  Host your second brain and digital garden for free. Quartz features extremely fast full-text search,\n  Wikilink support, backlinks, local graph, tags, and link previews.\n\n# title of the home page (also for SEO)\npage_title:\n  \"🪴 Quartz 3.3\"\n\n# links to show in the footer\nlinks:\n  - link_name: Twitter\n    link: https://twitter.com/_jzhao\n  - link_name: Github\n    link: https://github.com/jackyzha0\n```\n\n### Code Block Titles\nTo add code block titles with Quartz:\n\n1. Ensure that code block titles are enabled in Quartz's configuration:\n\n    ```yaml {title=\"data/config.yaml\", linenos=false}\n    enableCodeBlockTitle: true\n    ```\n\n2. Add the `title` attribute to the desired [code block\n   fence](https://gohugo.io/content-management/syntax-highlighting/#highlighting-in-code-fences):\n\n      ```markdown {linenos=false}\n       ```yaml {title=\"data/config.yaml\"}\n       enableCodeBlockTitle: true  # example from step 1\n       ```\n      ```\n\n**Note** that if `{title=\u003cmy-title\u003e}` is included, and code block titles are not\nenabled, no errors will occur, and the title attribute will be ignored.\n\n### HTML Favicons\nIf you would like to customize the favicons of your Quartz-based website, you \ncan add them to the `data/config.yaml` file. The **default** without any set \n`favicon` key is:\n\n```html {title=\"layouts/partials/head.html\", linenostart=15}\n\u003clink rel=\"shortcut icon\" href=\"icon.png\" type=\"image/png\"\u003e\n```\n\nThe default can be overridden by defining a value to the `favicon` key in your \n`data/config.yaml` file. For example, here is a `List[Dictionary]` example format, which is\nequivalent to the default:\n\n```yaml {title=\"data/config.yaml\", linenos=false}\nfavicon:\n  - { rel: \"shortcut icon\", href: \"icon.png\", type: \"image/png\" }\n#  - { ... } # Repeat for each additional favicon you want to add\n```\n\nIn this format, the keys are identical to their HTML representations.\n\nIf you plan to add multiple favicons generated by a website (see list below), it\nmay be easier to define it as HTML. Here is an example which appends the \n**Apple touch icon** to Quartz's default favicon:\n\n```yaml {title=\"data/config.yaml\", linenos=false}\nfavicon: |\n  \u003clink rel=\"shortcut icon\" href=\"icon.png\" type=\"image/png\"\u003e\n  \u003clink rel=\"apple-touch-icon\" sizes=\"180x180\" href=\"/apple-touch-icon.png\"\u003e\n```\n\nThis second favicon will now be used as a web page icon when someone adds your \nwebpage to the home screen of their Apple device. If you are interested in more \ninformation about the current and past standards of favicons, you can read \n[this article](https://www.emergeinteractive.com/insights/detail/the-essentials-of-favicons/).\n\n**Note** that all generated favicon paths, defined by the `href` \nattribute, are relative to the `static/` directory.\n\n### Graph View\nTo customize the Interactive Graph view, you can poke around `data/graphConfig.yaml`.\n\n```yaml {title=\"data/graphConfig.yaml\"}\n# if true, a Global Graph will be shown on home page with full width, no backlink.\n# A different set of Local Graphs will be shown on sub pages.\n# if false, Local Graph will be default on every page as usual\nenableGlobalGraph: false\n\n### Local Graph ###\nlocalGraph:\n    # whether automatically generate a legend\n    enableLegend: false\n    \n    # whether to allow dragging nodes in the graph\n    enableDrag: true\n    \n    # whether to allow zooming and panning the graph\n    enableZoom: true\n    \n    # how many neighbours of the current node to show (-1 is all nodes)\n    depth: 1\n    \n    # initial zoom factor of the graph\n    scale: 1.2\n    \n    # how strongly nodes should repel each other\n    repelForce: 2\n\n    # how strongly should nodes be attracted to the center of gravity\n    centerForce: 1\n\n    # what the default link length should be\n    linkDistance: 1\n    \n    # how big the node labels should be\n    fontSize: 0.6\n    \n    # scale at which to start fading the labes on nodes\n    opacityScale: 3\n\n### Global Graph ###\nglobalGraph:\n\t# same settings as above\n\n### For all graphs ###\n# colour specific nodes path off of their path\npaths:\n  - /moc: \"#4388cc\"\n```\n\n\n## Styling\nWant to go even more in-depth? You can add custom CSS styling and change existing colours through editing `assets/styles/custom.scss`. If you'd like to target specific parts of the site, you can add ids and classes to the HTML partials in `/layouts/partials`. \n\n### Partials\nPartials are what dictate what gets rendered to the page. Want to change how pages are styled and structured? You can edit the appropriate layout in `/layouts`.\n\nFor example, the structure of the home page can be edited through `/layouts/index.html`. To customize the footer, you can edit `/layouts/partials/footer.html`\n\nMore info about partials on [Hugo's website.](https://gohugo.io/templates/partials/)\n\nStill having problems? Checkout our [FAQ and Troubleshooting guide](notes/troubleshooting.md).\n\n## Language Support\n[CJK + Latex Support (测试)](notes/CJK%20+%20Latex%20Support%20(测试).md) comes out of the box with Quartz.\n\nWant to support languages that read from right-to-left (like Arabic)? Hugo (and by proxy, Quartz) supports this natively.\n\nFollow the steps [Hugo provides here](https://gohugo.io/content-management/multilingual/#configure-languages) and modify your `config.toml`\n\nFor example:\n\n```toml\ndefaultContentLanguage = 'ar'\n[languages]\n  [languages.ar]\n    languagedirection = 'rtl'\n    title = 'مدونتي'\n    weight = 1\n```\n","lastmodified":"2022-12-30T07:57:21.475263787Z","tags":null},"/notes/custom-Domain":{"title":"Custom Domain","content":"\n### Registrar\nThis step is only applicable if you are using a **custom domain**! If you are using a `\u003cYOUR-USERNAME\u003e.github.io` domain, you can skip this step.\n\nFor this last bit to take effect, you also need to create a CNAME record with the DNS provider you register your domain with (i.e. NameCheap, Google Domains).\n\nGitHub has some [documentation on this](https://docs.github.com/en/pages/configuring-a-custom-domain-for-your-github-pages-site/managing-a-custom-domain-for-your-github-pages-site), but the tldr; is to\n\n1. Go to your forked repository (`github.com/\u003cYOUR-GITHUB-USERNAME\u003e/quartz`) settings page and go to the Pages tab. Under \"Custom domain\", type your custom domain, then click **Save**.\n2. Go to your DNS Provider and create a CNAME record that points from your domain to `\u003cYOUR-GITHUB-USERNAME.github.io.` (yes, with the trailing period).\n\n\t![Example Configuration for Quartz](/notes/images/google-domains.png)*Example Configuration for Quartz*\n3. Wait 30 minutes to an hour for the network changes to kick in.\n4. Done!","lastmodified":"2022-12-30T07:57:21.475263787Z","tags":null},"/notes/editing":{"title":"Editing Content in Quartz","content":"\n## Editing \nQuartz runs on top of [Hugo](https://gohugo.io/) so all notes are written in [Markdown](https://www.markdownguide.org/getting-started/).\n\n### Folder Structure\nHere's a rough overview of what's what.\n\n**All content in your garden can found in the `/content` folder.** To make edits, you can open any of the files and make changes directly and save it. You can organize content into any folder you'd like.\n\n**To edit the main home page, open `/content/_index.md`.**\n\nTo create a link between notes in your garden, just create a normal link using Markdown pointing to the document in question. Please note that **all links should be relative to the root `/content` path**. \n\n```markdown\nFor example, I want to link this current document to `notes/config.md`.\n[A link to the config page](notes/config.md)\n```\n\nSimilarly, you can put local images anywhere in the `/content` folder.\n\n```markdown\nExample image (source is in content/notes/images/example.png)\n![Example Image](/content/notes/images/example.png)\n```\n\nYou can also use wikilinks if that is what you are more comfortable with!\n\n### Front Matter\nHugo is picky when it comes to metadata for files. Make sure that your title is double-quoted and that you have a title defined at the top of your file like so. You can also add tags here as well.\n\n```yaml\n---\ntitle: \"Example Title\"\ntags:\n- example-tag\n---\n\nRest of your content here...\n```\n\n### Obsidian\nI recommend using [Obsidian](http://obsidian.md/) as a way to edit and grow your digital garden. It comes with a really nice editor and graphical interface to preview all of your local files.\n\nThis step is **highly recommended**.\n\n\u003e 🔗 Step 3: [How to setup your Obsidian Vault to work with Quartz](notes/obsidian.md)\n\n## Previewing Changes\nThis step is purely optional and mostly for those who want to see the published version of their digital garden locally before opening it up to the internet. This is *highly recommended* but not required.\n\n\u003e 👀 Step 4: [Preview Quartz Changes](notes/preview%20changes.md)\n\nFor those who like to live life more on the edge, viewing the garden through Obsidian gets you pretty close to the real thing.\n\n## Publishing Changes\nNow that you know the basics of managing your digital garden using Quartz, you can publish it to the internet!\n\n\u003e 🌍 Step 5: [Hosting Quartz online!](notes/hosting.md)\n\nHaving problems? Checkout our [FAQ and Troubleshooting guide](notes/troubleshooting.md).\n","lastmodified":"2022-12-30T07:57:21.475263787Z","tags":null},"/notes/hosting":{"title":"Deploying Quartz to the Web","content":"\n## Hosting on GitHub Pages\nQuartz is designed to be effortless to deploy. If you forked and cloned Quartz directly from the repository, everything should already be good to go! Follow the steps below.\n\n### Enable GitHub Actions\nBy default, GitHub disables workflows from running automatically on Forked Repostories. Head to the 'Actions' tab of your forked repository and Enable Workflows to setup deploying your Quartz site!\n\n![Enable GitHub Actions](notes/images/github-actions.png)*Enable GitHub Actions*\n\n### Enable GitHub Pages\n\nHead to the 'Settings' tab of your forked repository and go to the 'Pages' tab.\n\n1. (IMPORTANT) Set the source to deploy from `master` (and not `hugo`) using `/ (root)`\n2. Set a custom domain here if you have one!\n\n![Enable GitHub Pages](/notes/images/github-pages.png)*Enable GitHub Pages*\n\n### Pushing Changes\nTo see your changes on the internet, we need to push it them to GitHub. Quartz is a `git` repository so updating it is the same workflow as you would follow as if it were just a regular software project.\n\n```shell\n# Navigate to Quartz folder\ncd \u003cpath-to-quartz\u003e\n\n# Commit all changes\ngit add .\ngit commit -m \"message describing changes\"\n\n# Push to GitHub to update site\ngit push origin hugo\n```\n\nNote: we specifically push to the `hugo` branch here. Our GitHub action automatically runs everytime a push to is detected to that branch and then updates the `master` branch for redeployment.\n\n### Setting up the Site\nNow let's get this site up and running. Never hosted a site before? No problem. Have a fancy custom domain you already own or want to subdomain your Quartz? That's easy too.\n\nHere, we take advantage of GitHub's free page hosting to deploy our site. Change `baseURL` in `/config.toml`. \n\nMake sure that your `baseURL` has a trailing `/`!\n\n[Reference `config.toml` here](https://github.com/jackyzha0/quartz/blob/hugo/config.toml)\n\n```toml\nbaseURL = \"https://\u003cYOUR-DOMAIN\u003e/\"\n```\n\nIf you are using this under a subdomain (e.g. `\u003cYOUR-GITHUB-USERNAME\u003e.github.io/quartz`), include the trailing `/`. **You need to do this especially if you are using GitHub!**\n\n```toml\nbaseURL = \"https://\u003cYOUR-GITHUB-USERNAME\u003e.github.io/quartz/\"\n```\n\nChange `cname` in `/.github/workflows/deploy.yaml`. Again, if you don't have a custom domain to use, you can use `\u003cYOUR-USERNAME\u003e.github.io`.\n\nPlease note that the `cname` field should *not* have any path `e.g. end with /quartz` or have a trailing `/`.\n\n[Reference `deploy.yaml` here](https://github.com/jackyzha0/quartz/blob/hugo/.github/workflows/deploy.yaml)\n\n```yaml {title=\".github/workflows/deploy.yaml\"}\n- name: Deploy  \n  uses: peaceiris/actions-gh-pages@v3  \n  with:  \n\tgithub_token: ${{ secrets.GITHUB_TOKEN }} # this can stay as is, GitHub fills this in for us!\n\tpublish_dir: ./public  \n\tpublish_branch: master\n\tcname: \u003cYOUR-DOMAIN\u003e\n```\n\nHave a custom domain? [Learn how to set it up with Quartz ](notes/custom%20Domain.md).\n\n### Ignoring Files\nOnly want to publish a subset of all of your notes? Don't worry, Quartz makes this a simple two-step process.\n\n❌ [Excluding pages from being published](notes/ignore%20notes.md)\n\n---\n\nNow that your Quartz is live, let's figure out how to make Quartz really *yours*!\n\n\u003e Step 6: 🎨 [Customizing Quartz](notes/config.md)\n\nHaving problems? Checkout our [FAQ and Troubleshooting guide](notes/troubleshooting.md).\n","lastmodified":"2022-12-30T07:57:21.475263787Z","tags":null},"/notes/ignore-notes":{"title":"Ignoring Notes","content":"\n### Quartz Ignore\nEdit `ignoreFiles` in `config.toml` to include paths you'd like to exclude from being rendered.\n\n```toml\n...\nignoreFiles = [  \n    \"/content/templates/*\",  \n    \"/content/private/*\", \n    \"\u003cyour path here\u003e\"\n]\n```\n\n`ignoreFiles` supports the use of Regular Expressions (RegEx) so you can ignore patterns as well (e.g. ignoring all `.png`s by doing `\\\\.png$`).\nTo ignore a specific file, you can also add the tag `draft: true` to the frontmatter of a note.\n\n```markdown\n---\ntitle: Some Private Note\ndraft: true\n---\n...\n```\n\nMore details in [Hugo's documentation](https://gohugo.io/getting-started/configuration/#ignore-content-and-data-files-when-rendering).\n\n### Global Ignore\nHowever, just adding to the `ignoreFiles` will only prevent the page from being access through Quartz. If you want to prevent the file from being pushed to GitHub (for example if you have a public repository), you need to also add the path to the `.gitignore` file at the root of the repository.","lastmodified":"2022-12-30T07:57:21.475263787Z","tags":null},"/notes/obsidian":{"title":"Obsidian Vault Integration","content":"\n## Setup\nObsidian is the preferred way to use Quartz. You can either create a new Obsidian Vault or link one that your already have.\n\n### New Vault\nIf you don't have an existing Vault, [download Obsidian](https://obsidian.md/) and create a new Vault in the `/content` folder that you created and cloned during the [setup](notes/setup.md) step.\n\n### Linking an existing Vault\nThe easiest way to use an existing Vault is to copy all of your files (directory and hierarchies intact) into the `/content` folder.\n\n## Settings\nGreat, now that you have your Obsidian linked to your Quartz, let's fix some settings so that they play well.\n\n1. Under Options \u003e Files and Links, set the New link format to always use Absolute Path in Vault.\n2. Go to Settings \u003e Files \u0026 Links \u003e Turn \"on\" automatically update internal links.\n\n![Obsidian Settings](/notes/images/obsidian-settings.png)*Obsidian Settings*\n\n## Templates\nInserting front matter everytime you want to create a new Note gets annoying really quickly. Luckily, Obsidian supports templates which makes inserting new content really easily.\n\n**If you decide to overwrite the `/content` folder completely, don't remove the `/content/templates` folder!**\n\nHead over to Options \u003e Core Plugins and enable the Templates plugin. Then go to Options \u003e Hotkeys and set a hotkey for 'Insert Template' (I recommend `[cmd]+T`). That way, when you create a new note, you can just press the hotkey for a new template and be ready to go!\n\n\u003e 👀 Step 4: [Preview Quartz Changes](notes/preview%20changes.md)","lastmodified":"2022-12-30T07:57:21.475263787Z","tags":null},"/notes/philosophy":{"title":"Quartz Philosophy","content":"\n\u003e “[One] who works with the door open gets all kinds of interruptions, but [they] also occasionally gets clues as to what the world is and what might be important.” — Richard Hamming\n\n## Why Quartz?\nHosting a public digital garden isn't easy. There are an overwhelming number of tutorials, resources, and guides for tools like [Notion](https://www.notion.so/), [Roam](https://roamresearch.com/), and [Obsidian](https://obsidian.md/), yet none of them have super easy to use *free* tools to publish that garden to the world.\n\nI've personally found that\n1. It's nice to access notes from anywhere\n2. Having a public digital garden invites open conversations\n3. It makes keeping personal notes and knowledge *playful and fun*\n\nI was really inspired by [Bianca](https://garden.bianca.digital/) and [Joel](https://joelhooks.com/digital-garden)'s digital gardens and wanted to try making my own.\n\n**The goal of Quartz is to make hosting your own public digital garden free and simple.** You don't even need your own website. Quartz does all of that for you and gives your own little corner of the internet.\n","lastmodified":"2022-12-30T07:57:21.475263787Z","tags":null},"/notes/preview-changes":{"title":"Preview Changes","content":"\nIf you'd like to preview what your Quartz site looks like before deploying it to the internet, here's exactly how to do that!\n\nNote that both of these steps need to be completed.\n\n## Install `hugo-obsidian`\nThis step will generate the list of backlinks for Hugo to parse. Ensure you have [Go](https://golang.org/doc/install) (\u003e= 1.16) installed.\n\n```bash\n# Install and link `hugo-obsidian` locally\ngo install github.com/jackyzha0/hugo-obsidian@latest\n```\n\nIf you are running into an error saying that `command not found: hugo-obsidian`, make sure you set your `GOPATH` correctly! This will allow your terminal to correctly recognize hugo-obsidian as an executable.\n\nAfterwards, start the Hugo server as shown above and your local backlinks and interactive graph should be populated!\n\n##  Installing Hugo\nHugo is the static site generator that powers Quartz. [Install Hugo with \"extended\" Sass/SCSS version](https://gohugo.io/getting-started/installing/) first. Then,\n\n```bash\n# Navigate to your local Quartz folder\ncd \u003clocation-of-your-local-quartz\u003e\n\n# Start local server\nmake serve\n\n# View your site in a browser at http://localhost:1313/\n```\n\n\u003e 🌍 Step 5: [Hosting Quartz online!](notes/hosting.md)","lastmodified":"2022-12-30T07:57:21.475263787Z","tags":null},"/notes/search":{"title":"Search","content":"\nQuartz supports two modes of searching through content.\n\n## Full-text\nFull-text search is the default in Quartz. It produces results that *exactly* match the search query. This is easier to setup but usually produces lower quality matches.\n\n```yaml {title=\"data/config.yaml\"}\n# the default option\nenableSemanticSearch: false\n```\n\n## Natural Language\nNatural language search is powered by [Operand](https://operand.ai/). It understands language like a person does and finds results that best match user intent. In this sense, it is closer to how Google Search works.\n\nNatural language search tends to produce higher quality results than full-text search.\n\nHere's how to set it up.\n\n1. Create an Operand Account on [their website](https://operand.ai/).\n2. Go to Dashboard \u003e Settings \u003e Integrations.\n3. Follow the steps to setup the GitHub integration. Operand needs access to GitHub in order to index your digital garden properly!\n4. Head over to Dashboard \u003e Objects and press `(Cmd + K)` to open the omnibar and select 'Create Collection'.\n\t1. Set the 'Collection Label' to something that will help you remember it.\n\t2. You can leave the 'Parent Collection' field empty.\n5. Click into your newly made Collection.\n\t1. Press the 'share' button that looks like three dots connected by lines.\n\t2. Set the 'Interface Type' to `object-search` and click 'Create'.\n\t3. This will bring you to a new page with a search bar. Ignore this for now.\n6. Go back to Dashboard \u003e Settings \u003e API Keys and find your Quartz-specific Operand API key under 'Other keys'.\n\t1. Copy the key (which looks something like `0e733a7f-9b9c-48c6-9691-b54fa1c8b910`).\n\t2. Open `data/config.yaml`. Set `enableSemanticSearch` to `true` and `operandApiKey` to your copied key.\n\n```yaml {title=\"data/config.yaml\"}\n# the default option\nenableSemanticSearch: true\noperandApiKey: \"0e733a7f-9b9c-48c6-9691-b54fa1c8b910\"\n```\n7. Make a commit and push your changes to GitHub. See the [[notes/hosting|hosting]] page if you haven't done this already.\n\t1. This step is *required* for Operand to be able to properly index your content. \n\t2. Head over to Dashboard \u003e Objects and select the collection that you made earlier\n8. Press `(Cmd + K)` to open the omnibar again and select 'Create GitHub Repo'\n\t1. Set the 'Repository Label' to `Quartz`\n\t2. Set the 'Repository Owner' to your GitHub username\n\t3. Set the 'Repository Ref' to `master`\n\t4. Set the 'Repository Name' to the name of your repository (usually just `quartz` if you forked the repository without changing the name)\n\t5. Leave 'Root Path' and 'Root URL' empty\n9. Wait for your repository to index and enjoy natural language search in Quartz! Operand refreshes the index every 2h so all you need to do is just push to GitHub to update the contents in the search.","lastmodified":"2022-12-30T07:57:21.475263787Z","tags":null},"/notes/setup":{"title":"Setup","content":"\n## Making your own Quartz\nSetting up Quartz requires a basic understanding of `git`. If you are unfamiliar, [this resource](https://resources.nwplus.io/2-beginner/how-to-git-github.html) is a great place to start!\n\n### Forking\n\u003e A fork is a copy of a repository. Forking a repository allows you to freely experiment with changes without affecting the original project.\n\nNavigate to the GitHub repository for the Quartz project:\n\n📁 [Quartz Repository](https://github.com/jackyzha0/quartz)\n\nThen, Fork the repository into your own GitHub account. If you don't have an account, you can make on for free [here](https://github.com/join). More details about forking a repo can be found on [GitHub's documentation](https://docs.github.com/en/get-started/quickstart/fork-a-repo).\n\n### Cloning\nAfter you've made a fork of the repository, you need to download the files locally onto your machine. Ensure you have `git`, then type the following command replacing `YOUR-USERNAME` with your GitHub username.\n\n```shell\ngit clone https://github.com/YOUR-USERNAME/quartz\n```\n\n## Editing\nGreat! Now you have everything you need to start editing and growing your digital garden. If you're ready to start writing content already, check out the recommended flow for editing notes in Quartz.\n\n\u003e ✏️ Step 2: [Editing Notes in Quartz](notes/editing.md)\n\nHaving problems? Checkout our [FAQ and Troubleshooting guide](notes/troubleshooting.md).\n","lastmodified":"2022-12-30T07:57:21.475263787Z","tags":null},"/notes/showcase":{"title":"Showcase","content":"\nWant to see what Quartz can do? Here are some cool community gardens :)\n\n- [Quartz Documentation (this site!)](https://quartz.jzhao.xyz/)\n- [Jacky Zhao's Garden](https://jzhao.xyz/)\n- [Scaling Synthesis - A hypertext research notebook](https://scalingsynthesis.com/)\n- [AWAGMI Intern Notes](https://notes.awagmi.xyz/)\n- [Shihyu's PKM](https://shihyuho.github.io/pkm/)\n- [Chloe's Garden](https://garden.chloeabrasada.online/)\n- [SlRvb's Site](https://slrvb.github.io/Site/)\n- [Course notes for Information Technology Advanced Theory](https://a2itnotes.github.io/quartz/)\n- [Brandon Boswell's Garden](https://brandonkboswell.com)\n- [Siyang's Courtyard](https://siyangsun.github.io/courtyard/)\n- [Data Dictionary 🧠](https://glossary.airbyte.com/)\n- [sspaeti.com's Second Brain](https://brain.sspaeti.com/)\n- [oldwinterの数字花园](https://garden.oldwinter.top/)\n- [SethMB Work](https://sethmb.xyz/)\n\nIf you want to see your own on here, submit a [Pull Request adding yourself to this file](https://github.com/jackyzha0/quartz/blob/hugo/content/notes/showcase.md)!\n","lastmodified":"2022-12-30T07:57:21.475263787Z","tags":null},"/notes/troubleshooting":{"title":"Troubleshooting and FAQ","content":"\nStill having trouble? Here are a list of common questions and problems people encounter when installing Quartz.\n\nWhile you're here, join our [Discord](https://discord.gg/cRFFHYye7t) :)\n\n### Does Quartz have Latex support?\nYes! See [CJK + Latex Support (测试)](notes/CJK%20+%20Latex%20Support%20(测试).md) for a brief demo.\n\n### Can I use \\\u003cObsidian Plugin\\\u003e in Quartz?\nUnless it produces direct Markdown output in the file, no. There currently is no way to bundle plugin code with Quartz.\n\nThe easiest way would be to add your own HTML partial that supports the functionality you are looking for.\n\n### My GitHub pages is just showing the README and not Quartz\nMake sure you set the source to deploy from `master` (and not `hugo`) using `/ (root)`! See more in the [hosting](/notes/hosting) guide\n\n### Some of my pages have 'January 1, 0001' as the last modified date\nThis is a problem caused by `git` treating files as case-insensitive by default and some of your posts probably have capitalized file names. You can turn this off in your Quartz by running this command.\n\n```shell\n# in the root of your Quartz (same folder as config.toml)\ngit config core.ignorecase true\n\n# or globally (not recommended)\ngit config --global core.ignorecase true\n```\n\n### Can I publish only a subset of my pages?\nYes! Quartz makes selective publishing really easy. Heres a guide on [excluding pages from being published](notes/ignore%20notes.md).\n\n### Can I host this myself and not on GitHub Pages?\nYes! All built files can be found under `/public` in the `master` branch. More details under [hosting](notes/hosting.md).\n\n### `command not found: hugo-obsidian`\nMake sure you set your `GOPATH` correctly! This will allow your terminal to correctly recognize `hugo-obsidian` as an executable.\n\n```shell\n# Add the following 2 lines to your ~/.bash_profile\nexport GOPATH=/Users/$USER/go\nexport PATH=$GOPATH/bin:$PATH\n\n# In your current terminal, to reload the session\nsource ~/.bash_profile\n```\n\n### How come my notes aren't being rendered?\nYou probably forgot to include front matter in your Markdown files. You can either setup [Obsidian](notes/obsidian.md) to do this for you or you need to manually define it. More details in [the 'how to edit' guide](notes/editing.md).\n\n### My custom domain isn't working!\nWalk through the steps in [the hosting guide](notes/hosting.md) again. Make sure you wait 30 min to 1 hour for changes to take effect.\n\n### How do I setup Google Analytics?\nYou can edit it in `config.toml` and either use a V3 (UA-) or V4 (G-) tag.\n\n### How do I change the content on the home page?\nTo edit the main home page, open `/content/_index.md`.\n\n### How do I change the colours?\nYou can change the theme by editing `assets/custom.scss`. More details on customization and themeing can be found in the [customization guide](notes/config.md).\n\n### How do I add images?\nYou can put images anywhere in the `/content` folder.\n\n```markdown\nExample image (source is in content/notes/images/example.png)\n![Example Image](/content/notes/images/example.png)\n```\n\n### My Interactive Graph and Backlinks aren't up to date\nBy default, the `linkIndex.json` (which Quartz needs to generate the Interactive Graph and Backlinks) are not regenerated locally. To set that up, see the guide on [local editing](notes/editing.md)\n\n### Can I use React/Vue/some other framework?\nNot out of the box. You could probably make it work by editing `/layouts/_default/single.html` but that's not what Quartz is designed to work with. 99% of things you are trying to do with those frameworks you can accomplish perfectly fine using just vanilla HTML/CSS/JS.\n\n## Still Stuck?\nQuartz isn't perfect! If you're still having troubles, file an issue in the GitHub repo with as much information as you can reasonably provide. Alternatively, you can message me on [Twitter](https://twitter.com/_jzhao) and I'll try to get back to you as soon as I can.\n\n🐛 [Submit an Issue](https://github.com/jackyzha0/quartz/issues)","lastmodified":"2022-12-30T07:57:21.475263787Z","tags":null},"/notes/updating":{"title":"Updating","content":"\nHaven't updated Quartz in a while and want all the cool new optimizations? On Unix/Mac systems you can run the following command for a one-line update! This command will show you a log summary of all commits since you last updated, press `q` to acknowledge this. Then, it will show you each change in turn and press `y` to accept the patch or `n` to reject it. Usually you should press `y` for most of these unless it conflicts with existing changes you've made! \n\n```shell\nmake update\n```\n\nOr, if you don't want the interactive parts and just want to force update your local garden (this assumed that you are okay with some of your personalizations been overriden!)\n\n```shell\nmake update-force\n```\n\nOr, manually checkout the changes yourself.\n\n\u003e [!warning] Warning!\n\u003e\n\u003e If you customized the files in `data/`, or anything inside `layouts/`, your customization may be overwritten!\n\u003e Make sure you have a copy of these changes if you don't want to lose them.\n\n\n```shell\n# add Quartz as a remote host\ngit remote add upstream git@github.com:jackyzha0/quartz.git\n\n# index and fetch changes\ngit fetch upstream\ngit checkout -p upstream/hugo -- layouts .github Makefile assets/js assets/styles/base.scss assets/styles/darkmode.scss config.toml data \n```\n","lastmodified":"2022-12-30T07:57:21.475263787Z","tags":null},"/other/Blockchain":{"title":"ブロックチェーン","content":"\nトランザクションをgit管理する。\n`H( H(transaction | prev_hash | created_at) | nonce) = 0000,,,`\n疑問 ある部分から先頭まで整合するように改変すれば改ざんできそうじゃない？\n\n多くの人が何か価値があると思っているから価値がある。\n\nコントラクト\n\nEthereum\n\n- [Beanstalkのexploitに感動したので半年ぶりにブログ書く - DeFiで落ちてるお金を拾いたいブログ (vividot-de.fi)](https://vividot-de.fi/entry/beanstalk-exploit)","lastmodified":"2022-12-30T07:57:21.475263787Z","tags":null},"/other/Circuit/Analog/Analog":{"title":"アナログ回路","content":"","lastmodified":"2022-12-30T07:57:21.475263787Z","tags":null},"/other/Circuit/Analog/Chopper":{"title":"チョッパ回路","content":"","lastmodified":"2022-12-30T07:57:21.475263787Z","tags":null},"/other/Circuit/Analog/MultiVibrator":{"title":"マルチバイブレータ回路","content":"","lastmodified":"2022-12-30T07:57:21.475263787Z","tags":null},"/other/Circuit/Analog/PowerElectronics":{"title":"パワー・エレクトロニクス","content":"\n電源\nLCRメーター\n\n自作VVVFインバーター\nチョッパ昇圧回路","lastmodified":"2022-12-30T07:57:21.475263787Z","tags":null},"/other/Circuit/Analog/SensorActuator":{"title":"センサー・アクチュエータ","content":"\n気圧センサー\n水圧センサー\n\n## モーターコントローラー\nHブリッジを用いて電気を流し正転、逆転するのと逆起電力によるブレーキを操作している。\nMOSFET を4つ","lastmodified":"2022-12-30T07:57:21.475263787Z","tags":null},"/other/Circuit/Circuit":{"title":"回路","content":"\n回路全然わからんから完全に理解するまでの軌跡を書く.\n高校に遡ると私はコンピュータクラブに所属していて, 先輩に誘われ, 水中ロボコンにプログラミング担当として参加した. しかしプログラミングの方が好きで1ミリも回路なんか知らずにやってたので何もわからず, 優勝して終わった. 高学年になってくると低レイヤーが好きになっていき. 次第に回路にも興味が出るようになったが当時手に入る文献は簡単なものしかなく Arduino やラズパイでちょっと触るくらいで基板などには手が届かなかった. そして受験を経て大学に入り, 東工大のロ技研というロボットを製作するサークルに入った. そこでは念願の回路設計班に志望し入れた. しかし, 自分の専門が物理学系で完全にアウェイな環境で回路がよくわからずみんなに先越され, どう学べばいいのかわからず幽霊になってた.\n1年後, 友人が自作 LSI をしていて自分も作りたくなったり, 自分が主催しているセミナーの講師が回路に詳しいということで再びデジタル回路に興味を持ち, その一環としてロ技研での活動を再開することにした. \n\n理解したい一心でやる.\n\n## 1日目 前提知識\n\nまず高校で習った回路を思い出してみる.\n\n- 回路とは電気が電源の+から動かしたい電子部品や導線を通って-に戻ってくる1周の輪.\n- 電流は電荷の流れ. 電源が電位を上げ, 電流を流し, 電子部品が電位を下げる.\n- 任意のループについて, 電位変化は0となる.\n- 任意の節点について, 電流は保存する.\n- 任意の区間について, 電圧, 電流, 抵抗にはオームの法則 $V=IR$ が成り立つ.\n- 使うエネルギーは電力 $P = VI$ で分かる. 電力が大きすぎると発熱し, 壊れる危険がある.\n- コンデンサに電圧を掛けると電荷 $Q = CV$ が集まる.\n\nこんな感じかな. あとは交流回路もやったけど知識として少ないから後でまとめる.\n\n## 2日目 交流回路の基礎\n\n大学で回路の授業を取ったのでそれを復習する.\n\n交流回路は電圧が波の形をしている. 位相は三角関数より複素数の方が扱いやすいのでそれを使う. ちなみにその虚部は実際に観測されない. そのままだと電流と虚数単位の記号が被さるから電流 $i$ は虚数単位 $j$ と書く.\n- 実数表示だと $v = V_m\\sin(\\omega t + \\phi)$\n- 複素表示だと $v=V_me^{j(\\omega t + \\phi)}$\n\n| 電子部品       | 関係式                                 | 直流回路 | 交流回路                   |\n| -------------- | -------------------------------------- | -------- | -------------------------- |\n| 抵抗 $R$       | $v = Ri$                               | $v = Ri$ | $v = Ri$                   |\n| コイル $L$     | $v = L\\frac{\\mathrm{d}i}{\\mathrm{d}t}$ | $v=0$    | $v = j\\omega Li$           |\n| コンデンサ $C$ | $i = C\\frac{\\mathrm{d}v}{\\mathrm{d}t}$ | $i=0$    | $v = \\frac{1}{j\\omega C}i$ |\n\n|                    | 関係式       | 実部               | 虚部             |\n| ------------------ | ------------ | ------------------ | ---------------- |\n| インピーダンス $Z=V/I$ | $Z = R + jX$ | 抵抗 $R$           | リアクタンス $X$ |\n| アドミタンス $Y=I/V$   | $Y = G + jB$ | コンダクタンス $G$ | サセプタンス $B$ |\n\nと書いたけど多分使うのはインピーダンスくらいだと思う. インピーダンスと言えば交流回路の抵抗と思えば良さそう.\n\n### RLC 回路\nRLC回路とは抵抗 $R$ コイル $L$ コンデンサ $C$ を直列や並列に色々繋いだとき共振という良い性質が出てくる回路.\n例えば最も簡単な例としてそれらを直列に繋いだとき, そのインピーダンスを計算すると\n\n$$\n\\begin{aligned}\nZ \u0026= R + j\\left(\\omega L - \\frac{1}{\\omega C}\\right) \\\\\n|Z| \u0026= \\sqrt{R^2 + \\left(\\omega L - \\frac{1}{\\omega C}\\right)^2}\n\\end{aligned}\n$$\n\nこの式を見ると, ある周波数 $\\omega = 1/\\sqrt{LC}$ で共振といって電流が最大となる. その他の周波数では少ない. 言葉では説明できないや, 後でグラフを置いとこ.\n\n| 固定                                 | 可変                          |\n| ------------------------------------ | ----------------------------- |\n| 抵抗                                 | ボリューム抵抗                |\n| コイル                               | 変成器 (トランス)             |\n| 電解コンデンサ, セラミックコンデンサ | バリコン (可変容量コンデンサ) |\n\nこの回路はラジオに使われている.\n\n### インダクタンス\n\n### 回路方程式\n重ね合わせの理 // TODO 図\n- 複数の電源をもつ回路において, それぞれ独立な電源として計算した電流, 電圧を重ね合わせたものと等しい.\n- 電圧源: 電圧 = 0 $\\implies$ 短絡\n- 電流源: 電流 = 0 $\\implies$ 解放\n\n**Thm. 相反定理**\n$$\n\\begin{pmatrix}\nV_1 \u0026 V_2 \u0026 \\cdots \u0026 V_n\n\\end{pmatrix}\n\\begin{pmatrix}\nI_1 \\\\ I_2 \\\\ \\vdots \\\\ I_n\n\\end{pmatrix}\n=\n\\begin{pmatrix}\nV_1' \u0026 V_2' \u0026 \\cdots \u0026 V_n'\n\\end{pmatrix}\n\\begin{pmatrix}\nI_1' \\\\ I_2' \\\\ \\vdots \\\\ I_n'\n\\end{pmatrix}\n$$\n**Proof.**\n**Thm. 補償定理**\n**Thm. 鳳・テブナンの定理**\n**Thm. Nortonの定理**\n**Thm. 最大電力伝送定理**\n\n三相交流\n\nなるほど～大体理解した.\n\n### 電子回路工作\n\nとりま良い資料と言われたのでこれを全部読む.\n- [回路講習会2017の資料 | Molina's Web Site](https://molina.jp/blog/%E5%9B%9E%E8%B7%AF%E8%AC%9B%E7%BF%92%E4%BC%9A%E3%81%AE%E8%B3%87%E6%96%99/)\n\t- ダンチで分かりやすくて面白かった.\n\nやること\n1. KiCad をインストールする.\n2. 新しい project を作る.\n3. スケッチを書く.\n\t- データシートを読む\n\t- A: 電子部品の追加\n\t- W: Wire\n\t- M: Move\n\t- G: 配線も一緒に動かす\n\t- E: Edit\n\t- V: Value\n4. PCB ファイルを書く.\n\n### 回路\n\n- LED + 抵抗\n- モーター + FET\n\nノイズ対策まとめ\n- 入力端子に何も繋がないと壊れる\n- ICの電源には必ずパスコン(バイパスコンデンサ)を付ける.\n\t- 0.1uFのセラミックコンデンサ\n\t- 電力補助\n- パターンが短く、周波数が高い(1MHz)とそれ自体がコンデンサ化する\n- 回路以外の部分をグランド化することで静電シールドとなる\n- グランドは太く短く\n折り返し(反射)\n- 終端抵抗\n\n水晶振動子\nこるピッツ発振回路\n\n### メカ\nギア\n- そのままだと回転数 高 トルク小なので\n- ギアを噛ませて減速 トルク大して使うのが一般的\n\nPWM制御 (Pulse Width Modulation)\n- 周波数の高いパルス波を断続的に流して相対的に電流量を減らす.\n- Duty比: パルス波のHighの割合\n\n### モーター\n**モーターの種類**\n\nDCモーター\n- FA-130RA\n\t- 模型用モーター\n- ロボサイトギアモーターRA25\nサーボモーター\n- モーターと処理回路が入っていて指定した角度になるようにしてくれる\nステッピングモーター\n- パルス波1つにつき1段階回転する\n\n**モーターコントローラー**\n- 何もしないと1方向しか回らない\n- Hブリッジ回路を組むと, 正転, 逆転, ブレーキができる.\n- ブレーキ: 逆起電力\n- MOS-FET を4つ\n\n[趣味の電子回路工作　目次 (piclist.com)](http://www.piclist.com/images/www/hobby_elec/menu.htm)\n\n## 3日目\n真空管\n400V掛けて電子が飛び出て\nプレート網目でキャッチ.\n+の電荷をためるとそこに引きつく\n高周波だと散乱しがちなのでローパスフィルタになりがち\n100mAが限界\n10W 100mA * 100\n\n周波数特性から抜け出す\n\nコンデンサを取り払う -\u003e オペアンプ\n交流 400V, 1000Vにオフセット200V, 500Vを付けてた. 逆流を防ぐ為にコンデンサを使っていた.\n基準電位から\nDC デカップリング\n\n2極管\n\nI2Cは高周波だけど, オープンコレクタ回路なので終端抵抗付けてはだめ\nVGAのケーブルはディスプレイ表示はI2C\nCMOSのオープンコレクタはノイズに強い\n\nオープンコレクタはトランジスタでNOT取って沢山ORを取ったもの\n\nSPIはオープンコレクタではない\nチップセレクト\n\n\n## 参考\n- [回路講習会2017の資料 | Molina's Web Site](https://molina.jp/blog/%E5%9B%9E%E8%B7%AF%E8%AC%9B%E7%BF%92%E4%BC%9A%E3%81%AE%E8%B3%87%E6%96%99/)\n- [The Electronic Lives Manufacturing - presented by ChaN (elm-chan.org)](http://elm-chan.org/index_j.html)\n- [My Tube Amp Manual (op316.com)](http://www.op316.com/tubes/tips/tips0.htm)\n","lastmodified":"2022-12-30T07:57:21.479263765Z","tags":null},"/other/Circuit/Digital/Communication":{"title":"通信技術","content":"","lastmodified":"2022-12-30T07:57:21.479263765Z","tags":null},"/other/Circuit/Digital/Digital":{"title":"デジタル回路","content":"","lastmodified":"2022-12-30T07:57:21.479263765Z","tags":null},"/other/Circuit/Digital/Keyboard":{"title":"キーボード","content":"","lastmodified":"2022-12-30T07:57:21.479263765Z","tags":null},"/other/Circuit/Digital/LogicCircuit":{"title":"論理回路","content":"\n\nラッチ\nフリップフロップ","lastmodified":"2022-12-30T07:57:21.479263765Z","tags":null},"/other/Circuit/Digital/Microcomputer":{"title":"マイコン","content":"\nマイコンの一番楽しい所ってなに\n\n主に次を使うことが多いです。\n- ATmega328P (Arduino)\n- RP2040 (Raspberry Pi Pico)\n- STM32 Nucleo (STM32F303K8)\n\n通信\n- SPI\n- I2C\n- UART; Universal Asynchronous Receiver/Transmitter\n- JTAG\nインターフェース\n- USB\n- HDMI\n\nTODO\n- Hardware Abstraction Layer (HAL)\n- オペアンプ\n\t- [楊子平さんはTwitterを使っています: 「オペアンプだけでアナログ乗算器？マジか？ https://t.co/VYLzO5XBfb」 / Twitter](https://twitter.com/hn12v1_jp/status/1591214722430668802)\n- レーザープロジェクター\n- オーディオアンプ\n- avr マイコン ライター\n- LCRメータ\n- グランドベタ\n- プリント基板\n- ノイズ対策\n- 放熱対策\n- 測定器\n- 分析装置","lastmodified":"2022-12-30T07:57:21.479263765Z","tags":null},"/other/Circuit/Digital/PC%E5%91%A8%E8%BE%BA%E6%A9%9F%E5%99%A8":{"title":"","content":"## スクリーン\nブラウン管\nニキシー管\n液晶\n","lastmodified":"2022-12-30T07:57:21.479263765Z","tags":null},"/other/Circuit/Element":{"title":"回路素子","content":"","lastmodified":"2022-12-30T07:57:21.479263765Z","tags":null},"/other/DeepLearning":{"title":"ディープラーニング","content":"\n## モデル\n- GPT\n- BERT\n\t- [Tiiiger/bert_score: BERT score for text generation (github.com)](https://github.com/Tiiiger/bert_score)\n- Transformer\n\t- [作って理解する Transformer / Attention - Qiita](https://qiita.com/halhorn/items/c91497522be27bde17ce)\n\n## AI セキュリティ\n- バックドア\n\t- 特定の入力データ(トリガー)を意図したクラスに誤分類させる\n\t- トリガー以外の入力データは正しく分類されるので検知は困難\n\t- Mitigation\n\t\t- 信頼できないドメインから入手した事前学習モデルを使用しない\n\t\t- 汚染されていないデータで再学習する\n- 敵対的サンプル\n\t- 誤分類を誘発させる\n\t- AIと人間両方を騙す攻撃\n\t\t- ex. スパムメールフィルタを騙した上で人間も騙してクリックさせる\n\t- AIを騙し人間には理解させる攻撃\n\t\t- ex. 誹謗中傷コメント (バ力(ちから))\n\t- Mitigation\n\t\t- 敵対的学習: ぼかしやノイズなどを加えたサンプルを用いる\n\t\t- 蒸留: 巨大なネットワークをなるべく精度を落とさずに小さなネットワークにする手法 (Why?)\n\t\t- アンサンブル・メソッド: 複数のAIを組み合わせて学習することで頑健性を上げる(Why?)\n\t\t- Autoencoderによる検出: データを圧縮して復元するモデルを用いて敵対的サンプルを検出する (How?)\n- モデル/データ抽出攻撃\n\t- メンバーシップ推論 ある画像が学習データ(メンバーシップ)に含まれているかは過剰に反応するかしないか\n\t- Mitigation\n\t\t- クエリアクセスに対して信頼スコアなどの不必要な情報を応答しない\n\t\t- 過学習を抑制する\n- モデルの脆弱性\n\t- TensorFlowのLambdaレイヤーで任意コード実行ができるので事前学習モデルに悪意あるコードを埋め込める。\n\t- Mitigation\n\t\t- 信頼できないドメインから入手した事前学習モデルを使用しない\n\t\t- サンドボックス内での実行\n\n[AIディフェンス研究所 (jpsec.ai)](https://jpsec.ai/)\n\n## 自作深層学習フレームワーク\n","lastmodified":"2022-12-30T07:57:21.479263765Z","tags":null},"/other/Network/%E9%9F%B3%E5%A3%B0%E3%82%B3%E3%83%BC%E3%83%87%E3%83%83%E3%82%AF":{"title":"音声コーデック","content":"\n","lastmodified":"2022-12-30T07:57:21.479263765Z","tags":null},"/other/Network/%E9%AB%98%E5%91%A8%E6%B3%A2-%E7%84%A1%E7%B7%9A-%E9%80%9A%E4%BF%A1":{"title":"無線","content":"\n","lastmodified":"2022-12-30T07:57:21.479263765Z","tags":null},"/other/Network/SDR":{"title":"Software Defined Radio","content":"\n無線機\n\n![[Pasted image 20220924223810.png]]\n\nGNU Radio\n- USRP B205mini-i\n- HackRF\n\n[GNU Radioで遊ぶ超高速ディジタル無線スタータキット “USRP B205mini-i” (zep.co.jp)](https://www.zep.co.jp/nbeppu/article/z-usrp-da1/)\n","lastmodified":"2022-12-30T07:57:21.479263765Z","tags":null},"/other/Network/network":{"title":"Network","content":"\n# ネットワーク\n\n1990年 10BASE-T\n\n## Ethernet\n米Xerox のパロアルト研究所(PARC)に所属していたロバート・メカトーフ氏によって発明された。\n初期実験は3Mbps 現在は最大400Gbpsの規格がある\nフレーム構造の規格 IEEE 802.3\n\n## TCP/IP\n### TCP BBR\nTCP を高速化\n[GoogleのTCP BBRでTCPを高速化しProxyもその恩恵にあずかる - Qiita](https://qiita.com/fallout/items/92b2099ab5e16cfeb1f9)\n\n### QUIC\n[shigeki/ask_nishida_about_quic_jp: QUICトランスポート機能に関して tcpm/mptcp wg chair の西田先生にいろいろ聞いてみる会 (github.com)](https://github.com/shigeki/ask_nishida_about_quic_jp)\n[aws/s2n-quic: An implementation of the IETF QUIC protocol (github.com)](https://github.com/aws/s2n-quic)\n\n## Network Interface Card: NIC\n\n## Data Plane Development Kit: DPDK\nユーザー空間で NIC を操作するフレームワーク。\nカーネルでの処理がオーバーヘッド。具体的には NIC へデータが到達したときの割り込みなど\nPull Mode Driver: PMD と呼ばれるポーリングベースの受信機構\nただしカーネルを通さない為、パケットキャプチャーが不可能\nDPDK Nginx は Nginx に比べ約3倍高速[2]\n\n1. [Linux Kernel vs DPDK: HTTP Performance Showdown | talawah.io](https://talawah.io/blog/linux-kernel-vs-dpdk-http-performance-showdown/)\n2. [DPDK-NGINX vs NGINX: Tech Overview and Performance Testing - PLVision](https://plvision.eu/rd-lab/blog/sdn/dpdk-nginx-vs-nginx-tech-overview-and-performance-testing)\n3. [Note, Accelerated Network Application | by dsugisawa | mixi developers](https://mixi-developers.mixi.co.jp/note-accelerated-network-application-2187939f05dd)\n\n## kTLS\nカーネルにTLS (Transport Layer Security)を実装し, カーネル空間とユーザー空間のコピーの必要性を大幅に減らし, パフォーマンス向上させる。\n\nVPoE\n\nRougue Access Point\n\n## 輻輳制御アルゴリズム\n\nsessionはどういう仕組みなのか\n","lastmodified":"2022-12-30T07:57:21.479263765Z","tags":null},"/other/OS/ACPI":{"title":"","content":"","lastmodified":"2022-12-30T07:57:21.479263765Z","tags":null},"/other/OS/BIOS":{"title":"BIOS","content":"\nセキュアブート\nファームウェアやブートコード、OSカーネル、デバイスドライバーなどが改ざんされていないかどうかをブートの各シーケンスに沿って順に署名が検証され、検証をパスしたものだけが実行される。\n","lastmodified":"2022-12-30T07:57:21.479263765Z","tags":null},"/other/OS/FileSystem":{"title":"","content":"","lastmodified":"2022-12-30T07:57:21.479263765Z","tags":null},"/other/OS/NIC":{"title":"NIC (Network Interface Card)","content":"\nマザボに差して動くもの: PCI デバイス\nUSBに差して動くもの: USB デバイス","lastmodified":"2022-12-30T07:57:21.479263765Z","tags":null},"/other/OS/OS":{"title":"OS","content":"\n## カーネルの種類\n\n- Unikernel\n\t- [Unikernelについての現状調査 - Fixstars Tech Blog /proc/cpuinfo](https://proc-cpuinfo.fixstars.com/2020/03/unikernel/)\n\t- [microsoft/monza: Research unikernel for virtualized services (github.com)](https://github.com/microsoft/monza)\n- Microkernel\n\t- seL4 Microkernel (Secure Embedded L4)\n\t\t- [オープンソースRTOS「seL4」の紆余曲折からマイクロカーネルの進化を俯瞰する：リアルタイムOS列伝（19）（1/3 ページ） - MONOist (itmedia.co.jp)](https://monoist.itmedia.co.jp/mn/articles/2201/31/news053.html)\n\n## システムコール\n\n- BIOS; Basic Input/Output System\n\t- ハードウェアの初期化\n\t- OS や bootloader へのサービスの提供\n\t- セキュアブート\n\t\t- ブートコードを改ざんしてシステムを乗っ取るようなタイプのウイルスなどの活動を防ぐためのもの\n\t\t- BIOSがデジタル署名を生成し, 信頼済み証明書と検証する.\n\t\t- TPM\n- UEFI; Unified Extensible Firmware Interface\n- PXE(Preboot eXecution Environment) Boot\n\n## 割り込みの仕組みを知りたい\n\n\n## io_uring\n\nmem_info\n\n## ロック\n- `std::sync::RwLock::{write(), try_read()}` を併用した場合には「書き込みロックを最優先」という挙動は必ずしも期待できない (LinuxではNG)\n- Pthread の規約が挙動に自由度をもたせており、Linuxにおけるデフォルト実装では **writer starvation** が発生する\n- Rustにおいて writer starvation を回避しつつ readers-writer lock を使うには [`parking_lot::RwLock`](https://docs.rs/parking_lot/latest/parking_lot/type.RwLock.html) を使うと良い\n\n\n## eBPF\n- [verifier.c - kernel/bpf/verifier.c - Linux source code (v5.18.14) - Bootlin](https://elixir.bootlin.com/linux/v5.18.14/source/kernel/bpf/verifier.c#L10186)\n\n\n## 自作OS\n\n## 参考\n[Linux source code (v5.17.9) - Bootlin](https://elixir.bootlin.com/linux/v5.17.9/source)\n[The Linux Kernel documentation — The Linux Kernel documentation](https://docs.kernel.org/)","lastmodified":"2022-12-30T07:57:21.479263765Z","tags":null},"/other/OS/Scheduler":{"title":"スケジューラ","content":"\n## タスク\nジョブ、プロセス、スレッド\n\n## プロセススケジューラ\nスケジュールする単位はタスク。タスクはプロセスやスレッドによって作業している仕事のこと。\n\n### 初期スケジューラ (~v2.4)\n実行可能タスクは一般にランキューと呼ばれるキューに繋がれています。\n$O(n)$\n\n1. ランキューから順方向に全走査してタイムスライスが最大のタスクにコンテキストスイッチ。\n2. インターバルタイマーが割り込み、タイムスライスを減らす。\n3. タイムスライスを使い果たすとランキュー末尾に挿入。\n4. 1~3をすべての実行可能タスクのタイムスライスが0になるまで繰り返し、すべて使い果たしたらタイムスライスを初期化。このとき、スリープ状態のタスクには少しタイムスライスを追加。\n\nnice 値が小さいほどタイムスライスが貰える。有効範囲は -19 ~ 20 で root でないとマイナス値を設定できない。 `nice()` システムコールによって変更可能。\n\n#### プリエンプション機能 (preemption)\n生成直後かスリープ起床時のタスクはタイムスライスを普段より多く与えてランキュー末尾に挿入。\n\n#### 複数LCPU対応\n複数のLCPUが1つのランキューを見る。排他制御が必要。各LCPUは前に取ったタスクを取りやすい。\n\n#### リアルタイムポリシー\nリアルタイムタスク\n`sched_setscheduler()` システムコールや `chrt` コマンドなどによってリアルタイムタスクにできる。常に優先的に動作可能。ハートビート処理など、システムの負荷が高いときでも定期的に動かないとまずいため、リアルタイムタスクにする。それが動いていれば他のタスクは永久にスケジュールされない。\n`SCHED_OTHER` ポリシー : デフォルトのポリシー\n`SCHED_FIFO` ポリシー : タイムスライスなし\n`SCHED_RR` ポリシー : タイムスライスあり\n\n### $O(1)$ スケジューラ (v2.6.0~2.6.22)\nv2.6系は $O(1)$ スケジューラを用いて管理していた。\nランキューは active キューと expired キューに分けられ、active キューの先頭のタスクを取り、タイムスライスを使い切ったら expired キューに挿入するのを繰り返す。\nnice 値ごとにキュー分けるようになって、優先度が高いキューから active キューを空にさせます。\nこれで LCPU 当たり $40\\times 2$ 本のキューがあることになります。\n\n#### ロードバランサー\nLCPU ごとにキューをもつようになったのでロードバランサーが必要になりました。\nNUMAシステムの場合は 2 階層のバランス処理が動作します。\n\n1. NUMAノード間のバランス\n2. ノード間LCPU間のバランス\n\nNUMAノードの中で負荷の偏りを検出し、負荷が高いノードの一番負荷の高い LCPU から負荷の低いノードの一番負荷の低い LCPU へタスクを移動させる。\n\n階層が複雑になると物理CPU \u003e ダイ \u003e CCX \u003e コア \u003e スレッドのそれぞれでバランスする。\n\n移動を許す LCPU を制限する CPU affinity がある。タスクが動作可能なLCPUの集合を決められる。`sched_setaffinity()`システムコールや`taskset`コマンドによって設定できる。\n\n### 対話型タスクの優先動作\nbash や X Window System などの、人間が直接やりとりする、応答性が重視されるタスク指す。\n\n- 単位時間あたりにスリープしている率が高いプロセスを対話型タスクとみなす。\n- 対話型タスクに次のような優遇措置をとる\n\t- タイムスライスが切れると expired キューではなく active キューに移す。\n\t- nice 値相当の優先度を上げる。タイムスライスは変化しない。\n\t- その一方、ずっと実行可能なタスクは優先度を下げる。\n\n\n### $O(1)$スケジューラの問題点\n- 対話型タスクによるハング\n1. 対話型タスクは優先度が上がり、 active キューに再挿入される。\n2. 他のタスクはそもそも動けないから優先度が上がらない。\n3. 少数の高優先度タスクが長時間動き続ける。\n- 実行可能タスクが多いと、なかなかCPU時間が回ってこない。典型的には、実行可能なタスク数 × 100ms 待たされる。\n- タイムスライスの粒度が荒いため、fair share scheduling や CFS bandwidth controllerなどのような細かい制御ができない。\n\t- 粒度を小さくするにはインターバルタイマーの割り込み頻度を増やせばよい。\n\t- 割り込み回数が増えると割り込みハンドラが動作する時間が増えるため、システム全体スループットが下がる。\n\n### Completely Fair Scheduler (v2.6.23~)\nv2.6.23 から入った Completely Fair Scheduler: CFS\n赤黒木上で葉ノードに個々のタスク、キーはタスクごとに存在するvruntimeという値。\n検索コスト $O(\\log n)$ に最適化(vruntime 最小のタスクをキャッシュなど)を加えてよい。\n\nワンショットの高精度タイマーを用いることでタイムスライスが切れるときだけ割り込むので割り込み負荷を減らし、CFSが実現できるようになった。\nレイテンシターゲット 数ms～数十ms を各タスクに均等に割り当てる。\nnice 値が1低いと1.25倍多くタイムスライスが与えられる。\n\nスケジューラアルゴリズムがプラガブルになった。スケジューリングクラスとコールバック関数を用意すればOK。\n\nfair group scheduling(v2.6.24): cgroup でグループごとにロードバランスする。メモリ制限したりもできる。\nRealtime group scheduling(v2.6.25): リアルタイムタスクが暴走すると通常のタスクは一切動けないため、1割程度他のタスクに渡す。\nCFS bandwidth controller(v3.2.2): 個々のユーザーにCPU時間の制限を与えることができる。マルチテナントシステムであるユーザーにリソースが占有されないようにあるcgroup 内のタスクがperiodと呼ばれる所定時間内にruntimeと呼ばれる時間のみ動けるように制限する。\ndeadline scheduling class(v3.14): リアルタイムタスクの多様性を持たせる。\nEnergy-aware scheduling(v5.0): スマートフォンなどで使われるbig.LITTLE processing考え方を採用したCPUの為のもの。\n- 処理性能が高いが消費電力が大きいCPU\n- 処理性能が低いが消費電力が小さいCPU\n重いタスクは前者に、軽いタスクは後者に実行させる。重いタスクがなければ全射のコアの動作周波数を下げたり、電源を切ったりすることによって消費電力を少なくするのが狙い。\n\n[A journey into the Linux scheduler | Maxgio's blog](https://blog.maxgio.me/posts/linux-scheduler-journey/)","lastmodified":"2022-12-30T07:57:21.479263765Z","tags":null},"/other/OS/abbreviation":{"title":"略語","content":"\nLinux 略語多いのでまとめてみる.\n\n## 一般\n\n| 略語 | 正式名称 |\n|:-:|:-:|\n| d | daemon |\n| f | file |\n| g | group |\n| h | header |\n| i | interval/interrupt |\n| l | link/library |\n| m | memory |\n| n | NULL |\n| p | process/program |\n| s | signal/section |\n| u | user |\n| v | virtual/vector |\n\n### 動詞\n\n| 略語 | 正式名称 |\n|:-:|:-:|\n| adj | adjust |\n| brk | break |\n| dup | duplicate |\n| dump | dump |\n| exec | execute |\n| mk | make |\n| rm | remove |\n| snd | send |\n| rcv | receive |\n| rq | request |\n| ret | return |\n\n| 略語 | 正式名称 |\n|:-:|:-:|\n| glibc | GNU C Library |\n| dir | directory |\n| sys | system |\n| sym | symbolic |\n| sched | schedule |\n| msg | message |\n| reg | register |\n| info | information |\n| io | Input/Output |\n| fs | File System |\n| fmt | format |\n| cpy | copy |\n| elf | Executable and Linking Format |\n| stat | statistics |\n| param | parameter |\n| desc | descriptor/description |\n\n## 割り込み\n\n| 略語 | 正式名称 |\n|:-:|:-:|\n| IRQ | interrupt request |\n| chmod | change mode |\n| cwd | Change Working Directory |\n| kstat |  |\n| gtod | gettimeofday |\n\n## システムコール\n\n| 略語 | 正式名称 |\n|:-:|:-:|\n| GDT | Global Descriptor Table |\n| TSS | Task State Segment |\n","lastmodified":"2022-12-30T07:57:21.479263765Z","tags":null},"/other/Processor/Architecture":{"title":"","content":"\n## x86-64アーキテクチャ\n### レジスタ\n64bit汎用レジスタ\n| 64bitレジスタ | 32bitレジスタ | 16bitレジスタ | 8bitレジスタ |\n|--|--|--|--|\n| RSP | ESP |  SP | SPL |\n| RBP | EBP |  BP | BPL |\n| RAX | EAX |  AX |  AL |\n| RBX | EBX |  BX |  BL |\n| RDI | EDI |  DI | DIL |\n| RSI | ESI |  SI | SIL |\n| RDX | EDX |  DX |  DL |\n| RCX | ECX |  CX |  CL |\n| R8  | R8D | R8W | R8B |\n| R9  | R9D | R9W | R9B |\n| R10 | R10D | R10W | R10B |\n| R11 | R11D | R11W | R11B |\n| R12 | R12D | R12W | R12B |\n| R13 | R13D | R13W | R13B |\n| R14 | R14D | R14W | R14B |\n| R15 | R15D | R15W | R15B |\n\nフラグレジスタ\n| 64bitレジスタ | 32bitレジスタ | 16bitレジスタ |\n| ------------- | ------------- | ------------- |\n| RFLAGS        | EFLAGS        | FLAGS         |\n\n| bit | ニーモニック | 説明 | 用途 | 1となる条件 |\n|--|--|--|--|--|\n| 11 | OF |        Overflow Flag | 符号付き整数演算の結果の最上位bitが本来と異なる |\n| 10 | DF |       Direction Flag | 文字列操作のデータポインタが減る向き |\n|  7 | SF |            Sign Flag | 算術演算の結果が負 |\n|  6 | ZF |            Zero Flag | 算術演算の結果が0 |\n|  4 | AF | Auxiliary Carry Flag |  |\n|  2 | PF |          Parity Flag | 演算の結果の最下位byte |\n|  0 | CF |           Carry Flag | 加算/減算命令で最上位bitで繰り上がり/繰り下がりが発生 |\n\n### メモリモデル\n### アドレッシング\n### 命令セット\n## X86アセンブリ言語\n### AT\u0026T記法とIntel記法\n\n## System V ABI(Application Binary Interface)","lastmodified":"2022-12-30T07:57:21.479263765Z","tags":null},"/other/Processor/FPGA":{"title":"","content":"\nHDL; Hardware Description Language\n- Verilog\n- Chisel\n\n## 自作CPU\n","lastmodified":"2022-12-30T07:57:21.479263765Z","tags":null},"/other/Processor/HIEE/DRM":{"title":"DRM","content":"\n# DRMの仕組みと実装を理解する\n\n## メモ\n\nDRM(Digital Rights Management)とは\n\u003e Digital rights management (DRM) is the management of legal access to digital content. Various tools or technological protection measures (TPM)[1] such as access control technologies can restrict the use of proprietary hardware and copyrighted works.[2] DRM technologies govern the use, modification, and distribution of copyrighted works (such as software and multimedia content), as well as systems that enforce these policies within devices.[3]\n\n1. マネタイズのために各種assetへのアクセスをコントロールしたい\n2. 物理assetは物理的束縛があるからコントロールしやすい\n3. degital assetはどうしようね\n4. **DRM**（に関する各種技術スタック）\n    - https://en.wikipedia.org/wiki/Digital_rights_management\n    - DRMはencryption/decryption keysをsecureにstore/deliverする技術（？）\n        - DRM protectedな書籍をキャプチャできないのとかはどう解釈できるのか？\n        - deliverされたkeyにconsumerが直接アクセスできない（はず）\n\n\u003e 【マネタイズ】\n\u003e For example, you could set rules to,\n\u003e - block people from certain countries,\n\u003e - allow access to the content for a certain period,\n\u003e - prevent a user from casting the movie onto a screen,\n\u003e - block free users from accessing premium content,\n\u003e - block playback on specific devices,\n\u003e - etc.\n\n【コア】\nencryptしたい人(creator side)とdecryptしたい人(consumer)がいる\n第三者(store)がkeyを安全かつ適切なルールに基づいて配布する\n![](https://md.trap.jp/uploads/upload_5feb762e9db1d37f5cb1159f2012a9e5.png)\n【ここまでで実現できていること】\n- a high-security level through daily renewal and code rotation\n- authentication and rights management (read, write permissions)\n    - 読み書きの権限を分ける\n    - 複数人が読むことも可能\n    - コンテンツへの段階的なアクセス\n    - 期限付きの鍵\n        - encryptする鍵をどんどん更新していけば最新のコンテンツが見れなくなるみたいなのは理解できる\n        - 画面の直撮りとかは考えないにしてもencrypted+keyを得た時点でdecryptedが得られそうだけどどうやって防いでるんだろう（単純に手間になるように実装されてるからだれもやってないだけ？）\n        - 専用クライアントみたいなのがあるわけだけどそのへんの実装に踏み込まないと分からなさそう？\n    - etc\n- a well-defined pricing model\n【更に実現したいこと】\n- コピー防止\n- キャプチャ防止\n\n---\n\n- building blocks\n    - EME(Encrypted Media Extensions)\n        - https://www.w3.org/2017/07/EME-backgrounder.html\n        - OS / ブラウザレベルでCDMとのインターフェースになっている\n        - 復号化されたデータが扱われることはない (CDMのみが扱う)\n        - https://bitmovin.com/digital-rights-management-everything-to-know/\n    - CDM(Content Decryption Module)\n    - AES(Advanced Encryption Standard)\n        - みんな知ってるアレ\n    - 動画固有\n        - ABR(Adaptive Bitrate Streaming)\n            - 各クライアントの帯域幅に応じて適切な複数bitrateで配信したい\n            - https://ottverse.com/what-is-abr-video-streaming/\n        - CMAF(Common Media Format)\n            - \u003e which said that videos can be stored in the fragmented mp4 container format (fmp4). With support from both MPEG-DASH and HLS, you can now create only one set of videos, store it in fmp4 format, and use a common set of files for both protocols.\n            - https://mpeg.chiariglione.org/standards/mpeg-a/common-media-application-format\n    - CENC(Common Encryption)\n        - storeが違う暗号化方式を採用してるとcreatorがダルいので共通化しようと言うモチベ\n        - \u003e specifying that videos can be encrypted using either cenc (AES-128 CTR) or cbcs (AES-128 CBC). CTR stands for Counter; and CBC stands for Cipher Block Chaining.\n    - Keys \u0026 Key Servers.\n        - keyとencrypted contentはKeyIDで紐づく\n        - KeyIDはmanifestにのってる\n\n![](https://md.trap.jp/uploads/upload_09363d2df17afc60ec315fde1b1a9fb5.png)\n\n現実のカスポイント\n\u003e Well, CENC might sound like a magic wand for DRM-unification, but it is not.\n\u003e \n\u003e There are three primary DRM technologies in the market – Apple FairPlay, Google Widevine, and Microsoft PlayReady.\n\u003e \n\u003e Apple FairPlay supports only AES-CBC cbcs mode.\nHLS supports only AES-CBC cbcs mode (irrespective of CMAF)\nWidevine and PlayReady support both AES-128 CTR cenc or AES-128 CBC cbcs modes.\nMPEG-DASH with CMAF supports both AES-128 CTR cenc or AES-128 CBC cbcs modes.\nMPEG-DASH without CMAF supports only AES-128 CTR cenc mode.\nAs you can see, the CMAF and CENC specs have lead to confusion and fragmentation in the streaming space.\n\u003e \n\u003e A possible convergence point is the universal use of CMAF and AES-CBC cbcs mode, but, how will these impact legacy devices that support only CTR or only MPEG-TS?\n\u003e \n\u003e That’s a discussion for another time.\n\n\n---\n分かりな疑問\n\u003e We’ve described a simple scheme, but there are many problems (technical and commercial) with our scheme. Here are some problems right off the bat.\n\u003e \n\u003e We’ve described a prototypical “player” that sends a request for the decryption keys to the DRM License Server. But,\nHow does the license server know if the player is trustworthy?\nAnd, what if the decryption software in the player exposes the key and the decrypted content?\nAlso, if you are a video player developer, do you have to develop decryption modules for every DRM technology? And, do you have to update it each time they make a change to their interfaces?\nFurthermore, the sequence of events at the player (client-side) looks something like this –\n\u003e \n\u003e 1. obtain the movie \u0026 its manifest from the CDN\n\u003e 1. extract the KeyID from the manifest\n\u003e 1. create the license request\n\u003e 1. send the license request to the license server\n\u003e 1. wait, listen, and receive the response from the license server.\n\u003e 1. use the decryption key from the server to decrypt the content\n\u003e 1. decode the decrypted content\n\u003e 1. display the decoded movie\n\u003e \n\u003e A single program or entity should NOT do all of the above.\n\n以下の2つに分ければいいらしい\n\n- Player\n    - 1, 2, 4, 5, (8 display これ安全じゃなさそう)\n- CDM\n    - 3(create Licence request), (understand the key), 6(decrypt), 7(decode)\n\n### CDM(これ大事)\n\u003e Every DRM provider provides its own\n\u003e 1. mechanism to create a license request (using the KeyID, device identifier, signing the request, etc.)\n\u003e 1. mechanism to understand the license response received from the DRM License Server (the response is encrypted too) and extract the decryption key.\n\u003e 1. rules around storing the license locally on the client, license renewal, expiry, etc.\n\n==browserにbuild-inでclosed-source==\n\n### EME\n![](https://md.trap.jp/uploads/upload_d6d10fe763ae69624a5057f9b1f37e00.png)\n\n---\n\nQ. 手元にある鍵はずっと使えそうだけど...？（「期限が切れたら自分のものでなくなる」というのをいかに実現しているか？）\nA. バージョンバインディングの仕組み\nバージョンを使って鍵の有効性を決めたい。普通の方法では古いバージョンのシステムの脆弱性だったりTEEの脆弱性があるとそれを使って有効にさせることができてしまう。そこでプロセスが起動する前にデバイスブートローダーがバージョン情報をTEE上で実行されているハードウェア格納型暗号サービスに渡し、鍵を生成する。アップグレード後は無効化するようにする。androidの記事より\nキーストア=DRM Serverである？\n他人が攻撃するときは完全に防げるけど自分のはブートローダーのレイヤーで攻撃すればいい話では（「正しく」実装されていることをなんらかの方法で証明できれば嬉しそう。しらんけど）\n（TODO: 可能ということは分かったが、鍵の有効無効という概念があんまり理解できておらず）\n\nQ. そもそもバージョンって何？なにのバージョン？\n今回だとデバイスとOSのバージョンらしい??→OS等をアップデートしなければコンテンツを見続けられる...？（謎そう)\n\nQ.有効なタイミングでdecryptedを保存するとかを防ぐのは別の仕組み？\nA. :hi_UD::naruhodo:\nencrypted+key(ネットワークを見ればいいからここは取れる。はず)-\u003e(ここにユーザーが介入できないようにする仕組みが必要)-\u003eview\n\n---\n:eyes:\n![](https://www.w3.org/TR/encrypted-media/stack_overview.svg)\nhttps://www.w3.org/TR/encrypted-media/\n\n### どうでもいい話\nstreaming protocols\n- https://linuxhit.com/rtmp-vs-hls-vs-dash-streaming-protocols/\n- https://youtube-eng.googleblog.com/2018/04/making-high-quality-video-efficient.html\n- https://en.wikipedia.org/wiki/Adaptive_bitrate_streaming\n    - https://ottverse.com/what-is-abr-video-streaming/\n    - https://gist.github.com/voluntas/dd3af733825c7ae64505a1fd1bd0d684\n\n## TODO\n暗号化や署名周りの具体的な実装（理論）\nDRM Provider各社のエコシステム\n\n## refs\n- https://source.android.com/security/keystore\n- https://developers.google.com/widevine/drm/overview\n- https://ottverse.com/eme-cenc-cdm-aes-keys-drm-digital-rights-management/\n","lastmodified":"2022-12-30T07:57:21.479263765Z","tags":null},"/other/Processor/HIEE/TEE":{"title":"TEE","content":"\nTrusted Execution Environment: TEE とはプロセッサ上に隔離された実行環境を用意することでセキュリティを高める技術です。\nより広義にHIEE: Hardware-assisted Isolated Execution Environment\n- Normal Mode\n- Secure Mode\n\n[Intel® Trust Domain Extensions](https://www.intel.com/content/www/us/en/developer/articles/technical/intel-trust-domain-extensions.html) (Intel® TDX)\n\nTEE の機能\n- OSやアプリケーションの改竄を検知\n- 公開鍵証明書による端末識別，認証\n- ストレージデータの安全な暗号化\n- ほぼほぼ暗号化処理をするため, 秘密鍵をそこにppm\n\n## Intel SGX\nEnclave では Ring 3 でしか動作しない, つまり syscall が使えない\n\n![[Pasted image 20220927024448.png]]\n\n- [Intel SGX入門 - SGX基礎知識編 - Qiita](https://qiita.com/Cliffford/items/2f155f40a1c3eec288cf)\n\n### Remote Attestation\nECDH\n- [Intel SGX - Remote Attestation概説 - Qiita](https://qiita.com/Cliffford/items/095b1df450583b4803f2)\n\n### Foreshadow\nCVE-2018-3615 - L1 Terminal Fault: SGX\nCVE-2018-3620 - L1 Terminal Fault: OS/SMM、CVE-2018-3646 - L1 Terminal Fault: VMM\nL1データキャッシュに存在するデータならなんでも読み取ることが可能\n\n### AEPIC Leak\n最初のアーキテクチャ由来のCPUのバグ. インテル製10~12世代のCPUの脆弱性を利用して, プロセッサ本体から機密情報を漏洩させる。APIC MMIOでの未定義範囲のアクセスによりキャッシュ階層から古いデータを参照できる。APIC MMIOのアクセスには管理者権限が必要であるから安全であるが, Intel SGXのような管理者権限を持つ攻撃者からデータを守るようなシステムはリスクとなる。\n未初期化メモリの読み取りのようなもの\n- [元論文](https://aepicleak.com/aepicleak.pdf)\n- https://github.com/IAIK/AEPIC\n\n### Graphene-SGX\n- [Graphene-SGX](https://www.usenix.org/system/files/conference/atc17/atc17-tsai.pdf)\n\n## ARM TrustZone\nCortex-A シリーズの拡張機能\nノーマルワールドとセキュアワールドそれぞれに特権/非特権モード\n- [Boomerang](https://github.com/ucsb-seclab/boomerang/)\n- [Abusing Trust: Mobile Kernel Subversion via TrustZone Rootkits](https://security.inso.tuwien.ac.at/pdfs/woot22-preprint.pdf)\n- [SoK: Understanding the Prevailing Security Vulnerabilities in TrustZone-assisted TEE Systems | IEEE Conference Publication | IEEE Xplore](https://ieeexplore.ieee.org/document/9152801)\n- [Project Zero: Trust Issues: Exploiting TrustZone TEEs (googleprojectzero.blogspot.com)](https://googleprojectzero.blogspot.com/2017/07/trust-issues-exploiting-trustzone-tees.html)\nProject ZeroはSpectre見つけた\n- [ARM TrustZone エクスプロイト入門 - Speaker Deck](https://speakerdeck.com/rkx1209/arm-trustzone-ekusupuroitoru-men)\n\n### Android KeyStore\nAndroid の SoC には ARM TrustZone があり、その上で KeyStore を動かしている.\nAndroid の Full Disk Encryption を TEE を介さずに Decrypt.  FBIでもできなかった\n- [Bits, Please!: Extracting Qualcomm's KeyMaster Keys - Breaking Android Full Disk Encryption (bits-please.blogspot.com)](http://bits-please.blogspot.com/2016/06/extracting-qualcomms-keymaster-keys.html)\n\n### Apple iOS Secure Enclave\n\n## RISC-V Keystone\n- BOOM\n- Speculative Attack\n- [Keystone: An Open Framework for Architecting Trusted Execution Environments (ethz.ch)](https://n.ethz.ch/~sshivaji/publications/keystone_eurosys20.pdf)\n\n## OP-TEE\n- [OP-TEE/optee_os: Trusted side of the TEE (github.com)](https://github.com/OP-TEE/optee_os)\n- [OP-TEE Documentation — OP-TEE documentation documentation (optee.readthedocs.io)](https://optee.readthedocs.io/en/latest/)\n\n須崎先生がよく知ってる\n\n","lastmodified":"2022-12-30T07:57:21.479263765Z","tags":null},"/other/Processor/HIEE/TPM":{"title":"TPM","content":"\nTPM 2.0\nTPM (Trusted Platform Module)\n\n暗号化用アルゴリズムエンジン、ハッシュエンジン、鍵生成器、乱数生成器、不揮発性メモリ(鍵などを保管)などを備えたモジュールで、TPM内への暗号キーの作成や使用制限をするために利用される。\n\nTPM (Trust) ハードウェアとして開発\n- Windows BitLocker\n\t- TPM を利用してディスク全体を暗号化を行う.\n- [A Bad Dream](https://www.usenix.org/system/files/conference/usenixsecurity18/sec18-han.pdf)\n\n[TPM 2.0 Library](https://trustedcomputinggroup.org/resource/tpm-library-specification/)\n\n## 参考文献\n[【特集】Windows 11で必須になった「TPM 2.0」って何？TPMの役割や確認方法を紹介 - PC Watch (impress.co.jp)](https://pc.watch.impress.co.jp/docs/topic/feature/1334277.html)","lastmodified":"2022-12-30T07:57:21.479263765Z","tags":null},"/other/Processor/LSI":{"title":"LSI","content":"\n## LSI自作\n- [OpenMPW入門 改訂版 (vlsi.jp)](https://vlsi.jp/OpenMPW.html)\n- [福岡IST 公開用 - Google スライド](https://docs.google.com/presentation/d/1rkpSEsxGbYurqHZDW3vPpKmPjOWm5pDi7h8AhsjY_Go/edit#slide=id.p)\n- [jacaranda_8_ISA_draft · cpu-dev/cpu-dev.github.io Wiki](https://github.com/cpu-dev/cpu-dev.github.io/wiki/jacaranda_8_ISA_draft)\n","lastmodified":"2022-12-30T07:57:21.479263765Z","tags":null},"/other/Processor/Processor":{"title":"プロセッサ","content":"\n## プロセッサの種類\n- CPU\n\t- LGA\n\t- BGA\n\t- QFP\n- GPU\n\t- iGPU(internal) CPU内にあるグラボ\n\t- dGPU(discrete) NVMe/SATA/PCIeなどで接続する外付けのグラボ\n\t- eGPU(external) Thunderbolt 3/4などで接続する外付けのグラボ\n- TPU 行列積演算\n- FPU\n\n未分類\n- [揚げて炙ってわかるコンピュータのしくみ | 秋田 純一 |本 | 通販 | Amazon](https://www.amazon.co.jp/%E6%8F%9A%E3%81%92%E3%81%A6%E7%82%99%E3%81%A3%E3%81%A6%E3%82%8F%E3%81%8B%E3%82%8B%E3%82%B3%E3%83%B3%E3%83%94%E3%83%A5%E3%83%BC%E3%82%BF%E3%81%AE%E3%81%97%E3%81%8F%E3%81%BF-%E7%A7%8B%E7%94%B0-%E7%B4%94%E4%B8%80/dp/4297116014)\n- Qualcomm Snapdragon 6 Gen 1\n- 富岳\n\t- OS IHK/McKernel\n- Read/Write\n- big.LITTLE processing\n\n## CPU機能\n- [ARM immediate value encoding (mcdiarmid.org)](https://alisdair.mcdiarmid.org/arm-immediate-value-encoding/)\n- RTDSC 命令\n\t- [How to Benchmark Code Execution Times on Intel IA-32 and IA-64 Instruction Set Architectures White Paper](https://www.intel.com/content/dam/www/public/us/en/documents/white-papers/ia-32-ia-64-benchmark-code-execution-paper.pdf)\n- ABI\n- System V AMD64\n- [x86_64-abi-0.99.pdf (linuxbase.org)](https://refspecs.linuxbase.org/elf/x86_64-abi-0.99.pdf)\n\n## アーキテクチャ\n命令セットアーキテクチャ (ISA; Instruction Set Architecture)\n- CISC\n\t- x86\n\t\t- IA-32\n\t\t- x64 (AMD64)\n\t- IA-64\n- RISC\n\t- ARM\n\t- RISC-V\n\t- PowerPC\n\t- MIPS\n\nマイクロアーキテクチャ\n\n## 回路\n全加算器\nDeep Learning を用いた回路設計も行われている.\n- [Designing Arithmetic Circuits with Deep Reinforcement Learning | NVIDIA Technical Blog](https://developer.nvidia.com/blog/designing-arithmetic-circuits-with-deep-reinforcement-learning/)\n\n## 応用\n- GPGPU\n\n## 脆弱性\nIntel の CPU の脆弱性を見つけたら [Project Circuit Breaker](https://www.projectcircuitbreaker.com/) に報告するとよい\n\n- PACMAN\n\t- Apple M1 CPUのポインター\n\t- [PACMAN (pacmanattack.com)](https://pacmanattack.com/)\n- Spectre\n\t- Branch Target Buffer: BPB\n\t- 危険性\n\t- Mitigation\n\t\t- Spectre-v1 SWAPGS\n\t\t\t- kernel parameter `nospectre_v1`\n\t\t- Spectre-v2 Retpoline\n\t\t\t- LFENCE/JMP\n\t\t\t- kernel parameter `nospectre_v2`\n\t\t- Spectre-v3 KPTI\n\t\t\t- kernel parameter\n\t\t\t\t- `pti=off`\n\t\t\t\t- `nopti`\n\t\t\t\t- `noibrs`\n\t\t\t\t- `noibpb`\n\t\t\t\t- `nospec_store_bypass_disable`\n\t- [KB4073119: Windows client guidance for IT Pros to protect against silicon-based microarchitectural and speculative execution side-channel vulnerabilities (microsoft.com)](https://support.microsoft.com/en-us/topic/kb4073119-windows-client-guidance-for-it-pros-to-protect-against-silicon-based-microarchitectural-and-speculative-execution-side-channel-vulnerabilities-35820a8a-ae13-1299-88cc-357f104f5b11)\n- MDS/Zombieload\n\t- https://www.kernel.org/doc/html/latest/admin-guide/hw-vuln/mds.html\n- TSX Asynchronous Abort\n\t- https://www.kernel.org/doc/html/latest/admin-guide/hw-vuln/tsx_async_abort.html\n- iTLB multihit\n","lastmodified":"2022-12-30T07:57:21.479263765Z","tags":null},"/other/Processor/rootkit":{"title":"Root kit","content":"\nNorth bridge\n[dsn2021.pdf (xgao-work.github.io)](https://xgao-work.github.io/paper/dsn2021.pdf)\n\n\n## PCI Rootkit\n[Implementing and Detecting a PCI Rootkit](https://www.blackhat.com/presentations/bh-dc-07/Heasman/Paper/bh-dc-07-Heasman-WP.pdf)\n\nPeripheral Component Interconnect: PCI はマザーボード\n\n","lastmodified":"2022-12-30T07:57:21.479263765Z","tags":null},"/other/Profiler/perf":{"title":"","content":"\n[perfから読み解くプロセッサトレースの仕組み (perf + Intel PT/ARM CoreSight) - Qiita](https://qiita.com/RKX1209/items/41758b6dcac6fb2fcee6)\n\n#Loki ","lastmodified":"2022-12-30T07:57:21.479263765Z","tags":null},"/other/Programming/Editor":{"title":"","content":"## Vim\n\n## VSCode\n\n## 自作エディタ\n","lastmodified":"2022-12-30T07:57:21.479263765Z","tags":null},"/other/Programming/LLVM":{"title":"LLVM","content":"\n[LLVMの新しい中間言語表現 MLIRを試す(1. Getting Started) - FPGA開発日記 (hatenablog.com)](https://msyksphinz.hatenablog.com/entry/2020/05/30/040000)","lastmodified":"2022-12-30T07:57:21.479263765Z","tags":null},"/other/Programming/Programming":{"title":"プログラミング言語","content":"\n# プログラミング言語入門\n\n任意の実行はデータとアクションで構成されている。\nそれを人間にとってわかりやすく書きやすい形にするがプログラミング言語が必要とされる理由であり、データとアクションの関係性における多様なデザインがプログラミング言語の多様性の理由である。\n\nデータとアクションの関係性はロジックや階層構造によって表現される。\nそして計算モデルに意味を与える意味論的な解釈を取り込みつつ解説する。\n\n最初は抽象的で簡単なところから始まり、具体的で難しい問題に立ち向かう。\n対象者\n- 任意の言語を素早く習得したい方\n- 基礎から理解して安心したい方\n- 新しい言語を実装したい方\n\n情報に踊らされずちゃんと軸を持つには論理で情報を作り出さないといけない。\n\n## 第一章 型\n\nTODO: なぜここで型を説明するのか\n馴染み深いから？前提知識として持っていないと抽象論を展開できないから？あいまいな定義や同義な言葉が各言語にあるのでまとめて扱う為に一回必要\n\nここでは公理的に計算するところはつまらんので省いて、なるべく実践的、アイデアが得られる点を紹介する。何故かというと私は計算より抽象的なことの方が好きだからです。(正直, 型理論の話は海外大の講義資料と論文以外はナンセンスな議論しかしない資料が豊富にあってｓ)不足分については型理論の方で説明します。($\\lambda, \\pi, \\mu$ 計算, Boehm-Berarducci encodingなど)\n\n### データの表現方法\n- 直積型 $A_1\\times A_2$\n\t- 直列にデータを繋げる.\n\t- ex.) 構造体, メソッドのないクラス, 配列, Vectorなど\n\t- Intersection Type を用いても構成できる.\n\t- 直積型のデータを分解して各要素を取り出す機能\n\t\t- 構造化束縛 (Structured Bindings, C++)\n\t\t- 多重代入 (Multiple assignment, PythonやRuby)\n\t\t- 分割代入 (Destructuring assignment, JavaScript)\n- 直和型 $A_1+A_2$\n\t- 識別子と各型のデータ長の最大値を確保して格納する.\n\t- ex.) Rustのenum\n- ユニオン型 $A_1\\cup A_2$\n\t- 直和型とほぼ同じであるが、反例としてすべての型に null や undefined などがある TypeScript は直和型と同値ではない。\n\t- ex.) Cのunion, タグ付き共用体, variant\n- 篩型 (refinement types) $\\lbrace x\\in A\\mid P(x)\\rbrace$\n\t- データに制約を持たせることができる。\n\t- 実装を篩型に分け与えてシンプルに出来る\n\t- ex.) Liquid Haskell\n\nパターンマッチ\n- 直積型や直和型のみならずクラスの継承関係、プレースホルダーを用いて簡潔に書ける。\n- [コンパイル技法: パターンマッチ (zenn.dev)](https://zenn.dev/blackenedgold/books/compiling-pattern-matching)\n\n### ロジックの表現方法\n- 関数型 $f\\colon A_1\\to A_2 \\to\\ldots\\to A_n \\to R$\n\t- カリー化\n\t- optional引数を考えるとカリー化は筋が良くない.\n- クラス $(A, f_1,\\ldots,f_n) \\text{s.t.} f_i\\colon A\\to\\ldots\\to R$\n\n### 型の順序\n順序、数でいう不等号を型に与えます。\n\ntrait\n- $(f)$ $f$ で生成されるtrait\n- ex.) Rust: trait, Swift: protocol, extension, Go: interface\n\n部分型\n- 関数と型の集合の部分集合として定義できる\n- $A_1 \\subset A_1\\cup A_2$\n- $A_1 \\subset A_1\\times A_2$\n- $(f_1, f_2) \\subset (f_1)$\n\n部分型の性質\n- 共変性 (covariant)\n\t- $A_1 \\subset A_2 \\implies I[A_1] \\subset I[A_2]$\n- 反変性 (contravariant)\n\t- $A_1 \\subset A_2 \\implies I[A_1] \\supset I[A_2]$\n\t- 関数の引数 $A_1 \\subset A_2 \\implies A_1\\to R \\supset A_2\\to R$\n- 双変性 (bivariant)\n\t- 共変かつ反変\n\t- $A_1 \\subset A_2 \\implies I[A_1] = I[A_2]$\n- 非変性 (nonvariant)\n\t- 共変でも反変でもない\n\n### 型の構成と分類\n- 依存型 $\\Pi_{x\\colon A}B(x)$\n- 依存和型 $\\sum_{x\\colon A}B(x)$\n- 全称量化 $\\forall$\n- 存在量化 $\\exists$\n- 帰納的型\n\t- 宇宙と依存積以外のほとんどの型は帰納的型として定義される.\n\t- 構成規則, 構成子, 除去子, 計算規則\n- 型演算子\n\t- 多相カインドの抽象化\n- 型クラス trait $\\lbrace A\\in\\mathcal{U}\\mid f_1,\\ldots,f_n \\in A\\rbrace$\n- Row Type\n\n### より高度な型\n- 停止性\n- 参照透過性\n\n### 型の意味を捉える\n- モナド/コモナド\n\t- 簡潔な状態遷移ができる\n\n型レベル○○\n- 型を用いてある代数と同値な型を定義すること\n- 型レベル自然数\n\t- 例えば $A_0 = A$, $A_{n+1}=A_0\\times \\ldots\\times A_n$ と定義すると加算、減算、乗算、順序などを埋め込むことができ、自然数と同型な代数となる。\n- 型レベル文字列\n\t- TypeScript にはもともとある\n\n### 型推論\n例えば最も基礎的な型システムの一つである構造的型システム [Substructural Type Systems](https://www.cs.cmu.edu/~janh/courses/ra19/assets/pdf/lect04.pdf) は次のようなものがある. 変数が使える回数と使う順番について制約のある型システムである.\n\n| 型システム            | 0回 (Weakening) | 1回 (Base) | 2回以上 (Contraction) | 順序の可換性 (Exchange) | 用途                          |\n| --------------------- |:---------------:|:----------:|:---------------------:|:-----------------------:| ----------------------------- |\n| Ordered Type Systems  |        X        |     O      |           X           |            X            | stack-based memory allocation |\n| Linear Type Systems   |        X        |     O      |           X           |            O            | mutable reference             |\n| Affine Type Systems   |        O        |     O      |           X           |            O            |                               |\n| Relevant Type Systems |        X        |     O      |           O           |            O            |                               |\n| Normal Type Systems   |        O        |     O      |           O           |            O            | 一般の型システム              |\n\n(線形型やアフィン型などは実際にIdris 2で数量的型として、HaskellでMultiplicity Polymorphismとして導入され、多相型の表現をより良くするために使われています。)\n\nもう少し本格的な型理論だと多相型が導入されて高級感があります. 次のような型理論が代表的です.\n[「型の理論」と証明支援システム -- COQの世界](https://www.slideshare.net/maruyama097/coq-31970579)\n\n- フロー的な型推論\n\t- この中で最も簡単で基礎的な型推論. C++, Java, TypeScript などで使われています.\n\t- 初期化時に代入演算子 `=` の両辺の型が一致することを利用して型推論する.\n- Martin-Löf 型理論\n\t- マルティン=レーフと読みます.\n- Hindley-Milner 型理論\n\t- 強力な型理論です. Haskell, Rust, SML, OCaml などで使われています.\n\t- 連立方程式を解くように変数の型を決定していき, 決定できなければ多相性を持たせることで必ず正当に型推論できるという方法があり, Hindley-Milner 型理論のアルゴリズム W と呼ばれています.\n- Homotopy Type Theory (HoTT)\n\t- Martin-Löf 型理論の拡張で直感主義的型理論を解決させた理論らしい. いつか理解したい.\n\n## 第二章 内部実装\nコード解析などで解決する問題はよくNP完全な問題であることが多い。しかし何がNP完全で何がそうではないか区別する技術を持つ人は少ないと思う。\nまた内部実装を理解すれば、よりよい言語というのが分かってくるだろう。\n\nよりよい言語を知る為だけに必要な内部実装とはどこまでなのか？それには今までのプログラミング言語の歴史なしで考えることはできない。私は低レイヤを抽象化し, ロジックに注目できるように改善されてきたと考えている。その為, ゼロコスト抽象化ができるかどうかの境界からが説明を与えるのに妥当であろう。\n\nここで単語の定義を行う.\n- 静的 $\\iff$ コンパイル時\n- 動的 $\\iff$ 実行時\n- 静的型付け言語 $\\iff$ 「型システムを利用する」かつ「コンパイラを利用する」言語\n- 動的型付け言語 $\\iff$ 「型システムを利用しない」または「インタプリタを利用する」言語\n\n注意としては動的に型が決定される場合も静的型付け言語と呼んでいる点です. 例えば\n\n### メモリ領域\nユーザーに渡されるメモリはローダによって以下のように分けられている。\n- データ領域\n\t- 文字列など静的に決定したものが格納される\n\t- 名前空間, マングリング\n- スタック領域\n\t- push/popのようにLIFOでメモリを管理するシステムです。コンパイル時にサイズが確定している必要があります。\n- ヒープ領域\n\t- malloc/freeで任意サイズのメモリ資源をO(1)で配るシステムです。\n\t- double free, dangling pointer\n- テキスト領域\n\t- コードが格納される。\n- Thread Local Storage\n\n### 関数\nここでの関数はある RIP に意味を与える操作と定義する. すると関数は各プログラミングで呼ばれている名前で表すと以下のようなものがある.\n- 関数\n- generator\n- 継続\n\t- Continuation-Passing Style: CPS変換\n\t- call/cc\n\t- shift/reset\n\t- control/prompt\n\n### 多相性 (Polymorphism)\n具体的に依存型を実装する多相性を紹介する。\n- アドホック多相 (ad hoc polymorphism)\n- パラメータ多相 (parametric polymorphism)\n- サブタイピング多相 (subtyping polymorphism)\n\n**アドホック多相**\n\nデフォルト引数\n- オーバーロード\n- オーバーライド\n- 型クラス (Haskell)\n- トレイト (Rust)\n- プロトコル (Swift)\n- implicit (Scala)\n\n**パラメータ多相**\n\n- ジェネリクス\n\t- ジェネリクス (Java)\n\t- テンプレート (C++)\n\t- let多相 (ML系言語)\n\nこれらの実装にはディスパッチを用いる\n- 事前バインディング\n\t- 静的ディスパッチ\n\t\t- 静的に呼び出された関数の引数の型を解析して自動で実装する.\n- 遅延バインディング\n\t- 動的ディスパッチ\n\t\t- vtable\n\t- 多重ディスパッチ\n\nこれ説明するならC++やRustだけではなくHaskellやScalaの内部実装を見ておきたい.\n\n**サブタイピング多相**\n\n部分型の判定\n- 公称的部分型 (Nominal subtyping)\n\t- 部分型として定義したもののみ部分型とみなす.\n\t- 多様な静的解析ができる.\n\t- ex.) C++, Java, Rust\n- 構造的部分型 (Structual subtyping)\n\t- すべての要素が包括されていれば部分型とみなす.\n\t- 意味的には部分型ではないものも構造的に部分型であると見なされる可能性がある.\n\t- ex.) TypeScript, Haskell, OCaml, Elm\n- ダックタイピング (Duck typing)\n\t- 部分型の概念はなく, 呼び出し時に同一の要素があるか検査する.\n\t- ダックタイピングが実装されるのは動的型付け言語が多く, そのとき, 実行時エラーが検出されず, 運用時に脆弱性として発見される可能性がある.\n\t- ex.) Ruby, Python\n\n| 方法 |\t記述法 | 複数指定 | 関数のオーバライド |\n| -------- | -------- | -------- | ------- |\n|通常の継承（extends）\t|class B extends A {}\t|✖\t|適宜必要な関数のみ\n|abstractを利用した継承（extends）|\tclass B extends A {}※Aは基本的にabstractクラス|\t✖\t|全関数必須\n|Interfaceとは（implements）|\tclass B implements A {}\t|○\t|全関数必須|\n|Mixins（with）|\tclass B with A {}※Aは基本的にmixinクラス|\t○|\t適宜必要な関数のみ\n\n- [【Dart】abstract,mixin,extends,implements,with等の使い方基礎 (zenn.dev)](https://zenn.dev/iwaku/articles/2020-12-16-iwaku)\n- [C++と 4 つのキャスト演算 | yunabe.jp](https://www.yunabe.jp/docs/cpp_casts.html)\n\n仮想関数\n- 継承先で別々の処理をするけれども親クラスからは同じ関数として呼びたいという抽象化を行うときに使います。この処理の裏では関数が呼ばれるとvtable(仮想関数テーブル: 型と関数の対応表)を見て、的確な関数へ飛ばすようにしています。これを動的ディスパッチまたは動的ポリモーフィズムと呼びます。これはvtableを経由するので比較的遅いです。(メモリのアドレスを読んでそこへジャンプすることは分岐予測が効きにくいから、TODO:本当に効きにくい？)\n\n### 最適化 (Optimization)\nコンパイラが行う最適化処理は低レイヤに依存するものが多いです. その点, アーキテクチャの抽象化とも言えます. それよりコードの読みやすさと高速化には相反する場合がよくあります. それらをコンパイラが最適化し, その両立を目指します.\n\n単に最適化と言ったとき, 3つの最適化のどれかまたはすべてを指しています.\n- 実行速度最適化\n- メモリ最適化\n- コードサイズ最適化\n\nSSA形式に落とし込むとCFGと単純な同値関係になり, グラフ理論を持ち込んでより深い最適化を考えられます.\n\n現代の主要なコンパイラの最適化は巨大となっているが, 最もクリティカルな8つの最適化さえ実装すれば最大80%の性能まで向上します.\n\n- インライン展開\n\t- ある関数が頻繁に呼び出されるとき, 関数のコードを展開し, 関数呼び出しのオーバーヘッドを減らす.\n- ループ展開, ベクトル化\n\t- 命令レベルの並列化を行う為にループを展開する.\n\t- ループ毎の分岐は減るが, ループ内に複雑な制御フローが含まれていると分岐予測が当たりづらくなる.\n\t- キャッシュミスが増加する可能性がある.\n- 共通部分式除去 (CSE; Common Subexpression Elimination)\n- デッドコード除去 (DCE; Dead Code Elimination)\n\t- よく定数畳み込みをすると命令列が\"死ぬ\"ことがある. 実行時に1度も到達できないコードをデッドコードと呼び, それらは削除できる.\n- コード移動\n- 定数畳み込み, 定数伝播 (Constant Fold, Constant Propagation)\n\t- コンパイル時に定数の計算をする.\n\t- 定数伝搬 constexpr, 定数畳み込み consteval\n- Peephole最適化\n\nその他の最適化\n- 末尾呼び出し最適化\n- Profile-Guided Optimization\n\t- 実行しプロファイルしたデータに基づいてより良い最適化を行う\n\t- [ガイド付き最適化のプロファイル | Microsoft Learn](https://learn.microsoft.com/ja-jp/cpp/build/profile-guided-optimizations?view=msvc-170)\n\t- BOLT (Facebook)\n\t- llvm-propeller (Google)\n- Copy On Write\n\t- あるデータをコピーする時, 読み取り時は前データを参照すればよく, 書き込み時までコピーを遅延させればよいです.\n- キャッシュ局所化\n- Strength Reduction\n\t- コストの高い演算を低い演算に置き換える最適化\n\n資料\n- [CompilerTalkFinal (venge.net)](http://venge.net/graydon/talks/CompilerTalk-2019.pdf)\n- [A Catalogue of Optimizing Transformations (rice.edu)](https://www.clear.rice.edu/comp512/Lectures/Papers/1971-allen-catalog.pdf)\n\nJIT (Just In Time Compiler)\n- 実行時にコンパイルして最適化を行う.\n- method JIT\n- tracing JIT\n- YJIT\n\nVM (Virtual Machine)\n- YARV\n\t- [YARV Maniacs 【第 1 回】 『Ruby ソースコード完全解説』不完全解説 (rubyist.net)](https://magazine.rubyist.net/articles/0006/0006-YarvManiacs.html)\n- HHVM Hac\n- ErlangVM\n\nRAII; Resource Acquisition Is Initialization\n- リソースの確保(Acquisition)と解放を変数の初期化(Initialization)と破棄に紐付けるという考え方を指す言葉です.\n- 生存期間はスコープ内\n- 解放のタイミングがスコープを抜けるとき\n- どんなリソースでも対応するオブジェクトを作るだけ\n- 解放処理を手で書かなくても勝手に解放してくれる\n- 解放のタイミングが明確\n- 例外送出時もちゃんと対応\n- 解放処理の失敗をトラップしたい場合にはどうしようもなく使いにくい\n\nLifetime\n\nGC (Gabage Collection)\n- 参照カウントが0になったものを自動的に解放する\n- Mark and Sweep\n- Copy GC\n- Stop the World\n- [Project Zero: The quantum state of Linux kernel garbage collection CVE-2021-0920 (Part I) (googleprojectzero.blogspot.com)](https://googleprojectzero.blogspot.com/2022/08/the-quantum-state-of-linux-kernel.html)\n\nムーブセマンティクス\n- mutable reference は Linear type を根拠にしている.\n- ダングリングポインタを無くす\n- smart pointer\n- miracle pointer\n\t- 脆弱性の1つ, Use after free を用いることで様々な exploit ができる為, できる限り無くしたい\n\t- [Google Online Security Blog: Use-after-freedom: MiraclePtr (googleblog.com)](https://security.googleblog.com/2022/09/use-after-freedom-miracleptr.html)\n- [はじめに - Rustで独自のスライス型を定義する本 (lo48576.gitlab.io)](https://lo48576.gitlab.io/rust-custom-slice-book/introduction.html)\n- [Rust で単方向 LinkedList を実装する | 53ningen.com](https://53ningen.com/linkedlist-in-rust)\n\nエラー処理\n- try-catch (Java, JavaScript)\n- Result (TypeScript, Rust), Opaque Result Type (Swift)\n\n### ライブラリ (Library)\n下のことを気にしないで開発できる.\n- 静的ライブラリ\n- 動的ライブラリ\n\t- glibc\n\n## 第三章 開発体験\n思想が混じりやすい話題なので極力様々な意見を取り込むべき\n\n開発体験が良い状態とは, 短期的にも長期的にも最短時間でコードを読み, 書くことができることとする. これには2つの軸で考える.\n\n- わかりやすさ\n- フェイルセーフ\n\nこれに対して以下のような問題を考えることが出来る.\n\n- Abstraction leak\n\t- うまく抽象化したつもりでも、どこかに必ず漏れが出てきてしまう\n- 幾何的, 編集距離\n- バグ\n\nこれを解決するには次のような方法がある.\n\n- 階層構造\n\t- import classの継承\n- 情報隠蔽\n\t- カプセル化 private public\n- 依存性注入\n- 情報の粗密\n- 具体的で正確で簡潔な文章\n- 1度に1つの情報, 情報の独立性\n- 一貫性\n- エコシステム\n- パターン\n- Immutable\n\n### オブジェクト指向\nカプセル化 getter/setter\n本来は、値引き判定のロジックをどのオブジェクトに配するかを決めるにあたって、どのような知識を隠蔽すべきか、あるいは裏返して言えば、どのような知識は開示して構わないかという点に思いをめぐらすべきでした。\n解決策は、「データとロジックを一体に」という、どちらかというとゲームのルールのような具体的で単純なルールから視点を引き上げ、「情報隠蔽（＝知識隠蔽）」のような、より本質的な、目的志向的な設計原則に立ち帰って考えることです。\n何を隠蔽して何を表に出すのかという設計判断\n引数に関数を入れることもできる。このような特性を持つ言語を関数型言語と呼ぶ。\nVisitorパターン\n\n### 関数型言語\n遅延処理\n- 演算自体をthunkというもので包み、評価しろと言われるまではその状態で保持しておきます。そして評価するとなったときにそれを広げて演算します。  \n- thunkで包む分時間がかかる。\n\n### Clean Architecture\n\n### エコシステム\n- 静的解析\n\t- LSP (補完, ハイライト, 定義ジャンプ, 型ヒント (inlay hints, etc...) など)\n\t- type checker\n\t- formatter, linter\n\t- コード生成\n\t- 脆弱性スキャン\n\t- コールグラフ\n- 動的解析\n\t- デバッガ\n\t- プロファイラ\n\t- fuzzer\n\t- Concolic Execution\n- テスト\n\t- CI/CD\n- VSCode拡張機能\n- パッケージマネージャ\n- ランタイム\n- FFI\n- ライブラリ\n\n## 第四章 Concurrency\n\nプロセスは1つ以上のスレッドを持つ.\n\nConcurrency\n- coroutine\n- future/Promise\n- async/await 並行\n\t- Golang event loop 複数のprocess\n- Actor\n- atomic\n\t- compare and swap\n- Semaphore\n\nそれぞれの手法\n- CPS変換, ステートマシンを書く\n\t- とても面倒\n- 言語によるグリーンスレッド\n\t- node\n\t\t- 標準ライブラリを非同期のみにした\n\t\t- single thread な event loop 上で並列処理を実現している.\n\t- coroutine\n\t\t- 軽量スレッド\n\t\t- Go (goroutines)\n\t- Erlang, Haskell\n\t\t- ランタイムでIOがブロックしない仕組み\n\t\t- Erlang (ErlangVM)\n\t- Algebraic Effects and Handlers\n\t\t- IOでブロックする/しないはアプリケーションで制御できるし、IOは2系統に分かれないし、タスクを中断したり再開したりする仕組みも自動でついてきます。\n- 便利構文のサポート\n\t- async/await\n\t\t- 高階関数との親和性がよくない\n- (限定)継続\n\nasync/await $\\iff$ goroutine\n- async $\\iff$ goroutine作ってchannel渡して\n- await $\\iff$ channel待つ\n- eventloop の queue $\\iff$ channel のqueue\n\nasync iterator\n- Arc/Rc\n- [Rustの `Arc` を読む(1): Arc/Rcの基本 - Qiita](https://qiita.com/qnighy/items/4bbbb20e71cf4ae527b9)\n\n意味論\n- happens-before 実行順序\n- read-modify-write\n- data race free\n- sequentially consistent atomics(素直なatomics)\n\t- Java (volatile), C++ (default atomics), Go (sync/atomic), JavaScript\n\n- pthread_spinlock_t\n- [Rustの std::sync::RwLock はLinuxでwriter starvation問題を起こす (macOSなら平気) | 俺とお前とlaysakura](https://laysakura.github.io/2022/03/30/rust-RwLock-writer-starvation/)\n## その他\n\n未定義動作\n- [C 言語とその未定義動作を社会言語学的視点からも見る - Google ドキュメント](https://docs.google.com/document/d/1gpw9bbTC-8lhLBlK7QtQQQURxyoqoQAbvL9nQtGlM_k/edit)\n- [Cover - Effective Rust (lurklurk.org)](https://lurklurk.org/effective-rust/)\n","lastmodified":"2022-12-30T07:57:21.479263765Z","tags":null},"/other/Programming/Shell":{"title":"シェル","content":"\nShell\n\nシェル入門\n- [雰囲気でシェルを使っている人のためのシェル入門 | κeenのHappy Hacκing Blog (keens.github.io)](https://keens.github.io/blog/2017/10/17/fun_ikideshieruwotsukatteiruninnotamenoshierunyuumon/)\n- [bash tips - ももいろテクノロジー (hatenablog.com)](https://inaz2.hatenablog.com/entry/2014/12/14/013234)\n\n`/dev/ttyS0`\n\nShell Shock (CVE-2014-6271)\n- [bash の脆弱性 \"Shell Shock\" のめっちゃ細かい話 (CVE-2014-6271) - もろず blog (hatenablog.com)](https://moro-archive.hatenablog.com/entry/2014/09/27/200553)\n\n\nコマンド\n- sftp\n- scp\n- rsync\n- shopt\n- [gum を使ってシェルスクリプトの表示をカッコよくする (zenn.dev)](https://zenn.dev/kou_pg_0131/articles/gum-introduction)\n\n## Makefile\n- [A Tutorial on Portable Makefiles (nullprogram.com)](https://nullprogram.com/blog/2017/08/20/)\n\n## 冪等性 (idempotency)\n- Ansible\n- Terraform\n\n## シェル芸\n\n## 新しいシェルスクリプト\n元からべき等性を担保しててパイプがモナドである型システムを持つシェルスクリプトあったら嬉しいのかな?\nこれ、べき等性を担保したコマンドを作るのとシェルスクリプトはレイヤーが違う.\n\n逆にべき等性にしてほしくないこととは\n- Aを追加するとき, Aが既にあるときエラーが出てほしい\n- Aを削除するとき, Aが既にないときエラーが出てほしい\n- Aを表示するとき, Aが一つもないときエラーが出てほしい\n\nエラー型が同じになるようにするべき\n\n$$\n\\begin{aligned}\n\\tau \u0026:= (\\tau\\to\\tau/\\tau) \\mid p\\to\\tau \\mid \\mathrm{result} \\tau \\tau \\\\\ne \u0026:= \\mathrm{do} x e; e \\mid \\mathrm{return}\\ e \\mid (e\\mid e) \\mid e\\ \\mathrm{2\\\u0026\u003e1} \\mid c\\ a \\mid \\ldots \\\\\n\n\\end{aligned}\n$$","lastmodified":"2022-12-30T07:57:21.479263765Z","tags":null},"/other/Programming/Type":{"title":"型理論","content":"\n# 型理論\n\n型はグロタンディーク宇宙の中であることを断っておく。\n\n### 論理\n最小述語論理+矛盾律 = 直観主義論理\n直観主義論理+排中律 = 古典論理: ゲンツェンの自然演繹(NK)\n\n\n### 型無しラムダ計算\nα-変換 : 束縛変数の名前は重要ではない\nβ-簡約 : 関数適用\nη-変換 : 2つの関数について任意の引数を関数適用した値が等しいならば、2つの関数は等しい\n\n領域理論\n\n[SKIコンビネータで遊んでみよう - Qiita](https://qiita.com/Anko_9801/items/74af196cce123550001a)\n\n### 型付きラムダ計算\n型チェックが実行前に一度だけ行うこと\n\n#### ラムダ・キューブ\n\n![[Pasted image 20220925021333.png]]\n\n- $\\lambda\\to$: 単純型付きラムダ計算\n- $\\lambda 2$: 二階命題論理 (System F)\nパラメトリック多相, 全称型\n- $\\lambda\\underline{\\omega}$: 弱性高階命題論理\n型演算子\n直積型や多相カインドは型演算子の1つ\n- $\\lambda P$: 一階述語論理\n依存型\n依存型はせいぜいarray bound checkくらいにしか使えないだろう\n- $F_{\u003c:}$:\nサブタイプ\n- $\\lambda C$: Culculus of Constructions\n\n### Curry-Howard 同型対応\n\n$p:_PP$ が「$p$ が命題 $P$ の証明である」\n$p:_TP$ が「$p$ が型 $P$ の要素である」\n\n|論理|プログラム|\n|---|---|\n|証明|型を構成するプログラム|\n|論理式|型|\n|ならば$\\implies$|型 $P\\to Q$|\n|否定 $\\lnot$|型 $P\\to\\bot$|\n|かつ $\\land$|型 $P\\times Q$|\n|または $\\lor$|型 $P+Q$|\n|モーダスポネンス|関数適用 $(a \\to b) \\to a \\to b$|\n|三段論法|関数合成 $(a \\to b) \\to (b \\to c) \\to (a \\to c)$ |\n|対偶|$(a\\to b)\\to(b\\to\\bot)\\to(a\\to\\bot)$|\n|直観主義論理|Calculus of Constructions|\n|二階直観主義論理|System F|\n|ゲンツェンの自然演繹(NK)|型付きラムダ計算|\n|パースの法則$((P→Q)→P)→P$|call/cc|\n|否定翻訳|CPS変換|\n\nGATsはデータコンストラクタによって型を柔軟に指定出来る機能です。\ncall/cc\n\n## 型理論\nMartin-Lof 型理論\nHomotopy 型理論\nCubical 型理論","lastmodified":"2022-12-30T07:57:21.479263765Z","tags":null},"/other/Programming/meta_programming":{"title":"メタプログラミング","content":"\nC++\n- constexpr\n- [コンパイル中にコンパイルする「コンパイル時Cコンパイラ」をつくった話 - kw-udonの日記 (hatenablog.com)](https://kw-udon.hatenablog.com/entry/2016/12/03/201722)\n\nruby\n- method_missing()\n- [[Ruby] method_missing()を実用レベルで理解する - Qiita](https://qiita.com/kidach1/items/75ae4a29c99a79816384)","lastmodified":"2022-12-30T07:57:21.483263743Z","tags":null},"/other/Programming/tips/go_gc":{"title":"","content":"# Go GC Pacer Redesign\n###### tags:`weekly tiken`\n\n## メモ\nGoのGCに詳しくない人向け: https://deepu.tech/memory-management-in-golang/\n- これまで\n    - heap sizeがしきい値（`freshly allocated / remaining memory \u003e GOGC/100`）を超える(or 一定時間経過←怪しい、忘れた)と次のサイクルを実行\n    - https://docs.google.com/document/d/1wmjrocXIWTr1JxU-3EQBI6BK6KgtiFArkG47XK73xIQ/edit\n\n\u003e The GOGC variable sets the initial garbage collection target percentage. A collection is triggered when the ratio of freshly allocated data to live data remaining after the previous collection reaches this percentage. The default is GOGC=100. Setting GOGC=off disables the garbage collector entirely. The runtime/debug package's SetGCPercent function allows changing this percentage at run time. See https://golang.org/pkg/runtime/debug/#SetGCPercent.\n\n- これから\n    - 色々加味する\n\u003e 1. Including all non-heap sources of GC work (stacks, globals) in pacing decisions.\n\u003e → will resolve long-standing issues with small heap sizes, allowing the Go garbage collector to scale down and act more predictably in general.\n\u003e 2. Reframing the pacing problem as a search problem, \"solved\" by a proportional-integral controller,\n\u003e → will eliminate offset error present in the current design, will allow turning off mark-assist almost entirely outside of exceptional cases, improving allocation latency, and will enable clearer designs for setting memory limits on Go applications.\n\u003e 3. Extending the hard heap goal to the worst-case heap goal of the next GC,\n\u003e → will enable smooth and consistent response to large changes in the live heap size with large GOGC values.\n\nGCの処理自体はRCと比べて重いので、適宜タイミングを見計らって実行される。\n- ヒープサイズが大きくなったとき\n- システムが暇なとき\n- プログラムから明示的に呼び出されたとき\n\nモチベーション: https://github.com/golang/go/issues/42430\n\nJavaとかはどうなってんの？\n例: https://wiki.openjdk.java.net/display/shenandoah/Main#Main-ImplementationOverview\n基本はheap size見てるけどHeuristicsのとこにモードとその説明がある。\n\nGC Paceがなぜ大事か\n\u003e These two goals are tightly related. If a garbage collection cycle starts too late, for instance, it may consume more CPU to avoid missing its target. If a cycle begins too early, it may end too early, resulting in GC cycles happening more often than expected.\n\n==CPU Utilization: 30% (GC 25%, assist 5%)==\n\u003e the steady-state is implicitly defined as: constant allocation rate, constant heap size, and constant heap composition (hence, constant mark rate). The pacer expects the application to settle on some average global behavior across GC cycles.\n\nbut still robust for transcient state, and this is acomplished by finding new steady-state. The GC makes allocating goroutines donate their time to assist the garbage collector, proportionally to the amount of memory that they allocate. \n\nwhat is propotional controller?\n\nwhat is assist system?\n\u003e The GC assist system operates by dynamically computing an assist ratio. The assist ratio is the slope of a curve in the space of allocation time and GC work time, a curve that the application is required to stay under. This assist ratio is then used as a conversion factor between the amount a goroutine has allocated, and how much GC assist work it should do. Meanwhile, GC workers generate assist credit from the work that they do and place it in a global pool that allocating goroutines may steal from to avoid having to assist.\n\nmeta-issues: https://github.com/golang/go/issues/42430\n\n## TODO\n- 以前のペーサーのコードリーディング\n    - https://cs.opensource.google/go/go/+/master:src/runtime/mgcpacer.go\n- assist systemの実装（Gorutineのglobal pool?）\n- 現在のペーサーがどのように加味するようになったか実装を確認\n\n## refs\n- https://github.com/golang/go/issues/44167\n- https://github.com/golang/proposal/blob/master/design/44167-gc-pacer-redesign.md\n- https://github.com/golang/go/commit/a108b280bc724779ebaa6656d35f0fb307fb2a9b\n- https://github.com/golang/go/issues/14951\n- https://eng.uber.com/how-we-saved-70k-cores-across-30-mission-critical-services/\n- https://concertio.com/blog/optimizing-the-go-garbage-collector-and-concurrency/","lastmodified":"2022-12-30T07:57:21.483263743Z","tags":null},"/other/Programming/tips/tips":{"title":"","content":"`inline` は呼び出し地点で関数のコードを展開する.\n`constexpr` は呼び出し地点で静的に計算し, 定数としてインライン展開される.\n### コンパイラの最適化手法: 定数伝搬で十分ではないか？またそれに任せることはできないのか?\n- 関数の形だと定数伝搬できるところもできないので最適化できない.\n- 定数伝搬可能関数と同値な性質\n- 抽象化された機能を使うより抽象化されてない機能の方がよいというのは改善すべき.\n\n- 停止性問題(決められる性質をeBPFや)\n\n静的に計算するにはいくつか条件が必要となるが C++ では次のように定義されている. constexpr制約\n- constexpr変数は初期化時, constexpr関数は呼び出し時に静的に検査する.\n- constexpr変数はprimitiveな値/演算, constexprかつ静的に決定可能な変数/関数によって初期化されること.\n- constexpr関数は. つまりコンパイル可能かは呼び出し時の引数に依存する.\n- constexpr関数の引数には実行時にしか決まらない値(標準入力, ファイルから読んだ値, 乱数など)を渡すことができる.\n- constexpr テンプレート関数がコンパイル可能かは呼び出し時に依存する\n```cpp\ninline constexpr Type funcname() noexcept { }\n```\n`const` や `private, public` などのアクセス修飾子, 名前空間などのスコープは静的に検査することで性質を保証し, その保証を利用してコードの見通しをよくしたり, バグを防げる.\n`const` は初期化後に二度と変更されない変数や関数である.\n\n\nC++20 `\u003cconcepts\u003e`\n","lastmodified":"2022-12-30T07:57:21.483263743Z","tags":null},"/other/Programming/toolchain":{"title":"ツールチェーン","content":"\n# toolchain\n\nツールチェーンとはソースコードを実行する一連の処理に必要なソフトウェアのこと。要はどんな開発にも必要なツールセットである。\n\n![[toolchain.svg]]\n\n## コンパイラ\n\n![[compiler.svg]]\n\n- glibc\n- [musl libc](https://musl.libc.org/)\n\n- [コンパイル中にコンパイルする「コンパイル時Cコンパイラ」をつくった話 - kw-udonの日記 (hatenablog.com)](https://kw-udon.hatenablog.com/entry/2016/12/03/201722)\n- [keiichiw/constexpr-8cc: Compile-time C Compiler implemented as C++14 constant expressions (github.com)](https://github.com/keiichiw/constexpr-8cc) \n- [コンパイル時Brainfuckコンパイラ ――C++14 constexpr の進歩と限界―― - ボレロ村上 - ENiyGmaA Code (hateblo.jp)](https://boleros.hateblo.jp/entry/2014/12/24/065155)\n- [go/compile.go at master · golang/go (github.com)](https://github.com/golang/go/blob/master/src/cmd/compile/internal/ssa/compile.go#L331)\n\n## disassembler\n\n## decompiler\n\nバイナリを入れてLLVM IR に変換後, 最適化する\n[facebookincubator/BOLT: Binary Optimization and Layout Tool - A linux command-line utility used for optimizing performance of binaries (github.com)](https://github.com/facebookincubator/BOLT)\n\n\n## 自作言語\n","lastmodified":"2022-12-30T07:57:21.483263743Z","tags":null},"/other/Quantum/Quantum":{"title":"量子コンピュータ","content":"\n## 対象読者\n- とにかく量子コンピュータを使ってみたい\n\n## 1. 初めに\n\n2019年10月23日、Googleの量子コンピューターが今までのコンピューターより速く計算出来るようになった！という事がありましたね。普段使っている暗号が解読され悪用されるかも！けど量子コンピューターとか量子アニーリング、名前は知ってるけど中で何やってるのかさっぱりわからん〜という人を見かけます。そこでここでは量子コンピューターを体感しつつ、仕組みを理解してこうと思います。量子回路を組む際に高校数学の知識は必要ですが、出来るだけ簡単に説明するのでそれ以上の量子力学などの知識は無くてもわかると思います。\n\n## 2. 量子コンピューターってなに？\n\nWikipediaによると\n\u003e量子コンピュータ （りょうしコンピュータ、英語：quantum computer） は、量子力学的な重ね合わせを用いて並列性を実現するとされるコンピュータ。\n量子コンピュータは「量子ビット」 (qubit; quantum bit、キュービット) により、重ね合わせ状態によって情報を扱う。\nn量子ビットがあれば$2^n$の状態が同時に計算され、$2^n$個の重ね合わされた結果が得られる。しかし、重ね合わされた結果を観測してもランダムに選ばれた結果が1つ得られるだけで、古典コンピュータに対する高速性は得られない。(引用元:https://ja.wikipedia.org/wiki/量子コンピュータ)\n\n量子コンピュータと対比して現在使われているコンピュータを古典コンピュータとします。\n\n## 3. 量子コンピュータを使う事で嬉しいことは？\n\n1994年にピーター・ショア（Peter Shor)は古典コンピュータでは解くことが難しい問題である素因数分解を量子計算によって容易な問題に落とすショーアのアルゴリズムというものを開発しました。それによって量子コンピュータの研究はとても盛んになりました。なぜなら暗号の中で今最もよく使われているRSA暗号は素因数分解を使って暗号化しているからです。それから色々な研究がなされ、機械学習を量子コンピュータで行ったり\n\n## 4. 量子ビット\n\n### ブラケット記法\n\n量子力学において量子の状態の記述に必要なものがブラケット記法です。なんかめっちゃ難しそうと思うかもしれませんが、これはベクトルを言い換えただけと思って構わないです。左がケット・ベクトル、右がブラ・ベクトルと呼びます。この記事内ではケット・ベクトルだけを使いますのでブラとケットを区別しないで、あぁただのベクトルねと思って大丈夫です。\n\n$$\n\\ket{\\psi} = \\begin{pmatrix} \na_0 \\\\\na_1 \\\\\n\\vdots \\\\\na_n \\\\\n\\vdots\n\\end{pmatrix}\n\\bra{\\psi}\n$$\n\n### 量子ビット\n古典コンピュータで扱うビットは0と1という数値を扱います。これは電圧の高低によって表現します。それに対して量子コンピュータは数値ではなく固有の状態を持ちます。これは古典コンピュータのビットとはとてもかけ離れたものであるので量子ビット・qubitと区別します。そして古典コンピュータのビットと対応する状態を$\\ket{0}$と$\\ket{1}$とします。$\\ket{0}$と$\\ket{1}$はその状態なら操作をしなければその状態のままで、$\\ket{0}$と$\\ket{1}$以外の状態にはなりません。\n\n2量子ビットの場合はそれぞれが独立な為それらの組み合わせで表現できます。これは直積を取るといい、2量子ビットの状態は$\\ket{0}\\otimes\\ket{1}$と表します。もっと増えてn量子ビットの場合もこれで表現できますが、面倒くさいので\n$$ \\ket{011} = \\ket{0}\\otimes\\ket{1}\\otimes\\ket{1} $$\nと表すことにします。\n\n### 重ね合わせの状態\n量子ビットは$\\ket{0}$と$\\ket{1}$だけではなく重ね合わせの状態を取る事ができ、このように表します。($c_0$と$c_1$は複素数)\n\n$$\n\\ket{\\psi} = c_0\\ket{0} + c_1\\ket{1}\\\\\n|c_0|^2 + |c_1|^2 = 1\n$$\n\nこのように$\\ket{0}$と$\\ket{1}$にそれぞれ複素数を掛けたものとなります。現実世界に複素数？どうしてそうなるの？と言われても実験での事実と矛盾が起きないからとしか言いようがありません。\n\n重ね合わせの状態の例としてこのようなものを考えます。\n\n$$\n\\ket{\\psi} = \\frac{1}{\\sqrt{2}}\\ket{0}+\\frac{1}{\\sqrt{2}}\\ket{1}\n$$\n\n$\\ket{\\psi}$と$\\ket{1}$の2量子ビットの時は\n\n$$\n\\ket{\\psi} \\otimes \\ket{1} = \\frac{1}{\\sqrt{2}}\\ket{01}+\\frac{1}{\\sqrt{2}}\\ket{11}\n$$\n\nと表し、$\\ket{\\psi}$がn量子ビットあったら\n\n$$\n\\begin{align}\n\\ket{\\psi}^n \u0026= \\frac{1}{\\sqrt{2^n}}(\\ket{0}+\\ket{1})^n \\\\\n\u0026= \\frac{1}{\\sqrt{2^n}}(\\ket{00\\cdots0}+\\ket{00\\cdots1}+\\cdots+\\ket{11\\cdots1})\n\\end{align}\n$$\n\nとなります。一般に2量子ビットの重ね合わせの状態は\n\n$$\n\\begin{align}\n\u0026(c_0\\ket{0} + c_1\\ket{1}) \\otimes (c_2\\ket{0} + c_3\\ket{1}) \\\\\n\u0026= c_0c_2\\ket{00} + c_0c_3\\ket{01} + c_1c_2\\ket{10} + c_1c_3\\ket{11}\n\\end{align}\n$$\n\nとなります。このような重ね合わせの状態にし、その状態のまま様々な演算を行う事で並列処理を可能にし量子計算を行えます。\n\n### どうやって作られているの？\n\n※ここは速く実際に動かしてみたいという方は飛ばして構わないです\nここまでは表記的な部分について触れてきましたが、これはどのように生成されているのか気になります。\n\nこれは主に2つあります。\n\n- 光子の偏光\n- スピン\n\n#### 光子の偏光\n\nEPRパラドックス\nアスペの実験\nベルの不等式\n\n#### スピン\n\nシュテルン・ゲルラッハの実験\n\n## 5. 量子論理ゲート\n\n古典コンピュータではANDやOR、NOT、XORなどの古典論理ゲートのようなものを使って計算します。対して量子コンピュータでは量子論理ゲートを用いて計算します。ユニタリ変換でありほとんどの演算がn対n対応\n量子計算をするためには量子論理ゲートは必須のものとなります。\n\n### 1. パウリゲート\nパウリゲートは3種類あり、Xゲート、Yゲート、Zゲートがあります。XゲートはNOTゲート、Zゲートは位相のNOTゲートとみれます。X,Y,Zゲートは$\\ket{0}$、$\\ket{1}$どちらも2回作用すると元に戻ります。確かめてみてください。\n\n$$\n\\begin{align}\n\u0026X:\\ket{0} \\rightarrow \\ket{1}, \\quad \\ket{1} \\rightarrow \\ket{0} \\\\\n\u0026Y:\\ket{0} \\rightarrow i\\ket{1}, \\quad \\ket{1} \\rightarrow -i\\ket{0} \\\\\n\u0026Z:\\ket{0} \\rightarrow \\ket{0}, \\quad \\ket{1} \\rightarrow -\\ket{1}\n\\end{align}\n$$\n\n### 2. アダマールゲート\nアダマールゲートは量子ビットの回転を表し、$H$と表記されます。\n\n$$\n\\ket{0} \\rightarrow \\frac{1}{\\sqrt{2}}(\\ket{0} + \\ket{1}) \\\\\n\\ket{1} \\rightarrow \\frac{1}{\\sqrt{2}}(\\ket{0} - \\ket{1})\n$$\n\nアダマールゲートも2回作用すると元に戻るという性質があります。パッと見分かりませんがこのようにして分かります。これは$\\ket{0}$の場合ですが$\\ket{1}$も同様です。\n\n$$\n\\begin{align}\nH(H(\\ket{0})) \u0026= H(\\frac{1}{\\sqrt{2}}(\\ket{0} + \\ket{1})) \\\\\n\u0026= \\frac{1}{\\sqrt{2}}(\\frac{1}{\\sqrt{2}}(\\ket{0} + \\ket{1})) + \\frac{1}{\\sqrt{2}}(\\frac{1}{\\sqrt{2}}(\\ket{0} - \\ket{1})) \\\\\n\u0026= \\frac{1}{2}\\ket{0} + \\frac{1}{2}\\ket{1} + \\frac{1}{2}\\ket{0} - \\frac{1}{2}\\ket{1} \\\\\n\u0026= \\ket{0}\n\\end{align}\n$$\n\n### ブロッホ球\n\n### 3. 制御ユニタリゲート・古典制御ゲート\n\n#### 制御ノットゲート CNOTゲート\nCNOTゲートは1つの量子ビットの状態によって、もう1つの量子ビットにNOTゲートを作用させるゲートです。この状態を判断する量子ビットを制御ビット(control qubit)、作用させる量子ビットを標的ビット(target qubit)と呼びます。制御ビットが$\\ket{1}$である場合のみ標的ビットに作用させます。左は制御ビット、右は標的ビットです。作用後の標的ビットは制御ビットと標的ビットの排他的論理和と同値と分かります。\n\n$$\n\\begin{align}\n\u0026\\ket{00} \\rightarrow \\ket{00} \\\\\n\u0026\\ket{01} \\rightarrow \\ket{01} \\\\\n\u0026\\ket{10} \\rightarrow \\ket{11} \\\\\n\u0026\\ket{11} \\rightarrow \\ket{10}\n\\end{align}\n$$\n\n例えば、一般の2量子ビットがあり、それについてCNOTゲートを作用させると\n\n$$\n\\begin{align}\n\u0026(c_0\\ket{0} + c_1\\ket{1}) \\otimes (c_2\\ket{0} + c_3\\ket{1}) \\\\\n\u0026= c_0c_2\\ket{00} + c_0c_3\\ket{01} + c_1c_2\\ket{10} + c_1c_3\\ket{11} \\\\\n\u0026\\rightarrow c_0c_2\\ket{00} + c_0c_3\\ket{01} + c_1c_2\\ket{11} + c_1c_3\\ket{10}\n\\end{align}\n$$\n\n\n#### トフォリゲート\nトフォリゲートはCNOTゲートの3つ版で、2つの量子ビットの状態がどちらも$\\ket{1}$のとき、もう1つの量子ビットにNOTゲートを通すゲートです。\n\n$$\n\\begin{align}\n\u0026\\ket{000} \\rightarrow \\ket{000} \\\\\n\u0026\\ket{010} \\rightarrow \\ket{010} \\\\\n\u0026\\ket{110} \\rightarrow \\ket{111}\n\\end{align}\n$$\n\n### 観測\n\n最終的に量子論理ゲートによって作られた状態から確率的に0か1の値を取り出すゲートです。その確率は状態に依存します。例えば、$\\ket{0}$,$\\ket{1}$はそれぞれ絶対的に0,1となり、 $\\frac{1}{\\sqrt{2}}(\\ket{0} + \\ket{1})$,$\\frac{1}{\\sqrt{2}}(\\ket{0} - \\ket{1})$は50%の確率で0か1となります。このように状態が確定する事を量子力学では「波束の収束」と言います。波束の収束をするとその量子ビットは壊れ、ゲートを通しても変化は起こりません。\n\nその他のゲートは[IBM Q Experience](https://quantum-computing.ibm.com/)や[OpenQASMのライブラリ](https://github.com/Qiskit/openqasm/blob/master/examples/generic/qelib1.inc)で感じとってください。\n\n#### IBM Q Experience\n\nIBM Q Experienceとはクラウド上で量子回路を構築し、シミュレーションや実際の量子コンピュータに計算させることが出来るIBMのシステムです。実際の量子コンピュータを使う時は5量子ビットだけという制限はありますが誰でも扱う事が出来ます！\n\n次は実際に量子論理ゲートを使って簡単な量子計算を行ってみます。[IBM Q Experience](https://quantum-computing.ibm.com/)へ飛んでサインアップをすると使えるようになります。\n\n#### スワップゲート\n\n量子計算の簡単な例としてスワップゲートがあります。スワップゲートとは2量子ビット間において状態を交換するような演算です。\n\n$$\n\\begin{align}\n\u0026\\ket{00} \\rightarrow \\ket{00} \\\\\n\u0026\\ket{01} \\rightarrow \\ket{10} \\\\\n\u0026\\ket{10} \\rightarrow \\ket{01} \\\\\n\u0026\\ket{11} \\rightarrow \\ket{11}\n\\end{align}\n$$\n\nこのようになるものを作ります。具体的にはCNOTゲートを交互に3つ置くと作れます。\n\n\u003cimg width=\"199\" alt=\"スクリーンショット 2019-11-03 22.56.10.png\" src=\"https://qiita-image-store.s3.ap-northeast-1.amazonaws.com/0/227781/d7b318fb-0d9d-4312-5a62-2764aa3a891b.png\"\u003e\n\nこれをIBM Qに置きます。制御ビットと標的ビットの順番が逆の場合、ゲートをクリックすると、バツマークとえんぴつマークが出るのでえんぴつマークを押して、繋がっている線を入れ替えましょう。そして、スワップゲートの前後に$\\ket{10}$(下から読みます)の状態を作る為にXゲート、値を取り出す為にそれぞれの量子ビットを観測します。観測する際どの古典ビットに埋め込むか指定する為に左のCircuit EditerからOpenQASMのコードを変更しましょう。するとこのようになります。\n\n\u003cimg width=\"1440\" alt=\"スクリーンショット 2019-11-09 19.47.16.png\" src=\"https://qiita-image-store.s3.ap-northeast-1.amazonaws.com/0/227781/5491aeff-888b-08fd-414d-b07176756ffb.png\"\u003e\n\nこれを右上のボタンで保存してRunしてみます...！しばらく待ち、Resultを見てみると...\n\n\u003cimg width=\"1257\" alt=\"スクリーンショット 2019-11-09 19.42.50.png\" src=\"https://qiita-image-store.s3.ap-northeast-1.amazonaws.com/0/227781/b6fcb9b8-ad7c-ef86-512a-bb0e79d78fa1.png\"\u003e\n\nこのように結果が出ます！100% $\\ket{01}$という事で成功してますね！！！やった！！！\n\n## エンタングルメント\n\n量子計算の上で非常に重要なものとしてエンタングルメントというものがあります。説明の前にまずは下のように制御ビットは$\\frac{1}{\\sqrt{2}}(\\ket{0} + \\ket{1})$、標的ビットは$\\ket{1}$のCNOTゲートを作用させます。\n\n$$\n\\begin{align}\n\u0026\\frac{1}{\\sqrt{2}}(\\ket{0} + \\ket{1}) \\otimes \\ket{1} \\\\\n\\rightarrow \u0026\\frac{1}{\\sqrt{2}}(\\ket{01} + \\ket{10})\n\\end{align}\n$$\n\nこの時、CNOTゲートを作用する前までは量子ビットの積で表せられていましたが、作用した後では積で表す事が出来なくなっています。これはつまり、量子ビットの一方が決まった時、もう一方も自然と決まってしまう事になります。この場合だと、左量子ビットが$\\ket{0}$と観測されるともう一方の量子ビットは$\\ket{1}$となります。その逆もまた然り。\n\nこのようにエンタングルメントとは複数の量子ビットが存在し、それらが各々の量子ビットの状態の積で表せない状態の事を言います。日本語では量子もつれ、絡まった状態と言います。EPRペア\n\n## 量子クローニングの不可能性\n\n### 量子テレポーテーション\n\n量子は通常\n\n量子クローニングの不可能性をどうやってかいくぐっているのか\n\nエンタングルメントの具体的な例として量子テレポーテーションというものがあります。量子テレポーテーションは二つの量子が量子情報の世界では情報の送り主をアリス、お届け先をボブと呼びます。\n\n1. アリスはボブへ量子情報を送ります。\n2. アリスは自分の量子を観測し、量子状態を知ります。\n3. ボブはアリスが知った量子状態から同じ量子状態にする事が出来ます。\n\n粒子が空間の別の場所に瞬間移動するものとは異なります。\n\n\n\u003cimg width=\"450\" alt=\"スクリーンショット 2019-11-03 23.05.39.png\" src=\"https://qiita-image-store.s3.ap-northeast-1.amazonaws.com/0/227781/2bb5ec39-5442-92af-660f-d06decafe44b.png\"\u003e\n\n\u003cimg width=\"1259\" alt=\"スクリーンショット 2019-11-09 21.35.02.png\" src=\"https://qiita-image-store.s3.ap-northeast-1.amazonaws.com/0/227781/25c06381-512c-abe7-5d54-8f51b52f383b.png\"\u003e\n\n\n## ショアのアルゴリズム\n\n素因数分解を古典・量子コンピュータを併用する事で今までよりも早く行えるようになるアルゴリズムです。\n\n### 量子フーリエ変換\n\n$$\n\\ket{j} \\rightarrow \\frac{1}{\\sqrt{2^n}}\\sum_{k=0}^{2^n-1}exp(\\frac{i2\\pi jk}{2^n})\\ket{k}\n$$\n\n## 量子エラーコレクション\nこれは沢山研究されていて\n\n\nまだまだ研究されているあります。\n\n\n[Quantum Algorithm Zoo](https://quantumalgorithmzoo.org/)\n","lastmodified":"2022-12-30T07:57:21.483263743Z","tags":null},"/other/Rendering/RayTracing":{"title":"レイトレーシング, パストレーシング","content":"\n## 説明\n\nレイトレーシング(Ray Tracing)とはCGを作成する技術の一つ。視点からレイ(Ray)と呼ばれる仮想の光線を飛ばし, 反射・屈折を繰り返して, 光源に当たればそこから逆算して画素を表示する仕組みです。\n\nガンマ補正 $(R^{2.2}, G^{2.2}, B^{2.2})$\n\nPPM画像というASCIIで画素を表現する規格を用いると楽\n\n## 物理ベースレンダリング理論\nある波長 $\\lambda$ の光のエネルギー\n$$e_\\lambda=\\frac{hc}{\\lambda}$$\nスペクトル放射エネルギー\n$$\n\\begin{aligned}\nQ_\\lambda\u0026=ne_\\lambda \\\\\nQ\u0026=\\int_0^\\infty Q_\\lambda d\\lambda\n\\end{aligned}\n$$\nスペクトル放射束\n$$\n\\begin{aligned}\n\\Phi_\\lambda\u0026=\\frac{dQ_\\lambda}{dt} \\\\\n\\Phi\u0026=\\frac{dQ}{dt}\n\\end{aligned}\n$$\n放射輝度\n$$L(x,\\vec\\omega)=\\frac{d^2\\Phi}{\\cos\\theta dAd\\vec\\omega}$$\n\nRGBそれぞれのスペクトル放射束を画像にすればよい。\n現実は可視光領域全てのスペクトルなのでこれは新井金治である。\n可視光の全波長考慮したレンダリングをフルスペクトラムレンダリングと呼び、プリズムの光の分散などで使われます。\n\n空気が真空なら光が進行しても放射輝度の値は変わらない。\n現実は空気中の微粒子との衝突で光の吸収、散乱などの現象が起きる。\nこれを再現したレンダリングをボリュームレンダリングと呼び、煙や雲などで使われます。\n\n### 双方向反射率分布関数 (BRDF)\n反射・屈折を表現する関数 BRDF\n\n$$\nf(x,\\vec\\omega_i,\\vec\\omega_r) = \\frac{dL_r(x,\\vec\\omega_r)}{L_i(x,\\vec\\omega_i)\\cos\\theta d\\vec\\omega_i}\n$$\n\nBRDF を用いると半球全体 $\\Omega$ からある点にきた光が、方向 $\\vec\\omega_r$ に反射される放射輝度の値 $L_r(x,\\vec\\omega_r)$ を計算することが出来る。\n\n$$\nL_r(x,\\vec\\omega_r) = \\int_\\Omega f(x,\\vec\\omega_i,\\vec\\omega_r)L_i(x,\\vec\\omega_i)\\cos\\theta d\\vec\\omega_i\n$$\n\nこれを $L_r(x,\\vec\\omega_r) = TL_i(x,\\omega_i)$ と略す事にする。\n- 物体表面のある点 $x$ から方向 $\\vec\\omega_r$ へ出射する放射輝度 $L_o(x,\\vec\\omega_r)$\n- 点 $x$ において物体が発光し、$\\vec\\omega_r$ の方向へ出射する放射輝度 $L_e(x,\\vec\\omega_r)$\n- 点 $x$ から $\\vec\\omega_r$ に反射される放射輝度 $L_r(x,\\vec\\omega_r)$\nとして次のレンダリング方程式が成り立つ。\n\n$$\nL_o(x,\\vec\\omega_r) = L_e(x,\\vec\\omega_r) + L_r(x,\\vec\\omega_r)\n$$\n\nまた, 点 $x$ から $\\vec\\omega$ の方向へ進んだとき, 衝突する点を返す関数 $t(x,\\vec\\omega)$ を用いて $L_i(x,\\vec\\omega_i) = L_o(t(x,\\vec\\omega_i),\\vec\\omega_i)$ と表せられる。するとレンダリング方程式は以下の無限級数で表現できる。\n\n$$\n\\begin{aligned}\nL_o(x_0,\\vec\\omega_0) \u0026= L_e(x_0,\\vec\\omega_0) + L_r(x_0,\\vec\\omega_0) \\\\\n\u0026= L_e(x_0,\\vec\\omega_0)+TL_i(x_0,\\vec\\omega_1) \\\\\n\u0026= L_e(x_0,\\vec\\omega_0)+TL_o(t(x_0,\\vec\\omega_1),\\vec\\omega_1) \\\\\n\u0026= L_e(x_0,\\vec\\omega_0)+T(L_e(x_1,\\vec\\omega_1)+TL_o(x_2,\\vec\\omega_2)) \\\\\n\u0026= L_e(x_0,\\vec\\omega_0)+T(L_e(x_1,\\vec\\omega_1)+T(L_e(x_2,\\vec\\omega_2)+T(L_e(x_3,\\vec\\omega_3)+\\ldots))) \\\\\n\u0026= L_e(x_0,\\vec\\omega_0)+\\sum_{k=1}^\\infty T^kL_e(x_k,\\vec\\omega_k) \\\\\n\\end{aligned}\n$$\n\nモンテカルロ法を用いることで積分を数値的解くことが出来る。\n\n$$\n\\begin{aligned}\nL_o(x_0,\\vec\\omega_0) \u0026= L_e(x_0,\\vec\\omega_0)+\\sum_{k=1}^\\infty T^kL_e(x_k,\\vec\\omega_k) \\\\\n\u0026= L_e(x_0,\\vec\\omega_0)+\\sum_{k=1}^\\infty \\int_\\Omega f(x,\\vec\\omega_k,\\vec\\omega_r)\\ldots\\left(\\int_\\Omega f(x,\\vec\\omega_k,\\vec\\omega_{k-1})L_e(x_k,\\vec\\omega_k)\\cos\\theta_k d\\vec\\omega_k\\right)\\ldots \\cos\\theta_1 d\\vec\\omega_1 \\\\\n\u0026= L_e(x_0,\\vec\\omega_0)+\\sum_{k=1}^\\infty\\int_\\Omega\\ldots\\int_\\Omega f(x_1,\\vec\\omega_1,\\vec\\omega_0)\\ldots f(x_k,\\vec\\omega_k,\\vec\\omega_{k-1})L_e(x_{k},\\vec\\omega_{k})\\cos\\theta_1\\ldots\\cos\\theta_k d\\vec\\omega_1\\ldots d\\vec\\omega_k \\\\\n\u0026\\approx L_e(x_0,\\vec\\omega_0)+\\sum_{k=1}^\\infty \\frac{1}{N}\\sum_{s=1}^N \\frac{f(x_1,\\vec\\omega_1^s,\\vec\\omega_0)\\ldots f(x_k,\\vec\\omega_k^s,\\vec\\omega_{k-1})L_e(x_{k},\\vec\\omega_{k})\\cos\\theta_1\\ldots\\cos\\theta_k}{p_1(\\vec\\omega_1)\\ldots p_k(\\vec\\omega_k)} \\\\\n\\end{aligned}\n$$\n\nサンプルには重点的サンプリングを行う。確率密度関数の累積分布関数の逆関数を用いてサンプルを生成することで\n\n級数の計算ではロシアンルーレットを用いる。次項を計算する確率 $p$ を用いて次のように計算する。\n\n$$\n\\begin{aligned}\nS_n \u0026= \\sum_{k=0}^n x_k \\\\\nR_n \u0026= S_\\infty - S_n \\\\\n\\hat R_n \u0026= x_n + \\begin{dcases}\n\\frac{\\hat R_{n+1}}{p} \u0026 (u\\leq p) \\\\\n0 \u0026 (u\u003ep)\n\\end{dcases} \\\\\n\\hat S_n \u0026\\approx x_0 + \\frac{x_1}{p} + \\frac{x_2}{p^2} + \\ldots + \\frac{x_n}{p^n} \\\\\n\\end{aligned}\n$$\n\nこの期待値を計算すると $S_\\infty$ となる。\n\n$$\nE[\\hat S] = x_0 + p\\frac{x_1}{p} + p^2\\frac{x_2}{p^2} + \\ldots + p^n\\frac{\\hat R_n}{p^n} = S_\\infty\n$$\n\n## モデル\n### 拡散反射モデル\n紙のような乱反射する物体を考える。このときBRDFは次のようになる。\n\n$$\nf_{Diffuse}(x, \\vec\\omega_i, \\vec\\omega_o) = \\frac{\\rho}{\\pi}\n$$\n\nこの確率密度関数 $p(\\vec\\omega)$ はBRDF$\\times\\cos\\theta$ に比例する為, 定数 $k$ を用いて $p(\\vec\\omega) = k\\cos\\theta$ となる。確率の条件より $k$ を決定することが出来る。\n\n$$\n\\begin{aligned}\n\\int_\\Omega p(\\vec\\omega)d\\vec\\omega \u0026= k\\int_0^{2\\pi}\\int_0^{\\frac{\\pi}{2}}\\cos\\theta\\sin\\theta d\\theta d\\phi = k\\pi = 1 \\\\\np(\\vec\\omega) \u0026= \\frac{\\cos\\theta}{\\pi}\n\\end{aligned}\n$$\n\n確率密度関数について変数を変えると\n\n$$\n\\begin{aligned}\np(\\theta,\\phi) \u0026= p(\\vec\\omega)\\sin\\theta = \\frac{1}{\\pi}\\sin\\theta\\cos\\theta \\\\\np(\\theta) \u0026= \\int_0^{2\\pi}p(\\theta, \\phi)d\\phi = \\sin{2\\theta} \\\\\np(\\phi\\mid\\theta) \u0026= \\frac{p(\\theta,\\phi)}{p(\\theta)} = \\frac{1}{2\\pi}\n\\end{aligned}\n$$\n\nこの累積分布関数の逆関数は\n\n$$\n\\begin{aligned}\nP(\\theta) \u0026= \\int_0^\\theta p(t)dt = \\frac{1-\\cos{2\\theta}}{2} \u0026 P_\\theta^{-1}(u) \u0026= \\frac{1}{2}\\cos^{-1}(1-2u) \\\\\nP(\\phi\\mid\\theta) \u0026= \\int_0^\\phi p(\\phi\\mid\\theta)dt = \\frac{\\phi}{2\\pi} \u0026 P_\\phi^{-1}(v) \u0026= 2\\pi v\n\\end{aligned}\n$$\n\nとなるので $\\theta, \\phi$ のサンプルは乱数 $u, v$ を用いて次のように計算すればよい。\n\n$$\n\\begin{dcases}\n\\theta = \\frac{1}{2}\\cos^{-1}(1-2u) \\\\\n\\phi = 2\\pi v\n\\end{dcases}\n$$\n\nちなみに極座標系から直交座標系に戻すには以下の式に代入すればよい。\n\n$$\n\\begin{dcases}\nx = \\sin\\theta\\cos\\phi \\\\\ny = \\cos\\theta \\\\\nz = \\sin\\theta\\sin\\phi\n\\end{dcases}\n$$\n\n### 完全鏡面反射モデル\n反射についての関係式は次のようになる。\n\n$$\n\\vec\\omega_i = -\\vec\\omega_o + 2(\\vec\\omega_o\\cdot\\vec n)\\vec n\n$$\n\nこれよりBRDFは次のようになる。$\\vec\\omega_r$ を $\\vec\\omega_o$ の反射方向とする。\n\n$$\nf_{Specular}(x,\\vec\\omega_i,\\vec\\omega_o) = \\frac{\\delta(\\vec\\omega_i-\\vec\\omega_r)}{\\cos\\theta}\n$$\n\nサンプルは反射方向を返せばよい。\n\n### ガラスモデル\nガラスに入射した光は反射と屈折をする。反射は上記の式を用いればよい。屈折方向 $\\vec\\omega_r$ は次のように計算する。入射側屈折率 $n_1$ 出射側屈折率 $n_2$ と入射光線が法線となす角度 $\\theta$ として\n\n$$\n\\begin{aligned}\n\\vec\\omega_r \u0026= \\frac{n_1}{n_2}(-\\vec\\omega_i+\\cos\\theta\\vec n)-\\sqrt{1-\\alpha^2}\\vec n \\\\\n\\alpha \u0026= \\frac{n_1}{n_2}\\sin\\theta\n\\end{aligned}\n$$\n\nこのBRDFは次のようになる。\n\n$$\nf_{Refract}(x,\\vec\\omega_i,\\vec\\omega_o) = (1-f)\\frac{\\delta(\\vec\\omega_i-\\vec\\omega_r)}{\\cos\\theta}\n$$\n\nまた屈折時には輝度も変化する。\n\n$$\nL_r = \\left(\\frac{n_1}{n_2}\\right)^2L\n$$\n\nまた、反射/屈折の割合はフレネルの式(Fresnel Equation) で表現される。それは複雑な式であるので通常それを近似したSchlickの近似式が使われる。\n\n$$\n\\begin{aligned}\nF_r(\\theta) \u0026= F_o + (1 - F_o)(1 - \\cos\\theta)^5 \\\\\nF_o \u0026= \\left(\\frac{n_1-n_2}{n_1+n_2}\\right)^2\n\\end{aligned}\n$$\n\n反射・屈折の割合は乱数を用いて振り分ければよい。\n\n### 光モデル\n発光については全ての方向に同じ強さの放射輝度の光を返せばよい。\n空についても同様に地平線に近ければ白く、天井に近くなれば青いように返せばよい。\nまた IBL (Image Based Lighting) を用いれば輝度を保持する HDR 画像を用いて周囲を画像で表現できる。[sIBL Archive (hdrlabs.com)](http://www.hdrlabs.com/sibl/archive.html) を使うとよい。\n\n## その他\n### Next Event Estimation (NEE)\n光源が少ない場所ではノイズが多く出やすい。そこで光源上の点をサンプリングしてその方向にレイを飛ばすことで光源が小さい場合でも寄与を加算しやすくできる。\n\n### Bounding Volume Hierarchy (BVH)\n複数の物体全体を囲むバウンディングボリュームを再帰的に作り、それぞれのレイヤーで衝突判定を行うことで衝突の探索を $O(n)$ から $O(\\log n)$ に改善させる方法。\n\n### 双方向パストレーシング\nレイを飛ばすだけではなく、光源からシーンに向けても光を追跡する方法。\n\n### メトロポリス光輸送\n\n### フォトンマッピング\n\n## 参考\nPhotorealism yumcyawiz","lastmodified":"2022-12-30T07:57:21.483263743Z","tags":null},"/other/Rendering/Rendering":{"title":"Rendering Engine","content":"\n\nDirectX\nVulkan\n\n- [Generative art by Anders Hoff · inconvergent](https://inconvergent.net/#writing)\n\nRenderingNG\nWebGPU\n\n- [API reference · sitRyo/DungeonTemplateLibraryUnity Wiki (github.com)](https://github.com/sitRyo/DungeonTemplateLibraryUnity/wiki/API-reference)","lastmodified":"2022-12-30T07:57:21.483263743Z","tags":null},"/other/Rendering/Shader":{"title":"シェーダー","content":"\nシェーダ言語\nGLSL\n\nつぶやきGLSL","lastmodified":"2022-12-30T07:57:21.483263743Z","tags":null},"/other/Rendering/Vulkan":{"title":"","content":"","lastmodified":"2022-12-30T07:57:21.483263743Z","tags":null},"/other/Rendering/voice":{"title":"","content":"\nHRTF; Head-related transfer function\nHRIR\nOpenAL-soft\nSiv3D\n- soloud","lastmodified":"2022-12-30T07:57:21.483263743Z","tags":null},"/other/SAT-SMT/ProofAssistant":{"title":"定理証明支援系","content":"\n## 説明\n\n\n## 計算量\n\n\n## 実装\n\n\n## 使用例\n\n\n## 参考\n[一人Computer Science Advent Calendar 2017](https://qiita.com/advent-calendar/2017/myuon_myon_cs)\n","lastmodified":"2022-12-30T07:57:21.483263743Z","tags":null},"/other/SAT-SMT/SAT-SMT":{"title":"SAT SMT","content":"\n## SAT\nSAT (SATisfiability Problem)\nSATを解くには指数時間掛かると信じられている. 指数時間の中でも高速化していく技術を学ぶ.\n\n$((a\\land\\lnot b\\land\\lnot c)\\lor(b\\land c\\land\\lnot d))\\land(\\lnot b\\lor\\lnot c) \\to (a,b,c,d)=(t,f,f,t)$\n\n### 単純な探索\nまずは SAT に関する全探索を考える. 以下の方法は DPLL (Davis Putnam Logemann Loveland) アルゴリズムと呼ばれている.\nリテラルが1つしかない節を単位節と呼ぶ.\n\n1. 単位節があればその変数の値は確定する.\n2. それがなければ変数のどれか1つを深さ優先探索する.\n3. コンフリクトしたなら失敗, コンフリクトなしに変数を全て割り当てられたら成功とする.\n\nこのとき深さ優先探索での深さが $d$ のときをレベル $d$ と呼ぶ.\n\n$$\n\\begin{aligned}\n\\phi \u0026= (a ∨ ¬b ∨ d) ∧ (a ∨ ¬b ∨ e) \\\\\n\u0026∧ (¬b ∨ ¬d ∨ ¬e) \\\\\n\u0026∧ (a ∨ b ∨ c ∨ d) ∧ (a ∨ b ∨ c ∨ ¬d) \\\\\n\u0026∧ (a ∨ b ∨ ¬c ∨ e) ∧ (a ∨ b ∨ ¬c ∨ ¬e)\n\\end{aligned}\n$$\nミュンヘン工科大学の資料より\n\n### 節学習\n\nDPLL に加え, コンフリクトしたときにその探索状態だと失敗することを条件に入れる.\nCDCL (Constrait-Driven Clause Learning) アルゴリズム\n\n| $t$ | $L_t$       | level | reason                                       |\n| --- | ----------- | ----- | -------------------------------------------- |\n| 0   | $\\lnot x_1$ | 0     | $\\lbrace\\lnot x_1\\rbrace$                    |\n| 1   | $x_2$       | 1     | $\\Lambda$                                    |\n| 2   | $\\lnot x_5$ | 1     | $\\lbrace \\lnot x_2,\\lnot x_5\\rbrace$         |\n| 3   | $\\lnot x_3$ | 2     | $\\Lambda$                                    |\n| 4   | $x_4$       | 2     | $\\lbrace x_1,x_3,x_4\\rbrace$                 |\n| 5   | $x_6$       | 2     | $\\lbrace x_1,\\lnot x_2,\\lnot x_4,x_6\\rbrace$ |\n| 6   | $\\lnot x_6$ | 2     | $\\lbrace x_3,\\lnot x_4,x_5,\\lnot x_6\\rbrace$ |\nミュンヘン工科大学の資料より\n\nここで $t$ が 0 から 3 までの条件 $\\lnot x_1\\land x_2\\land\\lnot x_5\\land\\lnot x_3$ のときコンフリクトすることが分かる. するとその否定 $x_1\\lor\\lnot x_2\\lor x_5\\lor x_3 = \\lbrace x_1,\\lnot x_2,x_5,x_3\\rbrace$ は必ず成立しなければならない為, 新たに条件として入れることができる.\n\n[疑問] このときなぜ $\\lnot x_4$ を入れてはいけないのかよくわからない. 資料には $x_6$ に依存しているからと書かれているが $\\lbrace x_1,x_3,x_4\\rbrace$ は $x_1, x_3$ によって決定されるので関係なさそう(入れた方が条件が弱くなるのは確かにそうだけれども, もし全てのリテラルがfalseでも $\\lbrace x_1,x_3,x_4\\rbrace$ とコンフリクトするので大丈夫そう). たぶん節内のリテラルを出来る限り少なくして探索時に有用に扱いたいんだと思う.\n\nそして条件が多くなればなるほど探索をしなくて済むので高速化出来る.\n\n### 実装\n効率的なCDCLの実装方法を学ぶ.\n\n節は $x_k$ と $\\lnot x_k$ は $2k$, $2k+1$ と表す. 合計で $2n$ ビット必要になる.\n各節はリテラルのポインタを格納するリンクリストを持つ\n次に探索する変数の優先順位を表すアクティビティスコアを持つ\nアクティビティスコアはコンフリクト時に各変数のそれに足されるものである. i回目のコンフリクト時には $\\rho^{-i}$ 足される. (ex. $\\rho=0.95$) 後の方になればなるほど増加するスピードが速くなり, 古いコンフリクトは無視されるようになる.\n\n殆どのSATソルバは連言標準形(CNF)を入力として受け取る.\n任意の命題論理式をCNFに変換する為のアルゴリズム(Tseitin Encoding)\nCNFの入力形式 DIMACS\n\n### Tseitin Encoding\n$$\n\\begin{aligned}\n\\phi\u0026\\coloneqq((p\\lor q)\\land r)\\to(\\lnot s) \\\\\nx_1\u0026\\leftrightarrow\\lnot s \\\\\nx_2\u0026\\leftrightarrow p\\lor q \\\\\nx_3\u0026\\leftrightarrow x_2\\land r \\\\\nx_4\u0026\\leftrightarrow x_3\\to x_1 \\\\\nT(\\phi)\u0026\\coloneqq x_4\\land(x_4\\leftrightarrow x_3\\to x_1)\\land(x_3\\leftrightarrow x_2\\land r)\\land(x_2\\leftrightarrow p\\lor q)\\land(x_1\\leftrightarrow\\lnot s) \\\\\nx_2\\leftrightarrow p\\lor q \u0026= (x_2\\to(p\\lor q))\\land((p\\lor q)\\to x_2) \\\\\n\u0026= (\\lnot x_2\\lor p\\lor q)\\land(\\lnot(p\\lor q)\\lor x_2) \\\\\n\u0026= (\\lnot x_2\\lor p\\lor q)\\land((\\lnot p\\land \\lnot q)\\lor x_2) \\\\\n\u0026= (\\lnot x_2\\lor p\\lor q)\\land(\\lnot p\\lor x_2)\\land(\\lnot q\\lor x_2) \\\\\n\\end{aligned}\n$$\n\n### Tableaux\nSAT において恒真命題, 矛盾命題について考える\n1955年に Evert William Beth によって提案, Raymond Smullyan が analytic tableau へ発展させた。\n**Tableauxの基礎** \n**Propositional Tableaux** \n**First-Order Tableaux** \n\n### Resolution\n定理\n\n## SMT\nSMT ソルバ全般\n- [SAT/SMTソルバの仕組み](https://www.slideshare.net/sakai/satsmt)\n- [ミュンヘン工科大学の夏学期の自動推論に関する授業](https://www21.in.tum.de/teaching/sar/SS20/)\n\nSAT/SMTソルバのサーベイ論文\n- [SATソルバ・SMTソルバの技術と応用](https://www.jstage.jst.go.jp/article/jssst/27/3/27_3_3_24/_pdf)\n- [A Survey of Satisfiability Modulo Theory](https://arxiv.org/abs/1606.04786)\n形式手法\n- モデル検査\n- 定理証明支援系\nSMT (Satisfiability Modulo Theories)\nEUF (Equality Logic With Uninterpreted Functions)\n\nFOL (First-Order Logic)\nHOL (Higher-Order Logic)\n\n### Bit Vectors\n\n### DPLL(T)\n\n### 実装\n\n\nSMTソルバの入力形式 SMT-LIBv2\n- [The SMT-LIBv2 Language and Tools: A Tutorial](http://smtlib.github.io/jSMTLIB/SMTLIBTutorial.pdf)\np20. SMT-LIBv2 の token が表になって並んでおり、どのような正規表現でマッチさせられるか掲載している\n- [SMT-LIB The Satisfiability Modulo Theories Library](http://smtlib.cs.uiowa.edu/)\nSMT ソルバに与える入力の形式 SMT-LIB v2 についてまとまっている Web サイト\n- [SMT-LIB-benchmarks / QF_UF · GitLab (uiowa.edu)](https://clc-gitlab.cs.uiowa.edu:2443/SMT-LIB-benchmarks/QF_UF)\nQF_UF のベンチマーク用入力が大量に用意されている\n","lastmodified":"2022-12-30T07:57:21.483263743Z","tags":null},"/other/SAT-SMT/SymbolicExecution":{"title":"シンボリック実行エンジン","content":"\n## 説明\n\nプログラム上で目的の地点に到達したいとき、それに当てはまるような入力値の条件を数学的に解くプログラム。条件分岐ごとに条件式を追加してそれをSMTソルバに解かせる。\n\nConcolic Execution\nSSA形式とCFGが対応する\nTaint 解析\n\n## 計算量\n\n条件分岐数を $N$ として $O(2^N)$\n\n## 実装\n\nレジスタ, メモリに関する制約とSSA形式のIRを条件式としてSMTソルバで解く。\n- [Rustでの実装 (mini_symbolic)](https://github.com/anko9801/mini_symbolic)\n\n## 使用例\n\nシンボリック実行エンジンのプロジェクト angr のサンプルコード。\n\n```python\nimport angr\nimport logging\n\nbinary_path = './chall'\n\ntarget = angr.Project(binary_path, main_opts={'base_addr': 0x10000})\nlogging.getLogger('angr').setLevel(logging.CRITICAL)\nentry_state = target.factory.entry_state()\nsimulation = target.factory.simulation_manager(entry_state)\nsimulation.explore(find=0x000115b1, avoid=0x000115c4)\nfor sf in simulation.found:\n    print(sf.posix.dumps(0))\n\nsolution - simulation.found[0].posix.dumps(0)\nprint(solution)\n```\n\n## 参考\n\n- [バイナリ萌えの彼女がシンボリック実行に恋着してますが、制約に挑む幼気な表情が最高です！（１）](https://speakerdeck.com/katc/bainarimeng-efalsebi-nu-gasinboritukushi-xing-nilian-zhao-sitemasuga-zhi-yue-nitiao-muyou-qi-nabiao-qing-gazui-gao-desu-1)\n- [Girls Meets Symbolic Execution: Assertion 2. Automated Exploit Generation](https://speakerdeck.com/katc/girls-meets-symbolic-execution-assertion-2-automated-exploit-generation)\n- [実装して学ぶ Symbolic Backward Execution](https://speakerdeck.com/katc/shi-zhuang-sitexue-bu-symbolic-backward-execution-aceefce8-d25e-4db0-8ebb-d648bb2c41cd)\n- [プログラム解析入門、もしくはC/C++を安全に書くのが難しすぎる話 - Google スライド](https://docs.google.com/presentation/d/1WHmCLeC5ZPiq2MBOQaZc-pNVWaJanx8eXAkViGl2zws/edit#slide=id.g135752f5899_0_673)\n","lastmodified":"2022-12-30T07:57:21.483263743Z","tags":null},"/other/Server/Cloud":{"title":"Cloud","content":"\nAWS\n- [7777 - Your remote AWS database on your local port 7777](https://port7777.com/)\n- [Scanning for AWS Security Issues With Trivy | liamg](https://lia.mg/posts/trivy-aws/)\nGAS\n- [google/clasp: 🔗 Command Line Apps Script Projects (github.com)](https://github.com/google/clasp)\n","lastmodified":"2022-12-30T07:57:21.483263743Z","tags":null},"/other/Server/Monitor":{"title":"","content":"\n## Prometheus\n\n\n## Grafana\nビューワー\nサーバー上でgrafanaを立ててCaddyで外から見れるようにする\ndocker-composeに入れればいい\n```\n{{ grafana.host }} {\n  reverse_proxy localhost:3000\n}\n```\n\n## ログ可視化\nログ保存、集計しメトリクスにする\n- #Loki\n\n## ログ転送\n- Promtail\n- Fluentd\n- Fluent Bit\n\n## Alertmanager\nSlackにアラートを飛ばす\ndocker-compose に入れればいい\n\n## node_exporter\n\n## Continuous profiling\nphlare","lastmodified":"2022-12-30T07:57:21.483263743Z","tags":null},"/other/Server/RDBMS":{"title":"RDBMS","content":"\n### データベースとは\n- [B-Tree/B+Tree](https://qiita.com/kiyodori/items/f66a545a47dc59dd8839)LSMツリーと呼ばれる平衡N分木で構築されたデータの集合。メモリ/実行時間最適化、排他制御をよしなにやってくれます。\n- やり取りに人間がわかりやすい言葉`DDL(Data Definition Language) DML(Data Manipulation Language) DCL(Data Control Language)`を使ってDBを操作します。例えば`Structured Query Language(SQL)`などがあります。\n- データベースシステムとSQLはごっちゃにして言われやすいので注意。例えば、MariaDBはMySQLから派生した`Relational Database Management System(RDBMS)`の一種だとか、`Not only SQL(NoSQL)`はクラウドのDBに対してネットワーク伝送コストを避けて最適化された非RDBMSで、MongoDBやAWSのDynamoDB, Redisがそれに含まるなど。\n\n### 具体的にどんな処理がされているのか\n\n工事中\n:::spoiler\nhttps://zenn.dev/tzkoba/articles/bb6d31d46be8b3\n\n\nコネクションプール\nクエリパーサ\nクエリーキャッシュ\nクエリプランナー\nクエリエクスキュータ\nアクセスメソッド\nバッファプールマネージャ = ストレージエンジン?\nディスクマネージャ\n\n[実行順序](https://qiita.com/k_0120/items/a27ea1fc3b9bddc77fa1)\nFROM句\nJOIN句\nWHERE句\nGROUP BY句\nHAVING句\nSELECT句\nORDER BY句\nLIMIT句\n\n\nアクセスメソッドCRUD\n\nmemcached\nRedis\n\nレプリケーション\n\nテンポラリーテーブル\n\nクラッシュリカバリ\nRedundant Array of Independent Disks\nRAID 0・RAID 1・RAID 5、およびこれら3方式の組み合わせが用いられている。後にRAID 5を拡張したRAID 6が定義され、RAID 5より耐障害性が必要な場面で利用されている。\n二重書き込みバッファー\nトランザクションログ\n\nクラスタデータベース\nセカンダリインデックス\nキー　セカンダリキー　バリュー　プライマリーキー\nクラスタードインデックス\nテーブルをB+Treeに入れる\n\nMemcomparable format\n\n[ProxySQL](https://qiita.com/yoan/items/ba62dd65b24ac1b6a458)\n\nシリアル　数字の羅列\nシーケンス　順番に並ぶ数字列\n\n負荷分散技術\n水平分割(シャーディング)　レコード単位で分割\n垂直分割　カラム単位で分割\n\nワークラウンド　回避策\nワークロード　仕事量\n\nストレージエンジン\nデータ変換\nインデックス\nメモリ利用\nトランザクション\n同時実行性(排他制御)\nユニークファンクション（MyISAMの空間情報インデックスなど）\ninnoDB : MySQLでもっとも汎用のストレージエンジン\n\nACID\nA: 原子性\nC: 一貫性\nI: 分離性\nD: 持続性\n\nMySQL InnoDB memcached Plugin\nhttps://qiita.com/hypermkt/items/ccfb47e69c4a6a3ce09a\nプラグインって何のプラグイン？\nこれってmemcachedと何が違うの\n\n\nMEMORY ストレージエンジン\nhttps://dev.mysql.com/doc/refman/5.6/ja/memory-storage-engine.html\nストレージエンジンをMEMORYにするのはかなり注意が必要(NaruseJunがそれでメモリ使い果たして鯖爆破していたはず)\n\nINVISIBLE COLUMNS \\*でとりだされない\nINSERT RETURNING\nFOREIGN KEY https://www.dbonline.jp/mysql/table/index11.html\n:::\n\n### Collation(照合順序)\n文字列をどうエンコーディングしてB+ツリーにどうソートして突っ込むかを設定できます。DB単位、テーブル単位、カラム単位で設定可能。\n\n```\nCREATE TABLE `utf8mb4_test`.`utf8mb4_test` (\n  `id` int(10) NOT NULL AUTO_INCREMENT,\n  `str` varchar(1000) COLLATE utf8mb4_bin NOT NULL,\n  PRIMARY KEY (`id`),\n  KEY `str` (`str`(767))\n) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_bin;\n```\n`文字コード_言語名_比較法`\n\n#### 文字コード(Character Set)\nutf8とかeucとかが入ります。\ncp932やbig5などは危険なエンコーディングらしい(しらんけど)\n\nconoHaがこれでやらかしていたらしい\ntraP SysAd TechBook より\nデータベースメンテナンスで⼤わらわ！\n\n2019年8⽉6⽇夜 ConoHaのマネージドDBでメンテナンスがありました。SysAd班で\nはメンテナンスの存在を知らず、急にtraQなどが機能しなくなったため⼀瞬混乱が起き\nました。しかしその後すぐ、@takashi_trapがメンテナンスであることをアナウンスし混乱\nは収束しました。\nしかし、本当の混乱はメンテナンス後に発⽣したのです。traQの復旧によりメンバー\nがtraQに戻ってきたのですが、下のような投稿がいろんなチャンネルで出始めたので\nす。\n図2.6: 表⽰名が壊れたメンバーの投稿（修正後スクリーンショットを撮った）\nその後すべてのサービスのデータを確認してみると、すべてのサービスで⼀部の絵⽂\n字データが破損していることが確認されました。班内で検討したところ、おそらく「寿司ビ\nール問題」として有名な、utf8mb4のデータをutf8として扱ってしまったことによる4バイト\n⽂字の破損であるだろうという結論に⾄りました。\nConoHaに問い合わせてみましたが、私達の推測通りメンテナンスではマシンの⼊れ\n替えのためにデータのバックアップを⾏なっており、その際にutf8でバックアップを取っ\nたとのこと。ConoHa側が持っている完全なバックアップは2⽉時点のものでそれ以降の\nデータを復旧することは不可能であると回答がありました*3。外部に公開されている\nBlogサービスのみ、たまたま2週間ほど前にBlogサービスのバージョンアップ検証を⾏\nうために取っていたバックアップから差分を復旧することで対処しました。\nまさかこんなことってあるんですねぇ……となった事件でした\n\n#### 言語名\njapaneseやthaiやgeneral、unicodeなどが入ります。\ngeneralやunicodeはマルチリンガルの事(utf8にjapaneseはない)。\n\n#### 比較法\n`_ci _cs _bin`のいずれか(で終わる)\n\n\\_ci: 大文字と小文字が区別されない\n\\_cs: 大文字と小文字が区別される\n\\_bin: バイナリ\n\n#### utf8_general_ciとutf8_unicode_ciの使い分け\nunicode の方はあいまいな照合が可能です。全角、半角、大文字、小文字を無視して一致するものを検索できます。\n\nたとえば、検索文字に`MySQL`を指定した時と、`ｍｙｓｑｌ`を指定した時の検索結果は同じになります。\n\ngeneral の方はその逆で、厳密に違いとして認識され先の例の検索結果は異なります。\n\nどちらも項目の用途によって使い分けるのが、あるべき姿なのでは無いかと思います。\n\n`utf8mb4_bin`のが`utf8mb4_general_ci`より少しはやいらしい https://yakst.com/ja/posts/5431\nMySQL8なら`utf8mb4_0900_bin`を試してみる https://qiita.com/hmatsu47/items/d66830c8a00c21f5edad\n\n\n### トランザクション\nINSERT, UPDATE文を複数送るとき、その一部だけがデータベースに反映されると、一時的にせよ、データベース全体としてデータが不整合な状態となります。トランザクションを使うことでそれらを同時に実行させられます。\n\nBEGINから始まりCOMMIT/ROLLBACKで終わる。\n\nWAL(Write Ahead Logging)\n\nTODO: FOR UPDATEとの違い\nFOR UPDATE（先行して行ロックを獲得したトランザクションがロックを開放する/ロックがタイムアウトするまで待たされる）\nNOWAIT（ロックが獲得できなかったときは即時にエラーを返す）\nSKIP LOCKED（即時に獲得可能なロックのみ獲得して結果を返す）\nhttps://www.informit.com/articles/article.aspx?p=29312\n- [ネストさせたいときはSAVEPOINT](https://qiita.com/_natsu_no_yuki_/items/e1db2a132cbff740896d)\n\n| BEGIN文  | SAVEPOINT文                |\n| -------- | -------------------------- |\n| BEGIN    | SAVEPOINT hoge             |\n| COMMIT   | RELEASE SAVEPOINT hoge     |\n| ROLLBACK | ROLLBACK TO SAVEPOINT hoge |\n\n```go\ntx, err := db.Begin()\nif err != nil {\n\tlog.Println(err)\n}\n\n_, err = tx.Exec(\"INSERT INTO test_user(name) VALUES(?)\", \"TRANS\")\nif err != nil {\n\tlog.Println(err)\n}\n\n// run something\n\nif err != nil {\n    // もとの状態に戻す\n    err = tx.Rollback()\n\tif err != nil {\n\t\tlog.Println(err)\n\t}\n} else {\n    // クエリを実行する\n    err = tx.Commit()\n\tif err != nil {\n\t\tlog.Println(err)\n\t}\n}\n```\n\n### PreparedStatement\nINSERT文など値は違えど同じクエリを大量に実行したいとき毎回クエリを解析せず最初に1回解析すれば後はそれを使い回して高速化しようという機能です。(多分パースしてクエリプランナーに突っ込んだ状態にしてあるだけ)\n\n- Go標準のSQLパッケージはプレースホルダを用いたクエリは暗黙的にPreparedStatementを使っている\n- 同じクエリではないとき段階を踏む上でコストが掛かり遅くなる(ADMIN PREPAREが多くなる)\nそこで`interpolateParams=true`を使ってPreparedStatementを減らせる\nhttp://dsas.blog.klab.org/archives/52191467.html\n- トランザクション中にPreparedStatementするときは先にCloseしてCommitしないと不整合が起こる\n- クエリのプレースホルダーはSQLインジェクション対策にもなる。fmt.Sprintf()で作らないようにする。\n```go\n// interpolateParams=true\ndb, err := sql.Open(\"mysql\", \"root:password@tcp(localhost:3306)/test?interpolateParams=true\u0026collation=utf8mb4_bin\")\n// SQL文を受け取って解析し、値があればいつでも実行できる状態にする\nstmt, err := db.Prepare(query)\nif err != nil {\n    return\n}\n// PreparedStatementを関数の終わりで終了させる\ndefer stmt.Close()\n// SQL文に必要な値をセットして実行\nstmt.Exec(value)\n```\n\n### 生成カラム(generated column)\n\nhttps://qiita.com/hmatsu47/items/128ece7276e4deac1477\n他のカラムのデータを使って新しいカラムを作る\n- VIRTUAL トランザクションが入ったときにデータを生成する\n- STORED INSERTしたときにデータを生成する\n\nNOT NULLを用いれば制約に合わないものがきたらエラーを吐かせて、データに制約を作ることができる\nCHECKでやれって話\nhttps://yakst.com/ja/posts/2834\nVIRTUALのとき仮想列と呼びそれを使ったINDEXを仮想インデックスと呼ぶ\nこの設計において、仮想列は簡単に追加して削除することができ、かつテーブル全体をリビルドする必要もない。これにより関連するテーブルのスキーマ変更がとても簡単かつ高速になる。\n\n高速な仮想列の管理\n`mysql\u003e ALTER TABLE t ADD new_col INT GENERATED ALWAYS AS (a - b) VIRTUAL;`\n\n### メモリ最適化\n\nhttps://dev.mysql.com/doc/refman/5.6/ja/data-size.html\n`MEDIUMINT` `INT`の25%削減\n`NOT NULL` null確認の処理がなくなる\n\nできるだけ少なく\nhttps://phpjavascriptroom.com/?t=mysql\u0026p=columntype\n\n### キーキャッシュ\nMyISAM\nhttps://dev.mysql.com/doc/refman/5.6/ja/myisam-key-cache.html\nテーブルブロックとは？\n\nページングに注意すべきキャッシュ\nInnoDB バッファプール\nMyISAM キーキャッシュ\nMySQL クエリーキャッシュ\n\n頻繁な更新を実行するアプリケーションでは、多くの場合に少数のカラムのある多数のテーブルを使用し、大量のデータを解析するアプリケーションでは、多くの場合に多数のカラムのある少数のテーブルを使用します。\n\n正規形\n\nInnoDB は、ほとんどのデータまたはすべてのデータをメモリーに保持する汎用的で永続的な方法を提供\n\ntmpfs\nセッションとは？\n\n### ORM O/Rマッパー\n開発効率を上げる為のSQLのラッパー(クエリービルダー)\nex.) gorm\n[O/Rマッパーによるトラブルを未然に防ぐ (slideshare.net)](https://www.slideshare.net/kwatch/how-topreventorm-troubles)\n\n### isolation level\n複数のトランザクションが1つのテーブルを操作するときの不整合についてどの程度許容するか\n1. READ UNCOMMITTED ... COMMIT されてないトランザクションの変更を参照できる\n2. READ COMMITTED ... COMMIT されたトランザクションの変更を参照できる\n3. REPEATABLE READ ... COMMIT されたトランザクションの追加を参照できる\n4. SERIALIZE ... 参照不可\n\n2以降を実現する為には `SELECT` で共有ロック, `UPDATE` `INSERT` で専有ロックを取得すればよい. ロックの取得はパフォーマンスを下げるのでなるべくしたくない. そこでMVCC .\n\n### MultiVersion Concurrency Controll: MVCC\n\n- `DB_ROW_ID` ... 行ID\n- `DB_TRX_ID` ... 最後にupdateしたトランザクションID\n- `DB_ROLL_PTR` ... レコードの過去の値を持つundo log recordへのポインタ\n\n参照トランザクションIDが `DB_TRX_ID` より大きいなら変更後の値を参照, 小さいなら undo log record から探して参照, 追加したトランザクションIDより小さいなら参照できない.\n\n[MySQLのMVCC - Qiita](https://qiita.com/nkriskeeic/items/24b7714b749d38bba87b)\n\n### Conflict-free replicated data type\n\nCAPの定理\n-   Partition Tolerance: ネットワークが故障しても\n-   Consistency: データの整合性をもって\n-   Availability: 読書が常にできる\n\n3つ同時に満たすことはできなくて、満たせても2つまでという定理\n\nAPを満たす -\u003e Conflict-free replicated data type\n\n可換な操作のみ扱い、後でマージする -\u003e ネットワークに繋がっていなくても操作可能！\nそれぞれのDBがgitのブランチみたいな気持ち\n\n\n[Goにおける型によってSQLインジェクションを防ぐ方法 (zenn.dev)](https://zenn.dev/tenntenn/articles/b452911b4200ff#%E3%81%AF%E3%81%98%E3%82%81%E3%81%AB)","lastmodified":"2022-12-30T07:57:21.483263743Z","tags":null},"/other/Server/exploit":{"title":"Cloud に対する攻撃","content":"\n- [いもす研 (imos laboratory) (imoz.jp)](https://imoz.jp/note/onlinejudge.html)\n- [CTF Cloud 問題の攻撃手法まとめ(2021年版) - blog of morioka12 (hatenablog.com)](https://scgajge12.hatenablog.com/entry/ctf_cloud_2021)","lastmodified":"2022-12-30T07:57:21.483263743Z","tags":null},"/other/Server/frontend-optimization":{"title":"フロントエンド最適化","content":"\n## Web Performance\nlighthouse\n\n## 先読み/遅延読み込み\n[Resource Hints](https://www.w3.org/TR/resource-hints/)\n[Priority Hints](https://chromestatus.com/feature/5273474901737472)\nリソースの優先度をブラウザに認識させ、読み込み順序を最適化できます。初期画面に必要なリソースの読み込みが後方にある場合、その分LCPやFIDが遅延することになります。\nlink `rel=preload`\nscript `async/defer`\nimg/iframe `loading=\"lazy\"`\n\n## 配信削減\n### 圧縮\ngzip\nbrotli圧縮\n\n画像のリサイズ・クリッピング\nJPEG -\u003e Webp -\u003e AVIF\nGIF -\u003e WebM(VP9) -\u003e WebM(AV1)\n\nwebpack: production\nWebpackPlugin\nminifier\n- css-minimizer-webpack-plugin\n\n### CSS/JSのバンドルサイズを削る\n計測方法\n- [You might Not Need Lodash](https://youmightnotneed.com/lodash/)\ntailwind cssのpurge\n不要なwebfontのcssの削除\n\n## Cache\n`Cache-Control: public, max-age=604800, immutable`\nついでに動的な部分でも`Cache-Control`から`no-transform`を取り除きました。それと、`Connection: close`を取り除きました。\n\n## 配信距離\nCloudFlare\nキャッシュ\n\nTCP/IP スロースタート時のパケット数10\nステータスコード 1kB\n1.5kB * 10回 - 1kB = 14kB\n14kB以下なら高速\n[ウェブサイトのファイルサイズは14kB以下にすべきという指摘、その理由とは？ - GIGAZINE](https://gigazine.net/news/20220828-website-should-be-under-14kb/)","lastmodified":"2022-12-30T07:57:21.483263743Z","tags":null},"/other/Server/kernel-optimization":{"title":"","content":"## カーネルパラメータ チューニング\n\n[【Linux】カーネルパラメータのパフォーマンスチューニングについて](https://ac-as.net/kernel-parameter-performance-tuning/)\n\n### ファイルディスクリプタの上限\n\n`ulimit -l 10000`\n\nsshだとulimitできない\nhttps://yohei-a.hatenablog.jp/entry/20090310/1236706236\n\nhttp://ramblog.blog129.fc2.com/blog-category-4.html\n\n```\n# /etc/systemd/system/*.service\n[Service]\nLimitNOFILE=65535\n```\n### カーネルパラメータ\n\n上ほど優先順位高い(同じ名前のfileをoverrideする)\n`/etc/sysctl.d/*.conf`\n`/run/sysctl.d/*.conf`\n`/usr/lib/sysctl.d/*.conf`\nすべての設定ファイルは、どのディレクトリにあるかに関わらず、ファイル名の並び順で辞書順にソートされます。複数のファイルが同じオプションを指定している場合は、辞書的に最新の名前を持つファイルのエントリが優先されます。ファイルの順序を簡単にするために、すべてのファイル名の前に 2 桁の数字とダッシュを付けることをお勧めします。\n\n```\n# /etc/sysctl.d/100-isucon.conf\n# maxconnection を増やす\nnet.core.somaxconn = 32768                  # 32768 (2^15) くらいまで大きくしても良いかも。\nnet.ipv4.ip_local_port_range = 10000 60999  # port の範囲を広げる\n\n# tcp connection の再利用を有効化\nnet.ipv4.tcp_tw_reuse = 1\n\n# tcp connection が FIN-WAIT2 から TIME_WAIT に状態が変化するまでの時間\nnet.ipv4.tcp_fin_timeout = 10               # デフォルト 60。CPU 負荷を減らせるが、短すぎると危ういかも？\n\n# TIME_WAIT状態にある tcp connection 数の上限\nnet.ipv4.tcp_max_tw_buckets = 2000000       # デフォルトは 32768(=2^15) くらい\n\n# パケット受信時にキューにつなぐことのできるパケットの最大数\nnet.core.netdev_max_backlog = 8192          # デフォルトは 1000 くらい\n\n# 新規コネクション開始時のSYNパケットを受信した際の処理待ちキューの上限値\nnet.ipv4.tcp_max_syn_backlog = 1024         # デフォルトは 128 くらい\n\n# window size scalingの有効化(ネットワークの帯域幅とメモリ使用量のトレードオフ)\nnet.ipv4.tcp_window_scaling = 1             # デフォルトで1になっているはず\n# すべての種類のsocketに基本設定されているbufferのsize デフォルトは 212992(=13*2^14) くらい\nnet.core.rmem_default = 253952\nnet.core.wmem_default = 253952\nnet.core.rmem_max = 16777216\nnet.core.wmem_max = 16777216\n# TCP socket buffer sizeの変更 デフォルトは 212992(=13*2^14) くらい\nnet.ipv4.tcp_rmem = 253952 253952 16777216  # min / default / max\nnet.ipv4.tcp_wmem = 253952 253952 16777216  # min / default / max\n# TCP用に使用できる合計メモリサイズを指定\nnet.ipv4.tcp_mem = 185688 247584 371376     # min / pressure / max; pressureの値を超えるとTCP memory pressureの状態になり、以降ソケットは指定されたmin値のメモリバッファのサイズを持つようになる\n\n# カーネルレベルでのファイルディスクリプタ上限数変更\n# プロセス単位のチューニングをやったけど、こっちもやっておく\nfs.file-max=65535\n\n# 3-way-handshakeの簡略化\n# 相手側のサーバーがONにしていないとデータが2回送られてオーバーヘッドになるので一回やってみてスコアが上がらなかったら切る\nnet.ipv4.tcp_fastopen = 3\n\n# 輻輳制御アルゴリズム TCP BBR の有効化\n# `uname -r`が4.9以上で`sysctl net.ipv4.tcp_available_congestion_control`にbbrが含まれている場合　\n# net.ipv4.tcp_congestion_control = bbr # 輻輳制御アルゴリズムをbbrに\n# net.core.default_qdisc = fq # キューイングアルゴリズムをfqに\n```\n\nhttps://html5experts.jp/jxck/3529/\nhttps://ac-as.net/kernel-parameter-performance-tuning/\nφ(.. )ﾒﾓｼﾃｵｺｳ /proc/sys/net/ipv4/tcp_fastopenに設定する内容とか実装\nhttps://kernhack.hatenablog.com/entry/2013/05/25/115634\n\n","lastmodified":"2022-12-30T07:57:21.483263743Z","tags":null},"/other/Server/rdbms-optimization":{"title":"バックエンド最適化","content":"\n\nCache\n\nCopy on Write\n[An Overview of Query Optimization in Relational Systems 論文紹介 - Google スライド](https://docs.google.com/presentation/d/1ruGYLRLeagkfv1gQBlmh_di7AviaSx0MJih4oH24AsY/edit#slide=id.p)\n\nO/R Mapper\n\n# ISUCONメモ\n\nhttps://github.com/FujishigeTemma/isucon9-qualify/blob/master/go/main.go\nhttps://github.com/tohutohu/isucon9/blob/master/webapp/go/main.go\n\nhttps://www.youtube.com/watch?v=0DhBLswwcRs\n\nhttps://gist.github.com/941/8c64842b71995a2d448315e2594f62c2\nhttps://gist.github.com/south37/d4a5a8158f49e067237c17d13ecab12a\nhttps://isucon.net/archives/54822761.html\n\n## 事前講習\n\n工事中\n:::spoiler\nssh接続\nssh鍵\ngithubで公開リポジトリに置くと失格\nマニュアルを全員読む(情報をまとめることが得意な人がいたら)\n初期ベンチ\nベンチの振れ幅、挙動を調べる\n1コミット1ベンチ\nコミットコメントにログとか載せると良き\nキャッシュが必要以上に残るとフェイル\nタイムアウトか間違ったキャッシュならタイムアウトを取る\n\n変更するファイル\nwebapp/go\nwebapp/sql\n各種設定ファイル\nnginxやmysqlの設定などはgit内に移して元の場所にシンボリックリンクを貼る\n\n\n\n### 開始直後\n\nマニュアルを全員で読む\n- 点数に関わる記述が重要情報\n- キャッシュの許され方\n    - 「N秒キャッシュしてもよい」と書いてある\n\n不要なデーモンを止める\n```\ncat /proc/cpuinfo\nfree -h\nsystemctl list-units --type=service --state=running\n```\n\nssh configの設定\nベンチ1回目\nリポジトリ内にシンボリックリンクを置く\ngit init git remote git add . git commit -m \"Initial commit\"\nお昼食べる\n利用するサイトの動作確認\n忘れて無ければ全ページのスクショを撮る\nラストのチェックのときにCSSとかをざっと見る\n使いそうなファイル群を固めてローカルに持ってくる\ntar xvcf webapp\nscp user@ip:~/webapp.tar .\n更新箇所のチェック\nエンドポイントの数\n更新があるエンドポイント\nmysqlとnginxのログ設定\n解析ツールのインストール\nベンチ2回目\n秘伝のタレ\nベンチ3回目\n\n```\nINDEX idx_category_id_created_at (category_id,created_at),\nINDEX idx_created_at (created_at),\nINDEX idx_buyer_id (buyer_id),\nINDEX mul_idx_seller_id_created_at (seller_id, created_at)\n```\nhttps://github.com/reyu0722/piscon2021\n- ItemとかUserとかで取れる部分はキャッシュする -\u003e 71500\n- Item以外をメモリだけで管理するようにした (他にもいくつか) -\u003e 87840\n    - 超大変だった\n:::\n\n## 各種解析ツール 推測するな計測せよ\n\n### パフォーマンスモニタリング\nCPU占有率の高いプロセスを特定します\nhtop dstat\ndstat -tlamp\n\n### メトリクス\n高級なパフォーマンスモニタリングツール\n[netdata](https://github.com/netdata/netdata) NewRelic Splunk\nhttps://dev.classmethod.jp/articles/netdata/\n\n### アクセス解析\nパスパラメータ/クエリパラメータ別のアクセス数を表示してくれます\n主に見るべきはavg 次にcount\nkataribe **[alp](https://github.com/tkuchiki/alp)**\n\n### プロファイリング\n**pprof** fgprof\n\n### スロークエリ\nmysqldumpslow **pt-query-digest**\n\n### SQL全般\n**[percona tool kit](https://www.s-style.co.jp/products/percona/toolkit)**\n[mysqltuner](https://github.com/major/MySQLTuner-perl)\n\n### Makefile\nTODO: 秘伝のMakefileを作る\nhttps://gist.github.com/azonti/dee0547cb561dfdec4a90e093a418bdc\nhttps://github.com/FujishigeTemma/isucon10-final/blob/master/Makefile\nhttps://github.com/tohutohu/isucon9/blob/master/Makefile\nhttps://git.trap.jp/eiya/202008piscon/src/branch/master/go/Makefile\n\n## アプリ\n\n- クエリ最適化\n- 変更の少ないデータのキャッシュ化\n- やらなくてよい処理を省く\n- 強いセキュリティを弱くして高速化(gorilla/sessions-\u003e自前実装 net/http-\u003efasthttp bcrypt-\u003eSHA256など)\n- APIの並列化\n- FOR UPDATEアプリケーションで排他制御\n- gollira/sessionはセキュアなセッションをcookieだけで実現しているので、暗号化のコストが結構かかる -\u003e ランダムな値とmapを使った実装に差し替え\n- jsonのエンコード/デコードをgo-json\n\n### プロファイラの設定\n\n#### pprof https://github.com/google/pprof\n標準で入っているプロファイラです。デファクトスタンダードという感じ。\n```go\nimport _ 'net/http/pprof'\n\nfunc main() {\n    go func() {\n        http.ListenAndServe(\":6060\")\n    }()\n\n    // \u003ccode to profile\u003e\n}\n```\nプロファイリングした画像をdiscordやslackに届けるシェルです。\n```shell\ngo tool pprof -png -output pprof.png http://localhost:6060/debug/pprof/profile?seconds=60\ncurl -X POST -F img=@pprof.png $(DISCORD_WEBHOOK_URL)\nslackcat --channel general pprof.png\n```\n\n#### fgprof https://github.com/felixge/fgprof\n一部適切な表示とならないことがある\n```go\nimport (\n    \"net/http\"\n    _ \"net/http/pprof\"\n    \"github.com/felixge/fgprof\"\n)\n\nfunc main() {\n    http.DefaultServeMux.Handle(\"/debug/fgprof\", fgprof.Handler())\n    go func() {\n        log.Println(http.ListenAndServe(\":6060\", nil))\n    }()\n\n    // \u003ccode to profile\u003e\n}\n```\n\n`http://localhost:6060/debug/fgprof`\n\n## MySQL チューニング\n\n### MySQL設定\n\n別のサーバーからDBへアクセスできるようにする\n`/etc/mysql/mysql.conf.d/mysqld.cnf`\n`bind-address = 127.0.0.1`をコメントアウト\n`bind-address = 0.0.0.0`\n\nhttp://dsas.blog.klab.org/archives/50860867.html\n- グローバルバッファ mysqld全体でそのバッファが1つだけ確保されるもの\n- スレッドバッファ スレッド(コネクション)ごとに確保されるもの\nチューニングの際にはグローバル/スレッドの違いを意識するようにしましょう。 なぜなら、スレッドバッファに多くのメモリを割り当てると、コネクションが増えたとたんにアッという間にメモリ不足になってしまうからです。\n\n```\nmax_connections=1024\nquery_cache_type=ON\n# innoDB全体で一つ生成されるグローバルバッファ(別鯖なら搭載メモリの80%)\ninnodb_buffer_pool_size = 1GB\n# InnoDBの内部データなどを保持する足りないとエラーログが出るからその時増やす\n#innodb_additional_mem_pool_size = 30MB ←これあるとダメ\n# innoDBの更新ログを保持するメモリ\ninnodb_log_buffer_size = 16MB\n# innodb_log_fileがいっぱいになると、メモリ上のinnodb_buffer_poolの中の更新された部分のデータを、ディスク上のInnoDBのデータファイルに書き出すしくみになっているから\ninnodb_log_file_size = 128MB\n# ORDER BYやGROUP BYのときに使われるメモリ上の領域\ninnodb_sort_buffer_size = 4MB\nread_rnd_buffer_size = 2MB #\nkey_buffer_size = 256MB\n# 1に設定するとトランザクション単位でログを出力するが 2 を指定すると1秒間に1回ログを吐く。0だとログも1秒に1回。TODO違いをみる\ninnodb_flush_log_at_trx_commit = 0\ninnodb_flush_log_at_trx_commit = 2\n# データファイル、ログファイルの読み書き方式を指定する(実験する価値はある)\ninnodb_flush_method = O_DIRECT\n# 再起動試験対策\ninnodb_buffer_pool_dump_at_shutdown = ON\ninnodb_buffer_pool_load_at_startup = ON\n```\n\n```\n$ mysql -u isucari -p\npass: isucari\n$ sudo journalctl -u isucari.golang\nsudo rm /var/log/mysql/mysql-slow.log\nsudo systemctl restart mysql\nsudo rm /var/log/nginx/access.log\nsudo nginx -t\nsudo systemctl reload nginx\ncd ~/isucari/webapp/go\nmake\ncd -\nsudo systemctl restart isucari.golang\n```\n\n### スロークエリ\n\n`/etc/mysql/mysql.conf.d/mysqld.cnf`\n```bash\nslow_query_log=1\nslow_query_log_file=/var/log/mysql/mysql-slow.log\nlong_query_time=0 # 全てのクエリを書き込んで解析ツールに渡す\nlog_queries_not_using_indexes=1 # インデックスを使っていないクエリも出力する\n```\n`sudo mysqldumpslow -s t -t 10 /path/to/slow.log`\n`pt-query-digest /path/to/slow.log`\n\n複数のSQLクエリをIN、JOIN、LIMIT句、外部キーでまとめる(N+1問題など)\n不要なカラムやクエリを削除する\n転送量を減らす。取得するカラムを減らす、特にでかいもの(`VARCHAR(4096)`など)が入っているのは削るべき\nhttps://qiita.com/ikenji/items/b868877492fee60d85ce\n\n**INDEX**\nB+ツリーのインデックスを適切に設定することで検索速度を高める。二分探索ができるものなら速くなる。\n更に言えば上記のBツリーインデックスとハッシュインデックスが存在し、ハッシュインデックスの方が速いが、等価比較しかできない。MySQLは自動的にそれらの選択をしている。\nこれが多すぎるとINSERTでくそおもになるので注意\n\nここで役立つコマンド\n`mysql -uユーザ名 -pパスワード DB名 -e'EXPLAIN ~~;'`\n\nLIKEも最初の方がワイルドカードではなければ使える\n- 速くなるもの WHERE, ORDER BY, JOIN句\n- 効かないもの LIKE, OR, 演算, 関数処理, IS NULL, 否定形\n- NOT NULLを出来る限りつける\n- ORをUNION/UNION ALLに変換する\n- ORDER BYでDESCとASCの混合-\u003eMySQL 8.0では[降順インデックス](https://dev.mysql.com/doc/refman/8.0/ja/descending-indexes.html)で適用できる\n- [空間インデックス](https://dev.mysql.com/doc/refman/8.0/ja/creating-spatial-indexes.html) `SRID 0`を付ける https://matsuu.hatenablog.com/entry/2020/09/13/131145\n\nプレフィックスインデックス\n非常に長い文字列にインデックスを付ける必要がある場合、値全体ではなく最初の数文字にインデックスを付けることで、記憶域を節約し、パフォーマンスを改善することができます。\n- プレフィックスインデックスでは、選択性も低下するため、十分な選択性が得られる長さを持ち、記憶域を節約するくらい短いプレフィックスを選択すること\n- 欠点として、ORDER BY 句や GROUP BY 句を使用するクエリにプレフィックスインデックスを使用できない\n- 適切なサイズは、下記クエリで選択性を計測し、収束する値を見ることで発見できる。選択性とは、インデックス付けされた値の数と、テーブル内の行の合計数の比率のこと\n\nマルチインデックス\n[クエリ文がINDEX作成時のカラム順に基づいていないと、INDEXが使えない](https://qiita.com/rm-rf-slant/items/8023500788352646b6c2)\n- 等しい (=)、より大きい (\u003e)、より小さい (\u003c)、BETWEENなどの検索条件のWHERE句で使用されるか、結合に含まれる列を、先頭に配置する\n- クエリによるカラム順序の制限がない場合、最も選択的な列をインデックスの先頭に配置する。カラム毎の選択性は下記クエリで計測する\n- ちゃんと出来てないとEXPLAIN type=index:フルインデックススキャンと言われる\n1種類の値に対し多くのデータが存在するようなカラムを先に置く\n重複の多いものを先に置く\nそれに伴うようにクエリのカラムを先に置く\n\nhttps://lukesilvia.hatenablog.com/entry/20080315/1205583930\nUsing filesort\nレコードをソートして取り出す方法を決定するには、MySQL はパスを余分に実行しなくてはならないことを示す。 join type に従ってすべてのレコードをスキャンし、WHERE 条件に一致する全てのレコードに、ソートキー + 行ポインタを格納して、ソートは実行される。 その後キーがソートされる。 最後に、ソートされた順にレコードが取り出される。\n\nUsing temporary\nクエリの解決に MySQL で結果を保持するテンポラリテーブルの作成が必要であることを示す。これは一般に、GROUP BY を実行したカラムセットと異なるカラムセットに対して ORDER BY を実行した場合に発生する。\nUNIONとかも...？\n\nhttps://qiita.com/katsukii/items/3409e3c3c96580d37c2b\nhttps://nishinatoshiharu.com/overview-multicolumn-indexes/\n\nインデックスオンリースキャン\nSELECTするカラムが少ないときINDEXにそのカラムを置くとそれを取ってくるだけでよい\n\n### クエリーキャッシュ Qcache\n※注意 [MySQL 8.0以降には存在しない](https://yakst.com/ja/posts/4612)\nメモリ上にクエリのバイト列とその結果を保存して再度同じ(大文字・小文字を区別する)クエリが来たらDBを探さずそれを返す。更新がかかるとキャッシュがフラッシュされる。\nディスクI/Oの多発の解決\nINSERT,UPDATEが少なくSELECTが多いアプリに有効\n\n[MySQL クエリーキャッシュ 【チューニング方法とかも】](https://qiita.com/ryurock/items/9f561e486bfba4221747)\n\n***\n\nSQLで画像を入れるとAXと呼ばれるやつが入るらしい\nhttps://stackoverflow.com/questions/52426874/how-do-i-extract-microsoft-sql-varbinarymax-field-to-image-using-golang\n\n`キーキャッシュのヒット率 = 100 - ( key_reads / key_read_requests × 100 )`\nmysqlをmariadbに変える? (あまり必要はない)\n\n```shell\n$ curl -LsS https://downloads.mariadb.com/MariaDB/mariadb_repo_setup | sudo bash\n$ sudo apt install mariadb-server\n$ #このあと/etc/mysql/mysql.conf.d/mysqld.cnfに書いてたやつを/etc/mysql/mariadb.conf.d/50-server.cnfに書く\n```\n\n~~proxysqlを利用する？~~ ~~mariadbなら~~そのままquery cache使えばよさそう\n\nhttp://dsas.blog.klab.org/archives/50860867.html\n\n### 再起試験対策\n1台目サーバと2台目サーバの再起動タイミングがずれるとアプリからのDB接続に失敗\n`/etc/systemd/system/isuumo.go.service`\n```\n[Service]\nStartLimitBurst=999 # 失敗して再起動するのを何回行うか デフォルトは5\n```\n\n再起動試験用DB待ち\n```go\npackage main\n\nimport (\n\t\"database/sql\"\n\t\"log\"\n\t\"time\"\n)\n\n// main関数内に置く\nwaitDB(db)\ngo pollDB(db)\n\nfunc waitDB(db *sql.DB) {\n\tfor {\n\t\terr := db.Ping()\n\t\tif err == nil {\n\t\t\treturn\n\t\t}\n\n\t\tlog.Printf(\"Failed to ping DB: %s\", err)\n\t\tlog.Println(\"Retrying...\")\n\t\ttime.Sleep(time.Second)\n\t}\n}\n\nfunc pollDB(db *sql.DB) {\n\tfor {\n\t\terr := db.Ping()\n\t\tif err != nil {\n\t\t\tlog.Printf(\"Failed to ping DB: %s\", err)\n\t\t}\n\n\t\ttime.Sleep(time.Second)\n\t}\n}\n```\n***\n\n#### golang\n```golang\ndbx.SetMaxIdleConns(1024) // デフォルトだと2\ndbx.SetConnMaxLifetime(0) // 一応セット\ndbx.SetConnMaxIdleTime(0) // 一応セット go1.15以上\n\n// goroutineを生やしすぎてもタイムアウトする https://www.sambaiz.net/article/61/\n// Keep-AliveするとTCPコネクションを使い回し、名前解決やコネクション(3 way handshake)を毎回行わなくてよくなる\nhttp.DefaultTransport.(*http.Transport).MaxIdleConns = 0 // 無制限 デフォルトだと100\nhttp.DefaultTransport.(*http.Transport).MaxIdleConnsPerHost = 1024 // 0にすると2になっちゃう\nhttp.DefaultTransport.(*http.Transport).ForceAttemptHTTP2 = true // go1.13以上\nhttp.DefaultClient.Timeout = 5 * time.Second // 問題の切り分け用\n```\n\nhttps://qiita.com/go_sagawa/items/11929cd0883608a6888d\n\n- redis\n```\nsudo add-apt-repository ppa:chris-lea/redis-server\nsudo apt update\nsudo apt install redis\n```\n`sudo nano /etc/redis/redis.conf`\n`bind 127.0.0.1 ::1`のコメントアウト\n`protected-mode yes`→`protected-mode no`\n`requirepass hogehoge`に\n```\nsudo systemctl unmask redis-server\nsudo systemctl enable redis-server\nsudo systemctl restart redis-server\n```\n`sudo echo never \u003e /sys/kernel/mm/transparent_hugepage/enabled`\n`sudo nano rc.local`→追記: `echo never \u003e /sys/kernel/mm/transparent_hugepage/enabled`\n\n### JSON\nhttps://github.com/json-iterator/go を試してみる\n```golang\nvar json = jsoniter.Config{\n    EscapeHTML:                    false,\n    ObjectFieldMustBeSimpleString: true,\n}.Froze()\n```\nhttps://github.com/francoispqt/gojay\nhttps://github.com/goccy/go-json\nhttps://github.com/minio/simdjson-go\nMarshal / Encoder: goccy/go-json \u003e francoispqt/gojay\nUnmarshal: francoispqt/gojay \u003e goccy/go-json\nDecoder: francoispqt/gojay \u003e\u003e goccy/go-json\n\n- メモリ上にキャッシュ\n    - `map`\n        - 読み込み書き込みともに多く行う -\u003e `sync.Map`\n        - 読み込み多く行う -\u003e `sync.RWMutex` + `map`\n        - ロックが気になるならシャーディングをするとよい\n            - https://github.com/orcaman/concurrent-map\n            - https://github.com/FujishigeTemma/isucon9-qualify/compare/6eaa28f77cb8bac674c0b8cfbf9794d91999d026...49cede08c6fcf59afa29857559d146abb1e96165\n            - 15～20個ずつになるくらいがよさそう？\n    - sessionメモリに持つ\n        - `gorilla/sessions`はコピーのために`encoding/gob`が無駄に呼び出される\n- singleflight\n    - `x/sync/singleflight`\n    - `sync.Map` + `sync.Cond`\n        - https://github.com/FujishigeTemma/isucon9-qualify/compare/2fb8ff382ce2f7b083ae9f343e5ae5d543bc5e65...6d3f1ab77bd377be00fdf6d5735ffe14b8f5afd6\n    - `go-chi/httpcoala`\n        - https://github.com/FujishigeTemma/isucon9-qualify/commit/495ae7ba4732b3bcb9c4a6795bea86dfac060c6c\n- メモリ効率化\n    - `sync.Pool`\n        - https://github.com/FujishigeTemma/isucon9-qualify/commit/4e7a9be6cbee699dc11db96c2134836dfd207def\n- 挿入後の結果をとらずに返す\n    - timeはミリ秒を四捨五入すること`.Round`\n        - デフォルトが秒までだけど、`DATETIME`のあとに数字がある場合は異なるので要確認\n        - https://dev.mysql.com/doc/refman/5.6/ja/fractional-seconds.html\n- session\n    - 自前の`interface`の変換なしの実装\n        - https://github.com/FujishigeTemma/isucon9-qualify/commit/64d095a6400bbde6df4ed62d6ad9bd12dbc8a964\n- `pat.Param`\n    - 自前の`interface`の変換なしの実装\n        - https://github.com/FujishigeTemma/isucon9-qualify/compare/b87747c27f305927b40b86285b1642cbe52e1c55...68c236f9782f041bca64f185ae0a3fbec9122ee2\n- misc\n    - キーが100個程度までならmapよりarrayを線形探索したほうがよいらしい\n    - sliceもmapもcapacityを指定する\n    - `i, item := range items`をすると`item`にコピーが走るので`items[i]`を使う\n    - 画像を返してる箇所はキャッシュのヘッダーを設定する\n    - GOGC `400`～`1200`とか\n        - 有効にしたときは**毎回再起動すること**\n\n- [MySQL のパーティショニングで速くなる？ならない？問題、あらためて実験してみた](https://qiita.com/hmatsu47/items/354f979cde6ad91bcc6b)\n- カバリングインデックス\n\nhttp://akouryy.hatenablog.jp/entry/2020/09/13/130415\n\n- https://dev.mysql.com/doc/refman/5.6/ja/optimizing-innodb-bulk-data-loading.html\n\n#### MySQL8\n- NOWAIT, SKIP LOCKED: https://qiita.com/hmatsu47/items/7675b026e65762d2445f\n- HASH JOIN: https://qiita.com/hmatsu47/items/e473a3e566b910d61f5b\n- Multi-valued index(jsonカラム用): https://qiita.com/hmatsu47/items/3e49a473bc36aeefc706\n- GROUP BYをLATERALにする？: https://qiita.com/hmatsu47/items/040d65d118d0ecec6381\n\n\nパーティショニングとは\n\n## HTTP チューニング\n\nhttps://qiita.com/yumin/items/5de33b068ead564ebcbf\n\n[martini](https://github.com/go-martini/martini)\n[gin](https://github.com/gin-gonic/gin)\n\nfasthttp\nhttps://medium.com/eureka-engineering/net-http%E3%82%88%E3%82%8A10%E5%80%8D%E9%80%9F%E3%81%84valyala-fasthttp%E3%81%8C%E9%9D%A2%E7%99%BD%E3%81%9D%E3%81%86%E3%81%AA%E3%81%AE%E3%81%A7%E8%AA%BF%E6%9F%BB%E3%81%97%E3%81%A6%E3%81%BF%E3%81%9F%E4%BB%B6-a608fe197f1d\n\n\n### メモ\nhttps://github.com/cs3238-tsuzu/sqlx-selector\n\nhttp://nginx.org/en/docs/http/ngx_http_rewrite_module.html#if\nhttps://stackoverflow.com/questions/8591600/nginx-proxy-pass-based-on-whether-request-method-is-post-put-or-delete\n\n得点につながるエンドポイントの確認\n大量アクセスかつ同じものが使える→singleflight\n\nlockfree map","lastmodified":"2022-12-30T07:57:21.483263743Z","tags":null},"/other/Server/reverse-proxy":{"title":"リバースプロキシ","content":"\n\n## ロードバランサ\n\nOCSP stapling\n\n","lastmodified":"2022-12-30T07:57:21.483263743Z","tags":null},"/other/Server/reverse-proxy-optimization":{"title":"Nginx (リバースプロキシ)チューニング","content":"\n\n### サーバー分割\n**DB分ける**\n**リクエストのロードバランス**\nロードバランサー\nセッションパーシステンス\n\nworker_processesにそれぞれ均等にworker_connectionsが分配される訳ではないので余裕をもって設定すべき\nhttps://nrok81.hatenablog.com/entry/2014/11/12/191240\n\n```conf\nworker_processes  auto;  # コア数と同じ数まで増やすと良いかも\n\n# nginx worker の設定\nworker_rlimit_nofile  4096;\nevents {\n    worker_connections  1024;  # 128より大きくするなら、 5_os にしたがって max connection 数を増やす必要あり（デフォルトで`net.core.somaxconn` が 128 くらいで制限かけられてるので）。さらに大きくするなら worker_rlimit_nofile も大きくする（file descriptor数の制限を緩める)\n    # multi_accept on;         # error が出るリスクあり。defaultはoff。\n    # accept_mutex_delay 100ms;\n}\n\nhttp {\n    log_format main '$remote_addr - $remote_user [$time_local] \"$request\" $status $body_bytes_sent \"$http_referer\" \"$http_user_agent\" $request_time';   # kataribe 用の log format\n    access_log  /var/log/nginx/access.log  main;   # これはしばらく on にして、最後に off にすると良さそう。\n    # access_log  off;\n\n    # 基本設定\n    sendfile    on;\n    tcp_nopush  on;\n    tcp_nodelay on;\n    types_hash_max_size 2048;\n    server_tokens    off;\n    open_file_cache max=100 inactive=65s; # file descriptor のキャッシュ。入れた方が良い。 20s-\u003e65s\n\n    # proxy buffer の設定。白金動物園が設定してた。\n    proxy_buffers 100 32k;\n    proxy_buffer_size 8k;\n\n    # mime.type の設定\n    include       /etc/nginx/mime.types;\n\n    # Keepalive 設定\n    # ベンチマークとの相性次第ではkeepalive off;にしたほうがいい\n    # keepalive off;\n    # ベンチは1分しか回らない\n    keepalive_timeout 65;\n    keepalive_requests 500;\n\n    # Proxy cache 設定。使いどころがあれば。1mでkey8,000個。1gまでcache。\n    proxy_cache_path /var/cache/nginx/cache levels=1:2 keys_zone=zone1:1m max_size=1g inactive=1h;\n    proxy_temp_path  /var/cache/nginx/tmp;\n    # オリジンから来るCache-Controlを無視する必要があるなら。。。\n    #proxy_ignore_headers Cache-Control;\n\n\n    # unix domain socket 設定1\n    upstream app {\n        server unix:/run/unicorn.sock;  # systemd を使ってると `/tmp` 以下が使えない。appのディレクトリに`tmp`ディレクトリ作って配置する方がpermissionでハマらずに済んで良いかも。\n    }\n\n    # 複数serverへ proxy\n    upstream app {\n        server 192.100.0.1:5000 weight=2;  # weight をつけるとproxyする量を変更可能。defaultは1。多いほどたくさんrequestを振り分ける。\n        server 192.100.0.2:5000;\n        server 192.100.0.3:5000;\n        # keepalive 60;  # app server への connection を keepalive する。app が対応できるならした方が良い。\n    }\n\n    server {\n        # reverse proxy の 設定\n        location / {\n            proxy_pass http://localhost:3000;\n            # proxy_http_version 1.1;          # app server との connection を keepalive するなら追加\n            # proxy_set_header Connection \"\";  # app server との connection を keepalive するなら追加\n        }\n\n        # Unix domain socket の設定2。設定1と組み合わせて。\n        location / {\n            proxy_pass http://app;\n        }\n\n        # 簡易静的ファイルをNginx配信\n        location / {\n            root /home/user/app/public/;\n            try_files $uri $uri/ @app;\n        }\n        location @app {\n            proxy_pass http://app;\n        }\n\n        # For Server Sent Event\n        location /api/stream/rooms {\n            # \"magic trio\" making EventSource working through Nginx\n            proxy_http_version 1.1;\n            proxy_set_header Connection '';\n            chunked_transfer_encoding off;\n            # These are not an official way\n            # proxy_buffering off;\n            # proxy_cache off;\n            proxy_pass http://localhost:8080;\n        }\n\n        # For websocket\n        location /wsapp/ {\n            proxy_http_version 1.1;\n            proxy_set_header Upgrade $http_upgrade;\n            proxy_set_header Connection \"upgrade\";\n            proxy_pass http://wsbackend;\n        }\n\n        # Proxy cache\n        location /cached/ {\n            proxy_cache zone1;\n            # proxy_set_header X-Real-IP $remote_addr;\n            # proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;\n            # proxy_set_header Host $http_host;\n            proxy_pass http://localhost:9292/;\n            # デフォルトでは 200, 301, 302 だけキャッシュされる。proxy_cache_valid で増やせる。\n            # proxy_cache_valid 200 301 302 3s;\n            # cookie を key に含めることもできる。デフォルトは $scheme$proxy_host$request_uri;\n            # proxy_cache_key $proxy_host$request_uri$cookie_jessionid;\n            # レスポンスヘッダにキャッシュヒットしたかどうかを含める\n            add_header X-Nginx-Cache $upstream_cache_status;\n        }\n\n        # static file の配信用の root\n        root /home/isucon/webapp/public/;\n\n        location ~ .*\\.(htm|html|css|js|jpg|png|gif|ico) {\n            expires 24h;\n            add_header Cache-Control public;\n\n            open_file_cache max=100;  # file descriptor などを cache\n\n            gzip on;  # cpu 使うのでメリット・デメリット見極める必要あり。gzip_static 使えるなら事前にgzip圧縮した上でそちらを使う。\n            gzip_types text/html text/css application/javascript application/json font/woff font/ttf image/gif image/png image/jpeg image/svg+xml image/x-icon application/octet-stream;\n            gzip_disable \"msie6\";\n            gzip_static on;  # nginx configure時に --with-http_gzip_static_module 必要\n        }\n    }\n}\n```\n\n```\nuser www-data;\npid /run/nginx.pid;\ninclude /etc/nginx/modules-enabled/*.conf;\nworker_rlimit_nofile 100000;\n\nerror_log  /var/log/nginx/error.log error;\n\nhttp {\n    default_type  application/octet-stream;\n\n    client_max_body_size 10m;\n\n    # TLS configuration\n    ssl_protocols TLSv1.2;\n    ssl_prefer_server_ciphers on;\n    ssl_ciphers 'ECDHE-ECDSA-AES128-GCM-SHA256:ECDHE-RSA-AES128-GCM-SHA256:ECDHE-ECDSA-AES256-GCM-SHA384:ECDHE-RSA-AES256-GCM-SHA384:ECDHE-ECDSA-CHACHA20-POLY1305:ECDHE-RSA-CHACHA20-POLY1305:DHE-RSA-AES128-GCM-SHA256:DHE-RSA-AES256-GCM-SHA384';\n\n\tserver {\n\t    listen 443 ssl http2;\n\t    server_name isucon9.catatsuy.org;\n\n\t    ssl_certificate /etc/nginx/ssl/fullchain.pem;\n\t    ssl_certificate_key /etc/nginx/ssl/privkey.pem;\n\n\t\troot /home/isucon/isucari/webapp/public;\n\t\tlocation /static/ {\n\t\t\tadd_header Cache-Control \"public max-age=86400\";\n\t\t}\n\t\tlocation /upload/ {\n\t\t\tadd_header Cache-Control \"public max-age=86400\";\n\t\t}\n\n\t    location / {\n\t\tproxy_pass http://app;\n\t\tproxy_set_header Host $host;\n\t    }\n\t    location /login {\n\t\tproxy_pass http://login_app;\n\t\tproxy_set_header Host $host;\n\t    }\n\t}\n}\n```\n\n### 初期設定\nhttps://wiki.trap.jp/user/to-hutohu/memo/ISUCON%E3%83%81%E3%83%BC%E3%83%88%E3%82%B7%E3%83%BC%E3%83%88\n#### OS\n設定したら`sudo sysctl -p {{filename}}`で反映する\n実行中のプロセスには反映されないからプロセスの再起動が必要\n\n備考: `net.ipv4.ip_, net.ipv4.ip_local_portrange, net.ipv4.tcp, net.ipv4.icmp_*`はipv6にも適用される\n\n#### nginx\n`$ sudo cp *.conf *.conf.bk`\n`/etc/nginx/nginx.conf`\n`/etc/nginx/sites-enabled/*.conf` (ここでは`http`ブロック内しか変更できない)\n`/etc/nginx/sites-available/*.conf`に書いて↑ではエイリアスを貼るのが正解\nhttps://wiki.trap.jp/user/to-hutohu/memo/ISUCON%E3%83%81%E3%83%BC%E3%83%88%E3%82%B7%E3%83%BC%E3%83%88#head10\n\nnginxとアプリケーションの間をunix domain socket\n`Unix domain socket`は後回し\nhttps://qiita.com/ihsiek/items/11106ce7a13e09b61547#web%E3%82%B5%E3%83%BC%E3%83%90\n`index.html`を配信してるところをnginxで返すようにする\n```\n    # index.htmlの配信\n    location ~ ^/(?:login|register|timeline|categories|sell|items|buy/complete|transactions|users)(?!.*.(?:json|png)) {\n        try_files $uri /index.html;\n    }\n```\n\n```\nserver {\n    listen       80 default_server;\n    server_name  _;\n\n    location / {\n         root /home/isucon/torb/webapp/static/;\n         try_files $uri $uri/ @app;\n    }\n\n    location @app {\n        proxy_set_header Host $host;\n        proxy_pass   http://127.0.0.1:8080;\n    }\n}\n```\n```\n    proxy_buffer_size 128k;\n    proxy_buffers 32 128k;\n    proxy_busy_buffers_size 128k;\n```\n\nh2cの有効化(意味なさそうなのでhttpsを使ってhttp2を使うべき)\n```\nserver {\n    listen 80 http2;\n```\n\n#####\n設定\n```\nworker_processes auto;\nworker_rlimit_nofile 4096;\nevents {\n    worker_connections 1024; # net.core.somaxconnとworker_rlimit_nofileも大きくする\n    #multi_accept on; # error が出るリスクあり。defaultはoff\n    #accept_mutex_delay 100ms;\n}\n```\n\nnginx の worker_connections は worker 当たりの同時接続数だと思ってたけどどうも違うっぽい\nhttps://nrok81.hatenablog.com/entry/2014/11/12/191240\n\n##### ログ設定 httpディレクティブの中\n```\nlog_format main '$remote_addr - $remote_user [$time_local] \"$request\" $status $body_bytes_sent \"$http_referer\" \"$http_user_agent\" $request_time';\naccess_log /tmp/access.log main;\n#access_log off;\n```\n\n##### 基本設定 httpディレクティブの中\n```\nsendfile on;\ntcp_nopush on;\ntcp_nodelay on;\ntypes_hash_max_size 2048;\nserver_tokens off;\nopen_file_cache max=100 inactive=20s; # file descriptorのキャッシュ\n\n# proxy bufferの設定\nproxy_buffers 100 32k;\nproxy_buffer_size 8k;\n\n# keepaliveの設定\n#keepalive off; # ベンチマークとの相性次第ではoffにしたほうがいい\nkeepalive_timeout 120;\nkeepalive_requests 1048576;\n\n# proxy cacheの設定\nproxy_cache_path /var/cache/nginx/cache levels=1:2 keys_zone=zone1:1m max_size=1g inactive=1h;\nproxy_temp_path  /var/cache/nginx/tmp;\n#proxy_ignore_headers Cache-Control; # upstreamから来るCache-Controlを無視する必要があるなら\n```\n\n##### upstream設定 httpディレクティブの中\n```\nupstream app {\n    server 127.0.0.1:8000;\n\n    keepalive 256;\n}\n```\n\n##### reverse proxy設定 serverディレクティブの中\n```\nlocation /initialize {\n    proxy_http_version 1.1;\n    proxy_set_header Connection \"\";\n\n    proxy_read_timeout 120;\n\n    #proxy_cache zone1;\n\n    proxy_set_header Host $host;\n    proxy_set_header X-Real-IP $remote_addr;\n    proxy_set_header X-Forwarded-Proto $scheme;\n    proxy_set_header X-Forwarded-Host $host;\n    proxy_set_header X-Forwarded-Server $host;\n    proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;\n\n    proxy_pass http://app;\n}\n```\n\n##### 静的配信設定 serverディレクティブの中\n```\n# static file の配信用の root\nroot /home/isucon/webapp/public/;\n\nlocation ~ .*\\.(htm|html|css|js|eot|svg|ttf|woff|woff2|gif|jpg|png|ico) {\n    expires 24h;\n\n    gzip off;\n    #gzip on; # CPUを使うのでメリット・デメリット見極める必要あり。gzip_staticが使えるなら事前にgzip圧縮した上でそちらを使う\n    #gzip_types *;\n    #gzip_disable \"msie6\";\n    #gzip_static on;\n}\n```\n\n##### gzip\n- できればgzip_staticを使う\n    - 圧縮コマンド `find ./* | xargs -I {}  sh -c 'gzip -9 -v -N -c {} \u003e {}.gz'`\n        - 元のファイルを残して圧縮する\n***\n","lastmodified":"2022-12-30T07:57:21.483263743Z","tags":null},"/other/Tools":{"title":"ツール","content":"\n- ユーティリティ\n\t- PowerToys (Windows)\n\t- Raycast (Mac)\n- バイナリエディタ\n\t- ImHex\n- ランチャー\n\t- Ear Trumpet\n\t- ATOK\n\t- ueli\n\t- Podman Desktop\n- メモ\n\t- Obsidian\n\t- Excalidraw\n- パスワードマネージャー\n\t- KeePassXC\n- プロファイラ\n\t- WizTree\n\t- Splunk\n\t- WakaTime\n\t- CrystalDisk\n\t- CrystalDiskMark\n- メール\n\t- Postfix\n\t- SendGrid\n\t- Mailgun\n- 液タブ\n\t- XP-PEN\n- サーバー\n\t- YAMAHA RTX1200\n- アイデア\n\t- ある単語について検索結果の要約をポップアップで表示する拡張機能\n\t- PEGを正規表現の拡張として使えるようなもの\n\t- version update時の確認不足で何かしらの悪意のあるプログラムを入れることができる\n- ライブラリ\n\t- デスクトップアプリ開発\n\t\t- Electron (TypeScript)\n\t\t- Dioxus (Rust)\n\t- トークナイザ\n\t\t- MeCab\n\t\t- vibrato\n","lastmodified":"2022-12-30T07:57:21.483263743Z","tags":null},"/other/Virtualization/Container":{"title":"コンテナ仮想化技術","content":"\nマルチステージビルド\nビルド環境と実行環境のコンテナを分けることでサイズを抑えられる.\n\n## Kubernetes\n\n[q3k/cve-2019-5736-poc: Unweaponized Proof of Concept for CVE-2019-5736 (Docker escape) (github.com)](https://github.com/q3k/cve-2019-5736-poc)\n[Dragon Sector: CVE-2019-5736: Escape from Docker and Kubernetes containers to root on host](https://blog.dragonsector.pl/2019/02/cve-2019-5736-escape-from-docker-and.html)\n[Security Camp B6 (notion.site)](https://mrtc0.notion.site/Security-Camp-B6-81eb740553154a70aeef92f3455717bf)\n\n[Dockerセキュリティベストプラクティス トップ20：究極ガイド #aqua #コンテナ #セキュリティ #ベストプラクティス - クリエーションライン株式会社 (creationline.com)](https://www.creationline.com/lab/aquasecurity/43087)\n\n[\"\u003e\u003cs\u003eはい\u003c/s\u003e (ssrf.in)](https://blog.ssrf.in/)\n[open_by_handle_at(2) でコンテナから Break Out する (ssrf.in)](https://blog.ssrf.in/post/escape-container-with-open-by-handle-at/)\n\n[実践入門 Kubernetesカスタムコントローラーへの道【委託】 - 達人出版会 (tatsu-zine.com)](https://tatsu-zine.com/books/kubernates-custom-controller)","lastmodified":"2022-12-30T07:57:21.483263743Z","tags":null},"/other/Virtualization/Emulator":{"title":"エミュレータ","content":"\nエミュレータとはハードウェアをソフトウェアで再現するプログラム。\n- [Go言語でゲームボーイアドバンスのエミュレータを作った話 (zenn.dev)](https://zenn.dev/akatsuki/articles/eac0703845aff2)\n- [Rustでゲームボーイアドバンスエミュレーターを書いた (zenn.dev)](https://zenn.dev/tanakh/articles/gba-emulator-in-rust#cpu)\n","lastmodified":"2022-12-30T07:57:21.483263743Z","tags":null},"/other/Virtualization/Hypervisor":{"title":"ハイパーバイザー","content":"\nx86を仮想化可能なアーキテクチャへ拡張したものVT-x (Vanderpool Technology)\n\n- [ハイパーバイザの作り方 (syuu1228.github.io)](https://syuu1228.github.io/howto_implement_hypervisor/)\n- [RISC-VのSupervisor Binary Interface(SBI)について - FPGA開発日記 (hatenablog.com)](https://msyksphinz.hatenablog.com/entry/2018/10/31/040000)\n- [VMMを自作してみた - おしぼりの日常 (hatenablog.com)](https://oshibori0121.hatenablog.com/entry/2021/02/12/193002)\n","lastmodified":"2022-12-30T07:57:21.483263743Z","tags":null},"/pwn/AEG":{"title":"Automatic Exploit Generation","content":"\n## 説明\n自動的にexploitを行うコードを生成する.\nバグを見つけるパートとexploitを生成するパートがある.\nバグを見つけるときはシンボリック実行エンジンを使う. ただ実行するだけだと実行時間がかなり長くなってしまう. これを効率的に行う為には前条件を用いるとよい.\n前条件に使われるものは次のようなものがある.\n- Known Length: BOF検知\n- Known Prefix: HTTPヘッダ\n- Concolic Execution\n\n疑問\nライブラリの定理証明をしていった方が良いのでは\n\n## 参考文献\n[AEG: Automatic Exploit Generation (psu.edu)](https://www.cse.psu.edu/~trj1/cse544-f15/docs/aeg-current.pdf)","lastmodified":"2022-12-30T07:57:21.483263743Z","tags":null},"/pwn/LinuxKernel/Kernel/kernel_reading":{"title":"","content":"\n[tkmru/linux-insides-ja: Japanese version of linux-insides book (github.com)](https://github.com/tkmru/linux-insides-ja)\n[Cryptogenic/PS5-IPV6-Kernel-Exploit: An experimental webkit-based kernel exploit (Arb. R/W) for the PS5 on \u003c= 4.51FW (github.com)](https://github.com/Cryptogenic/PS5-IPV6-Kernel-Exploit)","lastmodified":"2022-12-30T07:57:21.483263743Z","tags":null},"/pwn/LinuxKernel/eBPF":{"title":"eBPF","content":"\n","lastmodified":"2022-12-30T07:57:21.483263743Z","tags":null},"/pwn/LinuxKernel/kernel_exploit":{"title":"Kernel Exploit用テンプレート","content":"\n## 説明\n\npwnのKernel Exploit時に使うテンプレート\n\n## 実装\n\n```python\nfrom ptrlib import *\nimport time\nimport base64\nimport os\n\ndef run(cmd):\n    sock.sendlineafter(\"$ \", cmd)\n    sock.recvline()\n\nwith open(\"./root/exploit\", \"rb\") as f:\n    payload = bytes2str(base64.b64encode(f.read()))\n\n#sock = Socket(\"HOST\", PORT) # remote\nsock = Process(\"./run.sh\")\n\nrun('cd /tmp')\n\nlogger.info(\"Uploading...\")\nfor i in range(0, len(payload), 512):\n    print(f\"Uploading... {i:x} / {len(payload):x}\")\n    run('echo \"{}\" \u003e\u003e b64exp'.format(payload[i:i+512]))\nrun('base64 -d b64exp \u003e exploit')\nrun('rm b64exp')\nrun('chmod +x exploit')\n\nsock.interactive()\n```\n","lastmodified":"2022-12-30T07:57:21.483263743Z","tags":null},"/pwn/LinuxKernel/vulnssecurity":{"title":"","content":"\n\n## セキュリティ機構\n### KASLR :  Kernel ASLR\n- [KASLRの実装と挙動の確認 - 人生は勉強ブログ](https://blog.ishikawa.tech/entry/2019/12/17/161319)\n### KADR :  Kernel Address Display Restriction\n### KPTI :  Kernel  Page Table Isolation\nMeltdown Spectreに対する防御機構として導入。\n### SMAP :  Supervisor Mode Access Prevention\n### SMEP :  Supervisor Mode Execution Prevention\nuser-space memory mapping\n- [LinuxカーネルモジュールでStackjackingによるSMEP+SMAP+KADR回避をやってみる - ももいろテクノロジー](https://inaz2.hatenablog.com/entry/2015/03/27/021422)\n","lastmodified":"2022-12-30T07:57:21.483263743Z","tags":null},"/pwn/LinuxUserland/FormatStringAttack":{"title":"Format String Attack","content":"\n## Format String Bug\n書式を `printf` の第一引数に入れることで読み込んだり書き込める.\n\n| Format                  | 説明                                                                                                         |\n| ----------------------- | ------------------------------------------------------------------------------------------------------------ |\n| `%x` `%6$x`             |                                                                                                              |\n| `%42x`                  | 指定した数だけ文字を出力する                                                                                 |\n| `%p` `%6$p`             | 読む                                                                                                         |\n| `%s` `%6$s`             | その64bitアドレスから(null文字まで)読む                                                                      |\n| `%n` `%6$n`             | その64bitアドレスへ書き込む                                                                                  |\n| `%hhn` `%hn` `%n` `%ln` | それぞれ 1 2 4 8 バイト書き込む。%hhnは0x100で剰余をとってくれるので一周回してあげれば任意の値を書き込める。 |\n\n## 対策\n`printf` の第一引数を攻撃者に渡さない.\n","lastmodified":"2022-12-30T07:57:21.483263743Z","tags":null},"/pwn/LinuxUserland/GOToverwrite":{"title":"GOT overwrite","content":"\n## 説明\nGOT (Global Offset Table) の行先を書き換える. ROPでscanfして書き換えたりできる.\n\n## 防御機構\nFull RELRO\n","lastmodified":"2022-12-30T07:57:21.483263743Z","tags":null},"/pwn/LinuxUserland/HeapExploit/HeapExploit":{"title":"Heap Exploitation","content":"\nThe `glibc` library provides functions such as `free` and `malloc` to help developers manage the heap memory according to their use cases. It is the responsibility of the developer to:\n\n* `free` any memory he/she has obtained using `malloc`.\n* Do not `free` the same memory more than once.\n* Ensure that memory usage does not go beyond the amount of memory requested, in other terms, prevent heap overflows.\n\nFailing to do makes the software vulnerable to various kinds of attacks. [Shellphish](https://twitter.com/shellphish), a famous Capture the Flag team from UC Santa Barbara, has done a great job in listing a variety of heap exploitation techniques in [how2heap](https://github.com/shellphish/how2heap). Attacks described in \"The Malloc Maleficarum\" by \"Phantasmal Phantasmagoria\" in an [email](http://seclists.org/bugtraq/2005/Oct/118) to the \"Bugtraq\" mailing list are also described.\n\nA summary of the attacks has been described below:\n\n| Attack | Target | Technique |\n| :---: | :---: | :---: |\n| First Fit | This is not an attack, it just demonstrates the nature of glibc's allocator | --- |\n| Double Free | Making `malloc` return an already allocated fastchunk | Disrupt the fastbin by freeing a chunk twice |\n| Forging chunks | Making `malloc` return a nearly arbitrary pointer | Disrupting fastbin link structure |\n| Unlink Exploit | Getting (nearly)arbitrary write access | Freeing a corrupted chunk and exploiting `unlink` |\n| Shrinking Free Chunks | Making `malloc` return a chunk overlapping with an already allocated chunk | Corrupting a free chunk by decreasing its size |\n| House of Spirit | Making `malloc` return a nearly arbitrary pointer | Forcing freeing of a crafted fake chunk |\n| House of Lore | Making `malloc` return a nearly arbitrary pointer | Disrupting smallbin link structure |\n| House of Force | Making `malloc` return a nearly arbitrary pointer | Overflowing into top chunk's header |\n| House of Einherjar | Making `malloc` return a nearly arbitrary pointer | Overflowing a single byte into the next chunk |\n\n## 引用\n- [Heap Exploitation - heap-exploitation (dhavalkapil.com)](https://heap-exploitation.dhavalkapil.com/attacks)","lastmodified":"2022-12-30T07:57:21.483263743Z","tags":null},"/pwn/LinuxUserland/HeapExploit/HouseOfXXX/HouseOfBotcake":{"title":"House of Botcake","content":"\n\nunsorted binの `fd` は `main_arena.top` を指す。\nlibc内の `main_arena.top` のオフセットが分かれば libc base address","lastmodified":"2022-12-30T07:57:21.483263743Z","tags":null},"/pwn/LinuxUserland/HeapExploit/HouseOfXXX/HouseOfLore":{"title":"House of Lore","content":"\n","lastmodified":"2022-12-30T07:57:21.483263743Z","tags":null},"/pwn/LinuxUserland/HeapExploit/HouseOfXXX/HouseOfOrange":{"title":"House of Orange","content":"本質: `top chunk` のサイズを書き換えることで `_int_free` を呼び出す.\n応用: https://ptr-yudai.hatenablog.com/entry/2019/10/12/181931","lastmodified":"2022-12-30T07:57:21.483263743Z","tags":null},"/pwn/LinuxUserland/HeapExploit/HouseOfXXX/HouseOfSpirit":{"title":"House of Spirit","content":"\n","lastmodified":"2022-12-30T07:57:21.483263743Z","tags":null},"/pwn/LinuxUserland/HeapExploit/tcache_poisoning":{"title":"tcache poisoning","content":"\n ヒープ関連\n C++ vtable overwrite\nC++では仮想関数を実現する為に実行バイナリ中に型に対して呼び出す関数の対応表( vtable :  virtual method table )を持つ。このvtableの行先を書き換える。たぶん、C++だけではなく動的ポリモーフィズムを選択した言語なら出来そう。\n動的ポリモーフィズム C++\n静的ポリモーフィズム Rust\n[ヒープオーバーフローによるC++ vtable overwriteをやってみる - ももいろテクノロジー](https://inaz2.hatenablog.com/entry/2014/05/15/012621)\n[use-after-freeによるC++ vtable overwriteをやってみる - ももいろテクノロジー](https://inaz2.hatenablog.com/entry/2014/06/18/220735)\n[`_IO_str_overflow` を使ったvtable改竄検知の回避手法 - CTFするぞ](https://ptr-yudai.hatenablog.com/entry/2019/02/12/000202)\n\n`__free_hook` 書き換え\n`__free_hook` はfree時に呼び出す関数アドレスを指定できる。Full RELROでも書き換えられる。\n[SECCON Beginners CTF 2020 Beginners Heap Writeup \u0026初心者向け解説](https://qiita.com/hanya1995/items/c29a89737bbd521e67f2)\n\ntcache poisoning\n[SECCON Beginners CTF 2019 - Babyheap](https://hackmd.io/@Xornet/H1hYUUR2I)\n\n tcache double-free\nglibc 2.28 以前の tcache では double free が検出されない\n[https://smallkirby.hatenablog.com/entry/2020/12/15/042803 【pwn 41.0】realloc-baseのmemory corruptionの古い小ネタと最近のtcache周りの小話 - newbieからバイナリアンへ]\n\nchunk overlap\n\nfastbin attack\n\n\n[https://ptr-yudai.hatenablog.com/entry/2019/05/31/235444 ヒープ系問題におけるstdout / stderrを利用したメモリリーク - CTFするぞ]","lastmodified":"2022-12-30T07:57:21.483263743Z","tags":null},"/pwn/LinuxUserland/HeapExploit/vulnssecurity":{"title":"Heap における脆弱性とセキュリティ機構","content":"\n## 脆弱性\n### Heap BOF\nヒープ上のバッファオーバーフローを利用して、関数の戻りアドレスや関数ポインタを書き換える\n- [ヒープオーバーフローによるGOT overwriteをやってみる - ももいろテクノロジー](https://inaz2.hatenablog.com/entry/2014/05/14/011448)\n- [ヒープオーバーフローによるC++ vtable overwriteをやってみる - ももいろテクノロジー](https://inaz2.hatenablog.com/entry/2014/05/15/012621)\n\n### Use After Free\n解放した領域を誤って使用してしまうUse After Freeを利用し、同じ領域に悪意のあるデータ構造を確保して利用させる事で、関数ポインタを書き換える。\n- [use-after-freeによるGOT overwriteをやってみる - ももいろテクノロジー](https://inaz2.hatenablog.com/entry/2014/06/18/215452)\n- [use-after-freeによるC++ vtable overwriteをやってみる - ももいろテクノロジー](https://inaz2.hatenablog.com/entry/2014/06/18/220735)\n\n## セキュリティ機構\n","lastmodified":"2022-12-30T07:57:21.483263743Z","tags":null},"/pwn/LinuxUserland/StackExploit/ROP":{"title":"ROP; Return-Oriented Programming","content":"\n ROP :  Return-Oriented Programming\nret命令で終わる少ない命令列(Gadget)を組み合わせてret2hogeをする。呼び出し規約 #Pwn_よく使うglibcの関数まとめ がcdeclなどスタックを用いる場合、3つ以上の関数を呼ぶとき引数が関数アドレスと被らないように引数を削除する為のpop retガジェットを挟む。fastcallなどレジスタを用いる場合、レジスタに引数を渡すためにpop rdi retガジェット等を使う。\n- 防御機構\nIntel CET\n[【pwn 36.0】Intel CETが、みんなの恋人ROPを殺す - newbieからバイナリアンへ](https://smallkirby.hatenablog.com/entry/2020/09/10/230629)\n[x64でスタックバッファオーバーフローをやってみる - ももいろテクノロジー](https://inaz2.hatenablog.com/entry/2014/07/04/001851)\n","lastmodified":"2022-12-30T07:57:21.483263743Z","tags":null},"/pwn/LinuxUserland/StackExploit/ret2xxx":{"title":"ret2xxx","content":"\n libcリーク :   libc leak\nlibc内のアドレスをputs, printf関数などで出力させる。\n ret2XX\nリターンアドレスを書き換える。\n\nret2libc\nret2plt\nret2csu\n[glibc code reading 〜なぜ俺達のglibcは後方互換を捨てたのか〜 - HackMD](https://hackmd.io/@t3mp/r1zt00V1j)","lastmodified":"2022-12-30T07:57:21.483263743Z","tags":null},"/pwn/LinuxUserland/StackExploit/vulnssecurity":{"title":"スタックの脆弱性とセキュリティ機構","content":"\n## 脆弱性\n### Stack BOF (Stack-based buffer overflow)\nスタック上のオーバーフローを利用してリターンアドレスやローカル変数を書き換えられる。\n- トリガー\nメモリ書き換え (文字列入力、文字列入力の最後尾にヌル文字を挿入するなど)\n- 防御機構\nSSP canary\n- [単純なスタックバッファオーバーフロー攻撃をやってみる - ももいろテクノロジー](https://inaz2.hatenablog.com/entry/2014/03/14/151011)\n\n#### Stack underflow\n関数フレーム外までpopを行う。\n\nOff-by-one error\nNull-byte Overflow\n\n## セキュリティ機構\n### Stack Canary\n\nMaster Canary\nhttps://www.youtube.com/watch?v=UTC2iWxQ4qc","lastmodified":"2022-12-30T07:57:21.483263743Z","tags":null},"/pwn/LinuxUserland/glibc/_IO_FILE/_IO_FILE":{"title":"_IO_FILE","content":"\n```c\nstruct _IO_FILE\n{\n  int _flags;                /* High-order word is _IO_MAGIC; rest is flags. */\n  /* The following pointers correspond to the C++ streambuf protocol. */\n  char *_IO_read_ptr;        /* Current read pointer */\n  char *_IO_read_end;        /* End of get area. */\n  char *_IO_read_base;        /* Start of putback+get area. */\n  char *_IO_write_base;        /* Start of put area. */\n  char *_IO_write_ptr;        /* Current put pointer. */\n  char *_IO_write_end;        /* End of put area. */\n  char *_IO_buf_base;        /* Start of reserve area. */\n  char *_IO_buf_end;        /* End of reserve area. */\n  /* The following fields are used to support backing up and undo. */\n  char *_IO_save_base; /* Pointer to start of non-current get area. */\n  char *_IO_backup_base;  /* Pointer to first valid character of backup area */\n  char *_IO_save_end; /* Pointer to end of non-current get area. */\n  struct _IO_marker *_markers;\n  struct _IO_FILE *_chain;\n  int _fileno;\n  int _flags2;\n  __off_t _old_offset; /* This used to be _offset but it's too small.  */\n  /* 1+column number of pbase(); 0 is unknown. */\n  unsigned short _cur_column;\n  signed char _vtable_offset;\n  char _shortbuf[1];\n  _IO_lock_t *_lock;\n#ifdef _IO_USE_OLD_IO_FILE\n};\n```\n\n```c\nstruct _IO_FILE_plus\n{\n  _IO_FILE file;\n  const struct _IO_jump_t *vtable;\n};\n```\n\n```c\nstruct _IO_jump_t\n{\n    JUMP_FIELD(size_t, __dummy);\n    JUMP_FIELD(size_t, __dummy2);\n    JUMP_FIELD(_IO_finish_t, __finish);\n    JUMP_FIELD(_IO_overflow_t, __overflow);\n    JUMP_FIELD(_IO_underflow_t, __underflow);\n    JUMP_FIELD(_IO_underflow_t, __uflow);\n    JUMP_FIELD(_IO_pbackfail_t, __pbackfail);\n    /* showmany */\n    JUMP_FIELD(_IO_xsputn_t, __xsputn);\n    JUMP_FIELD(_IO_xsgetn_t, __xsgetn);\n    JUMP_FIELD(_IO_seekoff_t, __seekoff);\n    JUMP_FIELD(_IO_seekpos_t, __seekpos);\n    JUMP_FIELD(_IO_setbuf_t, __setbuf);\n    JUMP_FIELD(_IO_sync_t, __sync);\n    JUMP_FIELD(_IO_doallocate_t, __doallocate);\n    JUMP_FIELD(_IO_read_t, __read);\n    JUMP_FIELD(_IO_write_t, __write);\n    JUMP_FIELD(_IO_seek_t, __seek);\n    JUMP_FIELD(_IO_close_t, __close);\n    JUMP_FIELD(_IO_stat_t, __stat);\n    JUMP_FIELD(_IO_showmanyc_t, __showmanyc);\n    JUMP_FIELD(_IO_imbue_t, __imbue);\n#if 0\n    get_column;\n    set_column;\n#endif\n};\n```\n\n## 参考\n- [`_IO_str_overflow` を使ったvtable改竄検知の回避手法 - CTFするぞ (hatenablog.com)](https://ptr-yudai.hatenablog.com/entry/2019/02/12/000202)\n- [ヒープ系問題におけるstdout / stderrを利用したメモリリーク - CTFするぞ (hatenablog.com)](https://ptr-yudai.hatenablog.com/entry/2019/05/31/235444)\n\n","lastmodified":"2022-12-30T07:57:21.483263743Z","tags":null},"/pwn/LinuxUserland/glibc/glibc":{"title":"glibc","content":"\n### glibc ビルド方法\n\n1. https://www.gnu.org/software/libc/ のリリースページから ftp に飛んでダウンロードする.\n2. ビルド作業用のディレクトリを作ってそこに入る\n3. `../glibc-hoge/congifure --prefix=/path/to/インストールしたい場所`\n4. `make -j{N}`\n5. `make install`\n\n### glibc\n\n- 自前ビルドしてるとデバッグ情報も付いてくる.\n- [patchelf](https://github.com/NixOS/patchelf) では手で叩かないといけない.\n- [pwninit](https://github.com/io12/pwninit) なら glibc を同じ階層に入れておけば `pwninit` で勝手にやってくれる.\n- `ldd` コマンドで確認できる.\n- パッチ自動化できそう.","lastmodified":"2022-12-30T07:57:21.483263743Z","tags":null},"/pwn/LinuxUserland/glibc/glibc_heap/BinsChunks":{"title":"Bins and Chunks","content":"\nA bin is a list (doubly or singly linked list) of free (non-allocated) chunks. Bins are differentiated based on the size of chunks they contain:\n\n1. Fast bin\n2. Unsorted bin\n3. Small bin\n4. Large bin\n\nFast bins are maintained using:\n\n```c\ntypedef struct malloc_chunk *mfastbinptr;\n\nmfastbinptr fastbinsY[]; // Array of pointers to chunks\n```\n\nUnsorted, small and large bins are maintained using a single array:\n\n```c\ntypedef struct malloc_chunk* mchunkptr;\n\nmchunkptr bins[]; // Array of pointers to chunks\n```\n\nInitially, during the initialization process, small and large bins are empty.\n\nEach bin is represented by two values in the bins array. The first one is a pointer to the 'HEAD' and the second one is a pointer to the 'TAIL' of the bin list. In the case of fast bins (singly linked list), the second value is NULL.\n\n## Fast bins\n\nThere are 10 fast bins. Each of these bins maintains a single linked list. Addition and deletion happen from the front of this list (LIFO manner).\n\nEach bin has chunks of the same size. The 10 bins each have chunks of sizes: 16, 24, 32, 40, 48, 56, 64, 72, 80 and 88. Sizes mentioned here include metadata as well. To store chunks, 4 fewer bytes will be available (on a platform where pointers use 4 bytes). Only the `prev_size` and `size` field of this chunk will hold meta data for allocated chunks. `prev_size` of next contiguous chunk will hold user data.\n\nNo two contiguous free fast chunks coalesce together.\n\n## Unsorted bin\n\nThere is only 1 unsorted bin. Small and large chunks, when freed, end up in this bin. The primary purpose of this bin is to act as a cache layer (kind of) to speed up allocation and deallocation requests.\n\n## Small bins\n\nThere are 62 small bins. Small bins are faster than large bins but slower than fast bins. Each bin maintains a doubly-linked list. Insertions happen at the 'HEAD' while removals happen at the 'TAIL' (in a FIFO manner).\n\nLike fast bins, each bin has chunks of the same size. The 62 bins have sizes: 16, 24, ... , 504 bytes.\n\nWhile freeing, small chunks may be coalesced together before ending up in unsorted bins.\n\n## Large bins\n\nThere are 63 large bins. Each bin maintains a doubly-linked list. A particular large bin has chunks of different sizes, sorted in decreasing order (i.e. largest chunk at the 'HEAD' and smallest chunk at the 'TAIL'). Insertions and removals happen at any position within the list.\n\nThe first 32 bins contain chunks which are 64 bytes apart:\n\n1st bin: 512 - 568 bytes  \n2nd bin: 576 - 632 bytes  \n.  \n.\n\nTo summarize:\n\n```\nNo. of Bins       Spacing between bins\n\n64 bins of size       8  [ Small bins]\n32 bins of size      64  [ Large bins]\n16 bins of size     512  [ Large bins]\n8 bins of size     4096  [ ..        ]\n4 bins of size    32768\n2 bins of size   262144\n1 bin  of size what's left\n```\n\nLike small chunks, while freeing, large chunks may be coalesced together before ending up in unsorted bins.\n\nThere are two special types of chunks which are not part of any bin.\n\n## Top chunk\n\nIt is the chunk which borders the top of an arena. While servicing 'malloc' requests, it is used as the last resort. If still more size is required, it can grow using the `sbrk` system call. The `PREV_INUSE` flag is always set for the top chunk.\n\n## Last remainder chunk\n\nIt is the chunk obtained from the last split. Sometimes, when exact size chunks are not available, bigger chunks are split into two. One part is returned to the user whereas the other becomes the last remainder chunk.","lastmodified":"2022-12-30T07:57:21.483263743Z","tags":null},"/pwn/LinuxUserland/glibc/glibc_heap/CoreFunctions":{"title":"Core Functions","content":"\n## `void * _int_malloc (mstate av, size_t bytes)`\n\n1. Updates `bytes` to take care of alignments, etc.\n2. Checks if `av` is NULL or not.\n3. In the case of absence of usable arena (when `av` is NULL), calls `sysmalloc` to obtain chunk using mmap. If successful, calls `alloc_perturb`. Returns the pointer.  \n4. * If size falls in the fastbin range:\n     1. Get index into the fastbin array to access an appropriate bin according to the request size.\n     2. Removes the first chunk in that bin and make `victim` point to it.\n     3. If `victim` is NULL, move on to the next case (smallbin).\n     4. If `victim` is not NULL, check the size of the chunk to ensure that it belongs to that particular bin. An error (\"malloc(): memory corruption (fast)\") is thrown otherwise.\n     5. Calls `alloc_perturb` and then returns the pointer.\n\n   * If size falls in the smallbin range:\n     1. Get index into the smallbin array to access an appropriate bin according to the request size.\n     2. If there are no chunks in this bin, move on to the next case. This is checked by comparing the pointers `bin` and `bin-\u003ebk`.\n     3. `victim` is made equal to `bin-\u003ebk` (the last chunk in the bin). If it is NULL (happens during `initialization`), call `malloc_consolidate` and skip this complete step of checking into different bins. \n     4. Otherwise, when `victim` is non NULL, check if `victim-\u003ebk-\u003efd` and `victim` are equal or not. If they are not equal, an error (\"malloc(): smallbin double linked list corrupted\") is thrown.\n     5. Sets the PREV\\_INSUSE bit for the next chunk (in memory, not in the doubly linked list) for `victim`.\n     6. Remove this chunk from the bin list.\n     7. Set the appropriate arena bit for this chunk depending on `av`.\n     8. Calls `alloc_perturb` and then returns the pointer.\n\n   * If size does not fall in the smallbin range:\n     1. Get index into the largebin array to access an appropriate bin according to the request size.\n     2. See if `av` has fastchunks or not. This is done by checking the `FASTCHUNKS_BIT` in `av-\u003eflags`. If so, call `malloc_consolidate` on `av`.\n\n5. If no pointer has yet been returned, this signifies one or more of the following cases:\n  1. Size falls into 'fastbin' range but no fastchunk is available.\n  2. Size falls into 'smallbin' range but no smallchunk is available (calls `malloc_consolidate` during initialization).\n  3. Size falls into 'largbin' range.\n\n6. Next, unsorted chunks are checked and traversed chunks are placed into bins. This is the only place where chunks are placed into bins. Iterate the unsorted bin from the 'TAIL'.\n  1. `victim` points to the current chunk being considered.\n  2. Check if `victim`'s chunk size is within minimum (`2*SIZE_SZ`) and maximum (`av-\u003esystem_mem`) range. Throw an error (\"malloc(): memory corruption\") otherwise.\n  3. If (size of requested chunk falls in smallbin range) and (`victim` is the last remainder chunk) and (it is the only chunk in the unsorted bin) and (the chunks size \u003e= the one requested):\n    Break the chunk into 2 chunks:\n     * The first chunk matches the size requested and is returned.\n     * Left over chunk becomes the new last remainder chunk. It is inserted back into the unsorted bin.\n       1. Set `chunk_size` and `chunk_prev_size` fields appropriately for both chunks.\n       2. The first chunk is returned after calling `alloc_perturb`.\n  4. If the above condition is false, control reaches here. Remove `victim` from the unsorted bin. If the size of `victim` matches the size requested exactly, return this chunk after calling `alloc_perturb`.\n  5. If `victim`'s size falls in smallbin range, add the chunk in the appropriate smallbin at the `HEAD`.\n  6. Else insert into appropriate largebin while maintaining sorted order:\n    * First checks the last chunk (smallest). If `victim` is smaller than the last chunk, insert it at the last.\n    * Otherwise, loop to find a chunk with size \u003e= size of `victim`. If size is exactly same, always insert in the second position.\n  7. Repeat this whole step a maximum of `MAX_ITERS` (10000) times or till all chunks in unsorted bin get exhausted.\n\n7. After checking unsorted chunks, check if requested size does not fall in the smallbin range, if so then check largebins.\n  1. Get index into largebin array to access an appropriate bin according to the request size.\n  2. If the size of the largest chunk (the first chunk in the bin) is greater than the size requested:\n    1. Iterate from 'TAIL' to find a chunk (`victim`) with the smallest size \u003e= the requested size.\n    2. Call `unlink` to remove the `victim` chunk from the bin.\n    3. Calculate `remainder_size` for the `victim`'s chunk (this will be `victim`'s chunk size - requested size).\n    4. If this `remainder_size` \u003e= `MINSIZE` (the minimum chunk size including the headers), split the chunk into two chunks. Otherwise, the entire `victim` chunk will be returned. Insert the remainder chunk in the unsorted bin (at the 'TAIL' end). A check is made in unsorted bin whether `unsorted_chunks(av)-\u003efd-\u003ebk == unsorted_chunks(av)`. An error is thrown otherwise (\"malloc(): corrupted unsorted chunks\").\n    5. Return the `victim` chunk after calling `alloc_perturb`.\n\n8. Till now, we have checked unsorted bin and also the respective fast, small or large bin. Note that a single bin (fast or small) was checked using the **exact** size of the requested chunk. Repeat the following steps till all bins are exhausted:\n  1. The index into bin array is incremented to check the next bin.\n  2. Use `av-\u003ebinmap` map to skip over bins that are empty.\n  3. `victim` is pointed to the 'TAIL' of the current bin.\n  4. Using the binmap ensures that if a bin is skipped (in the above 2nd step), it is definitely empty. However, it does not ensure that all empty bins will be skipped. Check if the victim is empty or not. If empty, again skip the bin and repeat the above process (or 'continue' this loop) till we arrive at a nonempty bin.\n  5. Split the chunk (`victim` points to the last chunk of a nonempty bin) into two chunks. Insert the remainder chunk in unsorted bin (at the 'TAIL' end). A check is made in the unsorted bin whether `unsorted_chunks(av)-\u003efd-\u003ebk == unsorted_chunks(av)`. An error is thrown otherwise (\"malloc(): corrupted unsorted chunks 2\").\n  6. Return the `victim` chunk after calling `alloc_perturb`.\n\n9. If still no empty bin is found, 'top' chunk will be used to service the request:\n  1. `victim` points to `av-\u003etop`.\n  2. If size of 'top' chunk \u003e= 'requested size' + `MINSIZE`, split it into two chunks. In this case, the remainder chunk becomes the new 'top' chunk and the other chunk is returned to the user after calling `alloc_perturb`.\n  3. See if `av` has fastchunks or not. This is done by checking the `FASTCHUNKS_BIT` in `av-\u003eflags`. If so, call `malloc_consolidate` on `av`. Return to step 6 (where we check unsorted bin).\n  4. If `av` does not have fastchunks, call `sysmalloc` and return the pointer obtained after calling `alloc_perturb`.\n\n## `__libc_malloc (size_t bytes)`\n\n1. Calls `arena_get` to get an `mstate` pointer.\n2. Calls `_int_malloc` with the arena pointer and the size.\n3. Unlocks the arena.\n4. Before returning the pointer to the chunk, one of the following should be true:\n   * Returned pointer is NULL\n   * Chunk is MMAPPED\n   * Arena for chunk is the same as the one found in 1.\n\n## `_int_free (mstate av, mchunkptr p, int have_lock)`\n\n1. Check whether `p` is before `p + chunksize(p)` in the memory (to avoid wrapping). An error (\"free(): invalid pointer\") is thrown otherwise.\n2. Check whether the chunk is at least of size `MINSIZE` or a multiple of `MALLOC_ALIGNMENT`. An error (\"free(): invalid size\") is thrown otherwise.\n3. If the chunk's size falls in fastbin list:\n   1. Check if next chunk's size is between minimum and maximum size (`av-\u003esystem_mem`), throw an error (\"free(): invalid next size (fast)\") otherwise.\n   2. Calls `free_perturb` on the chunk.\n   3. Set `FASTCHUNKS_BIT` for `av`.\n   4. Get index into fastbin array according to chunk size.\n   5. Check if the top of the bin is not the chunk we are going to add. Otherwise, throw an error (\"double free or corruption (fasttop)\").\n   6. Check if the size of the fastbin chunk at the top is the same as the chunk we are adding. Otherwise, throw an error (\"invalid fastbin entry (free)\").\n   7. Insert the chunk at the top of the fastbin list and return.\n4. If the chunk is not mmapped:\n   1. Check if the chunk is the top chunk or not. If yes, an error (\"double free or corruption (top)\") is thrown.\n   2. Check whether next chunk (by memory) is within the boundaries of the arena. If not, an error (\"double free or corruption (out)\") is thrown.\n   3. Check whether next chunk's (by memory) previous in use bit is marked or not. If not, an error (\"double free or corruption (!prev)\") is thrown.\n   4. Check whether the size of next chunk is between the minimum and maximum size (`av-\u003esystem_mem`). If not, an error (\"free(): invalid next size (normal)\") is thrown.\n   5. Call `free_perturb` on the chunk.\n   6. If previous chunk (by memory) is not in use, call `unlink` on the previous chunk.\n   7. If next chunk (by memory) is not top chunk:\n      1. If next chunk is not in use, call `unlink` on the next chunk.\n      2. Merge the chunk with previous, next (by memory), if any is free and add it to the head of unsorted bin. Before inserting, check whether `unsorted_chunks(av)-\u003efd-\u003ebk == unsorted_chunks(av)` or not. If not, an error (\"free(): corrupted unsorted chunks\") is thrown.\n   8. If next chunk (by memory) was a top chunk, merge the chunks appropriately into a single top chunk.\n5. If the chunk was mmapped, call `munmap_chunk`.\n\n## `__libc_free (void *mem)`\n\n1. Return if `mem` is NULL.\n2. If the corresponding chunk is mmapped, call `munmap_chunk` if the dynamic brk/mmap threshold needs adjusting.\n3. Get arena pointer for that corresponding chunk.\n4. Call `_int_free`.","lastmodified":"2022-12-30T07:57:21.483263743Z","tags":null},"/pwn/LinuxUserland/glibc/glibc_heap/InternalFunctions":{"title":"Internal Functions","content":"\nThis is a list of some common functions used internally. Note that some functions are in fact defined using the `#define` directive. So, changes to call parameters are in fact retained after the call. Also, it is assumed that MALLOC\\_DEBUG is not set.\n\n## arena_get (ar_ptr, size)\n\nAcquires an arena and locks the corresponding mutex. `ar_ptr` is set to point to the corresponding arena. `size` is just a hint as to how much memory will be required immediately.\n\n## sysmalloc [TODO]\n\n```c\n/*\n   sysmalloc handles malloc cases requiring more memory from the system.\n   On entry, it is assumed that av-\u003etop does not have enough\n   space to service request for nb bytes, thus requiring that av-\u003etop\n   be extended or replaced.\n */\n```\n\n## void alloc_perturb (char *p, size_t n)\n\nIf `perturb_byte` (tunable parameter for malloc using `M_PERTURB`) is non-zero (by default it is 0), sets the `n` bytes pointed to by `p` to be equal to `perturb_byte` ^ 0xff.\n\n## void free_perturb (char *p, size_t n)\n\nIf `perturb_byte` (tunable parameter for malloc using `M_PERTURB`) is non-zero (by default it is 0), sets the `n` bytes pointed to by `p` to be equal to `perturb_byte`.\n\n## void malloc_init_state (mstate av)\n\n```c\n/*\n   Initialize a malloc_state struct.\n\n   This is called only from within malloc_consolidate, which needs\n   be called in the same contexts anyway.  It is never called directly\n   outside of malloc_consolidate because some optimizing compilers try\n   to inline it at all call points, which turns out not to be an\n   optimization at all. (Inlining it in malloc_consolidate is fine though.)\n */\n```\n\n1. For non fast bins, create empty circular linked lists for each bin.\n2. Set `FASTCHUNKS_BIT` flag for `av`.\n3. Initialize `av-\u003etop` to the first unsorted chunk.\n\n## unlink(AV, P, BK, FD)\n\nThis is a defined macro which removes a chunk from a bin.\n\n1. Check if chunk size is equal to the previous size set in the next chunk. Else, an error (\"corrupted size vs. prev\\_size\") is thrown.\n2. Check if `P-\u003efd-\u003ebk == P` and `P-\u003ebk-\u003efd == P`. Else, an error (\"corrupted double-linked list\") is thrown.\n3. Adjust forward and backward pointers of neighboring chunks (in list) to facilitate removal:\n   1. Set `P-\u003efd-\u003ebk` = `P-\u003ebk`.\n   2. Set `P-\u003ebk-\u003efd` = `P-\u003efd`.\n\n## void malloc_consolidate(mstate av)\n\nThis is a specialized version of free().\n\n1. Chech if `global_max_fast` is 0 (`av` not initialized) or not. If it is 0, call `malloc_init_state` with `av` as parameter and return.\n2. If `global_max_fast` is non-zero, clear the `FASTCHUNKS_BIT` for `av`.\n3. Iterate on the fastbin array from first to last indices:\n   1. Get a lock on the current fastbin chunk and proceed if not null.\n   2. If previous chunk (by memory) is not in use, call `unlink` on the previous chunk.\n   3. If next chunk (by memory) is not top chunk:\n      1. If next chunk is not in use, call `unlink` on the next chunk.\n      2. Merge the chunk with previous, next (by memory), if any is free, and then add the consolidated chunk to the head of unsorted bin.\n   4. If next chunk (by memory) was a top chunk, merge the chunks appropriately into a single top chunk.\n\n_Note_: The check for 'in use' is done using `PREV_IN_USE` flag. Hence, other fastbin chunks won't identified as free here.","lastmodified":"2022-12-30T07:57:21.483263743Z","tags":null},"/pwn/LinuxUserland/glibc/glibc_heap/SecurityChecks":{"title":"","content":"\n| Function    | Security Check                                                                                                                                | Error                              |\n| ----------- | --------------------------------------------------------------------------------------------------------------------------------------------- | ---------------------------------- |\n| unlink      | Whether chunk size is equal to the previous size set in the next chunk (in memory)                                                            | corrupted size vs. prev_size       |\n| unlink      | Whether `P-\u003efd-\u003ebk == P` and `P-\u003ebk-\u003efd == P`*                                                                                                | corrupted double-linked list       |\n| `_int_malloc` | While removing the first chunk from fastbin (to service a malloc request), check whether the size of the chunk falls in fast chunk size range | malloc(): memory corruption (fast) |\n| `_int_malloc` | While removing the last chunk (`victim`) from a smallbin (to service a malloc request), check whether `victim-\u003ebk-\u003efd` and `victim` are equal | malloc(): smallbin double linked list corrupted |\n| `_int_malloc` | While iterating in unsorted bin, check whether size of current chunk is within minimum (`2*SIZE_SZ`) and maximum (`av-\u003esystem_mem`) range | malloc(): memory corruption |\n| `_int_malloc` | While inserting last remainder chunk into unsorted bin (after splitting a large chunk), check whether `unsorted_chunks(av)-\u003efd-\u003ebk == unsorted_chunks(av)` | malloc(): corrupted unsorted chunks |\n| `_int_malloc` | While inserting last remainder chunk into unsorted bin (after splitting a fast or a small chunk), check whether `unsorted_chunks(av)-\u003efd-\u003ebk == unsorted_chunks(av)` | malloc(): corrupted unsorted chunks 2 |\n| `_int_free` | Check whether `p`** is before `p + chunksize(p)` in the memory (to avoid wrapping) | free(): invalid pointer |\n| `_int_free` | Check whether the chunk is at least of size `MINSIZE` or a multiple of `MALLOC_ALIGNMENT` | free(): invalid size |\n| `_int_free` | For a chunk with size in fastbin range, check if next chunk's size is between minimum and maximum size (`av-\u003esystem_mem`) | free(): invalid next size (fast) |\n| `_int_free` | While inserting fast chunk into fastbin (at `HEAD`), check whether the chunk already at `HEAD` is not the same | double free or corruption (fasttop) |\n| `_int_free` | If the chunk is not within the size range of fastbin and neither it is a mmapped chunks, check whether it is not the same as the top chunk | double free or corruption (top) | `_int_free` | While inserting fast chunk into fastbin (at `HEAD`), check whether size of the chunk at `HEAD` is same as the chunk to be inserted | invalid fastbin entry (free) |\n| `_int_free` | Check whether next chunk (by memory) is within the boundaries of the arena | double free or corruption (out) |\n| `_int_free` | Check whether next chunk's (by memory) previous in use bit is marked | double free or corruption (!prev) |\n| `_int_free` | Check whether size of next chunk is within the minimum and maximum size (`av-\u003esystem_mem`) | free(): invalid next size (normal) |\n| `_int_free` | While inserting the coalesced chunk into unsorted bin, check whether `unsorted_chunks(av)-\u003efd-\u003ebk == unsorted_chunks(av)` | free(): corrupted unsorted chunks |\n\n","lastmodified":"2022-12-30T07:57:21.483263743Z","tags":null},"/pwn/LinuxUserland/glibc/glibc_heap/glibc_heap":{"title":"glibc malloc","content":"\n## ヒープとは\n\n## 動的メモリ\n\n```cpp\n// Dynamically allocate 10 bytes\n\nchar *buffer = (char *)malloc(10);\n\nstrcpy(buffer, \"hello\");\n\nprintf(\"%s\\n\", buffer); // prints \"hello\"\n\n// Frees/unallocates the dynamic memory allocated earlier\n\nfree(buffer);\n```\n\n\n## glibc heap\n\n### malloc chunk\n\n```c\n struct malloc_chunk {\n   INTERNAL_SIZE_T      mchunk_prev_size;  /* Size of previous chunk (if free).  */\n   INTERNAL_SIZE_T      mchunk_size;       /* Size in bytes, including overhead. */\n   struct malloc_chunk* fd;                /* double links -- used only if free. */\n   struct malloc_chunk* bk;\n   /* Only used for large blocks: pointer to next larger size.  */\n   struct malloc_chunk* fd_nextsize; /* double links -- used only if free. */\n   struct malloc_chunk* bk_nextsize;\n };\n```\n\n```\nAllocated chunk\ncode:c\n     chunk-\u003e +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n             |             Size of previous chunk, if unallocated (P clear)  |\n             +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n             |             Size of chunk, in bytes                     |A|M|P|\n       mem-\u003e +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n             |             User data starts here...                          .\n             .                                                               .\n             .             (malloc_usable_size() bytes)                      .\n             .                                                               |\n nextchunk-\u003e +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n             |             (size of chunk, but used for application data)    |\n             +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n             |             Size of next chunk, in bytes                |A|0|1|\n             +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\nNotice how the data of an allocated chunk uses the first attribute (mchunk_prev_size) of the next chunk. mem is the pointer which is returned to the user.\nFree chunk\ncode:c\n     chunk-\u003e +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n             |             Size of previous chunk, if unallocated (P clear)  |\n             +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n     `head:' |             Size of chunk, in bytes                     |A|0|P|\n       mem-\u003e +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n             |             Forward pointer to next chunk in list             |\n             +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n             |             Back pointer to previous chunk in list            |\n             +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n             |             Unused space (may be 0 bytes long)                .\n             .                                                               .\n             .                                                               |\n nextchunk-\u003e +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n     `foot:' |             Size of chunk, in bytes                           |\n             +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n             |             Size of next chunk, in bytes                |A|0|0|\n             +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n```\n\n前回使用したサイズ以下の容量を確保することでfreeした後のデータを使える。\n解放済みポインタ ( ダングリングポインタ :  dangling pointer ) を悪意のあるアドレスへ変えることで意図しない挙動にすることができる。\n\nglibc のデータ領域に main_arena\n\n### malloc_state\n\n```cpp\nstruct malloc_state\n{\n  /* Serialize access.  */\n  __libc_lock_define (, mutex);\n\n  /* Flags (formerly in max_fast).  */\n  int flags;\n\n  /* Set if the fastbin chunks contain recently inserted free blocks.  */\n  /* Note this is a bool but not all targets support atomics on booleans.  */\n  int have_fastchunks;\n\n  /* Fastbins */\n  mfastbinptr fastbinsY[NFASTBINS];\n\n  /* Base of the topmost chunk -- not otherwise kept in a bin */\n  mchunkptr top;\n\n  /* The remainder from the most recent split of a small request */\n  mchunkptr last_remainder;\n\n  /* Normal bins packed as described above */\n  mchunkptr bins[NBINS * 2 - 2];\n\n  /* Bitmap of bins */\n  unsigned int binmap[BINMAPSIZE];\n\n  /* Linked list */\n  struct malloc_state *next;\n\n  /* Linked list for free arenas.  Access to this field is serialized\n     by free_list_lock in arena.c.  */\n  struct malloc_state *next_free;\n\n  /* Number of threads attached to this arena.  0 if the arena is on\n     the free list.  Access to this field is serialized by\n     free_list_lock in arena.c.  */\n  INTERNAL_SIZE_T attached_threads;\n\n  /* Memory allocated from the system in this arena.  */\n  INTERNAL_SIZE_T system_mem;\n  INTERNAL_SIZE_T max_system_mem;\n};\n```\n\nbinには沢山の種類がある\n- tcache\n- fastbins\n- unsorted bins\n- small bins\n- large bins\n\nヒープ領域\n```cpp\nstruct malloc_chunk{\n  size_t prev_size; // Size of previous chunk (if free).\n  size_t size;      // Size in bytes, including overhead. 下3bitはフラグ\n\n  // userに渡されるアドレスはここ\n  // double links -- used only if free.\n  void *fd; // next\n  void *bk; // key\n\n  // for large size\n  void *fd_nextsize;\n  void *bk_nextsize;\n}\n```\n\n| bins   | fd | bk |\n|:------:|:---|:---|\n| tcache | next | tcache_key |\n| fastbins | next | null |\n| unsorted bins | \u0026main_arena.top |  |\n| small bins |  |  |\n| large bins |  |  |\n\ntcache\n\n```cpp\n/* We overlay this structure on the user-data portion of a chunk when\n   the chunk is stored in the per-thread cache.  */\ntypedef struct tcache_entry\n{\n  struct tcache_entry *next;\n  /* This field exists to detect double frees.  */\n  uintptr_t key;\n} tcache_entry;\n\n/* There is one of these for each thread, which contains the\n   per-thread cache (hence \"tcache_perthread_struct\").  Keeping\n   overall size low is mildly important.  Note that COUNTS and ENTRIES\n   are redundant (we could have just counted the linked list each\n   time), this is for performance reasons.  */\ntypedef struct tcache_perthread_struct\n{\n  uint16_t counts[TCACHE_MAX_BINS];\n  tcache_entry *entries[TCACHE_MAX_BINS];\n} tcache_perthread_struct;\n```\n本質は next つまり単方向連結リスト\n\n#### mitigations\n**counts**\n初期値 0, free すると +1, malloc すると -1 される値\n上限7個 これを超えると fastbin へ\n連結リストとは独立にカウントされることで malloc の回数と free の回数の非整合性を検知する(counts は負の数となることはない).\n\nex)\nB: 攻撃者が指定するchunk\n```\nentry:空 -\u003e entry: A -\u003e改ざん！ -\u003e entry: A-\u003eB -\u003emalloc-\u003e entry: B\ncount:0 -\u003e count: 1 -----------\u003e count:1 -------------\u003e count: 0\n\nこのmitigationのbypass例\nentry:空 -\u003e entry: A ... entry: A_1-\u003eA_2 -\u003e改ざん！ -\u003e entry: A_1-\u003eB -\u003emalloc-\u003e entry: B\ncount:0 -\u003e count: 1 ... count: 2 ------------------\u003e count:2 --------------------\u003e count: 1\n```\n**key**\nfreeする度にentry.keyに\u0026tcacheを代入する\nfree するときに entry.keyの位置に\u0026tcache がある場合に限り\nentryのリストを探索しdouble free を検知する.\n\nmallocしてきた chunk A{.a = 0x12345678, .b = 0x90abcdef}\n-\u003e free -\u003e\nfreeされた tcache chunk A{.next = (次のchunkのアドレス) .key= \u0026tcache}\n\nmallocしてきた chunk B{.a = 0x12345678, .b = \u0026tcache} たまたまkeyの位置が\u0026tcacheになってる！\n-\u003e free -\u003e double free(擬陽性)\n\ntcache.entry[0x10] -\u003e A -\u003e B -\u003e C\n\n```\nstruct malloc_chunk{\n  size_t prev_size; // malloc中に必要！\n  size_t size; // malloc中に必要！ 下3bitはフラグ\n\n  // userに渡されるアドレスはここ\n\n  void *fd; // next\n  void *bk; // key\n\n  // for large size\n  void *fd_nextsize;\n  void *bk_nextsize;\n}\n```\n\nstruct tcache_entryはこの構造体のfdの位置にoverlapしてtcache_perthread_structで管理してる\n### 雑〜なexploit\n- 余分にfreeをしてcountを増やした後、対象のfree済みchunkに対してkeyをごちゃごちゃにしnext改ざん\n- これでentryの連結リストの中に攻撃者指定のアドレスが入るため、このままmallocしていけば任意アドレス書き込み可能\n\n\nlibc 2.29 tcache_key\ntcacheでdouble freeはできない\nwwwdsssssssssssssssssssssssssssasssssssad\n```cpp\n/* Caller must ensure that we know tc_idx is valid and there's room\n   for more chunks.  */\nstatic __always_inline void\ntcache_put (mchunkptr chunk, size_t tc_idx)\n{\n  tcache_entry *e = (tcache_entry *) chunk2mem (chunk);\n\n  /* Mark this chunk as \"in the tcache\" so the test in _int_free will\n     detect a double free.  */\n  e-\u003ekey = tcache_key;\n\n  e-\u003enext = PROTECT_PTR (\u0026e-\u003enext, tcache-\u003eentries[tc_idx]);\n  tcache-\u003eentries[tc_idx] = e;\n  ++(tcache-\u003ecounts[tc_idx]);\n}\n```\n\n##\n\nglibc-2.35\nPROTECT_PTR\n```cpp\n/* Safe-Linking:\n   Use randomness from ASLR (mmap_base) to protect single-linked lists\n   of Fast-Bins and TCache.  That is, mask the \"next\" pointers of the\n   lists' chunks, and also perform allocation alignment checks on them.\n   This mechanism reduces the risk of pointer hijacking, as was done with\n   Safe-Unlinking in the double-linked lists of Small-Bins.\n   It assumes a minimum page size of 4096 bytes (12 bits).  Systems with\n   larger pages provide less entropy, although the pointer mangling\n   still works.  */\n#define PROTECT_PTR(pos, ptr) \\\n  ((__typeof (ptr)) ((((size_t) pos) \u003e\u003e 12) ^ ((size_t) ptr)))\n#define REVEAL_PTR(ptr)  PROTECT_PTR (\u0026ptr, ptr)\n```\n`(pos \u003e\u003e 12) ^ ptr`\n攻撃者側は最初heapのアドレスがわからない状態から始まる\nページは4k単位なので下位3nibble(12bit)は何度実行しても変わらない(randomizeされない)\nだから3nibble分右にずらしてxorすると最大限の効果を得られる\n\nただfree済み tcacheを読めたとき\nA{\n.next = 0x7ffabcdef;\n}\nAの上位9nibble分はとれる。\n\nメモリの確保量が小さいとき、すなわちheapが1ページで収まっているとき\nAでとれた上位9nibble分の情報をそのまま使える。\n-\u003e nextに対して復元するようなXORを掛ければお終い\n\n## 参考\n- [malloc(3)のメモリ管理構造](https://www.valinux.co.jp/technologylibrary/document/linux/malloc0001/)\n- [MallocInternals - glibc wiki (sourceware.org)](https://sourceware.org/glibc/wiki/MallocInternals)\n- malloc動画 [The 67th Yokohama kernel reading party - YouTube](https://www.youtube.com/watch?v=0-vWT-t0UHg)\n- [mallocの動作を追いかける(mmap編) - Qiita](https://qiita.com/kaityo256/items/9e78b507940b2292bf79)\n- [Preface - heap-exploitation (dhavalkapil.com)](https://heap-exploitation.dhavalkapil.com/)\n- [shellphish/how2heap: A repository for learning various heap exploitation techniques. (github.com)](https://github.com/shellphish/how2heap)\n- [ヒープ系問題におけるstdout / stderrを利用したメモリリーク - CTFするぞ (hatenablog.com)](https://ptr-yudai.hatenablog.com/entry/2019/05/31/235444)","lastmodified":"2022-12-30T07:57:21.483263743Z","tags":null},"/pwn/LinuxUserland/glibc/glibc_heap/malloc_chunk":{"title":"malloc_chunk","content":"\nThis structure represents a particular chunk of memory. The various fields have different meaning for allocated and unallocated chunks.\n\n```c\nstruct malloc_chunk {\n  INTERNAL_SIZE_T      mchunk_prev_size;  /* Size of previous chunk, if it is free. */\n  INTERNAL_SIZE_T      mchunk_size;       /* Size in bytes, including overhead. */\n  struct malloc_chunk* fd;                /* double links -- used only if this chunk is free. */\n  struct malloc_chunk* bk;\n  /* Only used for large blocks: pointer to next larger size.  */\n  struct malloc_chunk* fd_nextsize; /* double links -- used only if this chunk is free. */\n  struct malloc_chunk* bk_nextsize;\n};\n\ntypedef struct malloc_chunk* mchunkptr;\n```\n\n## Allocated chunk\n\n```\n    chunk-\u003e +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n            |             Size of previous chunk, if unallocated (P clear)  |\n            +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n            |             Size of chunk, in bytes                     |A|M|P|\n      mem-\u003e +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n            |             User data starts here...                          .\n            .                                                               .\n            .             (malloc_usable_size() bytes)                      .\n            .                                                               |\nnextchunk-\u003e +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n            |             (size of chunk, but used for application data)    |\n            +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n            |             Size of next chunk, in bytes                |A|0|1|\n            +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n```\n\nNotice how the data of an allocated chunk uses the first attribute (`mchunk_prev_size`) of the next chunk. `mem` is the pointer which is returned to the user.\n\n## Free chunk\n\n        chunk-\u003e +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n                |             Size of previous chunk, if unallocated (P clear)  |\n                +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n        `head:' |             Size of chunk, in bytes                     |A|0|P|\n          mem-\u003e +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n                |             Forward pointer to next chunk in list             |\n                +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n                |             Back pointer to previous chunk in list            |\n                +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n                |             Unused space (may be 0 bytes long)                .\n                .                                                               .\n                .                                                               |\n    nextchunk-\u003e +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n        `foot:' |             Size of chunk, in bytes                           |\n                +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n                |             Size of next chunk, in bytes                |A|0|0|\n                +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\nFree chunks maintain themselves in a circular doubly linked list.\n\n**P (PREV\\_INUSE)**: 0 when previous chunk \\(not the previous chunk in the linked list, but the one directly before it in memory\\) is free \\(and hence the size of previous chunk is stored in the first field\\). The very first chunk allocated has this bit set. If it is 1, then we cannot determine the size of the previous chunk.\n\n**M (IS\\_MMAPPED)**: The chunk is obtained through `mmap`. The other two bits are ignored. `mmapped` chunks are neither in an arena, not adjacent to a free chunk.\n\n**A (NON\\_MAIN\\_ARENA)**: 0 for chunks in the main arena. Each thread spawned receives its own arena and for those chunks, this bit is set.\n\n_Note_: Chunks in fastbins are treated as _allocated_ chunks in the sense that they are not consolidated with neighboring free chunks.","lastmodified":"2022-12-30T07:57:21.483263743Z","tags":null},"/pwn/LinuxUserland/glibc/glibc_heap/malloc_state":{"title":"malloc_state","content":"\nThis structure represents the header details of an Arena. The main thread's arena is a global variable and not part of the heap segment. Arena headers (`malloc_state` structures) for other threads are themselves stored in the heap segment. Non main arenas can have multiple heaps ('heap' here refers to the internal structure used instead of the heap segment) associated with them.\n\n```c\nstruct malloc_state\n{\n  /* Serialize access.  */\n  __libc_lock_define (, mutex);\n  /* Flags (formerly in max_fast).  */\n  int flags;\n  \n  /* Fastbins */\n  mfastbinptr fastbinsY[NFASTBINS];\n  /* Base of the topmost chunk -- not otherwise kept in a bin */\n  mchunkptr top;\n  /* The remainder from the most recent split of a small request */\n  mchunkptr last_remainder;\n  /* Normal bins packed as described above */\n  mchunkptr bins[NBINS * 2 - 2];\n  \n  /* Bitmap of bins */\n  unsigned int binmap[BINMAPSIZE];\n  \n  /* Linked list */\n  struct malloc_state *next;\n  /* Linked list for free arenas.  Access to this field is serialized\n     by free_list_lock in arena.c.  */\n  struct malloc_state *next_free;\n  /* Number of threads attached to this arena.  0 if the arena is on\n     the free list.  Access to this field is serialized by\n     free_list_lock in arena.c.  */\n     \n  INTERNAL_SIZE_T attached_threads;\n  /* Memory allocated from the system in this arena.  */\n  INTERNAL_SIZE_T system_mem;\n  INTERNAL_SIZE_T max_system_mem;\n};\n\ntypedef struct malloc_state *mstate;\n```","lastmodified":"2022-12-30T07:57:21.483263743Z","tags":null},"/pwn/LinuxUserland/method":{"title":"pwn を解く為に必要なステップ","content":"\n脆弱性の種類と，その攻略方法\n\n| 段階               | 例                                                                         |\n| ------------------ | -------------------------------------------------------------------------- |\n| Vulnerabilities    | Stack BOF, Heap BOF, Use After Free, Format String Bug, Race Condition ... |\n| Exploit Techniques | ret2plt, ret2libc, ROP, GOT Overwrite, Stack pivot ...                     |\n| Anti-Exploits      | NX, ASLR, RELRO, PIE, Stack Canary ...                                     |\n\nflagを獲得する方法\n1. シェルコードを実行\n\t1. Exec-shell系\n\t2. Exec-shell + バックコネクト系\n\t3. [shellcode - Qiita](https://qiita.com/yyamada_bigtree/items/97ea176484f5b05c195d)\n2. `system(\"/bin/sh\")`や`execve(\"/bin/sh\", 0, 0)`を実行\n\t1. 必要に応じてdup2したりする\n3. open(\"flag\") -\u003e read() -\u003e write()\n\t1. サンドボックスでexec系が禁止されているケース，chrootされているケースなどで有効\n\n## バイナリ解析\n動的解析\n- gdb\n\t- gdb-peda\n\t- pwndbg\n\t- rust-gdb\n静的解析\n- Ghidra\n\t- v10.1.5が安定版 (プラグインも豊富だと思う)\n- IDA Pro (アイダプロ)\n\t- 専門家はデコンパイラの性能から Ghidra より IDA Pro の方を使いがち\n- Binary Ninja\n- WinDbg\n\t- `bp \u003caddress\u003e` : ブレークポイント\n\t- `pr` : レジスタ情報とgdbでいうnexti\n\t- `pt` : retが来るまで進める\n\t- `pctr` : レジスタ情報とcallとretが来るまで進める\n\t- `dc \u003caddress reg\u003e` : double word単位とascii文字でデータ表示\n- Immunity Debugger\n- radare2\n\nデバッグ情報\n- DWARF\n- gdbの自動的にやることでカバレッジを取れる\n- seccomp BPF\n\n必要なコマンド\n- ld: リンク先\n- patchelf: 動的ライブラリの解決\n\t- [libcにデバッグシンボルを付ける方法と自動化 - Satoooonの物置 (hatenablog.com)](https://satoooon1024.hatenablog.com/entry/2022/06/12/libc%E3%81%AB%E3%83%87%E3%83%90%E3%83%83%E3%82%B0%E3%82%B7%E3%83%B3%E3%83%9C%E3%83%AB%E3%82%92%E4%BB%98%E3%81%91%E3%82%8B%E6%96%B9%E6%B3%95%E3%81%A8%E8%87%AA%E5%8B%95%E5%8C%96)\n- objdump\n- checksec.sh\n- one_gadget\n- ROPgadget\n- ptrace\n- strace\n\n ```shell\n$ (cat out; cat) | ./a.out\n$ nm -D ./a.out | grep \" system\"\n$ strings -a -tx ./libc.so.6 | grep \"sh$\"\n$ objdump -S -M intel ./libc.so.6 --disassemble=execve\n$ ldd a.out\n$ echo -en \"\"\n$ grep -E \"\"\n$ one_gadget ./libc.so.6\n$ ROPgadget --binary ./a.out\n```\n\n## gccオプション\n\n- No RELRO: RELRO無効\n- Partial RELRO: RELRO有効かつ遅延バインド有効\n- Full RELRO: RELRO有効かつ遅延バインド無効\n\n| やること                   | オプション                                |\n|:-------------------------- |:----------------------------------------- |\n| SSP 無効                   | `-fno-stack-protector`                    |\n| SSP 有効 (default)         | `-fstack-protector`                       |\n| NX bit 無効                | `-z execstack`                            |\n| NX bit 有効 (default)      | `-z`                                      |\n| No RELRO                   | `-Wl,-z,norelro`                          |\n| Partial RELRO              | `-Wl,-z,relro,-z lazy`                    |\n| Full RELRO (default)       | `-Wl,-z,relro,-z,now`                     |\n| ASLR 無効                  | `sudo sysctl kernel.randomize_va_space=0` |\n| ASLR 有効 (default)        | `sudo sysctl kernel.randomize_va_space=2` |\n| PIE 無効                   | `-fno-pie -no-pie`                        |\n| PIE 有効 (default)         | `-fPIE -pie`                              |\n| Exec-Shield 無効           | `sudo sysctl -w kernel.exec-shield=0`     |\n| Exec-Shield 有効 (default) | `sudo sysctl -w kernel.exec-shield=1`     |\n\n","lastmodified":"2022-12-30T07:57:21.483263743Z","tags":null},"/pwn/LinuxUserland/template":{"title":"pwnテンプレート","content":"\n## 説明\n\nCTFのpwn分野で使うテンプレート。pwntoolsパッケージを使用する。\n\n## 実装\n\n```python\nfrom pwn import *\nimport sys\n\nbinary_path = './chall'\n\nif len(sys.argv) == 3:\n    io = remote(sys.argv[1], int(sys.argv[2]))\nelse:\n    io = process(binary_path)\nelf = ELF(binary_path)\n# libc = ELF(\"./libc.so.6\")\ncontext(arch='amd64', os='linux')\n\ndef wait_for_attach():\n    print('attach?')\n    raw_input()\n\n# str   -\u003e bytes: text.encode('utf-8')\n# bytes -\u003e str  : text.decode('utf-8')\n# long  -\u003e bytes(big)   : long_to_bytes(num)\n# long  -\u003e bytes(little): p64(num)\n# bytes -\u003e long(big)    : bytes_to_long(data)\n# bytes -\u003e long(little) : int.from_bytes(data, 'little')\n# bytes -\u003e int          : int(data, 16)\n\npayload = b''\nio.sendlineafter(b'\u003e ', payload)\nio.recvline()\nio.interactive()\n```\n\n## 使用例\n\n```shell\n$ python3 solve.py\n$ python3 solve.py localhost 3000\n```\n\n## 参考文献\n[shellphish/how2heap: A repository for learning various heap exploitation techniques. (github.com)](https://github.com/shellphish/how2heap)\n[Exploiting Intel Graphics Kernel Extensions on macOS | RET2 Systems Blog](https://blog.ret2.io/2022/06/29/pwn2own-2021-safari-sandbox-intel-graphics-exploit/)","lastmodified":"2022-12-30T07:57:21.483263743Z","tags":null},"/pwn/LinuxUserland/vulnssecurity":{"title":"Linux Userland のセキュリティ機構","content":"\n## Anti-Exploits\n\n### DEP (Data Execution Prevention)\n- NX bit (No eXecute bit)  read write execute protection\n- セグメント毎に実行する権限を付与するかしないかを設定する。任意のコードを挿入し実行を誘う攻撃を防御できる。\n- メモリ領域のアクセス保護オプションを書き換えるには、Windowsの場合VirtualProtectEx関数、Linuxの場合mprotect(2)が使える。\n\t- [Return-to-libcとmprotect(2)でDEPを回避してみる - ももいろテクノロジー](https://inaz2.hatenablog.com/entry/2014/04/20/010545)\n\n### RELRO (RELocation Read-Only)\nGOTは初回呼び出し時に行き先を書き込む ( 遅延バインド: lazy binding )。\n- [RELROとformat string attackによるリターンアドレス書き換え - ももいろテクノロジー](https://inaz2.hatenablog.com/entry/2014/04/30/173618)\n\n### ASLR (Address Space Layout Randomization)\nスタック領域・ヒープ領域や共有ライブラリが置かれるベースアドレスは一定の範囲の中でランダムに決められる。これらのアドレスを知るには以下のコマンドを叩く。一回目と二回目で変わることが分かる。\n\n```shell\n$ cat /proc/\u003cprocess ID\u003e/maps              // = gdbのi proc map = pwndbgのvmmap\n```\n\n- [32bit環境ASLRに対してブルートフォース + NOP sled](https://inaz2.hatenablog.com/entry/2014/03/15/073837)\n\n防御機構\n- SSP :  Stack-Smashing Protection\n- 関数呼び出し時にランダムな値(Canary)を配置し、関数から出る時に変化したか検証し、変わっていたら`__stack_chk_fail` 関数を呼び出し、強制終了させる。\n\n#### PIE (Position-Independent Executables)\n\n実行ファイルそのものが置かれるベースアドレスをランダムに決められる。\n\n1nibble brute force\n- ASLR + PIEに対する対抗策\n- ベースアドレスがランダム化しても関数・データ間のオフセットは同じであるため、例えば次のようにしてベースアドレスを取得できる。\n\t- スタックに積まれたリターンアドレスの値から、実行ファイルのベースアドレスが計算できる。\n\t- 一度呼び出されたライブラリ関数のGOTアドレスの値から、そのライブラリのベースアドレスが計算できる。\n\t- スタックに積まれたsaved ebpの値から、スタック領域に置かれる他のデータのアドレスが計算できる。\n\t- ヒープ領域に確保されたデータを指すポインタの値から、ヒープ領域のベースアドレスが計算できる。\n- ASCII-armor - Exec-Shield\n\t- 共有ライブラリのベースアドレスを0x00XXXXXXのように\\x00を含めることでret2libcを難しくする機構。\n\n対抗策\n- ライブラリ内のsystem関数ではなくsystem@pltに飛ばす(ret2plt)。\n- system@pltがなければstrcpy@pltやsnprintf@pltに飛ばして(ret2strcpy)、実行バイナリ中の1バイトで1つずつGOT overwriteし、シェルを起動する。\n\n`/etc/sysctl.conf`\n\n","lastmodified":"2022-12-30T07:57:21.483263743Z","tags":null},"/science/Biology":{"title":"生物学","content":"\n","lastmodified":"2022-12-30T07:57:21.483263743Z","tags":null},"/science/Physics/Physics":{"title":"物理学","content":"\n# 物理学\n\n## ベクトル解析\n\n[ベクトル解析ノート](https://drive.google.com/file/d/1C-eszj1VSI98aenIdvabiADAPzYHqdXA/view?usp=sharing)\n\n## 電磁気学\n\n## 解析力学\n\n波動方程式の離散化\n\n$$\n\\begin{aligned}\n\\frac{\\partial^2u}{\\partial t^2} \u0026= v^2\\left(\\frac{\\partial^2u}{\\partial x^2} + \\frac{\\partial^2u}{\\partial y^2}\\right) \\\\\n\\frac{u_{i,j}^{n+1}-2u_{i,j}^n+u_{i,j}^{n-1}}{\\Delta t^2} \u0026= v^2\\left(\\frac{u_{i,j}^{n+1}-2u_{i,j}^n+u_{i,j}^{n-1}}{\\Delta x^2} + \\frac{u_{i,j}^{n+1}-2u_{i,j}^n+u_{i,j}^{n-1}}{\\Delta y^2}\\right) \\\\\nu_{i,j}^{n+1} \u0026= 2u_{i,j}^n - u_{i,j}^{n-1} + \\Delta t^2v^2\\left(\\frac{u_{i,j}^{n+1}-2u_{i,j}^n+u_{i,j}^{n-1}}{\\Delta x^2} + \\frac{u_{i,j}^{n+1}-2u_{i,j}^n+u_{i,j}^{n-1}}{\\Delta y^2}\\right)\n\\end{aligned}\n$$\n\n## 量子力学\n","lastmodified":"2022-12-30T07:57:21.483263743Z","tags":null},"/science/math/%E4%BD%93%E8%AB%96":{"title":"体論","content":"\n$$\n\\newcommand{\\Ker}{\\operatorname{Ker}}\n\\newcommand{\\Image}{\\operatorname{Im}}\n\\newcommand{\\ch}{\\operatorname{ch}}\n\\newcommand{\\Hom}{\\operatorname{Hom}}\n\\newcommand{\\Aut}{\\operatorname{Aut}}\n\\newcommand{\\id}{\\mathrm{id}}\n\\newcommand{\\NN}{\\mathbb{N}}\n\\newcommand{\\ZZ}{\\mathbb{Z}}\n\\newcommand{\\QQ}{\\mathbb{Q}}\n\\newcommand{\\RR}{\\mathbb{R}}\n\\newcommand{\\CC}{\\mathbb{C}}\n\\newcommand{\\FF}{\\mathbb{F}}\n$$\n# 輪読会 復習\n\n## Def. 標数\n$\\phi: \\ZZ\\to K$, $n \\mapsto n\\cdot 1$\n整数は全順序集合なので順序を与えて次のように $\\phi$ を定義する.\n\n$$\n\\phi(n) =\n\\begin{cases}\n\\overbrace{1_K + \\cdots + 1_K}^{n} \u0026 (n \u003e 0) \\\\\n0_K \u0026 (n = 0) \\\\\n-\\phi(-n) \u0026 (n \u003c 0)\n\\end{cases}\n$$\n\nこのとき $\\phi$ は準同型である. $\\phi: \\ZZ\\to K$ に準同型定理を適用して $\\ZZ/\\Ker(\\phi) \\cong \\Im(\\phi)$ となり $\\Im(\\phi)$ は整域なので $\\Ker(\\phi) \\subset \\ZZ$ は素イデアルであり $(0)$ か素数 $p$ を用いて $(p)$ と表せられる. この単項イデアルを生成する元 $0$ または $p$ を標数と呼び, $\\mathrm{ch}\\ K$ と書く.\n\n### Prop. 標数の部分体\n体 $K$ が標数 $0$ なら部分体に $\\QQ$、標数 $p$ なら $\\FF_p$ がある.\nこの命題から $\\QQ$ や $\\FF_p$ を素体と呼ぶ.\n局所化の普遍性 本当に同型になるのか.\n\n**Proof.**\n標数 $0$ ならば標数の定義より $\\ZZ/(0) = \\ZZ \\cong \\Im(\\phi) \\subseteq K$ となる。 $K$ は体より $K\\backslash\\{0\\}$ の元は単元であるから $\\exists S \\subseteq K$, $\\QQ \\cong S$.\n標数 $p$ ならば $\\ZZ/(p) = \\ZZ/p\\ZZ = \\FF_p \\cong \\Im(\\phi) \\subseteq K$ となる.\n\n### Def. フロベニウス写像\n標数 $p$ の体で $q=p^n$ として $(x+y)^q = x^q+y^q, (xy)^q = x^qy^q$ より $\\mathrm{Frob}_q: x \\mapsto x^q$ は体の準同型となる。これをフロベニウス準同型という.\n\n## 拡大体\n### Prop. $K$ 上 $S$ で生成された体 $K(S)$ は体である\n\n**Proof.**\n$K[x_1,\\ldots , x_n]$ は整域であり, それを局所化すると商体となるから、有理関数体 $K(x_1,\\ldots , x_n)$ は体である.\n- $S$ が有限集合のとき\n有理関数体 $K(x_1,\\ldots , x_n)$ に代入して分母が $0$ ではないものを集めたものは体となる.\n- $S$ が無限集合のとき\n任意の有理関数体に無限集合の部分無限集合を代入した体は構成することはできない. なぜなら有理関数体には無限回の演算を伴うからである.\nこれより有限集合で生成した体の和集合は体となる.\n\n### Prop. 7.1.6\n$L/K$ を拡大体, $S\\subset L$ としたとき $T\\subset S \\implies T\\subset K(S) \\implies K(T)\\subset K(S)$\n\n**Proof.**\n$f_1,\\ldots,f_m\\in T$ が $\\alpha_1,\\ldots,\\alpha_n\\in S$ の有理式で表されるなら $f_1,\\ldots,f_m\\in T$ の有理式も $\\alpha_1,\\ldots,\\alpha_n\\in S$ の有理式で表される.\n\n### Def. 代数拡大・超越拡大\n$L$ の全ての元が $K$ 上代数的ならば $L/K$ は代数拡大, そうでなければ超越拡大という.\n\n単拡大が超越拡大になる例: $K(x)/K$, $\\QQ(\\pi)/\\QQ$, $\\QQ(e)/\\QQ$ など.\n\n### Prop. (1) $\\alpha$ は $K$ 上代数的である$\\iff$(2) $K[\\alpha]=K(\\alpha)$\n(1)$\\implies$(2)\n$\\phi\\colon K[x]\\to K[\\alpha]$ を $\\phi(x)=\\alpha$ となる $K$ 準同型を考えると $f(\\alpha)=0$ となる既約多項式を用いて $K[x]/(f(x))\\cong K[\\alpha]$ となる. $K[\\alpha]$ は整域より $(f(x))$ は素イデアルであり, $K[x]$ は単項イデアル整域であるから $(f(x))$ は極大イデアルである. よって $K[\\alpha]$ は体であり, $K[\\alpha] = K(\\alpha)$ となる.\n\n(2)$\\implies$(1)\n$\\alpha = 0$ のときは自明に $K$ 上代数的である. $\\alpha\\neq0$ のとき $\\alpha^{-1}=a_n\\alpha^n+\\ldots+a_0$ とかけるから, $a_n\\alpha^{n+1}+\\ldots+a_0\\alpha-1=0$ より $\\alpha$ は $K$ 上代数的である.\n↑これ天才\n\n### Prop. $K$ 上代数的な元 $\\alpha$ とその最小多項式 $f(x)$ において $[K(\\alpha):K] = \\deg f$ となる。\n$f(x) = x^n + a_{n-1}x^{n-1} + \\ldots + a_0$ とおくと $\\alpha^m = -\\alpha^{m-n}(a_{n-1}\\alpha^{n-1} + \\ldots + a_0)$ となるから $K[\\alpha] = K(\\alpha)$ の任意の元は $c_{n-1}\\alpha^{n-1} + \\ldots + c_0$ とかける. ここで $g(x) = c_{n-1}x^{n-1} + \\ldots + c_0$ とおくと, $g(\\alpha) = 0$ のとき, $g(x) \\neq 0$ なら最小多項式 $f(x)$ と矛盾する為, $g(x) = 0$ となる. よって $\\{\\alpha^{n-1}, \\ldots, 1\\}$ は基底であり, $[K(\\alpha):K] = \\deg f$ となる.\n\n### Prop. $L/K$ 拡大について (1) 有限生成な代数拡大$\\iff$(2) 有限次拡大\n(1)$\\implies$(2)\n有限生成な代数拡大より $L = K(\\alpha_1, \\ldots, \\alpha_n)$ とおくと $L = K(\\alpha_1)\\ldots(\\alpha_n)$ とかけ, 上の命題より単拡大かつ代数拡大は有限次拡大であるから有限回繰り返し用いて有限次拡大となる.\n\n(2)$\\implies$(1)\n$L/K$ が有限次拡大より $n = [L:K]$ とおくと $L$ を $K$ 上ベクトル空間として, その $n$ 個の基底 $\\{x_1,\\ldots,x_n\\}$ で有限生成される. また任意の元 $x\\in L$ について $m \u003e n$ が存在し, $\\{1,x,\\ldots,x^m\\}$ は一次従属となる. よって $a_0, \\ldots, a_m\\in K$ が存在し, $a_0 + \\ldots + a_mx^m = 0$ となり $x$ は代数的な元である. よって有限生成かつ代数拡大となる.\n\n### Prop. $L/M$, $M/K$ が体の代数拡大ならば, $L/K$ も体の代数拡大である\n**Proof.**\n$\\alpha\\in L$ とその $M$ 上最小多項式 $f(x)=x^n+a_1x^{n-1}+\\ldots+a_n\\in M[x]$ をおく. このとき $M' = K(a_1,\\ldots,a_n)$ とおくと $M'/K$ は有限次拡大であり $M'(\\alpha)/M'$ も有限次拡大である. よって $M'(\\alpha)/K$ は代数拡大であり, $\\alpha$ は $K$ 上代数的である.\n\n## 代数閉包\n代数拡大 任意の $\\alpha\\in K$ に対し $f(\\alpha)=0$ となる $f(x)\\in K[x]$ が存在する.\n代数閉体 任意の $f(x)\\in K[x]$ に対し, $f(\\alpha)=0$ となる $\\alpha\\in K$ が存在する.\n代数閉包 代数拡大かつ代数閉体\n\n### Prop. 代数閉包の存在\n**Proof.**\nまず $K$ を含む代数閉体が存在することを示す.\n$K[x]$ の既約多項式の集合 $P$ をおき, $f(x)\\in P$ に対し, (これから構成する拡大体での多項式の根として)1つの変数 $X_f$ を考えた無限変数の多項式環 $A = K[X_f]_{f\\in P}$ を考える.\n$f(X_f)_{f\\in P}$ で生成された $A$ 上イデアル $\\mathfrak{a}$ について $\\mathfrak{a}\\neq A$ であることを示す. $a=A$ と仮定すると, 有限和 $\\sum_{i=1}^na_if_i(X_{f_i})\\in \\mathfrak{a}$ が存在し, $\\sum_{i=1}^na_if_i(X_{f_i})=1$ を満たす. $K$ について各 $f_i(x)$ の根の1つ $\\alpha_i$ により生成された体の $X_f$ による多項式環 $K(\\alpha_1,\\ldots,\\alpha_n)[X_f]_{f\\in P}$ において $X_{f_i}$ に $\\alpha_i$ を代入することで $\\sum_{i=1}^na_if_i(X_{f_i})=0$ が成立する. また $K[X_f]_{f\\in P} \\subset K(\\alpha_1,\\ldots,\\alpha_n)[X_f]_{f\\in P}$ となる為, $\\sum_{i=1}^na_if_i(X_{f_i})=1$ は恒等的に成り立つ. よって $0 = 1$ となり矛盾する.\nこれより $\\mathfrak{a}$ を含む極大イデアル $\\mathfrak{m}$ が存在し, $K_1 = A/\\mathfrak{m}$ は体となる. $P$ の既約多項式 $f(x)$ に $\\alpha = X_f+\\mathfrak{m}$ を代入することで $f(X_f) \\in \\mathfrak{a} \\subset \\mathfrak{m}$ より $f(\\alpha) = f(X_f) + \\mathfrak{m} = 0 + \\mathfrak{m}$ であるから, 任意の $K[x]$ 上既約多項式は $K_1$ で根を持つ. また $X_f\\in K_1$ は $K$ 上代数的であるから $K_1/K$ は代数拡大である.\n\n$K_0=K$ とおいて $K_0$ から $K_1$ を構成したように $K_i$ から $K_{i+1}$ を構成でき, 集合列 $K_0\\subset K_1\\subset K_2\\subset\\ldots$ を作る. $\\overline{K}=\\bigcup_{i=0}^{\\infty}K_i$ とおくと $\\overline{K}$ は代数拡大である. $\\overline{K}$ が代数閉体であることを示す.\n$f(x)\\in\\overline{K}[x]\\backslash\\overline{K}$ について, ある $i$ が存在し, $f(x)\\in K_i[x]$ となる. すると $K_{i+1}$ において $f(x)$ の根 $\\alpha$ が存在する. よって $\\overline{K}$ が代数閉体となるから, $\\overline{K}$ は代数閉包である.\n\n### Prop. $L_1\\subset M_1\\subset K_1$, $L_2\\subset M_2\\subset K_2$ が $K$ の代数拡大で, $L_1$, $L_2$ は代数閉体, $\\phi\\colon M_1\\to M_2$ は $K$ 上同型とする. このとき, $K$ 上同型 $\\psi\\colon L_1\\to L_2$ で $\\phi$ を拡張するものが存在する.\n\n$X$ を $L_1/M_1$ の中間体 $F$ と $\\phi$ の拡張になっている $K$ 同型 $\\psi \\colon F\\to L_2$ の組 $(F, \\psi)$ の集合とする.\n$X$ について順序を定める. $(F_1, \\psi_1), (F_2, \\psi_2)\\in X$ に対し, $F_1\\subset F_2$ かつ $\\psi_2$ が $\\psi_1$ の拡張となっているとき, $(F_1, \\psi_1) \\leq (F_2, \\psi_2)$ とすると順序となる.\n$X$ の任意の全順序部分集合 $Y$ に対し, $F_0 = \\bigcup_{(F,\\psi)\\in Y} F$ とおく. $x\\in F_0$ なら $x\\in F$ となる組 $(F,\\psi)$ が存在し $\\psi_0(x) = \\psi(x)$ とおく. このとき, $(F_0, \\psi_0)$ は $Y$ は上界となる. よって, ツォルンの補題より $X$ に極大元 $(F_{max}, \\psi_{max})$ が存在する.\nもし $L_1 \\neq F_{max}$ なら, $\\alpha\\in L_1\\backslash F_{max}$ をとって $\\psi_{max}$ の拡張である $\\psi'_{max}$ 極大元より大きい元 $(F_{max}(\\alpha), \\psi'_{max})$\n$F_{max}(\\alpha)\\cong F_{max}[x]/(f(x))\\cong\\phi_{max}(F_{max})[x]/(\\psi(f(x)))\\cong \\phi_{max}(F_{max})(\\beta)$\n\n\n\n[疑問] $\\mathbb{F}_2[x]$ 上で $f(x)=(x-\\alpha)^2, f'(x)=0$ は重根であるのか?\n雪江代数2の系3.3.4について互いに素または $f'(x)=0$ として場合分けすれば同様に証明できる. 多分gcdが定義できないときも互いに素と言っていそう.\n","lastmodified":"2022-12-30T07:57:21.487263721Z","tags":null},"/science/math/%E5%9C%8F%E8%AB%96":{"title":"圏論","content":"\n\n淡中圏 ガロア理論\nテイト・シャファレヴィッチ群\n\n```tikz\n\\usepackage{tikz-cd}\n\n\\begin{document}\n\\begin{tikzcd}\n\n    T\n    \\arrow[drr, bend left, \"x\"]\n    \\arrow[ddr, bend right, \"y\"]\n    \\arrow[dr, dotted, \"{(x,y)}\" description] \u0026 \u0026 \\\\\n    K \u0026 X \\times_Z Y \\arrow[r, \"p\"] \\arrow[d, \"q\"]\n    \u0026 X \\arrow[d, \"f\"] \\\\\n    \u0026 Y \\arrow[r, \"g\"]\n    \u0026 Z\n\n\\end{tikzcd}\n\n\\quad \\quad\n\n\\begin{tikzcd}[row sep=2.5em]\n\nA' \\arrow[rr,\"f'\"] \\arrow[dr,swap,\"a\"] \\arrow[dd,swap,\"g'\"] \u0026\u0026\n  B' \\arrow[dd,swap,\"h'\" near start] \\arrow[dr,\"b\"] \\\\\n\u0026 A \\arrow[rr,crossing over,\"f\" near start] \u0026\u0026\n  B \\arrow[dd,\"h\"] \\\\\nC' \\arrow[rr,\"k'\" near end] \\arrow[dr,swap,\"c\"] \u0026\u0026 D' \\arrow[dr,swap,\"d\"] \\\\\n\u0026 C \\arrow[rr,\"k\"] \\arrow[uu,\u003c-,crossing over,\"g\" near end]\u0026\u0026 D\n\n\\end{tikzcd}\n\n\\end{document}\n```\n\n[数学 | 壱大整域 (alg-d.com)](http://alg-d.com/math/)","lastmodified":"2022-12-30T07:57:21.487263721Z","tags":null},"/science/math/Math":{"title":"数学","content":"\n# 数学\n各単元を下の階層で証明する. ここでは重要な定義と本質をまとめる.\n\n## 数学基礎論\n\n[数学基礎論ノート](https://drive.google.com/file/d/1NlaVJEUUf_jEIPLkx6i4JgU9X47J4nat/view?usp=sharing)\n\n## 集合論\n- 全順序集合\n- 同値類\n- 濃度\n\n## 群論\n- 群・正規部分群\n**群**: 単位元, 逆元のある結合的な演算を持つ集合\n**ラグランジュの定理** $|G_1|=|G_2|(G_1:G_2)$\n準同型\n**準同型定理** $G/\\Ker(\\phi)\\cong\\Image(\\phi)$\n- 群の作用\n**Sylow の定理** p-Sylow 部分群の数 $s=|G|/|N_G(H)|=1\\pmod{p}$\n**有限アーベル群の構造定理** $G\\cong\\ZZ/a_1\\ZZ\\times\\ldots\\times\\ZZ/a_n\\ZZ$\n\n## 環・加群\n- 環・イデアル\n**環準同型定理** $A/\\Ker(\\phi)\\cong\\Image(\\phi)$\n- 多項式環\n- 素イデアル・極大イデアル\n**中国剰余定理**\n- 局所化\n- 一意分解環, 単項イデアル整域, ユークリッド環\n環$\\impliedby$可換環$\\impliedby$整域$\\impliedby$正規環$\\impliedby$UFD(一意分解環)$\\impliedby$PID(単項イデアル整域)$\\impliedby$ユークリッド環$\\impliedby$体\n- 加群\n\n## 体論\n- 代数拡大・超越拡大\n有限次拡大$\\iff$有限生成の代数拡大\n- 代数閉包\n**Steinitz の定理**\n- 分離拡大・正規拡大\n既約な非分離多項式 $f(x)\\in K[x]$ $\\iff$$\\ch K=p\u003e0$ であり, 既約な分離多項式 $g(x)\\in K[x]$ と $n\u003e0$ があり, $f(x)=g(x^{p^n})$ となる.\n- Galois 理論\n**Galois の基本定理**\n\n## 代数的整数論\n\n## 代数幾何学\n\n## 圏論\n- 圏論の基本\n**米田の補題**\n```tikz\n\\usepackage{tikz-cd}\n\n\\begin{document}\n\\begin{tikzcd}\n    F(y) \\arrow[r, \"\\phi(y)\"] \\arrow[d, \"F(f)\"] \u0026 G(y)=Hom_{Sets^{C^{op}}}(h_y,F) \\arrow[d, \"G(f)\"] \\\\\n    F(x) \\arrow[r, \"\\phi(x)\"] \u0026 G(x)=Hom_{Sets^{C^{op}}}(h_x,F)\n\\end{tikzcd}\n\\end{document}\n```\n\n## 楕円曲線\n- pairing\n","lastmodified":"2022-12-30T07:57:21.483263743Z","tags":null},"/science/math/PropositionalLogic":{"title":"命題論理","content":"\n## 推論規則\n\n```=\nMP: Modus Ponens\nP -\u003e Q\nP\n------\nQ\n\nMT: Modus Tollens\nP -\u003e Q\n~Q\n------\n~P\n\nDN: Double Negation\nP\n------\n~~P\n\n~~P\n------\nP\n\nR: Repetition\nP\n------\nP\n\nAdj: Adjunction\nP\nQ\n------\nP ∧ Q\n\nS: Simplification\nP ∧ Q\n------\nP\n\nP ∧ Q\n------\nQ\n\nAdd: Addition\nP\n------\nP ∨ Q\n\nQ\n------\nP ∨ Q\n\nMTP: Modus Tollendo Ponens\nP ∨ Q\n~P\n------\nQ\n\nP ∨ Q\n~Q\n------\nP\n\nCB: Conditional-Biconditional\nP -\u003e Q\nQ -\u003e P\n-------\nP \u003c-\u003e Q\n\nBC: Binconditional-Conditional\nP \u003c-\u003e Q\n-------\nP -\u003e Q\n\nP \u003c-\u003e Q\n-------\nQ -\u003e P\n```\n\n## 証明\n\n`P -\u003e Q, ~P -\u003e Q ∴ Q`\n```=\nShow Q\n     ~Q        AssID\n     P -\u003e Q    Pr\n     ~P -\u003e Q   Pr\n     ~P        2,3MT\n     ~~P       2,4MT\n5,6ID\n```\n\n`P -\u003e (R -\u003e ~Q), Q ∴ P -\u003e ~R`\n```=\nShow P -\u003e ~R\n     P              AssCD\n     P -\u003e (R -\u003e ~Q) Pr\n     Q              Pr\n     R -\u003e ~Q        2,3MP\n     ~~Q            4DN\n     ~R             5,6MT\n7CD\n```\n\n`~P ∧ ~Q ∴ ~(P ∨ Q)`\n```=\nShow ~(P ∨ Q)\n     ~~(P ∨ Q) AssID\n     P ∨ Q     2DN\n     ~P ∧ ~Q   Pr\n     ~P        4S\n     Q         3,5MTP\n     ~Q        4S\n6,7ID\n```\n\n`P ∨ Q -\u003e R ∴ P -\u003e R ∨ Q`\n```=\nShow P -\u003e R ∨ Q\n     P          AssCD\n     P ∨ Q -\u003e R Pr\n     P ∨ Q      2Add\n     R          3,4MP\n     R ∨ Q      5Add\n6CD\n```\n\n`P -\u003e Q, ~Q ∴ ~P`\n```=\nShow ~P\n     ~~P    AssID\n     P      2DN\n     P -\u003e Q Pr\n     ~Q     Pr\n     Q      3,4MP\n5,6ID\n```\n\n`P, ~P ∴ Q`\n```=\nShow Q\n     P     Pr\n     P ∨ Q 2Add\n     ~P    Pr\n     Q     3,4MTP\n5DD\n```\n\n`(P -\u003e ~Q) -\u003e ~T, ~Q ∴ ~T`\n```=\nShow ~T\n     ~~T             AssID\n     (P -\u003e ~Q) -\u003e ~T Pr\n     ~Q              Pr\n     ~(P -\u003e ~Q)      2,3MTP\n     Show P -\u003e ~Q\n          P          AssCD\n          ~Q         4R\n     8CD\n5,6ID\n```\n\n`W, (P -\u003e W) -\u003e (R -\u003e T) ∴ ~T -\u003e (Q -\u003e ~R)`\n```=\nShow ~T -\u003e (Q -\u003e ~R)\n     ~T                   AssCD\n     W                    Pr\n     (P -\u003e W) -\u003e (R -\u003e T) Pr\n     Show P -\u003e W\n          P               AssCD\n          W               3R\n     7CD\n     R -\u003e T               4,5MP\n     ~R                   2,9MTP\n     Show Q -\u003e ~R\n          Q               AssCD\n          ~R              10R\n     13CD\n11CD\n```\n\n\nここから自明なDNは省略する.\n\n`~(P -\u003e Q) -\u003e ~(R -\u003e S), S -\u003e ~Q ∴ P -\u003e ~S`\n```=\nShow P -\u003e ~S\n     P                      AssCD\n     ~(P -\u003e Q) -\u003e ~(R -\u003e S) Pr\n     S -\u003e ~Q                Pr\n     Show ~S\n          S                 AssID\n          ~Q                4,6MP\n          Show ~(P -\u003e Q)\n               P -\u003e Q       AssID\n               Q            2,9MP\n               ~Q           7R\n          10,11ID\n          ~(R -\u003e S)         3,8MP\n          Show R -\u003e S\n               R            AssCD\n               S            6R\n          16CD\n     13,14ID\n5CD\n```\n\n`(P -\u003e Q) -\u003e R, ~R ∴ ~Q`\n```=\nShow ~Q\n     Q             AssID\n     (P -\u003e Q) -\u003e R Pr\n     ~R            Pr\n     Show P -\u003e Q\n          P        AssCD\n          Q        2R\n     7CD\n     R             3,5MP\n4,9ID\n```\n\n`(R -\u003e S) -\u003e P, ~S -\u003e Q ∴ ~P -\u003e Q`\n```=\nShow ~P -\u003e Q\n     ~P            AssCD\n     (R -\u003e S) -\u003e P Pr\n     ~S -\u003e Q       Pr\n     Show Q\n          ~Q       AssID\n          S        4,6MT\n          Show R -\u003e S\n               R   AssCD\n               S   7R\n          10CD\n          P        3,8MP\n          ~P       2R\n     12,13ID\n5CD\n```\n\n`(Q -\u003e ~~S) -\u003e (~R -\u003e ~S) ∴ S -\u003e R`\n```=\nShow S -\u003e R\n     S                        AssCD\n     (Q -\u003e ~~S) -\u003e (~R -\u003e ~S) Pr\n     ~~S                      2DN\n     Show Q -\u003e ~~S\n          Q                   AssCD\n          ~~S                 4R\n     7CD\n     ~R -\u003e ~S                 3,5MP\n     R                        4,9MT\n10CD\n```\n\n`(P -\u003e Q) -\u003e (T -\u003e R), U -\u003e ~R, ~(S -\u003e P) ∴ U -\u003e ~T`\n```=\nShow U -\u003e ~T\n     U                      AssCD\n     (P -\u003e Q) -\u003e (T -\u003e R)   Pr\n     U -\u003e ~R                Pr\n     ~(S -\u003e P)              Pr\n     ~R                     2,4MP\n     Show ~T\n          T                 AssID\n          Show ~(T -\u003e R)\n               T -\u003e R       AssID\n               R            8,10MP\n               ~R           6R\n          11,12ID\n          ~(P -\u003e Q)         3,9MT\n          Show P -\u003e Q\n               P            AssCD\n               Show S -\u003e P\n                    S       AssCD\n                    P       16R\n               19CD\n               (S -\u003e P) ∨ Q 17Add\n               Q            5,21MTP\n          22CD\n     14,15ID\n7CD\n```\n\n`(~Q -\u003e S) -\u003e P, ~R -\u003e Q, R -\u003e S ∴ P`\n```=\nShow P\n     ~P             AssID\n     (~Q -\u003e S) -\u003e P Pr\n     ~R -\u003e Q        Pr\n     R -\u003e S         Pr\n     ~(~Q -\u003e S)     2,3MT\n     Show ~Q -\u003e S\n          ~Q        AssCD\n          R         4,8MT\n          S         5,9MP\n     10CD\n6,7ID\n```\n\n`P -\u003e (Q -\u003e R), P -\u003e (~Q -\u003e R), ~P -\u003e (Q -\u003e R), ~P -\u003e (~Q -\u003e R) ∴ R`\n```=\nShow R\n     ~R              AssID\n     P -\u003e (Q -\u003e R)   Pr\n     P -\u003e (~Q -\u003e R)  Pr\n     ~P -\u003e (Q -\u003e R)  Pr\n     ~P -\u003e (~Q -\u003e R) Pr\n     Show P\n          ~P         AssID\n          Q -\u003e R     5,8MP\n          ~Q -\u003e R    6,8MP\n          ~Q         2,9MT\n          ~~Q        2,10MT\n     11,12ID\n     Q -\u003e R          3,7MP\n     ~Q -\u003e R         4,7MP\n     ~Q              2,14MT\n     ~~Q             2,15MT\n16,17ID\n```\n\n`(P -\u003e Q) -\u003e ~(Q -\u003e P) ∴ P -\u003e ~Q`\n```=\nShow P -\u003e ~Q\n     P                     AssCD\n     (P -\u003e Q) -\u003e ~(Q -\u003e P) Pr\n     Show ~Q\n          Q                AssID\n          Show P -\u003e Q\n               P           AssCD\n               Q           5R\n          8CD\n          ~(Q -\u003e P)        3,6MP\n          Show Q -\u003e P\n               Q           AssCD\n               P           2R\n          13CD\n     10,11ID\n4CD\n```\n\n`(P -\u003e Q) -\u003e (R -\u003e S), (Q -\u003e P) -\u003e (R -\u003e S) ∴ ~S -\u003e ~R`\n```=\nShow ~S -\u003e ~R\n     ~S                          AssCD\n     (P -\u003e Q) -\u003e (R -\u003e S)        Pr\n     (Q -\u003e P) -\u003e (R -\u003e S)        Pr\n     Show ~R\n          R                      AssID\n          Show P -\u003e Q\n               P                 AssCD\n               Show Q\n                    ~Q           AssID\n                    Show Q -\u003e P\n                         Q       AssCD\n                         P       8R\n                    13CD\n                    R -\u003e S       4,11MP\n                    ~R           2,15MT\n                    R            6R\n               16,17ID\n          9CD\n          R -\u003e S                 3,7MP\n          ~R                     2,20MT\n     6,21ID\n5CD\n```\n\n対偶律\n`∴ (P -\u003e Q) \u003c-\u003e (~Q -\u003e ~P)`\n```=\nShow (P -\u003e Q) \u003c-\u003e (~Q -\u003e ~P)\n     Show (P -\u003e Q) -\u003e (~Q -\u003e ~P)\n          P -\u003e Q             AssCD\n          Show ~Q -\u003e ~P\n               ~Q            AssCD\n               ~P            3,5MT\n          6CD\n     4CD\n     Show (~Q -\u003e ~P) -\u003e (P -\u003e Q)\n          ~Q -\u003e ~P           AssCD\n          Show P -\u003e Q\n               P             AssCD\n               ~~P           12DN\n               ~~Q           10,13MT\n               Q             14DN\n          15CD\n     11CD\n     (P -\u003e Q) \u003c-\u003e (~Q -\u003e ~P) 2,9CB\n18DD\n```\n\n排中律\n`∴ P ∨ ~P`\n```=\nShow P ∨ ~P\n     ~(P ∨ ~P)      AssID\n     Show P\n          ~P        AssID\n          P ∨ ~P    4Add\n          ~(P ∨ ~P) 2R\n     5,6ID\n     P ∨ ~P         3Add\n2,8ID\n```\n\nCDJ\n`∴ P ∨ Q \u003c-\u003e (~P -\u003e Q)`\n```=\nShow P ∨ Q \u003c-\u003e (~P -\u003e Q)\n     Show P ∨ Q -\u003e (~P -\u003e Q)\n          P ∨ Q         AssCD\n          Show ~P -\u003e Q\n               ~P       AssCD\n               Q        3,5MTP\n          6CD\n     4CD\n     Show (~P -\u003e Q) -\u003e P ∨ Q\n          ~P -\u003e Q       AssCD\n          Show P ∨ Q\n               ~(P ∨ Q) AssID\n               ~P ∧ ~Q  12DM\n               ~P       13S\n               Q        10,14MP\n               ~Q       13S\n          15,16ID\n     11CD\n     P ∨ Q \u003c-\u003e (~P -\u003e Q) 2,9CB\n19DD\n```\n\nド・モルガン則\n`∴ ~(P ∧ Q) \u003c-\u003e ~P ∨ ~Q`\n```=\nShow ~(P ∧ Q) \u003c-\u003e ~P ∨ ~Q\n     Show ~(P ∧ Q) -\u003e ~P ∨ ~Q\n          ~(P ∧ Q)                AssCD\n          Show ~P ∨ ~Q\n               ~(~P ∨ ~Q)         AssID\n               Show ~P\n                    ~~P           AssID\n                    P             7DN\n                    Show ~Q\n                         ~~Q      AssID\n                         Q        10DN\n                         P ∧ Q    8,11Adj\n                         ~(P ∧ Q) 3R\n                    12,13ID\n                    ~P ∨ ~Q       9Add    \n                    ~(~P ∨ ~Q)    5R\n               ~P ∨ ~Q            6Add\n          4CD\n     Show ~P ∨ ~Q -\u003e ~(P ∧ Q)\n          ~P ∨ ~Q                 AssCD\n          Show ~(P ∧ Q)\n               ~~(P ∧ Q)          AssID\n               P ∧ Q              22DN\n               P                  23S\n               ~~P                24DN\n               ~Q                 20,25MTP\n               Q                  23S\n          26,27ID\n     21CD\n     ~(P ∧ Q) \u003c-\u003e ~P ∨ ~Q         2,19CB\n30DD\n```\n\nド・モルガン則\n`∴ ~(P ∨ Q) \u003c-\u003e ~P ∧ ~Q`\n```=\nShow ~(P ∨ Q) \u003c-\u003e ~P ∧ ~Q\n     Show ~(P ∨ Q) -\u003e ~P ∧ ~Q\n          ~(P ∨ Q)        AssCD\n          Show ~P\n               P          AssID\n               P ∨ Q      5Add\n               ~(P ∨ Q)   3R\n          6,7ID\n          Show ~Q\n               Q          AssID\n               P ∨ Q      10Add\n               ~(P ∨ Q)   3R\n          11,12ID\n          ~P ∧ ~Q         4,9Adj\n     14CD\n     Show ~P ∧ ~Q -\u003e ~(P ∨ Q)\n          ~P ∧ ~Q         AssCD\n          Show ~(P ∨ Q)\n               ~~(P ∨ Q)  AssID\n               P ∨ Q      19DN\n               ~P         17S\n               Q          20,21MTP\n               ~Q         17S\n          22,23ID\n     18CD\n     ~(P ∨ Q) \u003c-\u003e ~P ∧ ~Q 2,16CB\n26DD\n```\n\n定理\n`∴ Q -\u003e (P -\u003e Q)`\n```=\nShow Q -\u003e (P -\u003e Q)\n     Q      AssCD\n     Show P -\u003e Q\n          P AssCD\n          Q 2R\n     5CD\n3CD\n```\n\n```\nDM: De Morgan\n~(P ∨ Q)\n--------\n~P ∧ ~Q\n\n~(P ∧ Q)\n--------\n~P ∨ ~Q\n\nCDJ\n~P -\u003e Q\n--------\nP ∨ Q\n```\n\n`∴ P ∨ (Q ∧ R) -\u003e (P ∨ Q) ∧ (P ∨ R)`\n```=\nShow P ∨ (Q ∧ R) -\u003e (P ∨ Q) ∧ (P ∨ R)\n     P ∨ (Q ∧ R)        AssCD\n     Show P ∨ Q\n          ~(P ∨ Q)      AssID\n          ~P ∧ ~Q       4DM\n          ~P            5S\n          Q ∧ R         2,6MTP\n          Q             7S\n          ~Q            5S\n     8,9ID\n     Show P ∨ R\n          ~(P ∨ R)      AssID\n          ~P ∧ ~R       12DM\n          ~P            13S\n          Q ∧ R         2,14MTP\n          R             15S\n          ~R            13S\n     16,17ID\n     (P ∨ Q) ∧ (P ∨ R)  3,11Adj\n19CD\n```\n\n`∴ (P ∨ Q) ∧ (P ∨ R) -\u003e P ∨ (Q ∧ R)`\n```=\nShow (P ∨ Q) ∧ (P ∨ R) -\u003e P ∨ (Q ∧ R)\n     (P ∨ Q) ∧ (P ∨ R)    AssCD\n     Show P ∨ (Q ∧ R)\n          ~(P ∨ (Q ∧ R))  AssID\n          ~P ∧ ~(Q ∧ R)   4DM\n          ~P              5S\n          P ∨ Q           2S\n          P ∨ R           2S\n          Q               6,7MTP\n          R               6,8MTP\n          Q ∧ R           9,10Adj\n          ~(Q ∧ R)        5S\n     11,12ID\n3CD\n```\n\n`∴ P ∧ (Q ∨ R) -\u003e (P ∧ Q) ∨ (P ∧ R)`\n```=\nShow P ∧ (Q ∨ R) -\u003e (P ∧ Q) ∨ (P ∧ R)\n     P ∧ (Q ∨ R)               AssCD\n     Show (P ∧ Q) ∨ (P ∧ R)\n          ~((P ∧ Q) ∨ (P ∧ R)) AssID\n          ~(P ∧ Q) ∧ ~(P ∧ R)  4DM\n          ~(P ∧ Q)             5S\n          ~P ∨ ~Q              6DM\n          P                    2S\n          ~Q                   7,8MTP\n          Q ∨ R                2S\n          R                    9,10MTP\n          ~(P ∧ R)             5S\n          ~P ∨ ~R              12DM\n          ~R                   8,13MTP\n     11,13ID\n3CD\n```\n\n`∴ (P ∧ Q) ∨ (P ∧ R) -\u003e P ∧ (Q ∨ R)`\n```=\nShow (P ∧ Q) ∨ (P ∧ R) -\u003e P ∧ (Q ∨ R)\n     (P ∧ Q) ∨ (P ∧ R) AssCD\n     Show P\n          ~P           AssID\n          ~P ∨ ~R      4Add\n          ~(P ∧ R)     5DM\n          P ∧ Q        2,6MTP\n          P            7S\n     4,8ID\n     Show Q ∨ R\n          ~(Q ∨ R)     AssID\n          ~Q ∧ ~R      11DM\n          ~R           12S\n          ~P ∨ ~R      13Add\n          ~(P ∧ R)     14DM\n          P ∧ Q        2,15MTP\n          Q            16S\n          ~Q           12S\n     17,18ID\n     P ∧ (Q ∨ R)       3,10Adj\n20CD\n```\n\n`∴ P ∧ (Q ∨ R) -\u003e (P ∧ Q) ∨ (P ∧ R)`\n```=\nShow P ∧ (Q ∨ R) -\u003e (P ∧ Q) ∨ (P ∧ R)\n     P ∧ (Q ∨ R)               AssCD\n     Show (P ∧ Q) ∨ (P ∧ R)\n          ~((P ∧ Q) ∨ (P ∧ R)) AssID\n          ~(P ∧ Q) ∧ ~(P ∧ R)  4DM\n          ~(P ∧ Q)             5S\n          ~(P ∧ R)             5S\n          ~P ∨ ~Q              6DM\n          ~P ∨ ~R              7DM\n          P                    2S\n          ~Q                   8,10MTP\n          ~R                   9,10MTP\n          ~Q ∧ ~R              11,12Adj\n          ~(Q ∨ R)             13DM\n          Q ∨ R                2S\n     14,15ID\n3CD\n```\n\n`P ∧ Q -\u003e R ∨ S ∴ (~P ∨ R) ∨ (Q -\u003e S)`\n```=\nShow (~P ∨ R) ∨ (Q -\u003e S)\n     ~((~P ∨ R) ∨ (Q -\u003e S)) AssID\n     ~(~P ∨ R) ∧ ~(Q -\u003e S)  2DM\n     P ∧ Q -\u003e R ∨ S         Pr\n     ~(~P ∨ R)              3S\n     P ∧ ~R                 5DM\n     ~(Q -\u003e S)              3S\n     Show Q ∧ ~S\n          ~(Q ∧ ~S)         AssID\n          ~Q ∨ S            9DM\n          Q -\u003e S            10CDJ\n          ~(Q -\u003e S)         7R\n     11,12ID\n     P                      6S\n     Q                      8S\n     P ∧ Q                  14,15Adj\n     R ∨ S                  4,16MP\n     ~R                     6S\n     S                      17,18MTP\n     ~S                     8S\n19,20ID\n```\n\n`(P ∧ Q) ∨ (P ∧ ~R), R ∨ ~P ∴ Q`\n```=\nShow Q\n     ~Q                 AssID\n     (P ∧ Q) ∨ (P ∧ ~R) Pr\n     R ∨ ~P             Pr\n     ~P ∨ ~Q            2Add\n     ~(P ∧ Q)           5DM\n     P ∧ ~R             3,6MTP\n     ~(P ∧ ~R)          4DM\n7,8ID\n```\n\n`P ∨ Q, P -\u003e S, Q \u003c-\u003e T ∴ S ∨ T`\n```=\nShow S ∨ T\n     ~(S ∨ T)  AssID\n     ~S ∧ ~T   2DM\n     P ∨ Q     Pr\n     P -\u003e S    Pr\n     Q \u003c-\u003e T   Pr\n     Q -\u003e T    6BC\n     ~T        3S\n     ~Q        7,8MT\n     P         4,9MTP\n     S         5,10MP\n     ~S        3S\n11,12ID\n```\n\n`~(P ∧ R) -\u003e (S -\u003e R) ∴ R ∨ ~S`\n```=\nShow R ∨ ~S\n     ~(R ∨ ~S)            AssID\n     ~R ∧ S               2DM\n     ~(P ∧ R) -\u003e (S -\u003e R) Pr\n     ~R                   3S\n     ~P ∨ ~R              5Add\n     ~(P ∧ R)             6DM\n     S -\u003e R               7MP\n     S                    3S\n     R                    8,9MP\n5,10ID\n```\n\n`(Q ∧ ~T) ∨ ~(T -\u003e Q) ∴ (P -\u003e Q) ∨ (T ∨ R)`\n```=\nShow (P -\u003e Q) ∨ (T ∨ R)\n     ~((P -\u003e Q) ∨ (T ∨ R)) AssID\n     ~(P -\u003e Q) ∧ ~(T ∨ R)  2DM\n     (Q ∧ ~T) ∨ ~(T -\u003e Q)  Pr\n     ~(T ∨ R)              4S\n     ~T ∧ ~R               5DM\n     ~T                    6S\n     ~T ∨ Q                7Add\n     T -\u003e Q                8CDJ\n     Q ∧ ~T                3,9MTP\n     Q                     10S\n     ~P ∨ Q                11Add\n     P -\u003e Q                12CDJ\n     ~(P -\u003e Q)             4S\n13,14ID\n```\n\n`(P \u003c-\u003e Q ∧ S) ∨ (P \u003c-\u003e R ∧ T) ∴ P -\u003e Q ∨ R`\n```=\nShow P -\u003e Q ∨ R\n     P                             AssCD\n     (P \u003c-\u003e Q ∧ S) ∨ (P \u003c-\u003e R ∧ T) Pr\n     Show Q ∨ R\n          ~(Q ∨ R)                 AssID\n          ~Q ∧ ~R                  5DM\n          ~Q                       6S\n          ~R                       6S\n          ~Q ∨ ~S                  7Add\n          ~R ∨ ~T                  8Add\n          ~(Q ∧ S)                 9DM\n          ~(R ∧ T)                 10DM\n          P ∧ ~(Q ∧ S)             2,11Adj\n          P ∧ ~(R ∧ T)             2,12Adj\n          ~(~P ∨ (Q ∧ S))          13DM\n          ~(~P ∨ (R ∧ T))          14DM\n          Show ~(P \u003c-\u003e (Q ∧ S))\n               P \u003c-\u003e (Q ∧ S)       AssID\n               P -\u003e (Q ∧ S)        18BC\n               ~P ∨ (Q ∧ S)        19CDJ\n               ~(~P ∨ (Q ∧ S))     15R\n          20,21ID\n          Show ~(P \u003c-\u003e (R ∧ T))\n               P \u003c-\u003e (R ∧ T)       AssID\n               P -\u003e (R ∧ T)        24BC\n               ~P ∨ (R ∧ T)        25CDJ\n               ~(~P ∨ (R ∧ T))     16R\n          26,27ID\n          P \u003c-\u003e R ∧ T              3,17MTP\n     23,29ID\n4CD\n```\n\n`~(P \u003c-\u003e Q), ~(P \u003c-\u003e R) ∴ Q \u003c-\u003e R`\n```=\nShow Q \u003c-\u003e R\n     ~(P \u003c-\u003e Q)                          Pr\n     ~(P \u003c-\u003e R)                          Pr\n     Show Q -\u003e R\n          Q                              AssCD\n          Show R\n               ~R                        AssID\n               Show P -\u003e Q\n                    P                    AssCD\n                    Q                    5R\n               10CD\n               Show Q -\u003e P\n                    Q                    AssCD\n                    Show P\n                         ~P              AssID\n                         Show P \u003c-\u003e R\n                              Show P -\u003e R\n                                   P     AssCD\n                                   P ∨ R 18Add\n                                   R     15,19MTP\n                              20CD\n                              Show R -\u003e P\n                                   R     AssCD\n                                   P ∨ R 23Add\n                                   P     7,24MTP\n                              25CD\n                              P \u003c-\u003e R    17,22CB\n                         27DD\n                         ~(P \u003c-\u003e R)      3R\n                    16,29ID\n               14CD\n               P \u003c-\u003e Q                   8,12CB\n               ~(P \u003c-\u003e Q)                2R\n          32,33ID\n     6CD\n     Show R -\u003e Q\n          R                              AssCD\n          Show Q\n               ~Q                        AssID\n               Show P -\u003e R\n                    P                    AssCD\n                    R                    37R\n               42CD\n               Show R -\u003e P\n                    R                    AssCD\n                    Show P\n                         ~P              AssID\n                         Show P \u003c-\u003e Q\n                              Show P -\u003e Q\n                                   P     AssCD\n                                   P ∨ Q 50Add\n                                   Q     47,51MTP\n                              52CD\n                              Show Q -\u003e P\n                                   Q     AssCD\n                                   P ∨ Q 55Add\n                                   P     39,56MTP\n                              57CD\n                              P \u003c-\u003e Q    49,54CB\n                         59DD\n                         ~(P \u003c-\u003e Q)      2R\n                    48,61ID\n               46CD\n               P \u003c-\u003e R                   40,44CB\n               ~(P \u003c-\u003e R)                3R\n          64,65ID\n     38CD\n     Q \u003c-\u003e R                             4,36CB\n68DD\n```\n\n","lastmodified":"2022-12-30T07:57:21.483263743Z","tags":null},"/science/math/Semantics":{"title":"意味論","content":"\n## 定義\n\n統語論的方法だと推論が正しくないことを証明できない.\n意味論的方法で正しい推論とは、前提が真であるならば、結論も必ず真である推論である.\n推論が意味論的方法において正しいことを、その推論は意味論的に妥当であるという.\n\n推論の正否を判定する二つの方法: 統語論的方法と意味論的方法は一致するかどうかを考える.\n- 健全性: 統語論的に正しい $\\implies$ 意味論的に正しい\n- 完全性: 意味論的に正しい $\\implies$ 統語論的に正しい\n\n$\\phi_1,\\ldots,\\phi_n \\vdash \\psi$\n$\\iff$ 前提 $\\phi_1,\\ldots,\\phi_n$ から、結論 $\\psi$ を導出する演繹が存在する.\n\n$\\phi_1,\\ldots,\\phi_n \\vDash \\psi$\n$\\iff$ 前提 $\\phi_1,\\ldots,\\phi_n$ から結論 $\\psi$ を得る推論が意味論的に妥当である.\n$\\iff$ その真理表において, すべての前提 $(\\phi_1,\\ldots,\\phi_n)$ が真でありかつ結論 $\\psi$ が偽である行が存在しない.\n\n特に $\\vdash \\psi$ を定理, $\\vDash \\psi$ をトートロジーと呼ぶ.\n\n## 真理値表\n次の原理を満たして真理値の表を書く.\n2値原理: 任意の記号文は真か偽のどちらか一方である。\n関数的合成の原理: 任意の記号文の真理値は、それを構成する原子文の真理値のみに依存して一意に定まる。\n\n//TODO\n\n## 命題論理の健全性・完全性\n以下は互いに同値である\n\n1. $\\phi_1,\\ldots,\\phi_n \\vdash \\psi$\n2. $\\vdash \\phi_1\\land\\cdots\\land\\phi_n\\to\\psi$\n3. $\\vDash \\phi_1\\land\\cdots\\land\\phi_n\\to\\psi$\n4. $\\phi_1,\\ldots,\\phi_n \\vDash \\psi$\n\n**proof**\n(1 $\\implies$ 2)\n1. Show $\\vdash \\phi_1\\land\\cdots\\land\\phi_n\\to\\psi$\n2. $\\phi_1\\land\\cdots\\land\\phi_n$ AssCD\n3. $\\phi_1,\\ldots,\\phi_n$ 2S\n4. $\\phi_1,\\ldots,\\phi_n \\vdash \\psi$ Pr\n5. $\\psi$\n5CD\n\n(1 $\\impliedby$ 2)\n1. Show $\\phi_1,\\ldots,\\phi_n \\vdash \\psi$\n2. $\\phi_1,\\ldots,\\phi_n$ Pr\n3. $\\phi_1\\land\\cdots\\land\\phi_n$ 2Adj\n4. $\\vdash \\phi_1\\land\\cdots\\land\\phi_n\\to\\psi$ Pr\n5. $\\psi$ 3,4MP\n5DD\n\n(2 $\\implies$ 3)\n1. 定理の演繹の行番号を演繹を構成する際に利用可能となる順に付け替える. \u003c-ちょっとバグある.\n2. 演繹の n 行目において利用可能な家庭すべてからなる連言を前件, n 行目の記号文を後件とする条件文を n 行目の導出式と定義する. ただし利用可能な仮定が存在しないとき, n 行目の記号分そのものを n 行目の導出式とする.\n3. 任意の導出式はトートロジーであることを数学的帰納法により示す.\n    1. 1行目の導出式はトートロジーである.\n    2. n行目までのすべての導出式がトートロジーならば n+1 行目もトートロジーである.\n4. 最後の導出式は定理そのものであり, それはトートロジーである.\n\n(2 $\\impliedby$ 3)\nまず意味論的な真理値と統語論的な結合子を対応させる.\n\n**Def.** 記号 $'$ を次のように定義する.\n\n$$\nx' = \\begin{cases}\nx \u0026 (x = 1) \\\\\n\\lnot x \u0026 (x = 0)\n\\end{cases}\n$$\n\n**Lemma.** 任意の記号文 $\\eta$ について, それに含まれる原子文 $P_1,\\ldots,P_n$ について $P_1',\\ldots,P_n' \\vdash \\eta'$ となる.\n\n**Proof.**\n結合子が 0 個のとき, $P_1' \\vdash \\eta'$ より成り立つ.\n結合子が n 個より小さいすべての記号文が成り立つと仮定し, 各結合子について n 個のときを考える.\n\n$P_1',\\ldots,P_n' \\vdash \\xi'$ が成り立つとき, $P_1',\\ldots,P_n' \\vdash (\\lnot\\xi)'$ について\n\n$$\n(\\lnot\\xi)' = \\begin{cases}\n\\lnot\\lnot\\xi \u0026 (\\xi = 1) \\\\\n\\lnot\\xi \u0026 (\\xi = 0)\n\\end{cases}\n$$\n\nよりこれは演繹により成り立つ.\n\n$P_1',\\ldots,P_i' \\vdash \\pi'$ かつ $Q_1',\\ldots,Q_j' \\vdash \\theta'$ が成り立つとき, $P_1',\\ldots,P_i',Q_1',\\ldots,Q_j' \\vdash (\\pi\\to\\theta)'$ について\n\n$$\n(\\pi\\to\\theta)' = \\begin{cases}\n\\pi\\to\\theta \u0026 (\\pi = 0 \\lor \\theta = 1) \\\\\n\\lnot(\\pi\\to\\theta) \u0026 (\\pi = 1 \\land \\theta = 0)\n\\end{cases}\n$$\n\nよりこれは演繹により成り立つ.\n\n**Thm.** $\\vDash \\xi \\implies \\vdash\\xi$\n\n**Proof.**\nLemma から記号文 $\\xi$ について $P_1',\\ldots,P_n' \\vdash \\xi'$ が成り立つ. $\\vDash \\xi$ なので $P_1',\\ldots,P_n' \\vdash \\xi$ であり, このとき $P_1',\\ldots,P_{n-1}' \\vdash P_n'\\to\\xi$ となる.\n同様に $P_n'$ についてだけ真理値が異なる真理表を考えると(これよく分からない) Lemma から $P_1',\\ldots,\\lnot P_n' \\vdash \\xi$ であり, $P_1',\\ldots,P_{n-1}' \\vdash \\lnot P_n'\\to\\xi$ が成り立つ.\n2つのことから $P_1',\\ldots,P_{n-1}' \\vdash \\xi$ が演繹できる. これを繰り返すことで $\\vdash \\xi$ が得られる.\n\n(3 $\\iff$ 4)\n$\\nvDash \\phi_1\\land\\cdots\\land\\phi_n\\to\\psi$\n$\\iff$ $\\phi_1\\land\\cdots\\land\\phi_n\\to\\psi$ がトートロジーではない\n$\\iff$ $\\phi_1\\land\\cdots\\land\\phi_n$ が真で $\\psi$ が偽である行がある.\n$\\iff$ $\\phi_1,\\ldots,\\phi_n$ が真で $\\psi$ が偽である行がある.\n$\\iff$ 前提 $\\phi_1,\\ldots,\\phi_n$ から結論 $\\psi$ を得る推論は意味論的に妥当ではない.\n$\\iff$ $\\phi_1,\\ldots,\\phi_n \\nvDash \\psi$\n\nよって $\\phi_1,\\ldots,\\phi_n \\vDash \\psi \\iff \\vDash \\phi_1\\land\\cdots\\land\\phi_n\\to\\psi$\n\nこれよりすべての同値性が証明された.\n\n完全性・健全性が成り立つとき次のことが言える.\n\n**Thm.** 無矛盾性\n矛盾する２つの記号文 $\\eta$ と $\\lnot\\eta$ が定理となることはない.\n\n**Proof.**\n$\\eta$, $\\lnot\\eta$ が定理だと仮定すると $\\eta\\land\\lnot\\eta$ はトートロジーでないから矛盾.\n","lastmodified":"2022-12-30T07:57:21.487263721Z","tags":null},"/science/math/inequality":{"title":"不等式","content":"\n## Minkowski の不等式\n三角不等式の一般化. 迂回するより直線的に進む方が短い.\n\n$$\n\\|x + y\\| _ p \\leq \\|x\\| _ p + \\|y\\| _ p\n$$\n\n**proof.**\n\n## ヘルダーの不等式\nコーシーシュワルツの不等式の一般化.\n\n$$\n\\prod_{i=1}^m\\left(\\sum_{j=1}^n a_{ij}\\right)^{w_i} \\geq \\sum_{j=1}^n\\left(\\prod_{i=1}^m a_{ij}^{w_i}\\right)\n$$\n\n## Muirhead の不等式\n$[a]\\preceq[b]$ のとき\n\n$$\n\\sum_{sym}\\prod_{i=1}^n x_i^{a_i} \\geq \\sum_{sym}\\prod_{i=1}^n x_i^{b_i}\n$$\n\n等号成立条件\n- $a=b$, $x_1 = \\cdots = x_n$\n\n## Schur の不等式\n$x, y, z \\geq 0$ のとき $x^r(x-y)(x-z) + y^r(y-z)(y-x) + z^r(z-x)(z-y) \\geq 0$\n\n等号成立条件\n- $(x, y, z) = (a, a, a), (0, a, a)$\n\n## Jensen の不等式\n$\\forall\\lambda_i \\geq 0$ $\\sum_i\\lambda_i = 1$ に対して $f(x)$ が凸関数\n\n$$\nf(\\lambda_1x_1+\\cdots+\\lambda_nx_n) \\leq \\lambda_1f(x_1)+\\cdots+\\lambda_nf(x_n)\n$$\n\n$f(x)$ が凹関数\n\n$$\nf(\\lambda_1x_1+\\cdots+\\lambda_nx_n) \\geq \\lambda_1f(x_1)+\\cdots+\\lambda_nf(x_n)\n$$\n\n## Karamata の不等式\n$f(x)$ が凸関数 $[a] \\preceq [b]$\n\n$$\nf(a_1)+\\cdots+f(a_n) \\leq f(b_1)+\\cdots+f(b_n)\n$$\n\n## Weighted AM-GM\n相加相乗平均の重み付きにおける一般化. 相加平均 (AM; Arithmetic Mean) は相乗平均 (GM; Geometric Mean) より大きいという定理.\n\n$$\n\\sum_{i=1}^n w_ia_i \\geq \\prod_{i=1}^n a_i^{w_i}\n$$\n\n**proof.**\n$f:x\\mapsto \\ln x$ は凸関数より Jensen の不等式から\n\n$$\n\\ln\\left(\\sum_i\\lambda_ia_i\\right) \\geq \\sum_i\\lambda_i\\ln a_i = \\ln\\left(\\prod_ia_i^{\\lambda_i}\\right)\n$$\n\nとなる.\n","lastmodified":"2022-12-30T07:57:21.487263721Z","tags":null},"/template":{"title":"競プロで使うテンプレート","content":"\n## 説明\n\n私が使うテンプレートです. このライブラリ集では少なくとも STL を全て読み込んで `using namespace std` してあることを前提として書いてあります.\n\n## 実装\n\n```cpp\n#ifndef LOCAL\n#pragma GCC optimize(\"Ofast\")\n#pragma GCC optimize(\"unroll-loops\")\n#endif\n\n#include \u003cbits/stdc++.h\u003e\n// #include \u003catcoder/all\u003e\nusing namespace std;\n// using namespace atcoder;\nusing ll = long long;\nusing ld = long double;\nusing uint = unsigned;\nusing ull = unsigned long long;\nusing u64 = uint_fast64_t;\nusing pll = pair\u003cll, ll\u003e;\nusing pdd = pair\u003cld, ld\u003e;\nusing C = complex\u003cld\u003e;\ntemplate \u003cclass T\u003e using pq = priority_queue\u003cT, vector\u003cT\u003e, greater\u003cT\u003e\u003e;\n\nconst int IINF = 0x1fffffff;\nconst ll LINF = 0x1fffffffffffffff;\nconst ll INF = 0x1fffffffffffffff;\nconst ll MINF = 0x7fffffffffff;\nconst ll MOD = 1000000007;\nconst ll MODD = 998244353;\nconst ld DINF = numeric_limits\u003cld\u003e::infinity();\nconst ld EPS = 1e-9;\nconst ld PI = 3.1415926535897932;\nconst ll dx[] = {0, 1, 0, -1, 1, -1, 1, -1};\nconst ll dy[] = {1, 0, -1, 0, 1, 1, -1, -1};\n\n#define overload4(_1, _2, _3, _4, name, ...) name\n#define overload3(_1, _2, _3, name, ...) name\n#define rep1(n) for (ll i = 0; i \u003c n; ++i)\n#define rep2(i, n) for (ll i = 0; i \u003c n; ++i)\n#define rep3(i, a, b) for (ll i = a; i \u003c b; ++i)\n#define rep4(i, a, b, c) for (ll i = a; i \u003c b; i += c)\n#define rep(...) overload4(__VA_ARGS__, rep4, rep3, rep2, rep1)(__VA_ARGS__)\n#define rrep1(n) for (ll i = n; i--;)\n#define rrep2(i, n) for (ll i = n; i--;)\n#define rrep3(i, a, b) for (ll i = b; i-- \u003e (a);)\n#define rrep4(i, a, b, c)                                                      \\\n  for (ll i = (a) + ((b) - (a)-1) / (c) * (c); i \u003e= (a); i -= c)\n#define rrep(...)                                                              \\\n  overload4(__VA_ARGS__, rrep4, rrep3, rrep2, rrep1)(__VA_ARGS__)\n#define each1(i, a) for (auto \u0026\u0026i : a)\n#define each2(x, y, a) for (auto \u0026\u0026[x, y] : a)\n#define each3(x, y, z, a) for (auto \u0026\u0026[x, y, z] : a)\n#define each(...) overload4(__VA_ARGS__, each3, each2, each1)(__VA_ARGS__)\n#define all1(i) begin(i), end(i)\n#define all2(i, a) begin(i), begin(i) + a\n#define all3(i, a, b) begin(i) + a, begin(i) + b\n#define all(...) overload3(__VA_ARGS__, all3, all2, all1)(__VA_ARGS__)\n#define rall1(i) (i).rbegin(), (i).rend()\n#define rall2(i, k) (i).rbegin(), (i).rbegin() + k\n#define rall3(i, a, b) (i).rbegin() + a, (i).rbegin() + b\n#define rall(...) overload3(__VA_ARGS__, rall3, rall2, rall1)(__VA_ARGS__)\n// g++ -DDBUG -I . ...\n#ifdef DEBUG\ninline ll __lg(ull x) { return 63 - __builtin_clzll(x); }\n#define debug(...)                                                             \\\n  {                                                                            \\\n    print(#__VA_ARGS__);                                                       \\\n    print(\":\");                                                                \\\n    out(__VA_ARGS__);                                                          \\\n  }\n#else\n#define debug(...) void(0)\n#endif\n\n#define vec vector\n#define fi first\n#define se second\n#define MM \u003c\u003c \" \" \u003c\u003c\n#define chmax(x, y) (x = max(x, y))\n#define chmin(x, y) (x = min(x, y))\nvoid debug_out() { std::cerr \u003c\u003c std::endl; }\ntemplate \u003ctypename Head, typename... Tail\u003e void debug_out(Head h, Tail... t) {\n  std::cerr \u003c\u003c \" \" \u003c\u003c h;\n  if (sizeof...(t) \u003e 0)\n    std::cout \u003c\u003c \" :\";\n  debug_out(t...);\n}\n\nint main() {\n  cin.tie(0);\n  ios::sync_with_stdio(0);\n  cout \u003c\u003c fixed \u003c\u003c setprecision(20);\n\n  return 0;\n}\n```\n```cpp\n/**\n * @brief 多次元 vector の作成\n * @author えびちゃん\n */\n#include \u003cbits/stdc++.h\u003e\nusing namespace std;\nusing ll = long long;\n\nnamespace detail {\ntemplate \u003ctypename Tp, size_t Nb\u003e\nauto make_vector(std::vector\u003csize_t\u003e \u0026sizes, Tp const \u0026x) {\n  if constexpr (Nb == 1) {\n    return std::vector(sizes[0], x);\n  } else {\n    size_t size = sizes[Nb - 1];\n    sizes.pop_back();\n    return std::vector(size, make_vector\u003cTp, Nb - 1\u003e(sizes, x));\n  }\n}\n} // namespace detail\n\ntemplate \u003ctypename Tp, size_t Nb\u003e\nauto make_vector(size_t const (\u0026sizes)[Nb], Tp const \u0026x = Tp()) {\n  std::vector\u003csize_t\u003e s(Nb);\n  for (size_t i = 0; i \u003c Nb; ++i)\n    s[i] = sizes[Nb - i - 1];\n  return detail::make_vector\u003cTp, Nb\u003e(s, x);\n}\n```\n\n## 参考文献\n- [shino16/cp_rust: 競プロライブラリ (github.com)](https://github.com/shino16/cp_rust)\n- [My Algorithm : kopricky アルゴリズムライブラリ](https://kopricky.github.io/index.html)\n- [Luzhiled’s Library | This documentation is automatically generated by online-judge-tools/verification-helper (ei1333.github.io)](https://ei1333.github.io/library/)\n- [nekolib - Rust (rsk0315.github.io)](https://rsk0315.github.io/library-rs/nekolib/)\n","lastmodified":"2022-12-30T07:57:21.487263721Z","tags":null},"/web/Browser":{"title":"ブラウザ","content":"\n## 説明\n\n- Chrome\n- Edge\n- FireFox\n- Vivaldi\n- Sidekick\n- Arc\n- Safari\n\n\n\n\n\n\nbrowser\n[d0iasm/vulbr: Toy browser on single process / thread (github.com)](https://github.com/d0iasm/vulbr)\n\nWAF\n\nPHP の `file_get_contents` はローカルファイルもウェブ上も取ってくる。\n正規表現の `.` は改行にマッチしない。\n\n- React\n- Preact\n- MobX\n- Solid: React + MobX feat. Svelte\n- Svelte\n\ndocument.location","lastmodified":"2022-12-30T07:57:21.487263721Z","tags":null},"/web/PrototypePollution":{"title":"Prototype Pollution","content":"\nグローバル変数 `Object.prototype`  と任意のオブジェクトの変数 `\u003cobj\u003e.__proto__` が一致することからの脆弱性","lastmodified":"2022-12-30T07:57:21.487263721Z","tags":null},"/web/security":{"title":"","content":"XSS\nPrototype Pollution\nCSV Injection\nSQL Injection \nFTP Injection\nXXE\nCSRF\nClickjacking\nSSRF\nWeb Cache Poisoning\nRelative Path Overwrite\n\nXXE\nCSP\nWAF\n\n[qazbnm456/awesome-web-security: 🐶 A curated list of Web Security materials and resources. (github.com)](https://github.com/qazbnm456/awesome-web-security)","lastmodified":"2022-12-30T07:57:21.487263721Z","tags":null}}